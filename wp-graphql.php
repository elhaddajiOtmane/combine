// File: wp-graphql\access-functions.php
<?php
/**
 * This file contains access functions for various class methods
 *
 * @package WPGraphQL
 * @since 0.0.2
 */

use GraphQL\Type\Definition\Type;
use WPGraphQL\Registry\TypeRegistry;
use WPGraphQL\Request;
use WPGraphQL\Router;
use WPGraphQL\Utils\Utils;

/**
 * Formats a string for use as a GraphQL name.
 *
 * Per the GraphQL spec, characters in names are limited to Latin ASCII letter, digits, or underscores.
 *
 * @see http://spec.graphql.org/draft/#sec-Names
 * @uses graphql_pre_format_name filter.
 *
 * @param string $name The name to format.
 * @param string $replacement The replacement character for invalid characters. Defaults to '_'.
 * @param string $regex The regex to use to match invalid characters. Defaults to '/[^A-Za-z0-9_]/i'.
 *
 * @since v1.17.0
 */
function graphql_format_name( string $name, string $replacement = '_', string $regex = '/[^A-Za-z0-9_]/i' ): string {
	return Utils::format_graphql_name( $name, $replacement, $regex );
}
/**
 * Formats the name of a field so that it plays nice with GraphiQL
 *
 * @param string $field_name Name of the field
 *
 * @return string Name of the field
 * @since  0.0.2
 *
 * @todo refactor to use Utils::format_field_name()
 */
function graphql_format_field_name( $field_name ) {
	// Bail if empty.
	if ( empty( $field_name ) ) {
		return '';
	}

	// First strip out the non-alphanumeric characters.
	$formatted_field_name = graphql_format_name( $field_name, ' ', '/[^A-Za-z0-9]/i' );

	// If the field name is empty, return the original field name for the error.
	if ( empty( $formatted_field_name ) ) {
		return $field_name;
	}

	// Then convert string to camelCase.
	return str_replace( ' ', '', lcfirst( ucwords( $formatted_field_name ) ) );
}

/**
 * Formats the name of a Type so that it plays nice with GraphiQL
 *
 * @param string $type_name Name of the field
 *
 * @return string Name of the field
 * @since  0.0.2
 */
function graphql_format_type_name( $type_name ) {
	// Bail if empty.
	if ( empty( $type_name ) ) {
		return '';
	}

	$formatted_type_name = graphql_format_name( $type_name, ' ', '/[^A-Za-z0-9]/i' );

	// If the field name is empty, return the original field name for the error.
	if ( empty( $formatted_type_name ) ) {
		return $type_name;
	}

	// Then convert the string to PascalCase.
	return str_replace( ' ', '', ucfirst( ucwords( $formatted_type_name ) ) );
}

/**
 * Provides a simple way to run a GraphQL query without posting a request to the endpoint.
 *
 * @param array<string,mixed> $request_data   The GraphQL request data (query, variables, operation_name).
 * @param bool                $return_request If true, return the Request object, else return the results of the request execution
 *
 * @return array<string,mixed>|\WPGraphQL\Request
 * @throws \Exception
 * @since  0.2.0
 */
function graphql( array $request_data = [], bool $return_request = false ) {
	$request = new Request( $request_data );

	// allow calls to graphql() to return the full Request instead of
	// just the results of the request execution
	if ( true === $return_request ) {
		return $request;
	}

	return $request->execute();
}

/**
 * Previous access function for running GraphQL queries directly. This function will
 * eventually be deprecated in favor of `graphql`.
 *
 * @param string              $query          The GraphQL query to run
 * @param string              $operation_name The name of the operation
 * @param array<string,mixed> $variables      Variables to be passed to your GraphQL request
 * @param bool                $return_request If true, return the Request object, else return the results of the request execution
 *
 * @return array<string,mixed>|\WPGraphQL\Request
 * @throws \Exception
 * @since  0.0.2
 */
function do_graphql_request( $query, $operation_name = '', $variables = [], $return_request = false ) {
	return graphql(
		[
			'query'          => $query,
			'variables'      => $variables,
			'operation_name' => $operation_name,
		],
		$return_request
	);
}

/**
 * Determine when to register types
 *
 * @return string
 */
function get_graphql_register_action() {
	$action = 'graphql_register_types_late';
	if ( ! did_action( 'graphql_register_initial_types' ) ) {
		$action = 'graphql_register_initial_types';
	} elseif ( ! did_action( 'graphql_register_types' ) ) {
		$action = 'graphql_register_types';
	}

	return $action;
}

/**
 * Given a type name and interface name, this applies the interface to the Type.
 *
 * Should be used at the `graphql_register_types` hook.
 *
 * @param string|string[] $interface_names Array of one or more names of the GraphQL Interfaces to apply to the GraphQL Types
 * @param string|string[] $type_names      Array of one or more names of the GraphQL Types to apply the interfaces to.
 *
 * Example:
 * The following would register the "MyNewInterface" interface to the Post and Page type in the
 * Schema.
 *
 * register_graphql_interfaces_to_types( [ 'MyNewInterface' ], [ 'Post', 'Page' ] );
 *
 * @return void
 */
function register_graphql_interfaces_to_types( $interface_names, $type_names ) {
	if ( is_string( $type_names ) ) {
		$type_names = [ $type_names ];
	}

	if ( is_string( $interface_names ) ) {
		$interface_names = [ $interface_names ];
	}

	if ( ! empty( $type_names ) && is_array( $type_names ) && ! empty( $interface_names ) && is_array( $interface_names ) ) {
		foreach ( $type_names as $type_name ) {

			// Filter the GraphQL Object Type Interface to apply the interface
			add_filter(
				'graphql_type_interfaces',
				static function ( $interfaces, $config ) use ( $type_name, $interface_names ) {
					$interfaces = is_array( $interfaces ) ? $interfaces : [];

					if ( strtolower( $type_name ) === strtolower( $config['name'] ) ) {
						$interfaces = array_unique( array_merge( $interfaces, $interface_names ) );
					}

					return $interfaces;
				},
				10,
				2
			);
		}
	}
}

/**
 * Given a Type Name and a $config array, this adds a Type to the TypeRegistry
 *
 * @param string              $type_name The name of the Type to register
 * @param array<string,mixed> $config    The Type config
 *
 * @throws \Exception
 * @return void
 */
function register_graphql_type( string $type_name, array $config ) {
	add_action(
		get_graphql_register_action(),
		static function ( TypeRegistry $type_registry ) use ( $type_name, $config ) {
			$type_registry->register_type( $type_name, $config );
		},
		10
	);
}

/**
 * Given a Type Name and a $config array, this adds an Interface Type to the TypeRegistry
 *
 * @param string                                                  $type_name The name of the Type to register
 * @param mixed|array<string,mixed>|\GraphQL\Type\Definition\Type $config    The Type config
 *
 * @throws \Exception
 * @return void
 */
function register_graphql_interface_type( string $type_name, $config ) {
	add_action(
		get_graphql_register_action(),
		static function ( TypeRegistry $type_registry ) use ( $type_name, $config ) {
			$type_registry->register_interface_type( $type_name, $config );
		},
		10
	);
}

/**
 * Given a Type Name and a $config array, this adds an ObjectType to the TypeRegistry
 *
 * @param string              $type_name The name of the Type to register
 * @param array<string,mixed> $config    The Type config
 *
 * @return void
 */
function register_graphql_object_type( string $type_name, array $config ) {
	$config['kind'] = 'object';
	register_graphql_type( $type_name, $config );
}

/**
 * Given a Type Name and a $config array, this adds an InputType to the TypeRegistry
 *
 * @param string              $type_name The name of the Type to register
 * @param array<string,mixed> $config    The Type config
 *
 * @return void
 */
function register_graphql_input_type( string $type_name, array $config ) {
	$config['kind'] = 'input';
	register_graphql_type( $type_name, $config );
}

/**
 * Given a Type Name and a $config array, this adds an UnionType to the TypeRegistry
 *
 * @param string              $type_name The name of the Type to register
 * @param array<string,mixed> $config    The Type config
 *
 * @throws \Exception
 *
 * @return void
 */
function register_graphql_union_type( string $type_name, array $config ) {
	add_action(
		get_graphql_register_action(),
		static function ( TypeRegistry $type_registry ) use ( $type_name, $config ) {
			$config['kind'] = 'union';
			$type_registry->register_type( $type_name, $config );
		},
		10
	);
}

/**
 * Given a Type Name and a $config array, this adds an EnumType to the TypeRegistry
 *
 * @param string              $type_name The name of the Type to register
 * @param array<string,mixed> $config    The Type config
 *
 * @return void
 */
function register_graphql_enum_type( string $type_name, array $config ) {
	$config['kind'] = 'enum';
	register_graphql_type( $type_name, $config );
}

/**
 * Given a Type Name, Field Name, and a $config array, this adds a Field to a registered Type in
 * the TypeRegistry
 *
 * @param string              $type_name  The name of the Type to add the field to
 * @param string              $field_name The name of the Field to add to the Type
 * @param array<string,mixed> $config     The Type config
 *
 * @return void
 * @throws \Exception
 * @since 0.1.0
 */
function register_graphql_field( string $type_name, string $field_name, array $config ) {
	add_action(
		get_graphql_register_action(),
		static function ( TypeRegistry $type_registry ) use ( $type_name, $field_name, $config ) {
			$type_registry->register_field( $type_name, $field_name, $config );
		},
		10
	);
}

/**
 * Given a Type Name and an array of field configs, this adds the fields to the registered type in
 * the TypeRegistry
 *
 * @param string                            $type_name The name of the Type to add the fields to
 * @param array<string,array<string,mixed>> $fields    An array of field configs
 *
 * @return void
 * @throws \Exception
 * @since 0.1.0
 */
function register_graphql_fields( string $type_name, array $fields ) {
	add_action(
		get_graphql_register_action(),
		static function ( TypeRegistry $type_registry ) use ( $type_name, $fields ) {
			$type_registry->register_fields( $type_name, $fields );
		},
		10
	);
}

/**
 * Adds a field to the Connection Edge between the provided 'From' Type Name and 'To' Type Name.
 *
 * @param string              $from_type  The name of the Type the connection is coming from.
 * @param string              $to_type    The name of the Type or Alias (the connection config's `FromFieldName`) the connection is going to.
 * @param string              $field_name The name of the field to add to the connection edge.
 * @param array<string,mixed> $config     The field config.
 *
 * @since 1.13.0
 */
function register_graphql_edge_field( string $from_type, string $to_type, string $field_name, array $config ): void {
	$connection_name = ucfirst( $from_type ) . 'To' . ucfirst( $to_type ) . 'ConnectionEdge';

	add_action(
		get_graphql_register_action(),
		static function ( TypeRegistry $type_registry ) use ( $connection_name, $field_name, $config ) {
			$type_registry->register_field( $connection_name, $field_name, $config );
		},
		10
	);
}

/**
 * Adds several fields to the Connection Edge between the provided 'From' Type Name and 'To' Type Name.
 *
 * @param string                            $from_type The name of the Type the connection is coming from.
 * @param string                            $to_type   The name of the Type or Alias (the connection config's `FromFieldName`) the connection is going to.
 * @param array<string,array<string,mixed>> $fields    An array of field configs.
 *
 * @since 1.13.0
 */
function register_graphql_edge_fields( string $from_type, string $to_type, array $fields ): void {
	$connection_name = ucfirst( $from_type ) . 'To' . ucfirst( $to_type ) . 'ConnectionEdge';

	add_action(
		get_graphql_register_action(),
		static function ( TypeRegistry $type_registry ) use ( $connection_name, $fields ) {
			$type_registry->register_fields( $connection_name, $fields );
		},
		10
	);
}

/**
 * Adds an input field to the Connection Where Args between the provided 'From' Type Name and 'To' Type Name.
 *
 * @param string              $from_type  The name of the Type the connection is coming from.
 * @param string              $to_type    The name of the Type or Alias (the connection config's `FromFieldName`) the connection is going to.
 * @param string              $field_name The name of the field to add to the connection edge.
 * @param array<string,mixed> $config      The field config.
 *
 * @since 1.13.0
 */
function register_graphql_connection_where_arg( string $from_type, string $to_type, string $field_name, array $config ): void {
	$connection_name = ucfirst( $from_type ) . 'To' . ucfirst( $to_type ) . 'ConnectionWhereArgs';

	add_action(
		get_graphql_register_action(),
		static function ( TypeRegistry $type_registry ) use ( $connection_name, $field_name, $config ) {
			$type_registry->register_field( $connection_name, $field_name, $config );
		},
		10
	);
}

/**
 * Adds several input fields to the Connection Where Args between the provided 'From' Type Name and 'To' Type Name.
 *
 * @param string                            $from_type The name of the Type the connection is coming from.
 * @param string                            $to_type   The name of the Type or Alias (the connection config's `FromFieldName`) the connection is going to.
 * @param array<string,array<string,mixed>> $fields    An array of field configs.
 *
 * @since 1.13.0
 */
function register_graphql_connection_where_args( string $from_type, string $to_type, array $fields ): void {
	$connection_name = ucfirst( $from_type ) . 'To' . ucfirst( $to_type ) . 'ConnectionWhereArgs';

	add_action(
		get_graphql_register_action(),
		static function ( TypeRegistry $type_registry ) use ( $connection_name, $fields ) {
			$type_registry->register_fields( $connection_name, $fields );
		},
		10
	);
}

/**
 * Renames a GraphQL field.
 *
 * @param string $type_name       Name of the Type to rename a field on.
 * @param string $field_name      Field name to be renamed.
 * @param string $new_field_name  New field name.
 *
 * @return void
 * @since 1.3.4
 */
function rename_graphql_field( string $type_name, string $field_name, string $new_field_name ) {
	// Rename fields on the type.
	add_filter(
		"graphql_{$type_name}_fields",
		static function ( $fields ) use ( $field_name, $new_field_name ) {
			// Bail if the field doesn't exist.
			if ( ! isset( $fields[ $field_name ] ) ) {
				return $fields;
			}

			$fields[ $new_field_name ] = $fields[ $field_name ];
			unset( $fields[ $field_name ] );

			return $fields;
		}
	);

	// Rename fields registered to the type by connections.
	add_filter(
		"graphql_wp_connection_{$type_name}_from_field_name",
		static function ( $old_field_name ) use ( $field_name, $new_field_name ) {
			// Bail if the field name doesn't match.
			if ( $old_field_name !== $field_name ) {
				return $old_field_name;
			}

			return $new_field_name;
		}
	);
}

/**
 * Renames a GraphQL Type in the Schema.
 *
 * @param string $type_name The name of the Type in the Schema to rename.
 * @param string $new_type_name  The new name to give the Type.
 *
 * @return void
 * @throws \Exception
 *
 * @since 1.3.4
 */
function rename_graphql_type( string $type_name, string $new_type_name ) {
	add_filter(
		'graphql_type_name',
		static function ( $name ) use ( $type_name, $new_type_name ) {
			if ( $name === $type_name ) {
				return $new_type_name;
			}
			return $name;
		}
	);

	// Add the new type to the registry referencing the original Type instance.
	// This allows for both the new type name and the old type name to be
	// referenced as the type when registering fields.
	add_action(
		'graphql_register_types_late',
		static function ( TypeRegistry $type_registry ) use ( $type_name, $new_type_name ) {
			$type = $type_registry->get_type( $type_name );
			if ( ! $type instanceof Type ) {
				return;
			}
			$type_registry->register_type( $new_type_name, $type );
		}
	);
}

/**
 * Given a config array for a connection, this registers a connection by creating all appropriate
 * fields and types for the connection
 *
 * @param array<string,mixed> $config Array to configure the connection
 *
 * @throws \Exception
 * @return void
 *
 * @since 0.1.0
 */
function register_graphql_connection( array $config ) {
	add_action(
		get_graphql_register_action(),
		static function ( TypeRegistry $type_registry ) use ( $config ) {
			$type_registry->register_connection( $config );
		},
		20
	);
}

/**
 * Given a Mutation Name and Config array, this adds a Mutation to the Schema
 *
 * @param string              $mutation_name The name of the Mutation to register
 * @param array<string,mixed> $config        The config for the mutation
 *
 * @throws \Exception
 *
 * @return void
 * @since 0.1.0
 */
function register_graphql_mutation( string $mutation_name, array $config ) {
	add_action(
		get_graphql_register_action(),
		static function ( TypeRegistry $type_registry ) use ( $mutation_name, $config ) {
			$type_registry->register_mutation( $mutation_name, $config );
		},
		10
	);
}

/**
 * Given a config array for a custom Scalar, this registers a Scalar for use in the Schema
 *
 * @param string              $type_name The name of the Type to register
 * @param array<string,mixed> $config    The config for the scalar type to register
 *
 * @throws \Exception
 * @return void
 *
 * @since 0.8.4
 */
function register_graphql_scalar( string $type_name, array $config ) {
	add_action(
		get_graphql_register_action(),
		static function ( TypeRegistry $type_registry ) use ( $type_name, $config ) {
			$type_registry->register_scalar( $type_name, $config );
		},
		10
	);
}

/**
 * Given a Type Name, this removes the type from the entire schema
 *
 * @param string $type_name The name of the Type to remove.
 *
 * @since 1.13.0
 */
function deregister_graphql_type( string $type_name ): void {
	// Prevent the type from being registered to the scheme directly.
	add_filter(
		'graphql_excluded_types',
		static function ( $excluded_types ) use ( $type_name ): array {
			// Normalize the types to prevent case sensitivity issues.
			$type_name = strtolower( $type_name );
			// If the type isn't already excluded, add it to the array.
			if ( ! in_array( $type_name, $excluded_types, true ) ) {
				$excluded_types[] = $type_name;
			}

			return $excluded_types;
		},
		10
	);

	// Prevent the type from being inherited as an interface.
	add_filter(
		'graphql_type_interfaces',
		static function ( $interfaces ) use ( $type_name ): array {
			// Normalize the needle and haystack to prevent case sensitivity issues.
			$key = array_search(
				strtolower( $type_name ),
				array_map( 'strtolower', $interfaces ),
				true
			);
			// If the type is found, unset it.
			if ( false !== $key ) {
				unset( $interfaces[ $key ] );
			}

			return $interfaces;
		},
		10
	);
}

/**
 * Given a Type Name and Field Name, this removes the field from the TypeRegistry
 *
 * @param string $type_name  The name of the Type to remove the field from
 * @param string $field_name The name of the field to remove
 *
 * @return void
 *
 * @since 0.1.0
 */
function deregister_graphql_field( string $type_name, string $field_name ) {
	add_action(
		get_graphql_register_action(),
		static function ( TypeRegistry $type_registry ) use ( $type_name, $field_name ) {
			$type_registry->deregister_field( $type_name, $field_name );
		},
		10
	);
}

/**
 * Given a Connection Name, this removes the connection from the Schema
 *
 * @param string $connection_name The name of the Connection to remove
 *
 * @since 1.14.0
 */
function deregister_graphql_connection( string $connection_name ): void {
	add_action(
		get_graphql_register_action(),
		static function ( TypeRegistry $type_registry ) use ( $connection_name ) {
			$type_registry->deregister_connection( $connection_name );
		},
		10
	);
}

/**
 * Given a Mutation Name, this removes the mutation from the Schema
 *
 * @param string $mutation_name The name of the Mutation to remove
 *
 * @since 1.14.0
 */
function deregister_graphql_mutation( string $mutation_name ): void {
	add_action(
		get_graphql_register_action(),
		static function ( TypeRegistry $type_registry ) use ( $mutation_name ) {
			$type_registry->deregister_mutation( $mutation_name );
		},
		10
	);
}

/**
 * Whether a GraphQL request is in action or not. This is determined by the WPGraphQL Request
 * class being initiated. True while a request is in action, false after a request completes.
 *
 * This should be used when a condition needs to be checked for ALL GraphQL requests, such
 * as filtering WP_Query for GraphQL requests, for example.
 *
 * Default false.
 *
 * @return bool
 * @since 0.4.1
 */
function is_graphql_request() {
	return WPGraphQL::is_graphql_request();
}

/**
 * Whether a GraphQL HTTP request is in action or not. This is determined by
 * checking if the request is occurring on the route defined for the GraphQL endpoint.
 *
 * This conditional should only be used for features that apply to HTTP requests. If you are going
 * to apply filters to underlying WordPress core functionality that should affect _all_ GraphQL
 * requests, you should use "is_graphql_request" but if you need to apply filters only if the
 * GraphQL request is an HTTP request, use this conditional.
 *
 * Default false.
 *
 * @return bool
 * @since 0.4.1
 */
function is_graphql_http_request() {
	return Router::is_graphql_http_request();
}

/**
 * Registers a GraphQL Settings Section
 *
 * @param string              $slug   The slug of the group being registered
 * @param array<string,mixed> $config Array configuring the section. Should include: title
 *
 * @return void
 * @since 0.13.0
 */
function register_graphql_settings_section( string $slug, array $config ) {
	add_action(
		'graphql_init_settings',
		static function ( \WPGraphQL\Admin\Settings\SettingsRegistry $registry ) use ( $slug, $config ) {
			$registry->register_section( $slug, $config );
		}
	);
}

/**
 * Registers a GraphQL Settings Field
 *
 * @param string              $group  The name of the group to register a setting field to
 * @param array<string,mixed> $config The config for the settings field being registered
 *
 * @return void
 * @since 0.13.0
 */
function register_graphql_settings_field( string $group, array $config ) {
	add_action(
		'graphql_init_settings',
		static function ( \WPGraphQL\Admin\Settings\SettingsRegistry $registry ) use ( $group, $config ) {
			$registry->register_field( $group, $config );
		}
	);
}

/**
 * Given a message and an optional config array
 *
 * @param mixed|string|mixed[] $message The debug message
 * @param array<string,mixed>  $config  The debug config. Should be an associative array of keys and values.
 *                                      $config['type'] will set the "type" of the log, default type is GRAPHQL_DEBUG.
 *                                      Other fields added to $config will be merged into the debug entry.
 *
 * @return void
 * @since 0.14.0
 */
function graphql_debug( $message, $config = [] ) {
	$debug_backtrace     = debug_backtrace(); // phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_debug_backtrace
	$config['backtrace'] = ! empty( $debug_backtrace )
		?
		array_values(
			array_map(
				static function ( $trace ) {
					$line = isset( $trace['line'] ) ? absint( $trace['line'] ) : 0;
					return sprintf( '%s:%d', $trace['file'], $line );
				},
				array_filter( // Filter out steps without files
					$debug_backtrace,
					static function ( $step ) {
						return ! empty( $step['file'] );
					}
				)
			)
		)
		:
		[];

	add_action(
		'graphql_get_debug_log',
		static function ( \WPGraphQL\Utils\DebugLog $debug_log ) use ( $message, $config ) {
			$debug_log->add_log_entry( $message, $config );
		}
	);
}

/**
 * Check if the name is valid for use in GraphQL
 *
 * @param string $type_name The name of the type to validate
 *
 * @return bool
 * @since 0.14.0
 */
function is_valid_graphql_name( string $type_name ) {
	if ( preg_match( '/^\d/', $type_name ) ) {
		return false;
	}

	return true;
}

/**
 * Registers a series of GraphQL Settings Fields
 *
 * @param string                $group  The name of the settings group to register fields to
 * @param array<string,mixed>[] $fields Array of field configs to register to the group
 *
 * @return void
 * @since 0.13.0
 */
function register_graphql_settings_fields( string $group, array $fields ) {
	add_action(
		'graphql_init_settings',
		static function ( \WPGraphQL\Admin\Settings\SettingsRegistry $registry ) use ( $group, $fields ) {
			$registry->register_fields( $group, $fields );
		}
	);
}

/**
 * Get an option value from GraphQL settings
 *
 * @param string $option_name   The key of the option to return
 * @param mixed  $default_value The default value the setting should return if no value is set
 * @param string $section_name  The settings group section that the option belongs to
 *
 * @return mixed|string|int|bool
 * @since 0.13.0
 */
function get_graphql_setting( string $option_name, $default_value = '', $section_name = 'graphql_general_settings' ) {
	$section_fields = get_option( $section_name );

	/**
	 * Filter the section fields

	 * @param array<string,mixed> $section_fields The values of the fields stored for the section
	 * @param string              $section_name   The name of the section
	 * @param mixed               $default_value  The default value for the option being retrieved
	 */
	$section_fields = apply_filters( 'graphql_get_setting_section_fields', $section_fields, $section_name, $default_value );

	/**
	 * Get the value from the stored data, or return the default
	 */
	$value = isset( $section_fields[ $option_name ] ) ? $section_fields[ $option_name ] : $default_value;

	/**
	 * Filter the value before returning it
	 *
	 * @param mixed               $value          The value of the field
	 * @param mixed               $default_value  The default value if there is no value set
	 * @param string              $option_name    The name of the option
	 * @param array<string,mixed> $section_fields The setting values within the section
	 * @param string              $section_name   The name of the section the setting belongs to
	 */
	return apply_filters( 'graphql_get_setting_section_field_value', $value, $default_value, $option_name, $section_fields, $section_name );
}

/**
 * Get the endpoint route for the WPGraphQL API
 *
 * @return string
 * @since 1.12.0
 */
function graphql_get_endpoint() {

	// get the endpoint from the settings. default to 'graphql'
	$endpoint = get_graphql_setting( 'graphql_endpoint', 'graphql' );

	/**
	 * @param string $endpoint The relative endpoint that graphql can be accessed at
	 */
	$filtered_endpoint = apply_filters( 'graphql_endpoint', $endpoint );

	// If the filtered endpoint has a value (not filtered to a falsy value), use it. else return the default endpoint
	return ! empty( $filtered_endpoint ) ? $filtered_endpoint : $endpoint;
}

/**
 * Return the full url for the GraphQL Endpoint.
 *
 * @return string
 * @since 1.12.0
 */
function graphql_get_endpoint_url() {
	return site_url( graphql_get_endpoint() );
}

/**
 * Polyfill for PHP versions below 7.3
 *
 * @return int|string|null
 *
 * @since 0.10.0
 */
if ( ! function_exists( 'array_key_first' ) ) {

	/**
	 * @param mixed[] $arr
	 *
	 * @return int|string|null
	 */
	function array_key_first( array $arr ) {
		foreach ( $arr as $key => $value ) {
			return $key;
		}
		return null;
	}
}

/**
 * Polyfill for PHP versions below 7.3
 *
 * @return mixed|string|int
 *
 * @since 0.10.0
 */
if ( ! function_exists( 'array_key_last' ) ) {

	/**
	 * @param mixed[] $arr
	 *
	 * @return int|string|null
	 */
	function array_key_last( array $arr ) {
		end( $arr );

		return key( $arr );
	}
}

/**
 * Polyfill for PHP versions below 8.0
 */
if ( ! function_exists( 'str_starts_with' ) ) {

	/**
	 * @param string $haystack
	 * @param string $needle
	 */
	function str_starts_with( string $haystack, string $needle ): bool {
		return 0 === strncmp( $haystack, $needle, strlen( $needle ) );
	}
}

/**
 * Polyfill for PHP versions below 8.0
 */
if ( ! function_exists( 'str_ends_with' ) ) {

	/**
	 * @param string $haystack
	 * @param string $needle
	 */
	function str_ends_with( string $haystack, string $needle ): bool {
		if ( '' === $needle || $needle === $haystack ) {
			return true;
		}

		if ( '' === $haystack ) {
			return false;
		}

		$needle_length = strlen( $needle );

		return $needle_length <= strlen( $haystack ) && 0 === substr_compare( $haystack, $needle, -$needle_length );
	}
}

/**
 * @param string       $slug A unique slug to identify the admin notice by
 * @param array<mixed> $config The config for the admin notice. Determines visibility, context, etc.
 */
function register_graphql_admin_notice( string $slug, array $config ): void {
	add_action(
		'graphql_admin_notices_init',
		static function ( \WPGraphQL\Admin\AdminNotices $admin_notices ) use ( $slug, $config ) {
			$admin_notices->add_admin_notice( $slug, $config );
		}
	);
}


// File: wp-graphql\activation.php
<?php
/**
 * Runs when WPGraphQL is activated
 *
 * @return void
 */
function graphql_activation_callback() {

	do_action( 'graphql_activate' );

	if ( ! defined( 'WPGRAPHQL_VERSION' ) ) {
		return;
	}

	// store the current version of WPGraphQL
	update_option( 'wp_graphql_version', WPGRAPHQL_VERSION );
}


// File: wp-graphql\constants.php
<?php
/**
 * Sets up constants for use throughout the plugin and by other extending plugins.
 *
 * This is in its own file so that it can be used via the autoloaded classes, but also
 * can be pulled in when composer dependencies have not been installed.
 *
 * @return void
 */
function graphql_setup_constants() {

	// Whether to autoload the files or not.
	// This must be defined here and not within the WPGraphQL.php because this constant
	// determines whether to autoload classes or not
	if ( ! defined( 'WPGRAPHQL_AUTOLOAD' ) ) {
		define( 'WPGRAPHQL_AUTOLOAD', true );
	}

	// Plugin version.
	if ( ! defined( 'WPGRAPHQL_VERSION' ) ) {
		define( 'WPGRAPHQL_VERSION', '1.26.0' );
	}

	// Plugin Folder Path.
	if ( ! defined( 'WPGRAPHQL_PLUGIN_DIR' ) ) {
		define( 'WPGRAPHQL_PLUGIN_DIR', plugin_dir_path( __FILE__ ) );
	}

	// Plugin Root File.
	if ( ! defined( 'WPGRAPHQL_PLUGIN_FILE' ) ) {
		define( 'WPGRAPHQL_PLUGIN_FILE', WPGRAPHQL_PLUGIN_DIR . '/wp-graphql.php' );
	}

	// The minimum version of PHP this plugin requires to work properly
	if ( ! defined( 'GRAPHQL_MIN_PHP_VERSION' ) ) {
		define( 'GRAPHQL_MIN_PHP_VERSION', '7.1' );
	}
}


// File: wp-graphql\deactivation.php
<?php
/**
 * Runs when WPGraphQL is de-activated
 *
 * This cleans up data that WPGraphQL stores
 *
 * @return void
 */
function graphql_deactivation_callback() {

	if ( ! graphql_can_load_plugin() ) {
		return;
	}

	// Fire an action when WPGraphQL is de-activating
	do_action( 'graphql_deactivate' );

	// Delete data during activation
	delete_graphql_data();
}

/**
 * Delete data on deactivation
 *
 * @return void
 */
function delete_graphql_data() {

	if ( ! class_exists( 'WPGraphQL' ) ) {
		return;
	}

	// Check if the plugin is set to delete data or not
	$delete_data = get_graphql_setting( 'delete_data_on_deactivate' );

	// If data is not set to delete, stop now
	if ( 'on' !== $delete_data ) {
		return;
	}

	// Delete graphql version
	delete_option( 'wp_graphql_version' );

	// Initialize the settings API
	$settings = new WPGraphQL\Admin\Settings\Settings();
	$settings->init();
	$settings->register_settings();

	// Get all the registered settings fields
	$fields = $settings->settings_api->get_settings_fields();

	// Loop over the registered settings fields and delete the options
	if ( ! empty( $fields ) && is_array( $fields ) ) {
		foreach ( $fields as $group => $fields ) {
			delete_option( $group );
		}
	}

	do_action( 'graphql_delete_data' );
}


// File: wp-graphql\wp-graphql.php
<?php
/**
 * Plugin Name: WPGraphQL
 * Plugin URI: https://github.com/wp-graphql/wp-graphql
 * GitHub Plugin URI: https://github.com/wp-graphql/wp-graphql
 * Description: GraphQL API for WordPress
 * Author: WPGraphQL
 * Author URI: http://www.wpgraphql.com
 * Version: 1.26.0
 * Text Domain: wp-graphql
 * Domain Path: /languages/
 * Requires at least: 5.0
 * Tested up to: 6.5
 * Requires PHP: 7.1
 * License: GPL-3
 * License URI: https://www.gnu.org/licenses/gpl-3.0.html
 *
 * @package  WPGraphQL
 * @category Core
 * @author   WPGraphQL
 * @version  1.26.0
 */

// Exit if accessed directly.
if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

// If the codeception remote coverage file exists, require it.
// This file should only exist locally or when CI bootstraps the environment for testing
if ( file_exists( __DIR__ . '/c3.php' ) ) {
	require_once __DIR__ . '/c3.php';
}

/**
 * Load files that are required even if the composer autoloader isn't installed
 */
function graphql_require_bootstrap_files(): void {
	if ( file_exists( __DIR__ . '/constants.php' ) ) {
		require_once __DIR__ . '/constants.php';
	}
	if ( file_exists( __DIR__ . '/activation.php' ) ) {
		require_once __DIR__ . '/activation.php';
	}
	if ( file_exists( __DIR__ . '/deactivation.php' ) ) {
		require_once __DIR__ . '/deactivation.php';
	}
	if ( file_exists( __DIR__ . '/access-functions.php' ) ) {
		require_once __DIR__ . '/access-functions.php';
	}
	if ( file_exists( __DIR__ . '/src/WPGraphQL.php' ) ) {
		require_once __DIR__ . '/src/WPGraphQL.php';
	}
}

/**
 * Determines if the plugin can load.
 *
 * Test env:
 *  - WPGRAPHQL_AUTOLOAD: false
 *  - autoload installed and manually added in test env
 *
 * Bedrock
 *  - WPGRAPHQL_AUTOLOAD: not defined
 *  - composer deps installed outside of the plugin
 *
 * Normal (.org repo install)
 * - WPGRAPHQL_AUTOLOAD: not defined
 * - composer deps installed INSIDE the plugin
 */
function graphql_can_load_plugin(): bool {

	// Load the bootstrap files (needed before autoloader is configured)
	graphql_require_bootstrap_files();

	// If GraphQL\GraphQL and WPGraphQL are both already loaded,
	// We can assume that WPGraphQL has been installed as a composer dependency of a parent project
	if ( class_exists( 'GraphQL\GraphQL' ) && class_exists( 'WPGraphQL' ) ) {
		return true;
	}

	/**
	 * WPGRAPHQL_AUTOLOAD can be set to "false" to prevent the autoloader from running.
	 * In most cases, this is not something that should be disabled, but some environments
	 * may bootstrap their dependencies in a global autoloader that will autoload files
	 * before we get to this point, and requiring the autoloader again can trigger fatal errors.
	 *
	 * The codeception tests are an example of an environment where adding the autoloader again causes issues
	 * so this is set to false for tests.
	 */
	if ( defined( 'WPGRAPHQL_AUTOLOAD' ) && false === WPGRAPHQL_AUTOLOAD ) {

		// IF WPGRAPHQL_AUTOLOAD is defined as false,
		// but the WPGraphQL Class exists, we can assume the dependencies
		// are loaded from the parent project.
		return true;
	}

	if ( file_exists( plugin_dir_path( __FILE__ ) . 'vendor/autoload.php' ) ) {
		// Autoload Required Classes.
		require_once plugin_dir_path( __FILE__ ) . 'vendor/autoload.php';
	}

	// If the GraphQL class still doesn't exist, bail as there was an issue bootstrapping the plugin
	if ( ! class_exists( 'GraphQL\GraphQL' ) || ! class_exists( 'WPGraphQL' ) ) {
		return false;
	}

	return true;
}

if ( ! function_exists( 'graphql_init' ) ) {
	/**
	 * Function that instantiates the plugins main class
	 *
	 * @return object|null
	 */
	function graphql_init() {

		// if the plugin can't be loaded, bail
		if ( false === graphql_can_load_plugin() ) {
			add_action( 'network_admin_notices', 'graphql_cannot_load_admin_notice_callback' );
			add_action( 'admin_notices', 'graphql_cannot_load_admin_notice_callback' );
			return null;
		}

		/**
		 * Return an instance of the action
		 */
		return \WPGraphQL::instance();
	}
}
graphql_init();

// Run this function when WPGraphQL is de-activated
register_deactivation_hook( __FILE__, 'graphql_deactivation_callback' );
register_activation_hook( __FILE__, 'graphql_activation_callback' );

/**
 * Render an admin notice if the plugin cannot load
 */
function graphql_cannot_load_admin_notice_callback(): void {
	if ( ! current_user_can( 'manage_options' ) ) {
		return;
	}

	printf(
		'<div class="notice notice-error">' .
		'<p>%s</p>' .
		'</div>',
		esc_html__( 'WPGraphQL appears to have been installed without it\'s dependencies. It will not work properly until dependencies are installed. This likely means you have cloned WPGraphQL from Github and need to run the command `composer install`.', 'wp-graphql' )
	);
}

if ( defined( 'WP_CLI' ) && WP_CLI ) {
	require_once plugin_dir_path( __FILE__ ) . 'cli/wp-cli.php';
}

/**
 * Initialize the plugin tracker
 *
 * @return void
 */
function graphql_init_appsero_telemetry() {
	// If the class doesn't exist, or code is being scanned by PHPSTAN, move on.
	if ( ! class_exists( 'Appsero\Client' ) || defined( 'PHPSTAN' ) ) {
		return;
	}

	$client   = new Appsero\Client( 'cd0d1172-95a0-4460-a36a-2c303807c9ef', 'WPGraphQL', __FILE__ );
	$insights = $client->insights();

	// If the Appsero client has the add_plugin_data method, use it
	if ( method_exists( $insights, 'add_plugin_data' ) ) {
		// @phpstan-ignore-next-line
		$insights->add_plugin_data();
	}

	// @phpstan-ignore-next-line
	$insights->init();
}

graphql_init_appsero_telemetry();


// File: wp-graphql\build\app.asset.php
<?php return array('dependencies' => array('react', 'react-dom', 'wp-element', 'wp-hooks'), 'version' => '81f173f818f820506c81');


// File: wp-graphql\build\graphiqlAuthSwitch.asset.php
<?php return array('dependencies' => array('react', 'react-dom', 'wp-element'), 'version' => '16eb60e48778b28a2f95');


// File: wp-graphql\build\graphiqlFullscreenToggle.asset.php
<?php return array('dependencies' => array('react'), 'version' => '6b693373109e52efe166');


// File: wp-graphql\build\graphiqlQueryComposer.asset.php
<?php return array('dependencies' => array('react', 'react-dom'), 'version' => '04f793b3da3bc9f36cbc');


// File: wp-graphql\build\index.asset.php
<?php return array('dependencies' => array('react', 'wp-element', 'wp-hooks'), 'version' => '252dbaf55e1db7ca04ca');


// File: wp-graphql\cli\wp-cli.php
<?php

if ( ! defined( 'ABSPATH' ) ) {
	exit; // Exit if accessed directly.
}

class WPGraphQL_CLI_Command extends WP_CLI_Command {

	/**
	 * Generate a static schema.
	 *
	 * Defaults to creating a schema.graphql file in the IDL format at the root
	 * of the plugin.
	 *
	 * @todo: Provide alternative formats (AST? INTROSPECTION JSON?) and options for output location/file-type?
	 * @todo: Add Unit Tests
	 *
	 * ## EXAMPLE
	 *
	 *     $ wp graphql generate-static-schema
	 *
	 * @alias generate
	 * @subcommand generate-static-schema
	 */
	public function generate_static_schema( $args, $assoc_args ) {

		/**
		 * Set the file path for where to save the static schema
		 */
		$file_path = get_temp_dir() . 'schema.graphql';

		if ( ! defined( 'GRAPHQL_REQUEST' ) ) {
			define( 'GRAPHQL_REQUEST', true );
		}

		do_action( 'init_graphql_request' );

		/**
		 * Generate the Schema
		 */
		WP_CLI::line( 'Getting the Schema...' );
		$schema = WPGraphQL::get_schema();

		/**
		 * Format the Schema
		 */
		WP_CLI::line( 'Formatting the Schema...' );
		$printed = \GraphQL\Utils\SchemaPrinter::doPrint( $schema );

		/**
		 * Save the Schema to the file
		 */
		WP_CLI::line( 'Saving the Schema...' );

		file_put_contents( $file_path, $printed ); // phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_file_put_contents

		/**
		 * All done!
		 */
		WP_CLI::success( sprintf( 'All done. Schema output to %s.', $file_path ) );
	}
}

WP_CLI::add_command( 'graphql', 'WPGraphQL_CLI_Command' );


// File: wp-graphql\src\AppContext.php
<?php

namespace WPGraphQL;

use GraphQL\Error\UserError;
use WPGraphQL\Data\Loader\CommentAuthorLoader;
use WPGraphQL\Data\Loader\CommentLoader;
use WPGraphQL\Data\Loader\EnqueuedScriptLoader;
use WPGraphQL\Data\Loader\EnqueuedStylesheetLoader;
use WPGraphQL\Data\Loader\PluginLoader;
use WPGraphQL\Data\Loader\PostObjectLoader;
use WPGraphQL\Data\Loader\PostTypeLoader;
use WPGraphQL\Data\Loader\TaxonomyLoader;
use WPGraphQL\Data\Loader\TermObjectLoader;
use WPGraphQL\Data\Loader\ThemeLoader;
use WPGraphQL\Data\Loader\UserLoader;
use WPGraphQL\Data\Loader\UserRoleLoader;
use WPGraphQL\Data\NodeResolver;

/**
 * Class AppContext
 * Creates an object that contains all of the context for the GraphQL query
 * This class gets instantiated and populated in the main WPGraphQL class.
 *
 * The context is passed to each resolver during execution.
 *
 * Resolvers have the ability to read and write to context to pass info to nested resolvers.
 *
 * @package WPGraphQL
 */
// @phpcs:ignore
#[\AllowDynamicProperties]
class AppContext {

	/**
	 * Stores the class to use for the connection query.
	 *
	 * @var \WP_Query|null
	 */
	public $connection_query_class = null;

	/**
	 * Stores the url string for the current site
	 *
	 * @var string $root_url
	 */
	public $root_url;

	/**
	 * Stores the WP_User object of the current user
	 *
	 * @var \WP_User $viewer
	 */
	public $viewer;

	/**
	 * @var \WPGraphQL\Registry\TypeRegistry
	 */
	public $type_registry;

	/**
	 * Stores everything from the $_REQUEST global
	 *
	 * @var mixed $request
	 */
	public $request;

	/**
	 * Stores additional $config properties
	 *
	 * @var mixed $config
	 */
	public $config;

	/**
	 * Passes context about the current connection being resolved
	 *
	 * @var mixed|string|null
	 */
	public $currentConnection = null;

	/**
	 * Passes context about the current connection
	 *
	 * @var array<string,mixed>
	 */
	public $connectionArgs = [];

	/**
	 * Stores the loaders for the class
	 *
	 * @var array<string,\WPGraphQL\Data\Loader\AbstractDataLoader>
	 */
	public $loaders = [];

	/**
	 * Instance of the NodeResolver class to resolve nodes by URI
	 *
	 * @var \WPGraphQL\Data\NodeResolver
	 */
	public $node_resolver;

	/**
	 * AppContext constructor.
	 */
	public function __construct() {

		/**
		 * Create a list of loaders to be available in AppContext
		 */
		$loaders = [
			'comment_author'      => new CommentAuthorLoader( $this ),
			'comment'             => new CommentLoader( $this ),
			'enqueued_script'     => new EnqueuedScriptLoader( $this ),
			'enqueued_stylesheet' => new EnqueuedStylesheetLoader( $this ),
			'plugin'              => new PluginLoader( $this ),
			'nav_menu_item'       => new PostObjectLoader( $this ),
			'post'                => new PostObjectLoader( $this ),
			'post_type'           => new PostTypeLoader( $this ),
			'taxonomy'            => new TaxonomyLoader( $this ),
			'term'                => new TermObjectLoader( $this ),
			'theme'               => new ThemeLoader( $this ),
			'user'                => new UserLoader( $this ),
			'user_role'           => new UserRoleLoader( $this ),
		];

		/**
		 * This filters the data loaders, allowing for additional loaders to be
		 * added to the AppContext or for existing loaders to be replaced if
		 * needed.
		 *
		 * @params array $loaders The loaders accessible in the AppContext
		 * @params AppContext $this The AppContext
		 */
		$this->loaders = apply_filters( 'graphql_data_loaders', $loaders, $this );

		/**
		 * This sets up the NodeResolver to allow nodes to be resolved by URI
		 *
		 * @param \WPGraphQL\AppContext $app_context The AppContext instance
		 */
		$this->node_resolver = new NodeResolver( $this );

		/**
		 * This filters the config for the AppContext.
		 *
		 * This can be used to store additional context config, which is available to resolvers
		 * throughout the resolution of a GraphQL request.
		 *
		 * @params array $config The config array of the AppContext object
		 */
		$this->config = apply_filters( 'graphql_app_context_config', $this->config );
	}

	/**
	 * Retrieves loader assigned to $key
	 *
	 * @param string $key The name of the loader to get
	 *
	 * @return \WPGraphQL\Data\Loader\AbstractDataLoader|mixed
	 *
	 * @deprecated Use get_loader instead.
	 */
	public function getLoader( $key ) {
		_deprecated_function( __METHOD__, '0.8.4', self::class . '::get_loader()' );
		return $this->get_loader( $key );
	}

	/**
	 * Retrieves loader assigned to $key
	 *
	 * @param string $key The name of the loader to get
	 *
	 * @return \WPGraphQL\Data\Loader\AbstractDataLoader|mixed
	 * @throws \GraphQL\Error\UserError If the loader is not found.
	 */
	public function get_loader( $key ) {
		if ( ! array_key_exists( $key, $this->loaders ) ) {
			// translators: %s is the key of the loader that was not found.
			throw new UserError( esc_html( sprintf( __( 'No loader assigned to the key %s', 'wp-graphql' ), $key ) ) );
		}

		return $this->loaders[ $key ];
	}

	/**
	 * Returns the $args for the connection the field is a part of
	 *
	 * @deprecated use get_connection_args() instead
	 * @return mixed[]|mixed
	 */
	public function getConnectionArgs() {
		_deprecated_function( __METHOD__, '0.8.4', self::class . '::get_connection_args()' );
		return $this->get_connection_args();
	}

	/**
	 * Returns the $args for the connection the field is a part of
	 *
	 * @return mixed[]|mixed
	 */
	public function get_connection_args() {
		return isset( $this->currentConnection ) && isset( $this->connectionArgs[ $this->currentConnection ] ) ? $this->connectionArgs[ $this->currentConnection ] : [];
	}

	/**
	 * Returns the current connection
	 *
	 * @return mixed|string|null
	 */
	public function get_current_connection() {
		return isset( $this->currentConnection ) ? $this->currentConnection : null;
	}

	/**
	 * @return mixed|string|null
	 * @deprecated use get_current_connection instead.
	 */
	public function getCurrentConnection() {
		return $this->get_current_connection();
	}
}


// File: wp-graphql\src\Request.php
<?php

namespace WPGraphQL;

use Exception;
use GraphQL\Error\DebugFlag;
use GraphQL\Error\Error;
use GraphQL\GraphQL;
use GraphQL\Server\OperationParams;
use GraphQL\Server\ServerConfig;
use GraphQL\Server\StandardServer;
use WPGraphQL\Server\ValidationRules\DisableIntrospection;
use WPGraphQL\Server\ValidationRules\QueryDepth;
use WPGraphQL\Server\ValidationRules\RequireAuthentication;
use WPGraphQL\Server\WPHelper;
use WPGraphQL\Utils\DebugLog;
use WPGraphQL\Utils\QueryAnalyzer;

/**
 * Class Request
 *
 * Proxies a request to graphql-php, applying filters and transforming request
 * data as needed.
 *
 * @package WPGraphQL
 */
class Request {

	/**
	 * App context for this request.
	 *
	 * @var \WPGraphQL\AppContext
	 */
	public $app_context;

	/**
	 * Request data.
	 *
	 * @var mixed|array<string,mixed>|\GraphQL\Server\OperationParams
	 */
	public $data;

	/**
	 * Cached global post.
	 *
	 * @var ?\WP_Post
	 */
	public $global_post;

	/**
	 * Cached global wp_the_query.
	 *
	 * @var ?\WP_Query
	 */
	private $global_wp_the_query;

	/**
	 * GraphQL operation parameters for this request. Can also be an array of
	 * OperationParams.
	 *
	 * @var mixed|mixed[]|\GraphQL\Server\OperationParams|\GraphQL\Server\OperationParams[]
	 */
	public $params;

	/**
	 * Schema for this request.
	 *
	 * @var \WPGraphQL\WPSchema
	 */
	public $schema;

	/**
	 * Debug log for WPGraphQL Requests
	 *
	 * @var \WPGraphQL\Utils\DebugLog
	 */
	public $debug_log;

	/**
	 * The Type Registry the Schema is built with
	 *
	 * @var \WPGraphQL\Registry\TypeRegistry
	 */
	public $type_registry;

	/**
	 * Validation rules for execution.
	 *
	 * @var array<int|string,\GraphQL\Validator\Rules\ValidationRule>
	 */
	protected $validation_rules;

	/**
	 * The default field resolver function. Default null
	 *
	 * @var callable|null
	 */
	protected $field_resolver;

	/**
	 * The root value of the request. Default null;
	 *
	 * @var mixed
	 */
	protected $root_value;

	/**
	 * @var \WPGraphQL\Utils\QueryAnalyzer
	 */
	protected $query_analyzer;

	/**
	 * Constructor
	 *
	 * @param array<string,mixed> $data The request data.
	 *
	 * @return void
	 *
	 * @throws \Exception
	 */
	public function __construct( array $data = [] ) {

		/**
		 * Whether it's a GraphQL Request (http or internal)
		 *
		 * @since 0.0.5
		 */
		if ( ! defined( 'GRAPHQL_REQUEST' ) ) {
			define( 'GRAPHQL_REQUEST', true );
		}

		/**
		 * Filter "is_graphql_request" to return true
		 */
		\WPGraphQL::set_is_graphql_request( true );

		/**
		 * Action – intentionally with no context – to indicate a GraphQL Request has started.
		 * This is a great place for plugins to hook in and modify things that should only
		 * occur in the context of a GraphQL Request. The base class hooks into this action to
		 * kick off the schema creation, so types are not set up until this action has run!
		 */
		do_action( 'init_graphql_request' );

		// Start tracking debug log messages
		$this->debug_log = new DebugLog();

		// Set request data for passed-in (non-HTTP) requests.
		$this->data = $data;

		// Get the Type Registry
		$this->type_registry = \WPGraphQL::get_type_registry();

		// Get the Schema
		$this->schema = \WPGraphQL::get_schema();

		// Get the App Context
		$this->app_context = \WPGraphQL::get_app_context();

		$this->root_value       = $this->get_root_value();
		$this->validation_rules = $this->get_validation_rules();
		$this->field_resolver   = $this->get_field_resolver();

		/**
		 * Configure the app_context which gets passed down to all the resolvers.
		 *
		 * @since 0.0.4
		 */
		$app_context                = new AppContext();
		$app_context->viewer        = wp_get_current_user();
		$app_context->root_url      = get_bloginfo( 'url' );
		$app_context->request       = ! empty( $_REQUEST ) ? $_REQUEST : null; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
		$app_context->type_registry = $this->type_registry;
		$this->app_context          = $app_context;

		$this->query_analyzer = new QueryAnalyzer( $this );

		// The query analyzer tracks nodes, models, list types and more
		// to return in headers and debug messages to help developers understand
		// what was resolved, how to cache it, etc.
		$this->query_analyzer->init();
	}

	/**
	 * Get the instance of the Query Analyzer
	 */
	public function get_query_analyzer(): QueryAnalyzer {
		return $this->query_analyzer;
	}

	/**
	 * @return callable|null
	 */
	protected function get_field_resolver() {
		return $this->field_resolver;
	}

	/**
	 * Return the validation rules to use in the request
	 *
	 * @return array<int|string,\GraphQL\Validator\Rules\ValidationRule>
	 */
	protected function get_validation_rules(): array {
		$validation_rules = GraphQL::getStandardValidationRules();

		$validation_rules['require_authentication'] = new RequireAuthentication();
		$validation_rules['disable_introspection']  = new DisableIntrospection();
		$validation_rules['query_depth']            = new QueryDepth();

		/**
		 * Return the validation rules to use in the request
		 *
		 * @param array<int|string,\GraphQL\Validator\Rules\ValidationRule> $validation_rules The validation rules to use in the request
		 * @param \WPGraphQL\Request                                        $request          The Request instance
		 */
		return apply_filters( 'graphql_validation_rules', $validation_rules, $this );
	}

	/**
	 * Returns the root value to use in the request.
	 *
	 * @return mixed|null
	 */
	protected function get_root_value() {
		/**
		 * Set the root value based on what was passed to the request
		 */
		$root_value = isset( $this->data['root_value'] ) && ! empty( $this->data['root_value'] ) ? $this->data['root_value'] : null;

		/**
		 * Return the filtered root value
		 *
		 * @param mixed              $root_value The root value the Schema should use to resolve with. Default null.
		 * @param \WPGraphQL\Request $request    The Request instance
		 */
		return apply_filters( 'graphql_root_value', $root_value, $this );
	}

	/**
	 * Apply filters and do actions before GraphQL execution
	 *
	 * @throws \GraphQL\Error\Error
	 */
	private function before_execute(): void {

		/**
		 * Store the global post so that it can be reset after GraphQL execution
		 *
		 * This allows for a GraphQL query to be used in the middle of post content, such as in a Shortcode
		 * without disrupting the flow of the post as the global POST before and after GraphQL execution will be
		 * the same.
		 */
		if ( ! empty( $GLOBALS['post'] ) ) {
			$this->global_post = $GLOBALS['post'];
		}

		if ( ! empty( $GLOBALS['wp_query'] ) ) {
			$this->global_wp_the_query = clone $GLOBALS['wp_the_query'];
		}

		/**
		 * If the request is a batch request it will come back as an array
		 */
		if ( is_array( $this->params ) ) {

			// If the request is a batch request, but batch requests are disabled,
			// bail early
			if ( ! $this->is_batch_queries_enabled() ) {
				throw new Error( esc_html__( 'Batch Queries are not supported', 'wp-graphql' ) );
			}

			$batch_limit = get_graphql_setting( 'batch_limit', 10 );
			$batch_limit = absint( $batch_limit ) ? absint( $batch_limit ) : 10;

			// If batch requests are enabled, but a limit is set and the request exceeds the limit
			// fail now
			if ( $batch_limit < count( $this->params ) ) {
				// translators: First placeholder is the max number of batch operations allowed in a GraphQL request. The 2nd placeholder is the number of operations requested in the current request.
				throw new Error( sprintf( esc_html__( 'Batch requests are limited to %1$d operations. This request contained %2$d', 'wp-graphql' ), absint( $batch_limit ), count( $this->params ) ) );
			}

			/**
			 * Execute batch queries
			 *
			 * @param \GraphQL\Server\OperationParams[] $params The operation params of the batch request
			 */
			do_action( 'graphql_execute_batch_queries', $this->params );

			// Process the batched requests
			array_walk( $this->params, [ $this, 'do_action' ] );
		} else {
			$this->do_action( $this->params );
		}

		/**
		 * This action runs before execution of a GraphQL request (regardless if it's a single or batch request)
		 *
		 * @param \WPGraphQL\Request $request The instance of the Request being executed
		 */
		do_action( 'graphql_before_execute', $this );
	}

	/**
	 * Checks authentication errors.
	 *
	 * False will mean there are no detected errors and
	 * execution will continue.
	 *
	 * Anything else (true, WP_Error, thrown exception, etc) will prevent execution of the GraphQL
	 * request.
	 *
	 * @return bool
	 * @throws \Exception
	 */
	protected function has_authentication_errors() {
		/**
		 * Bail if this is not an HTTP request.
		 *
		 * Auth for internal requests will happen
		 * via WordPress internals.
		 */
		if ( ! is_graphql_http_request() ) {
			return false;
		}

		/**
		 * Access the global $wp_rest_auth_cookie
		 */
		global $wp_rest_auth_cookie;

		/**
		 * Default state of the authentication errors
		 */
		$authentication_errors = false;

		/**
		 * Is cookie authentication NOT being used?
		 *
		 * If we get an auth error, but the user is still logged in, another auth mechanism
		 * (JWT, oAuth, etc) must have been used.
		 */
		if ( true !== $wp_rest_auth_cookie && is_user_logged_in() ) {

			/**
			 * Return filtered authentication errors
			 */
			return $this->filtered_authentication_errors( $authentication_errors );

			/**
			 * If the user is not logged in, determine if there's a nonce
			 */
		} else {
			$nonce = null;

			if ( isset( $_REQUEST['_wpnonce'] ) ) {
				$nonce = $_REQUEST['_wpnonce']; // phpcs:ignore WordPress.Security.NonceVerification.Recommended,WordPress.Security.ValidatedSanitizedInput.MissingUnslash,WordPress.Security.ValidatedSanitizedInput.InputNotSanitized
			} elseif ( isset( $_SERVER['HTTP_X_WP_NONCE'] ) ) {
				$nonce = $_SERVER['HTTP_X_WP_NONCE']; // phpcs:ignore WordPress.Security.ValidatedSanitizedInput.MissingUnslash,WordPress.Security.ValidatedSanitizedInput.InputNotSanitized
			}

			if ( null === $nonce ) {
				// No nonce at all, so act as if it's an unauthenticated request.
				wp_set_current_user( 0 );

				return $this->filtered_authentication_errors( $authentication_errors );
			}

			// Check the nonce.
			$result = wp_verify_nonce( $nonce, 'wp_rest' );

			if ( ! $result ) {
				throw new Exception( esc_html__( 'Cookie nonce is invalid', 'wp-graphql' ) );
			}
		}

		/**
		 * Return the filtered authentication errors
		 */
		return $this->filtered_authentication_errors( $authentication_errors );
	}

	/**
	 * Filter Authentication errors. Allows plugins that authenticate to hook in and prevent
	 * execution if Authentication errors exist.
	 *
	 * @param bool $authentication_errors Whether there are authentication errors with the request.
	 *
	 * @return bool
	 */
	protected function filtered_authentication_errors( $authentication_errors = false ) {

		/**
		 * If false, there are no authentication errors. If true, execution of the
		 * GraphQL request will be prevented and an error will be thrown.
		 *
		 * @param bool $authentication_errors Whether there are authentication errors with the request
		 * @param \WPGraphQL\Request $request Instance of the Request
		 */
		return apply_filters( 'graphql_authentication_errors', $authentication_errors, $this );
	}

	/**
	 * Performs actions and runs filters after execution completes
	 *
	 * @param mixed|array<string,mixed>|object $response The response from execution. Array for batch requests, single object for individual requests.
	 *
	 * @return mixed[]
	 *
	 * @throws \Exception
	 */
	private function after_execute( $response ) {

		/**
		 * If there are authentication errors, prevent execution and throw an exception.
		 */
		if ( false !== $this->has_authentication_errors() ) {
			throw new Exception( esc_html__( 'Authentication Error', 'wp-graphql' ) );
		}

		/**
		 * If the params and the $response are both arrays
		 * treat this as a batch request and map over the array to apply the
		 * after_execute_actions, otherwise apply them to the current response
		 */
		if ( is_array( $this->params ) && is_array( $response ) ) {
			$filtered_response = [];
			foreach ( $response as $key => $resp ) {
				$filtered_response[] = $this->after_execute_actions( $resp, (int) $key );
			}
		} else {
			$filtered_response = $this->after_execute_actions( $response, null );
		}

		/**
		 * Reset the global post after execution
		 *
		 * This allows for a GraphQL query to be used in the middle of post content, such as in a Shortcode
		 * without disrupting the flow of the post as the global POST before and after GraphQL execution will be
		 * the same.
		 *
		 * We cannot use wp_reset_postdata here because it just resets the post from the global query which can
		 * be anything the because the resolvers themself can set it to whatever. So we just manually reset the
		 * post with setup_postdata we cached before this request.
		 */

		if ( ! empty( $this->global_wp_the_query ) ) {
			$GLOBALS['wp_the_query'] = $this->global_wp_the_query; // phpcs:ignore WordPress.WP.GlobalVariablesOverride
			wp_reset_query(); // phpcs:ignore WordPress.WP.DiscouragedFunctions.wp_reset_query_wp_reset_query
		}

		if ( ! empty( $this->global_post ) ) {
			$GLOBALS['post'] = $this->global_post; // phpcs:ignore WordPress.WP.GlobalVariablesOverride
			setup_postdata( $this->global_post );
		}

		/**
		 * Run an action after GraphQL Execution
		 *
		 * @param mixed[] $filtered_response The response of the entire operation. Could be a single operation or a batch operation
		 * @param \WPGraphQL\Request  $request Instance of the Request being executed
		 */
		do_action( 'graphql_after_execute', $filtered_response, $this );

		/**
		 * Return the filtered response
		 */
		return $filtered_response;
	}

	/**
	 * Apply filters and do actions after GraphQL execution
	 *
	 * @param mixed|array<string,mixed>|object $response The response for your GraphQL request
	 * @param mixed|int|null                   $key      The array key of the params for batch requests
	 *
	 * @return mixed|array<string,mixed>|object
	 */
	private function after_execute_actions( $response, $key = null ) {

		/**
		 * Determine which params (batch or single request) to use when passing through to the actions
		 */
		$query     = null;
		$operation = null;
		$variables = null;
		$query_id  = null;

		if ( $this->params instanceof OperationParams ) {
			$operation = $this->params->operation;
			$query     = $this->params->query;
			$query_id  = $this->params->queryId;
			$variables = $this->params->variables;
		} elseif ( is_array( $this->params ) ) {
			$operation = $this->params[ $key ]->operation ?? '';
			$query     = $this->params[ $key ]->query ?? '';
			$query_id  = $this->params[ $key ]->queryId ?? null;
			$variables = $this->params[ $key ]->variables ?? null;
		}

		/**
		 * Run an action. This is a good place for debug tools to hook in to log things, etc.
		 *
		 * @param mixed|array<string,mixed>|object $response  The response your GraphQL request
		 * @param \WPGraphQL\WPSchema              $schema The schema object for the root request
		 * @param mixed|string|null                $operation The name of the operation
		 * @param string                           $query     The query that GraphQL executed
		 * @param mixed[]|null                     $variables Variables to passed to your GraphQL query
		 * @param \WPGraphQL\Request               $request Instance of the Request
		 *
		 * @since 0.0.4
		 */
		do_action( 'graphql_execute', $response, $this->schema, $operation, $query, $variables, $this );

		/**
		 * Add the debug log to the request
		 */
		if ( ! empty( $response ) ) {
			if ( is_array( $response ) ) {
				$response['extensions']['debug'] = $this->debug_log->get_logs();
			} else {
				$response->extensions['debug'] = $this->debug_log->get_logs();
			}
		}

		/**
		 * Filter the $response of the GraphQL execution. This allows for the response to be filtered
		 * before it's returned, allowing granular control over the response at the latest point.
		 *
		 * POSSIBLE USAGE EXAMPLES:
		 * This could be used to ensure that certain fields never make it to the response if they match
		 * certain criteria, etc. For example, this filter could be used to check if a current user is
		 * allowed to see certain things, and if they are not, the $response could be filtered to remove
		 * the data they should not be allowed to see.
		 *
		 * Or, perhaps some systems want the response to always include some additional piece of data in
		 * every response, regardless of the request that was sent to it, this could allow for that
		 * to be hooked in and included in the $response.
		 *
		 * @param mixed|array<string,mixed>|object $response  The response for your GraphQL query
		 * @param \WPGraphQL\WPSchema              $schema    The schema object for the root query
		 * @param string                           $operation The name of the operation
		 * @param string                           $query     The query that GraphQL executed
		 * @param mixed[]|null                     $variables Variables to passed to your GraphQL request
		 * @param \WPGraphQL\Request               $request   Instance of the Request
		 * @param ?string                          $query_id  The query id that GraphQL executed
		 *
		 * @since 0.0.5
		 */
		$filtered_response = apply_filters( 'graphql_request_results', $response, $this->schema, $operation, $query, $variables, $this, $query_id );

		/**
		 * Run an action after the response has been filtered, as the response is being returned.
		 * This is a good place for debug tools to hook in to log things, etc.
		 *
		 * @param mixed|array<string,mixed>|object $filtered_response The filtered response for the GraphQL request
		 * @param mixed|array<string,mixed>|object $response          The response for your GraphQL request
		 * @param \WPGraphQL\WPSchema              $schema            The schema object for the root request
		 * @param string                           $operation         The name of the operation
		 * @param string                           $query             The query that GraphQL executed
		 * @param mixed[]|null                     $variables         Variables to passed to your GraphQL query
		 * @param \WPGraphQL\Request               $request           Instance of the Request
		 * @param ?string                          $query_id          The query id that GraphQL executed
		 */
		do_action( 'graphql_return_response', $filtered_response, $response, $this->schema, $operation, $query, $variables, $this, $query_id );

		/**
		 * Filter "is_graphql_request" back to false.
		 */
		\WPGraphQL::set_is_graphql_request( false );

		return $filtered_response;
	}

	/**
	 * Run action for a request.
	 *
	 * @param \GraphQL\Server\OperationParams $params OperationParams for the request.
	 *
	 * @return void
	 */
	private function do_action( OperationParams $params ) {

		/**
		 * Run an action for each request.
		 *
		 * @param ?string          $query     The GraphQL query
		 * @param ?string          $operation The name of the operation
		 * @param ?array          $variables Variables to be passed to your GraphQL request
		 * @param \GraphQL\Server\OperationParams $params The Operation Params. This includes any extra params,
		 * such as extenions or any other modifications to the request body
		 */
		do_action( 'do_graphql_request', $params->query, $params->operation, $params->variables, $params );
	}

	/**
	 * Execute an internal request (graphql() function call).
	 *
	 * @return array<string,mixed>
	 * @throws \Exception
	 */
	public function execute() {
		$helper = new WPHelper();

		if ( ! $this->data instanceof OperationParams ) {
			$this->params = $helper->parseRequestParams( 'POST', $this->data, [] );
		} else {
			$this->params = $this->data;
		}

		if ( is_array( $this->params ) ) {
			return array_map(
				function ( $data ) {
					$this->data = $data;
					return $this->execute();
				},
				$this->params
			);
		}

		// If $this->params isnt an array or an OperationParams instance, then something probably went wrong.
		if ( ! $this->params instanceof OperationParams ) {
			throw new \Exception( 'Invalid request params.' );
		}

		/**
		 * Initialize the GraphQL Request
		 */
		$this->before_execute();
		$response = apply_filters( 'pre_graphql_execute_request', null, $this );

		if ( null === $response ) {

			/**
			 * Allow the query string to be determined by a filter. Ex, when params->queryId is present, query can be retrieved.
			 */
			$query = apply_filters(
				'graphql_execute_query_params',
				isset( $this->params->query ) ? $this->params->query : '',
				$this->params
			);

			$result = GraphQL::executeQuery(
				$this->schema,
				$query,
				$this->root_value,
				$this->app_context,
				isset( $this->params->variables ) ? $this->params->variables : null,
				isset( $this->params->operation ) ? $this->params->operation : null,
				$this->field_resolver,
				$this->validation_rules
			);

			/**
			 * Return the result of the request
			 */
			$response = $result->toArray( $this->get_debug_flag() );
		}

		/**
		 * Ensure the response is returned as a proper, populated array. Otherwise add an error.
		 */
		if ( empty( $response ) || ! is_array( $response ) ) {
			$response = [
				'errors' => __( 'The GraphQL request returned an invalid response', 'wp-graphql' ),
			];
		}

		/**
		 * If the request is a batch request it will come back as an array
		 */
		return $this->after_execute( $response );
	}

	/**
	 * Execute an HTTP request.
	 *
	 * @return array<string,mixed>
	 * @throws \Exception
	 */
	public function execute_http() {
		/**
		 * Parse HTTP request.
		 */
		$helper       = new WPHelper();
		$this->params = $helper->parseHttpRequest();

		/**
		 * Initialize the GraphQL Request
		 */
		$this->before_execute();

		/**
		 * Get the response.
		 */
		$response = apply_filters( 'pre_graphql_execute_request', null, $this );

		/**
		 * If no cached response, execute the query
		 */
		if ( null === $response ) {
			$server   = $this->get_server();
			$response = $server->executeRequest( $this->params );
		}

		return $this->after_execute( $response );
	}

	/**
	 * Get the operation params for the request.
	 *
	 * @return \GraphQL\Server\OperationParams|\GraphQL\Server\OperationParams[]
	 */
	public function get_params() {
		return $this->params;
	}

	/**
	 * Returns the debug flag value
	 *
	 * @return int
	 */
	public function get_debug_flag() {
		$flag = DebugFlag::INCLUDE_DEBUG_MESSAGE;
		if ( 0 !== get_current_user_id() ) {
			// Flag 2 shows the trace data, which should require user to be logged in to see by default
			$flag = DebugFlag::INCLUDE_DEBUG_MESSAGE | DebugFlag::INCLUDE_TRACE;
		}

		return true === \WPGraphQL::debug() ? $flag : DebugFlag::NONE;
	}

	/**
	 * Determines if batch queries are enabled for the server.
	 *
	 * Default is to have batch queries enabled.
	 *
	 * @return bool
	 */
	private function is_batch_queries_enabled() {
		$batch_queries_enabled = true;

		$batch_queries_setting = get_graphql_setting( 'batch_queries_enabled', 'on' );
		if ( 'off' === $batch_queries_setting ) {
			$batch_queries_enabled = false;
		}

		/**
		 * Filter whether batch queries are supported or not
		 *
		 * @param bool         $batch_queries_enabled Whether Batch Queries should be enabled
		 * @param \GraphQL\Server\OperationParams $params Request operation params
		 */
		return apply_filters( 'graphql_is_batch_queries_enabled', $batch_queries_enabled, $this->params );
	}

	/**
	 * Create the GraphQL server that will process the request.
	 *
	 * @return \GraphQL\Server\StandardServer
	 */
	private function get_server() {
		$debug_flag = $this->get_debug_flag();

		$config = new ServerConfig();
		$config
			->setDebugFlag( $debug_flag )
			->setSchema( $this->schema )
			->setContext( $this->app_context )
			->setValidationRules( $this->validation_rules )
			->setQueryBatching( $this->is_batch_queries_enabled() );

		if ( ! empty( $this->root_value ) ) {
			$config->setFieldResolver( $this->root_value );
		}

		if ( ! empty( $this->field_resolver ) ) {
			$config->setFieldResolver( $this->field_resolver );
		}

		/**
		 * Run an action when the server config is created. The config can be acted
		 * upon directly to override default values or implement new features, e.g.,
		 * $config->setValidationRules().
		 *
		 * @param \GraphQL\Server\ServerConfig $config Server config
		 * @param \GraphQL\Server\OperationParams $params Request operation params
		 *
		 * @since 0.2.0
		 */
		do_action( 'graphql_server_config', $config, $this->params );

		return new StandardServer( $config );
	}
}


// File: wp-graphql\src\Router.php
<?php

namespace WPGraphQL;

use GraphQL\Error\FormattedError;
use WP_User;

/**
 * Class Router
 * This sets up the /graphql endpoint
 *
 * @package WPGraphQL
 * @since   0.0.1
 */
class Router {

	/**
	 * Sets the route to use as the endpoint
	 *
	 * @var string $route
	 */
	public static $route = 'graphql';

	/**
	 * Holds the Global Post for later resetting
	 *
	 * @var string
	 */
	protected static $global_post = '';

	/**
	 * Set the default status code to 200.
	 *
	 * @var int
	 */
	public static $http_status_code = 200;

	/**
	 * @var \WPGraphQL\Request | null
	 */
	protected static $request;

	/**
	 * Initialize the WPGraphQL Router
	 *
	 * @return void
	 * @throws \Exception
	 */
	public function init() {
		self::$route = graphql_get_endpoint();

		/**
		 * Create the rewrite rule for the route
		 *
		 * @since 0.0.1
		 */
		add_action( 'init', [ $this, 'add_rewrite_rule' ], 10 );

		/**
		 * Add the query var for the route
		 *
		 * @since 0.0.1
		 */
		add_filter( 'query_vars', [ $this, 'add_query_var' ], 1, 1 );

		/**
		 * Redirects the route to the graphql processor
		 *
		 * @since 0.0.1
		 */
		add_action( 'parse_request', [ $this, 'resolve_http_request' ], 10 );

		/**
		 * Adds support for application passwords
		 */
		add_filter( 'application_password_is_api_request', [ $this, 'is_api_request' ] );
	}

	/**
	 * Returns the GraphQL Request being executed
	 */
	public static function get_request(): ?Request {
		return self::$request;
	}

	/**
	 * Adds rewrite rule for the route endpoint
	 *
	 * @return void
	 * @since  0.0.1
	 * @uses   add_rewrite_rule()
	 */
	public static function add_rewrite_rule() {
		add_rewrite_rule(
			self::$route . '/?$',
			'index.php?' . self::$route . '=true',
			'top'
		);
	}

	/**
	 * Determines whether the request is an API request to play nice with
	 * application passwords and potential other WordPress core functionality
	 * for APIs
	 *
	 * @param bool $is_api_request Whether the request is an API request
	 *
	 * @return bool
	 */
	public function is_api_request( $is_api_request ) {
		return true === is_graphql_http_request() ? true : $is_api_request;
	}

	/**
	 * Adds the query_var for the route
	 *
	 * @param string[] $query_vars The array of whitelisted query variables.
	 *
	 * @return string[]
	 * @since  0.0.1
	 */
	public static function add_query_var( $query_vars ) {
		$query_vars[] = self::$route;

		return $query_vars;
	}

	/**
	 * Returns true when the current request is a GraphQL request coming from the HTTP
	 *
	 * NOTE: This will only indicate whether the GraphQL Request is an HTTP request. Many features
	 * need to affect _all_ GraphQL requests, including internal requests using the `graphql()`
	 * function, so be careful how you use this to check your conditions.
	 *
	 * @return bool
	 */
	public static function is_graphql_http_request() {

		/**
		 * Filter whether the request is a GraphQL HTTP Request. Default is null, as the majority
		 * of WordPress requests are NOT GraphQL requests (at least today that's true 😆).
		 *
		 * If this filter returns anything other than null, the function will return now and skip the
		 * default checks.
		 *
		 * @param ?bool $is_graphql_http_request Whether the request is a GraphQL HTTP Request. Default false.
		 */
		$pre_is_graphql_http_request = apply_filters( 'graphql_pre_is_graphql_http_request', null );

		/**
		 * If the filter has been applied, return now before executing default checks
		 */
		if ( null !== $pre_is_graphql_http_request ) {
			return (bool) $pre_is_graphql_http_request;
		}

		// Default is false
		$is_graphql_http_request = false;

		// Support wp-graphiql style request to /index.php?graphql.
		if ( isset( $_GET[ self::$route ] ) ) { // phpcs:ignore WordPress.Security.NonceVerification

			$is_graphql_http_request = true;
		} elseif ( isset( $_SERVER['HTTP_HOST'] ) && isset( $_SERVER['REQUEST_URI'] ) ) {
			// Check the server to determine if the GraphQL endpoint is being requested
			$host = wp_unslash( $_SERVER['HTTP_HOST'] ); // phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized
			$uri  = wp_unslash( $_SERVER['REQUEST_URI'] ); // phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized

			if ( ! is_string( $host ) ) {
				return false;
			}

			if ( ! is_string( $uri ) ) {
				return false;
			}

			$parsed_site_url    = wp_parse_url( site_url( self::$route ), PHP_URL_PATH );
			$graphql_url        = ! empty( $parsed_site_url ) ? wp_unslash( $parsed_site_url ) : self::$route;
			$parsed_request_url = wp_parse_url( $uri, PHP_URL_PATH );
			$request_url        = ! empty( $parsed_request_url ) ? wp_unslash( $parsed_request_url ) : '';

			// Determine if the route is indeed a graphql request
			$is_graphql_http_request = str_replace( '/', '', $request_url ) === str_replace( '/', '', $graphql_url );
		}

		/**
		 * Filter whether the request is a GraphQL HTTP Request. Default is false, as the majority
		 * of WordPress requests are NOT GraphQL requests (at least today that's true 😆).
		 *
		 * The request has to "prove" that it is indeed an HTTP request via HTTP for
		 * this to be true.
		 *
		 * Different servers _might_ have different needs to determine whether a request
		 * is a GraphQL request.
		 *
		 * @param bool $is_graphql_http_request Whether the request is a GraphQL HTTP Request. Default false.
		 */
		return apply_filters( 'graphql_is_graphql_http_request', $is_graphql_http_request );
	}

	/**
	 * DEPRECATED: Returns whether a request is a GraphQL Request. Deprecated
	 * because it's name is a bit misleading. This will only return if the request
	 * is a GraphQL request coming from the HTTP endpoint. Internal GraphQL requests
	 * won't be able to use this to properly determine if the request is a GraphQL request
	 * or not.
	 *
	 * @return bool
	 * @deprecated 0.4.1 Use Router::is_graphql_http_request instead. This now resolves to it
	 */
	public static function is_graphql_request() {
		_deprecated_function( __METHOD__, '0.4.1', self::class . 'is_graphql_http_request()' );
		return self::is_graphql_http_request();
	}

	/**
	 * This resolves the http request and ensures that WordPress can respond with the appropriate
	 * JSON response instead of responding with a template from the standard WordPress Template
	 * Loading process
	 *
	 * @return void
	 * @throws \Exception Throws exception.
	 * @throws \Throwable Throws exception.
	 * @since  0.0.1
	 */
	public static function resolve_http_request() {

		/**
		 * Access the $wp_query object
		 */
		global $wp_query;

		/**
		 * Ensure we're on the registered route for graphql route
		 */
		if ( ! self::is_graphql_http_request() || is_graphql_request() ) {
			return;
		}

		/**
		 * Set is_home to false
		 */
		$wp_query->is_home = false;

		/**
		 * Whether it's a GraphQL HTTP Request
		 *
		 * @since 0.0.5
		 */
		if ( ! defined( 'GRAPHQL_HTTP_REQUEST' ) ) {
			define( 'GRAPHQL_HTTP_REQUEST', true );
		}

		/**
		 * Process the GraphQL query Request
		 */
		self::process_http_request();
	}

	/**
	 * Sends an HTTP header.
	 *
	 * @param string $key   Header key.
	 * @param string $value Header value.
	 *
	 * @return void
	 * @since  0.0.5
	 */
	public static function send_header( $key, $value ) {

		/**
		 * Sanitize as per RFC2616 (Section 4.2):
		 *
		 * Any LWS that occurs between field-content MAY be replaced with a
		 * single SP before interpreting the field value or forwarding the
		 * message downstream.
		 */
		$value = preg_replace( '/\s+/', ' ', $value );
		header( apply_filters( 'graphql_send_header', sprintf( '%s: %s', $key, $value ), $key, $value ) );
	}

	/**
	 * Sends an HTTP status code.
	 *
	 * @return void
	 */
	protected static function set_status() {
		status_header( self::$http_status_code );
	}

	/**
	 * Returns an array of headers to send with the HTTP response
	 *
	 * @return array<string,mixed>
	 */
	protected static function get_response_headers() {

		/**
		 * Filtered list of access control headers.
		 *
		 * @param string[] $access_control_headers Array of headers to allow.
		 */
		$access_control_allow_headers = apply_filters(
			'graphql_access_control_allow_headers',
			[
				'Authorization',
				'Content-Type',
			]
		);

		// For cache url header, use the domain without protocol. Path for when it's multisite.
		// Remove the starting http://, https://, :// from the full hostname/path.
		$host_and_path = preg_replace( '#^.*?://#', '', graphql_get_endpoint_url() );

		$headers = [
			'Access-Control-Allow-Origin'  => '*',
			'Access-Control-Allow-Headers' => implode( ', ', $access_control_allow_headers ),
			'Access-Control-Max-Age'       => 600,
			// cache the result of preflight requests (600 is the upper limit for Chromium).
			'Content-Type'                 => 'application/json ; charset=' . get_option( 'blog_charset' ),
			'X-Robots-Tag'                 => 'noindex',
			'X-Content-Type-Options'       => 'nosniff',
			'X-GraphQL-URL'                => $host_and_path,
		];

		// If the Query Analyzer was instantiated
		// Get the headers determined from its Analysis
		if ( self::get_request() instanceof Request && self::get_request()->get_query_analyzer()->is_enabled_for_query() ) {
			$headers = self::get_request()->get_query_analyzer()->get_headers( $headers );
		}

		if ( true === \WPGraphQL::debug() ) {
			$headers['X-hacker'] = __( 'If you\'re reading this, you should visit github.com/wp-graphql/wp-graphql and contribute!', 'wp-graphql' );
		}

		/**
		 * Send nocache headers on authenticated requests.
		 *
		 * @param bool $rest_send_nocache_headers Whether to send no-cache headers.
		 *
		 * @since 0.0.5
		 */
		$send_no_cache_headers = apply_filters( 'graphql_send_nocache_headers', is_user_logged_in() );
		if ( $send_no_cache_headers ) {
			foreach ( wp_get_nocache_headers() as $no_cache_header_key => $no_cache_header_value ) {
				$headers[ $no_cache_header_key ] = $no_cache_header_value;
			}
		}

		/**
		 * Filter the $headers to send
		 */
		return apply_filters( 'graphql_response_headers_to_send', $headers );
	}

	/**
	 * Set the response headers
	 *
	 * @return void
	 * @since  0.0.1
	 */
	public static function set_headers() {
		if ( false === headers_sent() ) {

			/**
			 * Set the HTTP response status
			 */
			self::set_status();

			/**
			 * Get the response headers
			 */
			$headers = self::get_response_headers();

			/**
			 * If there are headers, set them for the response
			 */
			if ( ! empty( $headers ) && is_array( $headers ) ) {
				foreach ( $headers as $key => $value ) {
					self::send_header( $key, $value );
				}
			}

			/**
			 * Fire an action when the headers are set
			 *
			 * @param array<string,mixed> $headers The headers sent in the response
			 */
			do_action( 'graphql_response_set_headers', $headers );
		}
	}

	/**
	 * Retrieves the raw request entity (body).
	 *
	 * @since  0.0.5
	 *
	 * @global string php://input Raw post data.
	 *
	 * @return string|false Raw request data.
	 */
	public static function get_raw_data() {
		$input = file_get_contents( 'php://input' ); // phpcs:ignore WordPressVIPMinimum.Performance.FetchingRemoteData.FileGetContentsRemoteFile

		return ! empty( $input ) ? $input : '';
	}

	/**
	 * This processes the graphql requests that come into the /graphql endpoint via an HTTP request
	 *
	 * @return void
	 * @throws \Exception Throws Exception.
	 * @throws \Throwable Throws Exception.
	 * @global WP_User $current_user The currently authenticated user.
	 * @since  0.0.1
	 */
	public static function process_http_request() {
		global $current_user;

		if ( $current_user instanceof WP_User && ! $current_user->exists() ) {
			/*
			 * If there is no current user authenticated via other means, clear
			 * the cached lack of user, so that an authenticate check can set it
			 * properly.
			 *
			 * This is done because for authentications such as Application
			 * Passwords, we don't want it to be accepted unless the current HTTP
			 * request is a GraphQL API request, which can't always be identified early
			 * enough in evaluation.
			 *
			 * See serve_request in wp-includes/rest-api/class-wp-rest-server.php.
			 */
			$current_user = null; // phpcs:ignore WordPress.WP.GlobalVariablesOverride
		}

		/**
		 * This action can be hooked to to enable various debug tools,
		 * such as enableValidation from the GraphQL Config.
		 *
		 * @since 0.0.4
		 */
		do_action( 'graphql_process_http_request' );

		/**
		 * Respond to pre-flight requests.
		 *
		 * Bail before Request() execution begins.
		 *
		 * @see: https://apollographql.slack.com/archives/C10HTKHPC/p1507649812000123
		 * @see: https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests
		 */
		if ( isset( $_SERVER['REQUEST_METHOD'] ) && 'OPTIONS' === $_SERVER['REQUEST_METHOD'] ) {
			self::$http_status_code = 200;
			self::set_headers();
			exit;
		}

		$query          = '';
		$operation_name = '';
		$variables      = [];
		self::$request  = new Request();

		try {
			$response = self::$request->execute_http();

			// Get the operation params from the request.
			$params         = self::$request->get_params();
			$query          = isset( $params->query ) ? $params->query : '';
			$operation_name = isset( $params->operation ) ? $params->operation : '';
			$variables      = isset( $params->variables ) ? $params->variables : null;
		} catch ( \Throwable $error ) {

			/**
			 * If there are errors, set the status to 500
			 * and format the captured errors to be output properly
			 *
			 * @since 0.0.4
			 */
			self::$http_status_code = 500;

			/**
			 * Filter thrown GraphQL errors
			 *
			 * @param mixed[]             $errors  Formatted errors object.
			 * @param \Throwable          $error   Thrown error.
			 * @param \WPGraphQL\Request  $request WPGraphQL Request object.
			 */
			$response['errors'] = apply_filters(
				'graphql_http_request_response_errors',
				[ FormattedError::createFromException( $error, self::$request->get_debug_flag() ) ],
				$error,
				self::$request
			);
		}

		// Previously there was a small distinction between the response and the result, but
		// now that we are delegating to Request, just send the response for both.
		$result = $response;

		if ( false === headers_sent() ) {
			self::prepare_headers( $response, $result, $query, $operation_name, $variables );
		}

		/**
		 * Run an action after the HTTP Response is ready to be sent back. This might be a good place for tools
		 * to hook in to track metrics, such as how long the process took from `graphql_process_http_request`
		 * to here, etc.
		 *
		 * @param array<string,mixed> $response       The GraphQL response
		 * @param array<string,mixed> $result         The result of the GraphQL Query
		 * @param string              $operation_name The name of the operation
		 * @param string              $query          The request that GraphQL executed
		 * @param ?array              $variables      Variables to passed to your GraphQL query
		 * @param int|string          $status_code    The status code for the response
		 *
		 * @since 0.0.5
		 */
		do_action( 'graphql_process_http_request_response', $response, $result, $operation_name, $query, $variables, self::$http_status_code );

		/**
		 * Send the response
		 */
		wp_send_json( $response );
	}

	/**
	 * Prepare headers for response
	 *
	 * @param mixed|array<string,mixed>|\GraphQL\Executor\ExecutionResult $response        The response of the GraphQL Request.
	 * @param mixed|array<string,mixed>|\GraphQL\Executor\ExecutionResult $graphql_results The results of the GraphQL execution.
	 * @param string                                                      $query           The GraphQL query.
	 * @param string                                                      $operation_name  The operation name of the GraphQL Request.
	 * @param mixed|array<string,mixed>|null                              $variables       The variables applied to the GraphQL Request.
	 * @param mixed|\WP_User|null                                         $user            The current user object.
	 *
	 * @return void
	 */
	protected static function prepare_headers( $response, $graphql_results, string $query, string $operation_name, $variables, $user = null ) {

		/**
		 * Filter the $status_code before setting the headers
		 *
		 * @param int      $status_code     The status code to apply to the headers
		 * @param array    $response        The response of the GraphQL Request
		 * @param array    $graphql_results The results of the GraphQL execution
		 * @param string   $query           The GraphQL query
		 * @param string   $operation_name  The operation name of the GraphQL Request
		 * @param mixed[]  $variables       The variables applied to the GraphQL Request
		 * @param \WP_User $user The current user object
		 */
		self::$http_status_code = apply_filters( 'graphql_response_status_code', self::$http_status_code, $response, $graphql_results, $query, $operation_name, $variables, $user );

		/**
		 * Set the response headers
		 */
		self::set_headers();
	}
}


// File: wp-graphql\src\Types.php
<?php

namespace WPGraphQL;

use WPGraphQL\Utils\Utils;

/**
 * This class was used to access Type definitions pre v0.4.0, but is no longer used.
 * See upgrade guide vor v0.4.0 (https://github.com/wp-graphql/wp-graphql/releases/tag/v0.4.0) for
 * information on updating to use non-static TypeRegistry methods to get_type(), etc.
 *
 * @deprecated since v0.6.0. Old static methods can now be done by accessing the
 *             TypeRegistry class from within the `graphql_register_types` hook
 */
class Types {

	/**
	 * @deprecated since v0.6.0. Use Utils:map_input instead
	 *
	 * @param mixed[] $args The raw query args from the GraphQL query.
	 * @param mixed[] $map  The mapping of where each of the args should go.
	 *
	 * @return array<string,mixed>
	 */
	public static function map_input( $args, $map ) {
		_deprecated_function( __METHOD__, '0.6.0', 'WPGraphQL\Utils\Utils::map_input()' );
		return Utils::map_input( $args, $map );
	}

	/**
	 * @deprecated since v0.6.0 use Utils::prepare_date_response(); instead
	 * @param string      $date_gmt GMT publication time.
	 * @param string|null $date     Optional. Local publication time. Default null.
	 * @return string|null ISO8601/RFC3339 formatted datetime.
	 */
	public static function prepare_date_response( $date_gmt, $date = null ) {
		_deprecated_function( __METHOD__, '0.6.0', 'WPGraphQL\Utils\Utils::prepare_date_response()' );
		return Utils::prepare_date_response( $date_gmt, $date );
	}
}


// File: wp-graphql\src\WPGraphQL.php
<?php
/**
 * The global WPGraphQL class.
 *
 * @package WPGraphQL
 */

use WPGraphQL\Admin\Admin;
use WPGraphQL\AppContext;
use WPGraphQL\Registry\SchemaRegistry;
use WPGraphQL\Registry\TypeRegistry;
use WPGraphQL\Router;
use WPGraphQL\Type\WPObjectType;
use WPGraphQL\Utils\InstrumentSchema;
use WPGraphQL\Utils\Preview;

/**
 * Class WPGraphQL
 *
 * This is the one true WPGraphQL class
 */
final class WPGraphQL {

	/**
	 * Stores the instance of the WPGraphQL class
	 *
	 * @var ?\WPGraphQL The one true WPGraphQL
	 * @since  0.0.1
	 */
	private static $instance;

	/**
	 * Holds the Schema def
	 *
	 * @var mixed|\WPGraphQL\WPSchema|null $schema The Schema used for the GraphQL API
	 */
	protected static $schema;

	/**
	 * Holds the TypeRegistry instance
	 *
	 * @var mixed|\WPGraphQL\Registry\TypeRegistry|null $type_registry The registry that holds all GraphQL Types
	 */
	protected static $type_registry;

	/**
	 * Stores an array of allowed post types
	 *
	 * @var ?\WP_Post_Type[] allowed_post_types
	 * @since  0.0.5
	 */
	protected static $allowed_post_types;

	/**
	 * Stores an array of allowed taxonomies
	 *
	 * @var ?\WP_Taxonomy[] allowed_taxonomies
	 * @since  0.0.5
	 */
	protected static $allowed_taxonomies;

	/**
	 * @var bool
	 */
	protected static $is_graphql_request;

	/**
	 * The instance of the WPGraphQL object
	 *
	 * @return \WPGraphQL - The one true WPGraphQL
	 * @since  0.0.1
	 */
	public static function instance() {
		if ( ! isset( self::$instance ) || ! ( self::$instance instanceof self ) ) {
			self::$instance = new self();
			self::$instance->setup_constants();
			self::$instance->includes();
			self::$instance->actions();
			self::$instance->filters();
		}

		/**
		 * Return the WPGraphQL Instance
		 */
		return self::$instance;
	}

	/**
	 * Throw error on object clone.
	 * The whole idea of the singleton design pattern is that there is a single object
	 * therefore, we don't want the object to be cloned.
	 *
	 * @return void
	 * @since  0.0.1
	 */
	public function __clone() {
		// Cloning instances of the class is forbidden.
		_doing_it_wrong( __FUNCTION__, esc_html__( 'The WPGraphQL class should not be cloned.', 'wp-graphql' ), '0.0.1' );
	}

	/**
	 * Disable unserializing of the class.
	 *
	 * @return void
	 * @since  0.0.1
	 */
	public function __wakeup() {
		// De-serializing instances of the class is forbidden.
		_doing_it_wrong( __FUNCTION__, esc_html__( 'De-serializing instances of the WPGraphQL class is not allowed', 'wp-graphql' ), '0.0.1' );
	}

	/**
	 * Setup plugin constants.
	 *
	 * @return void
	 * @since  0.0.1
	 */
	private function setup_constants() {
		graphql_setup_constants();
	}

	/**
	 * Include required files.
	 * Uses composer's autoload
	 *
	 * @since  0.0.1
	 */
	private function includes(): void {
	}

	/**
	 * Set whether the request is a GraphQL request or not
	 *
	 * @param bool $is_graphql_request
	 *
	 * @return void
	 */
	public static function set_is_graphql_request( $is_graphql_request = false ) {
		self::$is_graphql_request = $is_graphql_request;
	}

	/**
	 * @return bool
	 */
	public static function is_graphql_request() {
		return self::$is_graphql_request;
	}

	/**
	 * Sets up actions to run at certain spots throughout WordPress and the WPGraphQL execution
	 * cycle
	 */
	private function actions(): void {
		/**
		 * Init WPGraphQL after themes have been setup,
		 * allowing for both plugins and themes to register
		 * things before graphql_init
		 */
		add_action(
			'after_setup_theme',
			static function () {
				new \WPGraphQL\Data\Config();
				$router = new Router();
				$router->init();
				$instance = self::instance();

				/**
				 * Fire off init action
				 *
				 * @param \WPGraphQL $instance The instance of the WPGraphQL class
				 */
				do_action( 'graphql_init', $instance );
			}
		);

		// Initialize the plugin url constant
		// see: https://developer.wordpress.org/reference/functions/plugins_url/#more-information
		add_action( 'init', [ $this, 'setup_plugin_url' ] );

		// Prevent WPGraphQL Insights from running
		remove_action( 'init', '\WPGraphQL\Extensions\graphql_insights_init' );

		/**
		 * Flush permalinks if the registered GraphQL endpoint has not yet been registered.
		 */
		add_action( 'wp_loaded', [ $this, 'maybe_flush_permalinks' ] );

		/**
		 * Hook in before fields resolve to check field permissions
		 */
		add_action(
			'graphql_before_resolve_field',
			[
				'\WPGraphQL\Utils\InstrumentSchema',
				'check_field_permissions',
			],
			10,
			8
		);

		// Determine what to show in graphql
		add_action( 'init_graphql_request', 'register_initial_settings', 10 );

		// Throw an exception
		add_action( 'do_graphql_request', [ $this, 'min_php_version_check' ] );

		// Initialize Admin functionality
		add_action( 'after_setup_theme', [ $this, 'init_admin' ] );

		add_action(
			'init_graphql_request',
			static function () {
				$tracing = new \WPGraphQL\Utils\Tracing();
				$tracing->init();

				$query_log = new \WPGraphQL\Utils\QueryLog();
				$query_log->init();
			}
		);
	}

	/**
	 * Check if the minimum PHP version requirement is met before execution begins.
	 *
	 * If the server is running a lower version than required, throw an exception and prevent
	 * further execution.
	 *
	 * @return void
	 * @throws \Exception
	 */
	public function min_php_version_check() {
		if ( defined( 'GRAPHQL_MIN_PHP_VERSION' ) && version_compare( PHP_VERSION, GRAPHQL_MIN_PHP_VERSION, '<' ) ) {
			throw new \Exception(
				esc_html(
					sprintf(
						// translators: %1$s is the current PHP version, %2$s is the minimum required PHP version.
						__( 'The server\'s current PHP version %1$s is lower than the WPGraphQL minimum required version: %2$s', 'wp-graphql' ),
						PHP_VERSION,
						GRAPHQL_MIN_PHP_VERSION
					)
				)
			);
		}
	}

	/**
	 * Sets up the plugin url
	 *
	 * @return void
	 */
	public function setup_plugin_url() {
		// Plugin Folder URL.
		if ( ! defined( 'WPGRAPHQL_PLUGIN_URL' ) ) {
			define( 'WPGRAPHQL_PLUGIN_URL', plugin_dir_url( dirname( __DIR__ ) . '/wp-graphql.php' ) );
		}
	}

	/**
	 * Determine the post_types and taxonomies, etc that should show in GraphQL
	 *
	 * @return void
	 */
	public function setup_types() {
		/**
		 * Setup the settings, post_types and taxonomies to show_in_graphql
		 */
		self::show_in_graphql();
	}

	/**
	 * Flush permalinks if the GraphQL Endpoint route isn't yet registered
	 *
	 * @return void
	 */
	public function maybe_flush_permalinks() {
		$rules = get_option( 'rewrite_rules' );
		if ( ! isset( $rules[ graphql_get_endpoint() . '/?$' ] ) ) {
			flush_rewrite_rules(); // phpcs:ignore WordPressVIPMinimum.Functions.RestrictedFunctions.flush_rewrite_rules_flush_rewrite_rules
		}
	}

	/**
	 * Setup filters
	 */
	private function filters(): void {
		// Filter the post_types and taxonomies to show in the GraphQL Schema
		$this->setup_types();

		/**
		 * Instrument the Schema to provide Resolve Hooks and sanitize Schema output
		 */
		add_filter(
			'graphql_get_type',
			[
				InstrumentSchema::class,
				'instrument_resolvers',
			],
			10,
			2
		);

		// Filter how metadata is retrieved during GraphQL requests
		add_filter(
			'get_post_metadata',
			[
				Preview::class,
				'filter_post_meta_for_previews',
			],
			10,
			4
		);

		/**
		 * Adds back compat support for the `graphql_object_type_interfaces` filter which was renamed
		 * to support both ObjectTypes and InterfaceTypes
		 *
		 * @deprecated
		 */
		add_filter(
			'graphql_type_interfaces',
			static function ( $interfaces, $config, $type ) {
				if ( $type instanceof WPObjectType ) {
					/**
					 * Filters the interfaces applied to an object type
					 *
					 * @param string[]                                                           $interfaces List of interfaces applied to the Object Type
					 * @param array<string,mixed>                                                $config     The config for the Object Type
					 * @param mixed|\WPGraphQL\Type\WPInterfaceType|\WPGraphQL\Type\WPObjectType $type       The Type instance
					 */
					return apply_filters_deprecated( 'graphql_object_type_interfaces', [ $interfaces, $config, $type ], '1.4.1', 'graphql_type_interfaces' );
				}

				return $interfaces;
			},
			10,
			3
		);
	}

	/**
	 * Initialize admin functionality
	 *
	 * @return void
	 */
	public function init_admin() {
		$admin = new Admin();
		$admin->init();
	}

	/**
	 * This sets up built-in post_types and taxonomies to show in the GraphQL Schema
	 *
	 * @return void
	 * @since  0.0.2
	 */
	public static function show_in_graphql() {
		add_filter( 'register_post_type_args', [ self::class, 'setup_default_post_types' ], 10, 2 );
		add_filter( 'register_taxonomy_args', [ self::class, 'setup_default_taxonomies' ], 10, 2 );

		// Run late so the user can filter the args themselves.
		add_filter( 'register_post_type_args', [ self::class, 'register_graphql_post_type_args' ], 99, 2 );
		add_filter( 'register_taxonomy_args', [ self::class, 'register_graphql_taxonomy_args' ], 99, 2 );
	}

	/**
	 * Sets up the default post types to show_in_graphql.
	 *
	 * @param array<string,mixed> $args      Array of arguments for registering a post type.
	 * @param string              $post_type Post type key.
	 *
	 * @return array<string,mixed>
	 */
	public static function setup_default_post_types( $args, $post_type ) {
		// Adds GraphQL support for attachments.
		if ( 'attachment' === $post_type ) {
			$args['show_in_graphql']     = true;
			$args['graphql_single_name'] = 'mediaItem';
			$args['graphql_plural_name'] = 'mediaItems';
		} elseif ( 'page' === $post_type ) { // Adds GraphQL support for pages.
			$args['show_in_graphql']     = true;
			$args['graphql_single_name'] = 'page';
			$args['graphql_plural_name'] = 'pages';
		} elseif ( 'post' === $post_type ) { // Adds GraphQL support for posts.
			$args['show_in_graphql']     = true;
			$args['graphql_single_name'] = 'post';
			$args['graphql_plural_name'] = 'posts';
		}

		return $args;
	}

	/**
	 * Sets up the default taxonomies to show_in_graphql.
	 *
	 * @param array<string,mixed> $args     Array of arguments for registering a taxonomy.
	 * @param string              $taxonomy Taxonomy key.
	 *
	 * @return array<string,mixed>
	 * @since 1.12.0
	 */
	public static function setup_default_taxonomies( $args, $taxonomy ) {
		// Adds GraphQL support for categories.
		if ( 'category' === $taxonomy ) {
			$args['show_in_graphql']     = true;
			$args['graphql_single_name'] = 'category';
			$args['graphql_plural_name'] = 'categories';
		} elseif ( 'post_tag' === $taxonomy ) { // Adds GraphQL support for tags.
			$args['show_in_graphql']     = true;
			$args['graphql_single_name'] = 'tag';
			$args['graphql_plural_name'] = 'tags';
		} elseif ( 'post_format' === $taxonomy ) { // Adds GraphQL support for post formats.
			$args['show_in_graphql']     = true;
			$args['graphql_single_name'] = 'postFormat';
			$args['graphql_plural_name'] = 'postFormats';
		}

		return $args;
	}

	/**
	 * Set the GraphQL Post Type Args and pass them through a filter.
	 *
	 * @param array<string,mixed> $args           The graphql specific args for the post type
	 * @param string              $post_type_name The name of the post type being registered
	 *
	 * @return array<string,mixed>
	 * @throws \Exception
	 * @since 1.12.0
	 */
	public static function register_graphql_post_type_args( array $args, string $post_type_name ) {
		// Bail early if the post type is hidden from the WPGraphQL schema.
		if ( empty( $args['show_in_graphql'] ) ) {
			return $args;
		}

		$graphql_args = self::get_default_graphql_type_args();

		/**
		 * Filters the graphql args set on a post type
		 *
		 * @param array<string,mixed> $args           The graphql specific args for the post type
		 * @param string              $post_type_name The name of the post type being registered
		 */
		$graphql_args = apply_filters( 'register_graphql_post_type_args', $graphql_args, $post_type_name );

		return wp_parse_args( $args, $graphql_args );
	}

	/**
	 * Set the GraphQL Taxonomy Args and pass them through a filter.
	 *
	 * @param array<string,mixed> $args          The graphql specific args for the taxonomy
	 * @param string              $taxonomy_name The name of the taxonomy being registered
	 *
	 * @return array<string,mixed>
	 * @throws \Exception
	 * @since 1.12.0
	 */
	public static function register_graphql_taxonomy_args( array $args, string $taxonomy_name ) {
		// Bail early if the taxonomy  is hidden from the WPGraphQL schema.
		if ( empty( $args['show_in_graphql'] ) ) {
			return $args;
		}

		$graphql_args = self::get_default_graphql_type_args();

		/**
		 * Filters the graphql args set on a taxonomy
		 *
		 * @param array<string,mixed> $args          The graphql specific args for the taxonomy
		 * @param string              $taxonomy_name The name of the taxonomy being registered
		 */
		$graphql_args = apply_filters( 'register_graphql_taxonomy_args', $graphql_args, $taxonomy_name );

		return wp_parse_args( $args, $graphql_args );
	}

	/**
	 * This sets the post type /taxonomy GraphQL properties.
	 *
	 * @since 1.12.0
	 *
	 * @return array<string,mixed>
	 */
	public static function get_default_graphql_type_args(): array {
		return [
			// The "kind" of GraphQL type to register. Can be `interface`, `object`, or `union`.
			'graphql_kind'                     => 'object',
			// The callback used to resolve the type. Only used if `graphql_kind` is an `interface` or `union`.
			'graphql_resolve_type'             => null,
			// An array of custom interfaces the type should implement.
			'graphql_interfaces'               => [],
			// An array of default interfaces the type should exclude.
			'graphql_exclude_interfaces'       => [],
			// An array of custom connections the type should implement.
			'graphql_connections'              => [],
			// An array of default connection field names the type should exclude.
			'graphql_exclude_connections'      => [],
			// An array of possible type the union can resolve to. Only used if `graphql_kind` is a `union`.
			'graphql_union_types'              => [],
			// Whether to register default connections to the schema.
			'graphql_register_root_field'      => true,
			'graphql_register_root_connection' => true,
		];
	}

	/**
	 * Get the post types that are allowed to be used in GraphQL.
	 * This gets all post_types that are set to show_in_graphql, but allows for external code
	 * (plugins/theme) to filter the list of allowed_post_types to add/remove additional post_types
	 *
	 * @param string|mixed[]      $output Optional. The type of output to return. Accepts post type 'names' or 'objects'. Default 'names'.
	 * @param array<string,mixed> $args   Optional. Arguments to filter allowed post types
	 *
	 * @return array<string,mixed>
	 * @since  0.0.4
	 * @since  1.8.1 adds $output as first param, and stores post type objects in class property.
	 */
	public static function get_allowed_post_types( $output = 'names', $args = [] ) {
		// Support deprecated param order.
		if ( is_array( $output ) ) {
			_deprecated_argument( __METHOD__, '1.8.1', '$args should be passed as the second parameter.' );
			$args   = $output;
			$output = 'names';
		}

		// Initialize array of allowed post type objects.
		if ( empty( self::$allowed_post_types ) ) {
			/**
			 * Get all post types objects.
			 *
			 * @var \WP_Post_Type[] $post_type_objects
			 */
			$post_type_objects = get_post_types(
				[ 'show_in_graphql' => true ],
				'objects'
			);

			$post_type_names = wp_list_pluck( $post_type_objects, 'name' );

			/**
			 * Pass through a filter to allow the post_types to be modified.
			 * For example if a certain post_type should not be exposed to the GraphQL API.
			 *
			 * @param string[]        $post_type_names   Array of post type names.
			 * @param \WP_Post_Type[] $post_type_objects Array of post type objects.
			 *
			 * @since 1.8.1 add $post_type_objects parameter.
			 * @since 0.0.2
			 */
			$allowed_post_type_names = apply_filters( 'graphql_post_entities_allowed_post_types', $post_type_names, $post_type_objects );

			// Filter the post type objects if the list of allowed types have changed.
			$post_type_objects = array_filter(
				$post_type_objects,
				static function ( $obj ) use ( $allowed_post_type_names ) {
					if ( empty( $obj->graphql_plural_name ) && ! empty( $obj->graphql_single_name ) ) {
						$obj->graphql_plural_name = $obj->graphql_single_name;
					}

					/**
					 * Validate that the post_types have a graphql_single_name and graphql_plural_name
					 */
					if ( empty( $obj->graphql_single_name ) || empty( $obj->graphql_plural_name ) ) {
						graphql_debug(
							sprintf(
							/* translators: %s will replaced with the registered type */
								__( 'The "%s" post_type isn\'t configured properly to show in GraphQL. It needs a "graphql_single_name" and a "graphql_plural_name"', 'wp-graphql' ),
								$obj->name
							),
							[
								'invalid_post_type' => $obj,
							]
						);
						return false;
					}

					return in_array( $obj->name, $allowed_post_type_names, true );
				}
			);

			self::$allowed_post_types = $post_type_objects;
		}

		/**
		 * Filter the list of allowed post types either by the provided args or to only return an array of names.
		 */
		if ( ! empty( $args ) || 'names' === $output ) {
			$field = 'names' === $output ? 'name' : false;

			return wp_filter_object_list( self::$allowed_post_types, $args, 'and', $field );
		}

		return self::$allowed_post_types;
	}

	/**
	 * Get the taxonomies that are allowed to be used in GraphQL.
	 * This gets all taxonomies that are set to "show_in_graphql" but allows for external code
	 * (plugins/themes) to filter the list of allowed_taxonomies to add/remove additional
	 * taxonomies
	 *
	 * @param string              $output Optional. The type of output to return. Accepts taxonomy 'names' or 'objects'. Default 'names'.
	 * @param array<string,mixed> $args   Optional. Arguments to filter allowed taxonomies.
	 *
	 * @return array<string,mixed>
	 * @since  0.0.4
	 */
	public static function get_allowed_taxonomies( $output = 'names', $args = [] ) {

		// Initialize array of allowed post type objects.
		if ( empty( self::$allowed_taxonomies ) ) {
			/**
			 * Get all post types objects.
			 *
			 * @var \WP_Taxonomy[] $tax_objects
			 */
			$tax_objects = get_taxonomies(
				[ 'show_in_graphql' => true ],
				'objects'
			);

			$tax_names = wp_list_pluck( $tax_objects, 'name' );

			/**
			 * Pass through a filter to allow the taxonomies to be modified.
			 * For example if a certain taxonomy should not be exposed to the GraphQL API.
			 *
			 * @param string[]       $tax_names   Array of taxonomy names
			 * @param \WP_Taxonomy[] $tax_objects Array of taxonomy objects.
			 *
			 * @since 1.8.1 add $tax_names and $tax_objects parameters.
			 * @since 0.0.2
			 */
			$allowed_tax_names = apply_filters( 'graphql_term_entities_allowed_taxonomies', $tax_names, $tax_objects );

			$tax_objects = array_filter(
				$tax_objects,
				static function ( $obj ) use ( $allowed_tax_names ) {
					if ( empty( $obj->graphql_plural_name ) && ! empty( $obj->graphql_single_name ) ) {
						$obj->graphql_plural_name = $obj->graphql_single_name;
					}

					/**
					 * Validate that the post_types have a graphql_single_name and graphql_plural_name
					 */
					if ( empty( $obj->graphql_single_name ) || empty( $obj->graphql_plural_name ) ) {
						graphql_debug(
							sprintf(
							/* translators: %s will replaced with the registered taxonomty */
								__( 'The "%s" taxonomy isn\'t configured properly to show in GraphQL. It needs a "graphql_single_name" and a "graphql_plural_name"', 'wp-graphql' ),
								$obj->name
							),
							[
								'invalid_taxonomy' => $obj,
							]
						);
						return false;
					}

					return in_array( $obj->name, $allowed_tax_names, true );
				}
			);

			self::$allowed_taxonomies = $tax_objects;
		}

		$taxonomies = self::$allowed_taxonomies;
		/**
		 * Filter the list of allowed taxonomies either by the provided args or to only return an array of names.
		 */
		if ( ! empty( $args ) || 'names' === $output ) {
			$field = 'names' === $output ? 'name' : false;

			$taxonomies = wp_filter_object_list( $taxonomies, $args, 'and', $field );
		}

		return $taxonomies;
	}

	/**
	 * Allow Schema to be cleared
	 *
	 * @return void
	 */
	public static function clear_schema() {
		self::$type_registry      = null;
		self::$schema             = null;
		self::$allowed_post_types = null;
		self::$allowed_taxonomies = null;
	}

	/**
	 * Returns the Schema as defined by static registrations throughout
	 * the WP Load.
	 *
	 * @return \WPGraphQL\WPSchema
	 *
	 * @throws \Exception
	 */
	public static function get_schema() {
		if ( null === self::$schema ) {
			$schema_registry = new SchemaRegistry();
			$schema          = $schema_registry->get_schema();

			/**
			 * Generate & Filter the schema.
			 *
			 * @param \WPGraphQL\WPSchema $schema The executable Schema that GraphQL executes against
			 * @param \WPGraphQL\AppContext $app_context Object The AppContext object containing all of the
			 * information about the context we know at this point
			 *
			 * @since 0.0.5
			 */
			self::$schema = apply_filters( 'graphql_schema', $schema, self::get_app_context() );
		}

		/**
		 * Fire an action when the Schema is returned
		 */
		do_action( 'graphql_get_schema', self::$schema );

		/**
		 * Return the Schema after applying filters
		 */
		return ! empty( self::$schema ) ? self::$schema : null;
	}

	/**
	 * Whether WPGraphQL is operating in Debug mode
	 */
	public static function debug(): bool {
		if ( defined( 'GRAPHQL_DEBUG' ) ) {
			$enabled = (bool) GRAPHQL_DEBUG;
		} else {
			$enabled = get_graphql_setting( 'debug_mode_enabled', 'off' );
			$enabled = 'on' === $enabled;
		}

		/**
		 * @param bool $enabled Whether GraphQL Debug is enabled or not
		 */
		return (bool) apply_filters( 'graphql_debug_enabled', $enabled );
	}

	/**
	 * Returns the Schema as defined by static registrations throughout
	 * the WP Load.
	 *
	 * @return \WPGraphQL\Registry\TypeRegistry
	 *
	 * @throws \Exception
	 */
	public static function get_type_registry() {
		if ( null === self::$type_registry ) {
			$type_registry = new TypeRegistry();

			/**
			 * Generate & Filter the schema.
			 *
			 * @param \WPGraphQL\Registry\TypeRegistry $type_registry The TypeRegistry for the API
			 * @param \WPGraphQL\AppContext $app_context Object The AppContext object containing all of the
			 * information about the context we know at this point
			 *
			 * @since 0.0.5
			 */
			self::$type_registry = apply_filters( 'graphql_type_registry', $type_registry, self::get_app_context() );
		}

		/**
		 * Fire an action when the Type Registry is returned
		 */
		do_action( 'graphql_get_type_registry', self::$type_registry );

		/**
		 * Return the Schema after applying filters
		 */
		return ! empty( self::$type_registry ) ? self::$type_registry : null;
	}

	/**
	 * Return the static schema if there is one
	 *
	 * @return string|null
	 */
	public static function get_static_schema() {
		$schema = null;
		if ( file_exists( WPGRAPHQL_PLUGIN_DIR . 'schema.graphql' ) && ! empty( file_get_contents( WPGRAPHQL_PLUGIN_DIR . 'schema.graphql' ) ) ) {
			$schema = file_get_contents( WPGRAPHQL_PLUGIN_DIR . 'schema.graphql' );
		}

		return $schema;
	}

	/**
	 * Get the AppContext for use in passing down the Resolve Tree
	 *
	 * @return \WPGraphQL\AppContext
	 */
	public static function get_app_context() {
		/**
		 * Configure the app_context which gets passed down to all the resolvers.
		 *
		 * @since 0.0.4
		 */
		$app_context           = new AppContext();
		$app_context->viewer   = wp_get_current_user();
		$app_context->root_url = get_bloginfo( 'url' );
		$app_context->request  = ! empty( $_REQUEST ) ? $_REQUEST : null; // phpcs:ignore WordPress.Security.NonceVerification.Recommended

		return $app_context;
	}
}


// File: wp-graphql\src\WPSchema.php
<?php

namespace WPGraphQL;

use GraphQL\Type\Schema;
use GraphQL\Type\SchemaConfig;
use WPGraphQL\Registry\TypeRegistry;

/**
 * Class WPSchema
 *
 * Extends the Schema to make some properties accessible via hooks/filters
 *
 * @package WPGraphQL
 */
class WPSchema extends Schema {

	/**
	 * @var \GraphQL\Type\SchemaConfig
	 */
	public $config;

	/**
	 * Holds the $filterable_config which allows WordPress access to modifying the
	 * $config that gets passed down to the Executable Schema
	 *
	 * @var \GraphQL\Type\SchemaConfig|null
	 * @since 0.0.9
	 */
	public $filterable_config;

	/**
	 * WPSchema constructor.
	 *
	 * @param \GraphQL\Type\SchemaConfig       $config The config for the Schema.
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @since 0.0.9
	 */
	public function __construct( SchemaConfig $config, TypeRegistry $type_registry ) {
		$this->config = $config;

		/**
		 * Set the $filterable_config as the $config that was passed to the WPSchema when instantiated
		 *
		 * @param \GraphQL\Type\SchemaConfig $config The config for the Schema.
		 * @param \WPGraphQL\Registry\TypeRegistry $type_registry The WPGraphQL type registry.
		 *
		 * @since 0.0.9
		 */
		$this->filterable_config = apply_filters( 'graphql_schema_config', $config, $type_registry );
		parent::__construct( $this->filterable_config );
	}
}


// File: wp-graphql\src\Admin\Admin.php
<?php

namespace WPGraphQL\Admin;

use WPGraphQL\Admin\GraphiQL\GraphiQL;
use WPGraphQL\Admin\Settings\Settings;

/**
 * Class Admin
 *
 * @package WPGraphQL\Admin
 */
class Admin {

	/**
	 * Whether Admin Pages are enabled or not
	 *
	 * @var bool
	 */
	protected $admin_enabled;

	/**
	 * Whether GraphiQL is enabled or not
	 *
	 * @var bool
	 */
	protected $graphiql_enabled;

	/**
	 * @var \WPGraphQL\Admin\Settings\Settings
	 */
	protected $settings;

	/**
	 * Initialize Admin functionality for WPGraphQL
	 *
	 * @return void
	 */
	public function init() {

		// Determine whether the admin pages should show or not.
		// Default is enabled.
		$this->admin_enabled    = apply_filters( 'graphql_show_admin', true );
		$this->graphiql_enabled = apply_filters( 'graphql_enable_graphiql', get_graphql_setting( 'graphiql_enabled', true ) );

		$admin_notices = new AdminNotices();
		$admin_notices->init();

		// This removes the menu page for WPGraphiQL as it's now built into WPGraphQL
		if ( $this->graphiql_enabled ) {
			add_action(
				'admin_menu',
				static function () {
					remove_menu_page( 'wp-graphiql/wp-graphiql.php' );
				}
			);
		}

		// If the admin is disabled, prevent admin from being scaffolded.
		if ( false === $this->admin_enabled ) {
			return;
		}

		$this->settings = new Settings();
		$this->settings->init();

		if ( 'on' === $this->graphiql_enabled || true === $this->graphiql_enabled ) {
			global $graphiql;
			$graphiql = new GraphiQL();
			$graphiql->init();
		}
	}
}


// File: wp-graphql\src\Admin\AdminNotices.php
<?php

namespace WPGraphQL\Admin;

/**
 * This class isn't intended for direct extending or customizing.
 *
 * This class is responsible for handling the management and display of admin notices
 * related directly to WPGraphQL.
 *
 * Breaking changes to this class will not be considered a semver breaking change as there's no
 * expectation that users will be calling these functions directly or extending this class.
 *
 * @internal
 */
class AdminNotices {

	/**
	 * Stores the admin notices to display
	 *
	 * @var array<string,array<string,mixed>>
	 */
	protected $admin_notices = [];

	/**
	 * @var array<string>
	 */
	protected $dismissed_notices = [];

	/**
	 * Initialize the Admin Notices class
	 */
	public function init(): void {

		register_graphql_admin_notice(
			'wpgraphql-acf-announcement',
			[
				'type'           => 'info',
				'message'        => __( 'You are using WPGraphQL and Advanced Custom Fields. Have you seen the new <a href="https://acf.wpgraphql.com/" target="_blank" rel="nofollow">WPGraphQL for ACF</a>?', 'wp-graphql' ),
				'is_dismissable' => true,
				'conditions'     => static function () {
					if ( ! class_exists( 'ACF' ) ) {
						return false;
					}

					// Bail if new version of WPGraphQL for ACF is active.
					if ( class_exists( 'WPGraphQLAcf' ) ) {
						return false;
					}

					return true;
				},
			]
		);

		// Initialize Admin Notices. This is where register_graphql_admin_notice hooks in
		do_action( 'graphql_admin_notices_init', $this );

		$current_user_id         = get_current_user_id();
		$this->dismissed_notices = get_user_meta( $current_user_id, 'wpgraphql_dismissed_admin_notices', true ) ?: [];

		// Filter the notices to remove any dismissed notices
		$this->pre_filter_dismissed_notices();

		add_action( 'admin_notices', [ $this, 'maybe_display_notices' ] );
		add_action( 'network_admin_notices', [ $this, 'maybe_display_notices' ] );
		add_action( 'admin_init', [ $this, 'handle_dismissal_of_notice' ] );
		add_action( 'admin_menu', [ $this, 'add_notification_bubble' ], 100 );
	}

	/**
	 * Pre-filters dismissed notices from the admin notices array.
	 */
	protected function pre_filter_dismissed_notices(): void {

		// remove any notice that's been dismissed
		foreach ( $this->dismissed_notices as $dismissed_notice ) {
			$this->remove_admin_notice( $dismissed_notice );
		}

		// For all remaining notices, run the callback to see if it's actually relevant
		foreach ( $this->admin_notices as $notice_slug => $notice ) {
			if ( ! isset( $notice['conditions'] ) ) {
				continue;
			}

			if ( ! is_callable( $notice['conditions'] ) ) {
				continue;
			}

			if ( false === $notice['conditions']() && ! is_network_admin() ) {
				$this->remove_admin_notice( $notice_slug );
			}
		}
	}

	/**
	 * Return all admin notices
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public function get_admin_notices(): array {
		return $this->admin_notices;
	}

	/**
	 * @param string              $slug The slug identifying the admin notice
	 * @param array<string,mixed> $config The config of the admin notice
	 *
	 * @return array<string,mixed>
	 */
	public function add_admin_notice( string $slug, array $config ): array {
		/**
		 * Pass the notice through a filter before registering it
		 *
		 * @param array<string,mixed> $config The config of the admin notice
		 * @param string              $slug   The slug identifying the admin notice
		 */
		$filtered_notice = apply_filters( 'graphql_add_admin_notice', $config, $slug );

		// If not a valid config, bail early.
		if ( ! $this->is_valid_config( $config ) ) {
			return [];
		}

		$this->admin_notices[ $slug ] = $filtered_notice;
		return $this->admin_notices[ $slug ];
	}

	/**
	 * Throw an error if the config is not valid.
	 *
	 * @since v1.21.0
	 *
	 * @param array<string,mixed> $config The config of the admin notice
	 */
	public function is_valid_config( array $config ): bool {
		if ( empty( $config['message'] ) ) {
			_doing_it_wrong( 'register_graphql_admin_notice', esc_html__( 'Config message is required', 'wp-graphql' ), '1.21.0' );
			return false;
		}

		if ( isset( $config['conditions'] ) && ! is_callable( $config['conditions'] ) ) {
			_doing_it_wrong( 'register_graphql_admin_notice', esc_html__( 'Config conditions should be callable', 'wp-graphql' ), '1.21.0' );
			return false;
		}

		if ( isset( $config['type'] ) && ! in_array( $config['type'], [ 'error', 'warning', 'success', 'info' ], true ) ) {
			_doing_it_wrong( 'register_graphql_admin_notice', esc_html__( 'Config type should be one of the following: error | warning | success | info', 'wp-graphql' ), '1.21.0' );
			return false;
		}

		if ( isset( $config['is_dismissable'] ) && ! is_bool( $config['is_dismissable'] ) ) {
			_doing_it_wrong( 'register_graphql_admin_notice', esc_html__( 'is_dismissable should be a boolean', 'wp-graphql' ), '1.21.0' );
			return false;
		}

		return true;
	}

	/**
	 * Given the slug of an admin notice, remove it from the notices
	 *
	 * @param string $slug The slug identifying the admin notice to remove
	 *
	 * @return array<mixed>
	 */
	public function remove_admin_notice( string $slug ): array {
		unset( $this->admin_notices[ $slug ] );
		return $this->admin_notices;
	}

	/**
	 * Determine whether a notice is dismissable or not
	 *
	 * @param array<mixed> $notice The notice to check whether its dismissable or not
	 */
	public function is_notice_dismissable( array $notice = [] ): bool {
		return ( ! isset( $notice['is_dismissable'] ) || false !== (bool) $notice['is_dismissable'] );
	}

	/**
	 * Display notices if they are displayable
	 */
	public function maybe_display_notices(): void {
		if ( ! $this->is_plugin_scoped_page() ) {
			return;
		}

		$this->render_notices();
	}

	/**
	 * Adds the notification count to the menu item.
	 */
	public function add_notification_bubble(): void {
		global $menu;

		$admin_notices = $this->get_admin_notices();

		$notice_count = count( $admin_notices );

		if ( 0 === $notice_count ) {
			return;
		}

		foreach ( $menu as $key => $item ) {
			if ( 'graphiql-ide' === $item[2] ) {
				// phpcs:ignore WordPress.WP.GlobalVariablesOverride.Prohibited
				$menu[ $key ][0] .= ' <span class="update-plugins count-' . absint( $notice_count ) . '>"><span class="plugin-count">' . absint( $notice_count ) . '</span></span>';
				break;
			}
		}
	}

	/**
	 * Render the notices.
	 */
	protected function render_notices(): void {

		$notices = $this->get_admin_notices();

		if ( empty( $notices ) ) {
			return;
		}
		?>
		<style>
			/* Only display the ACF notice */
			body.toplevel_page_graphiql-ide #wpbody .wpgraphql-admin-notice {
				display: block;
				position: absolute;
				top: 0;
				right: 0;
				z-index: 1;
				min-width: 40%;
			}
			body.toplevel_page_graphiql-ide #wpbody #wp-graphiql-wrapper {
				margin-top: <?php echo count( $notices ) * 45; ?>px;
			}
			.wpgraphql-admin-notice {
				position: relative;
				text-decoration: none;
				padding: 1px 40px 1px 12px;
			}
			.wpgraphql-admin-notice .notice-dismiss {
				text-decoration: none;
			}

		</style>
		<?php
		$count = 0;

		/**
		 * Fires before the admin notices are rendered.
		 *
		 * @param array<string,mixed> $notices The notices to be rendered
		 *
		 * @since v1.23.0
		 */
		do_action( 'graphql_admin_notices_render_notices', $notices );

		foreach ( $notices as $notice_slug => $notice ) {
			$type = $notice['type'] ?? 'info';
			?>
			<style>
				body.toplevel_page_graphiql-ide #wpbody #wpgraphql-admin-notice-<?php echo esc_attr( $notice_slug ); ?> {
					top: <?php echo esc_attr( ( $count * 45 ) . 'px' ); ?>
				}
			</style>
			<div id="wpgraphql-admin-notice-<?php echo esc_attr( $notice_slug ); ?>" class="wpgraphql-admin-notice notice notice-<?php echo esc_attr( $type ); ?> <?php echo $this->is_notice_dismissable( $notice ) ? 'is-dismissable' : ''; ?>">
				<p><?php echo ! empty( $notice['message'] ) ? wp_kses_post( $notice['message'] ) : ''; ?></p>
				<?php
				$is_dismissable = $this->is_notice_dismissable( $notice );
				if ( $is_dismissable ) {
					$dismiss_acf_nonce = wp_create_nonce( 'wpgraphql_disable_notice_nonce' );
					$dismiss_url       = add_query_arg(
						[
							'wpgraphql_disable_notice_nonce' => $dismiss_acf_nonce,
							'wpgraphql_disable_notice' => $notice_slug,
						]
					);
					?>
					<a href="<?php echo esc_url( $dismiss_url ); ?>" class="notice-dismiss">
						<span class="screen-reader-text"><?php esc_html_e( 'Dismiss', 'wp-graphql' ); ?></span>
					</a>
				<?php } ?>
			</div>
			<?php
			/**
			 * Fires for each admin notice that is rendered.
			 *
			 * @param string $notice_slug The slug of the notice
			 * @param array<mixed> $notice The notice to be rendered
			 * @param bool $is_dismissable Whether the notice is dismissable or not
			 * @param int $count The count of the notice
			 *
			 * @since v1.23.0
			 */
			do_action( 'graphql_admin_notices_render_notice', $notice_slug, $notice, $is_dismissable, $count );
			++$count;
		}
	}

	/**
	 * Checks if the current admin page is within the scope of the plugin's own pages.
	 *
	 * @return bool True if the current page is within scope of the plugin's pages.
	 */
	protected function is_plugin_scoped_page(): bool {
		$screen = get_current_screen();

		// Guard clause for invalid screen.
		if ( ! $screen ) {
			return false;
		}

		$allowed_pages = [
			'plugins',
			'plugins-network',
			'toplevel_page_graphiql-ide',
			'graphql_page_graphql-settings',
		];

		$current_page_id = $screen->id;

		$is_allowed_admin_page = in_array( $current_page_id, $allowed_pages, true );

		/**
		 * Filter to determine if the current admin page is within the scope of the plugin's own pages.
		 * This filter can be used to add additional pages to the list of allowed pages.
		 *
		 * The filter receives the following arguments:
		 *
		 * @param bool $is_plugin_scoped_page True if the current page is within scope of the plugin's pages.
		 * @param string $current_page_id The ID of the current admin page.
		 * @param array<string> $allowed_pages The list of allowed pages.
		 */
		return apply_filters( 'graphql_admin_notices_is_allowed_admin_page', $is_allowed_admin_page, $current_page_id, $allowed_pages );
	}

	/**
	 * Handles the dismissal of the ACF notice.
	 * set_transient reference: https://developer.wordpress.org/reference/functions/set_transient/
	 * This function sets a transient to remember the dismissal status of the notice.
	 */
	public function handle_dismissal_of_notice(): void {
		if ( ! isset( $_GET['wpgraphql_disable_notice_nonce'], $_GET['wpgraphql_disable_notice'] ) ) {
			return;
		}

		$nonce       = sanitize_text_field( wp_unslash( $_GET['wpgraphql_disable_notice_nonce'] ) );
		$notice_slug = sanitize_text_field( wp_unslash( $_GET['wpgraphql_disable_notice'] ) );

		if ( empty( $notice_slug ) || ! wp_verify_nonce( $nonce, 'wpgraphql_disable_notice_nonce' ) ) {
			return;
		}

		$current_user_id = get_current_user_id();

		$disabled   = get_user_meta( $current_user_id, 'wpgraphql_dismissed_admin_notices', true ) ?: [];
		$disabled[] = $notice_slug;

		update_user_meta( $current_user_id, 'wpgraphql_dismissed_admin_notices', array_unique( $disabled ) );

		// Redirect to clear URL parameters
		wp_safe_redirect( remove_query_arg( [ 'wpgraphql_disable_notice_nonce', 'wpgraphql_disable_notice' ] ) );
		exit();
	}
}


// File: wp-graphql\src\Admin\GraphiQL\GraphiQL.php
<?php

namespace WPGraphQL\Admin\GraphiQL;

use WP_Admin_Bar;

/**
 * Class GraphiQL
 *
 * Sets up GraphiQL in the WordPress Admin
 *
 * @package WPGraphQL\Admin\GraphiQL
 */
class GraphiQL {

	/**
	 * @var bool Whether GraphiQL is enabled
	 */
	protected $is_enabled = false;

	/**
	 * Initialize Admin functionality for WPGraphQL
	 *
	 * @return void
	 */
	public function init() {
		$this->is_enabled = get_graphql_setting( 'graphiql_enabled' ) !== 'off';

		/**
		 * If GraphiQL is disabled, don't set it up in the Admin
		 */
		if ( ! $this->is_enabled ) {
			return;
		}

		// Register the admin page
		add_action( 'admin_menu', [ $this, 'register_admin_page' ], 9 );
		add_action( 'admin_bar_menu', [ $this, 'register_admin_bar_menu' ], 100 );
		// Enqueue GraphiQL React App
		add_action( 'admin_enqueue_scripts', [ $this, 'enqueue_graphiql' ] );

		/**
		 * Enqueue extension styles and scripts
		 *
		 * These extensions are part of WPGraphiQL core, but were built in a way
		 * to showcase how extension APIs can be used to extend WPGraphiQL
		 */
		add_action( 'enqueue_graphiql_extension', [ $this, 'graphiql_enqueue_query_composer' ] );
		add_action( 'enqueue_graphiql_extension', [ $this, 'graphiql_enqueue_auth_switch' ] );
		add_action( 'enqueue_graphiql_extension', [ $this, 'graphiql_enqueue_fullscreen_toggle' ] );
	}

	/**
	 * Registers admin bar menu
	 *
	 * @param \WP_Admin_Bar $admin_bar The Admin Bar Instance
	 *
	 * @return void
	 */
	public function register_admin_bar_menu( WP_Admin_Bar $admin_bar ) {
		if ( ! current_user_can( 'manage_options' ) || 'off' === get_graphql_setting( 'show_graphiql_link_in_admin_bar' ) ) {
			return;
		}

		$icon_url = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIj48cGF0aCBmaWxsPSIjRTEwMDk4IiBkPSJNNTcuNDY4IDMwMi42NmwtMTQuMzc2LTguMyAxNjAuMTUtMjc3LjM4IDE0LjM3NiA4LjN6Ii8+PHBhdGggZmlsbD0iI0UxMDA5OCIgZD0iTTM5LjggMjcyLjJoMzIwLjN2MTYuNkgzOS44eiIvPjxwYXRoIGZpbGw9IiNFMTAwOTgiIGQ9Ik0yMDYuMzQ4IDM3NC4wMjZsLTE2MC4yMS05Mi41IDguMy0xNC4zNzYgMTYwLjIxIDkyLjV6TTM0NS41MjIgMTMyLjk0N2wtMTYwLjIxLTkyLjUgOC4zLTE0LjM3NiAxNjAuMjEgOTIuNXoiLz48cGF0aCBmaWxsPSIjRTEwMDk4IiBkPSJNNTQuNDgyIDEzMi44ODNsLTguMy0xNC4zNzUgMTYwLjIxLTkyLjUgOC4zIDE0LjM3NnoiLz48cGF0aCBmaWxsPSIjRTEwMDk4IiBkPSJNMzQyLjU2OCAzMDIuNjYzbC0xNjAuMTUtMjc3LjM4IDE0LjM3Ni04LjMgMTYwLjE1IDI3Ny4zOHpNNTIuNSAxMDcuNWgxNi42djE4NUg1Mi41ek0zMzAuOSAxMDcuNWgxNi42djE4NWgtMTYuNnoiLz48cGF0aCBmaWxsPSIjRTEwMDk4IiBkPSJNMjAzLjUyMiAzNjdsLTcuMjUtMTIuNTU4IDEzOS4zNC04MC40NSA3LjI1IDEyLjU1N3oiLz48cGF0aCBmaWxsPSIjRTEwMDk4IiBkPSJNMzY5LjUgMjk3LjljLTkuNiAxNi43LTMxIDIyLjQtNDcuNyAxMi44LTE2LjctOS42LTIyLjQtMzEtMTIuOC00Ny43IDkuNi0xNi43IDMxLTIyLjQgNDcuNy0xMi44IDE2LjggOS43IDIyLjUgMzEgMTIuOCA0Ny43TTkwLjkgMTM3Yy05LjYgMTYuNy0zMSAyMi40LTQ3LjcgMTIuOC0xNi43LTkuNi0yMi40LTMxLTEyLjgtNDcuNyA5LjYtMTYuNyAzMS0yMi40IDQ3LjctMTIuOCAxNi43IDkuNyAyMi40IDMxIDEyLjggNDcuN00zMC41IDI5Ny45Yy05LjYtMTYuNy0zLjktMzggMTIuOC00Ny43IDE2LjctOS42IDM4LTMuOSA0Ny43IDEyLjggOS42IDE2LjcgMy45IDM4LTEyLjggNDcuNy0xNi44IDkuNi0zOC4xIDMuOS00Ny43LTEyLjhNMzA5LjEgMTM3Yy05LjYtMTYuNy0zLjktMzggMTIuOC00Ny43IDE2LjctOS42IDM4LTMuOSA0Ny43IDEyLjggOS42IDE2LjcgMy45IDM4LTEyLjggNDcuNy0xNi43IDkuNi0zOC4xIDMuOS00Ny43LTEyLjhNMjAwIDM5NS44Yy0xOS4zIDAtMzQuOS0xNS42LTM0LjktMzQuOSAwLTE5LjMgMTUuNi0zNC45IDM0LjktMzQuOSAxOS4zIDAgMzQuOSAxNS42IDM0LjkgMzQuOSAwIDE5LjItMTUuNiAzNC45LTM0LjkgMzQuOU0yMDAgNzRjLTE5LjMgMC0zNC45LTE1LjYtMzQuOS0zNC45IDAtMTkuMyAxNS42LTM0LjkgMzQuOS0zNC45IDE5LjMgMCAzNC45IDE1LjYgMzQuOSAzNC45IDAgMTkuMy0xNS42IDM0LjktMzQuOSAzNC45Ii8+PC9zdmc+';

		$icon = sprintf(
			'<span class="custom-icon" style="
    background-image:url(\'%s\'); float:left; width:22px !important; height:22px !important;
    margin-left: 5px !important; margin-top: 5px !important; margin-right: 5px !important;
    "></span>',
			$icon_url
		);

		$admin_bar->add_menu(
			[
				'id'    => 'graphiql-ide',
				'title' => $icon . __( 'GraphiQL IDE', 'wp-graphql' ),
				'href'  => trailingslashit( admin_url() ) . 'admin.php?page=graphiql-ide',
			]
		);
	}

	/**
	 * Register the admin page as a subpage
	 *
	 * @return void
	 */
	public function register_admin_page() {

		// Top level menu page should be labeled GraphQL
		add_menu_page(
			__( 'GraphQL', 'wp-graphql' ),
			__( 'GraphQL', 'wp-graphql' ),
			'manage_options',
			'graphiql-ide',
			[ $this, 'render_graphiql_admin_page' ],
			'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIj48cGF0aCBmaWxsPSIjRTEwMDk4IiBkPSJNNTcuNDY4IDMwMi42NmwtMTQuMzc2LTguMyAxNjAuMTUtMjc3LjM4IDE0LjM3NiA4LjN6Ii8+PHBhdGggZmlsbD0iI0UxMDA5OCIgZD0iTTM5LjggMjcyLjJoMzIwLjN2MTYuNkgzOS44eiIvPjxwYXRoIGZpbGw9IiNFMTAwOTgiIGQ9Ik0yMDYuMzQ4IDM3NC4wMjZsLTE2MC4yMS05Mi41IDguMy0xNC4zNzYgMTYwLjIxIDkyLjV6TTM0NS41MjIgMTMyLjk0N2wtMTYwLjIxLTkyLjUgOC4zLTE0LjM3NiAxNjAuMjEgOTIuNXoiLz48cGF0aCBmaWxsPSIjRTEwMDk4IiBkPSJNNTQuNDgyIDEzMi44ODNsLTguMy0xNC4zNzUgMTYwLjIxLTkyLjUgOC4zIDE0LjM3NnoiLz48cGF0aCBmaWxsPSIjRTEwMDk4IiBkPSJNMzQyLjU2OCAzMDIuNjYzbC0xNjAuMTUtMjc3LjM4IDE0LjM3Ni04LjMgMTYwLjE1IDI3Ny4zOHpNNTIuNSAxMDcuNWgxNi42djE4NUg1Mi41ek0zMzAuOSAxMDcuNWgxNi42djE4NWgtMTYuNnoiLz48cGF0aCBmaWxsPSIjRTEwMDk4IiBkPSJNMjAzLjUyMiAzNjdsLTcuMjUtMTIuNTU4IDEzOS4zNC04MC40NSA3LjI1IDEyLjU1N3oiLz48cGF0aCBmaWxsPSIjRTEwMDk4IiBkPSJNMzY5LjUgMjk3LjljLTkuNiAxNi43LTMxIDIyLjQtNDcuNyAxMi44LTE2LjctOS42LTIyLjQtMzEtMTIuOC00Ny43IDkuNi0xNi43IDMxLTIyLjQgNDcuNy0xMi44IDE2LjggOS43IDIyLjUgMzEgMTIuOCA0Ny43TTkwLjkgMTM3Yy05LjYgMTYuNy0zMSAyMi40LTQ3LjcgMTIuOC0xNi43LTkuNi0yMi40LTMxLTEyLjgtNDcuNyA5LjYtMTYuNyAzMS0yMi40IDQ3LjctMTIuOCAxNi43IDkuNyAyMi40IDMxIDEyLjggNDcuN00zMC41IDI5Ny45Yy05LjYtMTYuNy0zLjktMzggMTIuOC00Ny43IDE2LjctOS42IDM4LTMuOSA0Ny43IDEyLjggOS42IDE2LjcgMy45IDM4LTEyLjggNDcuNy0xNi44IDkuNi0zOC4xIDMuOS00Ny43LTEyLjhNMzA5LjEgMTM3Yy05LjYtMTYuNy0zLjktMzggMTIuOC00Ny43IDE2LjctOS42IDM4LTMuOSA0Ny43IDEyLjggOS42IDE2LjcgMy45IDM4LTEyLjggNDcuNy0xNi43IDkuNi0zOC4xIDMuOS00Ny43LTEyLjhNMjAwIDM5NS44Yy0xOS4zIDAtMzQuOS0xNS42LTM0LjktMzQuOSAwLTE5LjMgMTUuNi0zNC45IDM0LjktMzQuOSAxOS4zIDAgMzQuOSAxNS42IDM0LjkgMzQuOSAwIDE5LjItMTUuNiAzNC45LTM0LjkgMzQuOU0yMDAgNzRjLTE5LjMgMC0zNC45LTE1LjYtMzQuOS0zNC45IDAtMTkuMyAxNS42LTM0LjkgMzQuOS0zNC45IDE5LjMgMCAzNC45IDE1LjYgMzQuOSAzNC45IDAgMTkuMy0xNS42IDM0LjktMzQuOSAzNC45Ii8+PC9zdmc+'
		);

		// Sub menu  should be labeled GraphiQL IDE
		add_submenu_page(
			'graphiql-ide',
			__( 'GraphiQL IDE', 'wp-graphql' ),
			__( 'GraphiQL IDE', 'wp-graphql' ),
			'manage_options',
			'graphiql-ide',
			[ $this, 'render_graphiql_admin_page' ]
		);
	}

	/**
	 * Render the markup to load GraphiQL to.
	 *
	 * @return void
	 */
	public function render_graphiql_admin_page() {
		$rendered = apply_filters( 'graphql_render_admin_page', '<div class="wrap" dir="ltr"><div id="graphiql" class="graphiql-container">Loading ...</div></div>' );

		echo wp_kses_post( $rendered );
	}

	/**
	 * Enqueues the stylesheet and js for the WPGraphiQL app
	 *
	 * @return void
	 */
	public function enqueue_graphiql() {
		if ( null === get_current_screen() || ! strpos( get_current_screen()->id, 'graphiql' ) ) {
			return;
		}

		$asset_file = include WPGRAPHQL_PLUGIN_DIR . 'build/index.asset.php';

		// Setup some globals that can be used by GraphiQL
		// and extending scripts
		wp_enqueue_script(
			'wp-graphiql', // Handle.
			WPGRAPHQL_PLUGIN_URL . 'build/index.js',
			$asset_file['dependencies'],
			$asset_file['version'],
			true
		);

		$app_asset_file = include WPGRAPHQL_PLUGIN_DIR . 'build/app.asset.php';

		wp_enqueue_script(
			'wp-graphiql-app', // Handle.
			WPGRAPHQL_PLUGIN_URL . 'build/app.js',
			array_merge( [ 'wp-graphiql' ], $app_asset_file['dependencies'] ),
			$app_asset_file['version'],
			true
		);

		wp_enqueue_style(
			'wp-graphiql-app',
			WPGRAPHQL_PLUGIN_URL . 'build/app.css',
			[ 'wp-components' ],
			$app_asset_file['version']
		);

		wp_localize_script(
			'wp-graphiql',
			'wpGraphiQLSettings',
			[
				'nonce'             => wp_create_nonce( 'wp_rest' ),
				'graphqlEndpoint'   => trailingslashit( site_url() ) . 'index.php?' . graphql_get_endpoint(),
				'avatarUrl'         => 0 !== get_current_user_id() ? get_avatar_url( get_current_user_id() ) : null,
				'externalFragments' => apply_filters( 'graphiql_external_fragments', [] ),
			]
		);

		// Extensions looking to extend GraphiQL can hook in here,
		// after the window object is established, but before the App renders
		do_action( 'enqueue_graphiql_extension' );
	}

	/**
	 * Enqueue the GraphiQL Auth Switch extension, which adds a button to the GraphiQL toolbar
	 * that allows the user to switch between the logged in user and the current user
	 *
	 * @return void
	 */
	public function graphiql_enqueue_auth_switch() {
		$auth_switch_asset_file = include WPGRAPHQL_PLUGIN_DIR . 'build/graphiqlAuthSwitch.asset.php';

		wp_enqueue_script(
			'wp-graphiql-auth-switch', // Handle.
			WPGRAPHQL_PLUGIN_URL . 'build/graphiqlAuthSwitch.js',
			array_merge( [ 'wp-graphiql', 'wp-graphiql-app' ], $auth_switch_asset_file['dependencies'] ),
			$auth_switch_asset_file['version'],
			true
		);
	}

	/**
	 * Enqueue the Query Composer extension, which adds a button to the GraphiQL toolbar
	 * that allows the user to open the Query Composer and compose a query with a form-based UI
	 *
	 * @return void
	 */
	public function graphiql_enqueue_query_composer() {

		// Enqueue the assets for the Explorer before enqueueing the app,
		// so that the JS in the exporter that hooks into the app will be available
		// by time the app is enqueued
		$composer_asset_file = include WPGRAPHQL_PLUGIN_DIR . 'build/graphiqlQueryComposer.asset.php';

		wp_enqueue_script(
			'wp-graphiql-query-composer', // Handle.
			WPGRAPHQL_PLUGIN_URL . 'build/graphiqlQueryComposer.js',
			array_merge( [ 'wp-graphiql', 'wp-graphiql-app' ], $composer_asset_file['dependencies'] ),
			$composer_asset_file['version'],
			true
		);

		wp_enqueue_style(
			'wp-graphiql-query-composer',
			WPGRAPHQL_PLUGIN_URL . 'build/graphiqlQueryComposer.css',
			[ 'wp-components' ],
			$composer_asset_file['version']
		);
	}

	/**
	 * Enqueue the GraphiQL Fullscreen Toggle extension, which adds a button to the GraphiQL toolbar
	 * that allows the user to toggle the fullscreen mode
	 *
	 * @return void
	 */
	public function graphiql_enqueue_fullscreen_toggle() {
		$fullscreen_toggle_asset_file = include WPGRAPHQL_PLUGIN_DIR . 'build/graphiqlFullscreenToggle.asset.php';

		wp_enqueue_script(
			'wp-graphiql-fullscreen-toggle', // Handle.
			WPGRAPHQL_PLUGIN_URL . 'build/graphiqlFullscreenToggle.js',
			array_merge( [ 'wp-graphiql', 'wp-graphiql-app' ], $fullscreen_toggle_asset_file['dependencies'] ),
			$fullscreen_toggle_asset_file['version'],
			true
		);

		wp_enqueue_style(
			'wp-graphiql-fullscreen-toggle',
			WPGRAPHQL_PLUGIN_URL . 'build/graphiqlFullscreenToggle.css',
			[ 'wp-components' ],
			$fullscreen_toggle_asset_file['version']
		);
	}
}


// File: wp-graphql\src\Admin\Settings\Settings.php
<?php

namespace WPGraphQL\Admin\Settings;

/**
 * Class Settings
 *
 * @package WPGraphQL\Admin\Settings
 */
class Settings {

	/**
	 * @var \WPGraphQL\Admin\Settings\SettingsRegistry
	 */
	public $settings_api;

	/**
	 * WP_ENVIRONMENT_TYPE
	 *
	 * @var string The WordPress environment.
	 */
	protected $wp_environment;

	/**
	 * Initialize the WPGraphQL Settings Pages
	 *
	 * @return void
	 */
	public function init() {
		$this->wp_environment = $this->get_wp_environment();
		$this->settings_api   = new SettingsRegistry();

		add_action( 'admin_menu', [ $this, 'add_options_page' ] );
		add_action( 'init', [ $this, 'register_settings' ] );
		add_action( 'admin_init', [ $this, 'initialize_settings_page' ] );
		add_action( 'admin_enqueue_scripts', [ $this, 'initialize_settings_page_scripts' ] );
	}

	/**
	 * Return the environment. Default to production.
	 *
	 * @return string The environment set using WP_ENVIRONMENT_TYPE.
	 */
	protected function get_wp_environment() {
		if ( function_exists( 'wp_get_environment_type' ) ) {
			return wp_get_environment_type();
		}

		return 'production';
	}

	/**
	 * Add the options page to the WP Admin
	 *
	 * @return void
	 */
	public function add_options_page() {
		$graphiql_enabled = get_graphql_setting( 'graphiql_enabled' );

		if ( 'off' === $graphiql_enabled ) {
			add_menu_page(
				__( 'WPGraphQL Settings', 'wp-graphql' ),
				__( 'GraphQL', 'wp-graphql' ),
				'manage_options',
				'graphql-settings',
				[ $this, 'render_settings_page' ],
				'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIj48cGF0aCBmaWxsPSIjRTEwMDk4IiBkPSJNNTcuNDY4IDMwMi42NmwtMTQuMzc2LTguMyAxNjAuMTUtMjc3LjM4IDE0LjM3NiA4LjN6Ii8+PHBhdGggZmlsbD0iI0UxMDA5OCIgZD0iTTM5LjggMjcyLjJoMzIwLjN2MTYuNkgzOS44eiIvPjxwYXRoIGZpbGw9IiNFMTAwOTgiIGQ9Ik0yMDYuMzQ4IDM3NC4wMjZsLTE2MC4yMS05Mi41IDguMy0xNC4zNzYgMTYwLjIxIDkyLjV6TTM0NS41MjIgMTMyLjk0N2wtMTYwLjIxLTkyLjUgOC4zLTE0LjM3NiAxNjAuMjEgOTIuNXoiLz48cGF0aCBmaWxsPSIjRTEwMDk4IiBkPSJNNTQuNDgyIDEzMi44ODNsLTguMy0xNC4zNzUgMTYwLjIxLTkyLjUgOC4zIDE0LjM3NnoiLz48cGF0aCBmaWxsPSIjRTEwMDk4IiBkPSJNMzQyLjU2OCAzMDIuNjYzbC0xNjAuMTUtMjc3LjM4IDE0LjM3Ni04LjMgMTYwLjE1IDI3Ny4zOHpNNTIuNSAxMDcuNWgxNi42djE4NUg1Mi41ek0zMzAuOSAxMDcuNWgxNi42djE4NWgtMTYuNnoiLz48cGF0aCBmaWxsPSIjRTEwMDk4IiBkPSJNMjAzLjUyMiAzNjdsLTcuMjUtMTIuNTU4IDEzOS4zNC04MC40NSA3LjI1IDEyLjU1N3oiLz48cGF0aCBmaWxsPSIjRTEwMDk4IiBkPSJNMzY5LjUgMjk3LjljLTkuNiAxNi43LTMxIDIyLjQtNDcuNyAxMi44LTE2LjctOS42LTIyLjQtMzEtMTIuOC00Ny43IDkuNi0xNi43IDMxLTIyLjQgNDcuNy0xMi44IDE2LjggOS43IDIyLjUgMzEgMTIuOCA0Ny43TTkwLjkgMTM3Yy05LjYgMTYuNy0zMSAyMi40LTQ3LjcgMTIuOC0xNi43LTkuNi0yMi40LTMxLTEyLjgtNDcuNyA5LjYtMTYuNyAzMS0yMi40IDQ3LjctMTIuOCAxNi43IDkuNyAyMi40IDMxIDEyLjggNDcuN00zMC41IDI5Ny45Yy05LjYtMTYuNy0zLjktMzggMTIuOC00Ny43IDE2LjctOS42IDM4LTMuOSA0Ny43IDEyLjggOS42IDE2LjcgMy45IDM4LTEyLjggNDcuNy0xNi44IDkuNi0zOC4xIDMuOS00Ny43LTEyLjhNMzA5LjEgMTM3Yy05LjYtMTYuNy0zLjktMzggMTIuOC00Ny43IDE2LjctOS42IDM4LTMuOSA0Ny43IDEyLjggOS42IDE2LjcgMy45IDM4LTEyLjggNDcuNy0xNi43IDkuNi0zOC4xIDMuOS00Ny43LTEyLjhNMjAwIDM5NS44Yy0xOS4zIDAtMzQuOS0xNS42LTM0LjktMzQuOSAwLTE5LjMgMTUuNi0zNC45IDM0LjktMzQuOSAxOS4zIDAgMzQuOSAxNS42IDM0LjkgMzQuOSAwIDE5LjItMTUuNiAzNC45LTM0LjkgMzQuOU0yMDAgNzRjLTE5LjMgMC0zNC45LTE1LjYtMzQuOS0zNC45IDAtMTkuMyAxNS42LTM0LjkgMzQuOS0zNC45IDE5LjMgMCAzNC45IDE1LjYgMzQuOSAzNC45IDAgMTkuMy0xNS42IDM0LjktMzQuOSAzNC45Ii8+PC9zdmc+'
			);
		} else {
			add_submenu_page(
				'graphiql-ide',
				__( 'WPGraphQL Settings', 'wp-graphql' ),
				__( 'Settings', 'wp-graphql' ),
				'manage_options',
				'graphql-settings',
				[ $this, 'render_settings_page' ]
			);
		}
	}

	/**
	 * Registers the initial settings for WPGraphQL
	 *
	 * @return void
	 */
	public function register_settings() {
		$this->settings_api->register_section(
			'graphql_general_settings',
			[
				'title' => __( 'WPGraphQL General Settings', 'wp-graphql' ),
			]
		);

		$custom_endpoint = apply_filters( 'graphql_endpoint', null );
		$this->settings_api->register_field(
			'graphql_general_settings',
			[
				'name'              => 'graphql_endpoint',
				'label'             => __( 'GraphQL Endpoint', 'wp-graphql' ),
				'desc'              => sprintf(
					// translators: %1$s is the site url, %2$s is the default endpoint
					__( 'The endpoint (path) for the GraphQL API on the site. <a target="_blank" href="%1$s/%2$s">%1$s/%2$s</a>. <br/><strong>Note:</strong> Changing the endpoint to something other than "graphql" <em>could</em> have an affect on tooling in the GraphQL ecosystem', 'wp-graphql' ),
					site_url(),
					get_graphql_setting( 'graphql_endpoint', 'graphql' )
				),
				'type'              => 'text',
				'value'             => ! empty( $custom_endpoint ) ? $custom_endpoint : null,
				'default'           => ! empty( $custom_endpoint ) ? $custom_endpoint : 'graphql',
				'disabled'          => ! empty( $custom_endpoint ),
				'sanitize_callback' => static function ( $value ) {
					if ( empty( $value ) ) {
						add_settings_error( 'graphql_endpoint', 'required', __( 'The "GraphQL Endpoint" field is required and cannot be blank. The default endpoint is "graphql"', 'wp-graphql' ), 'error' );

						return 'graphql';
					}

					return $value;
				},
			]
		);

		$this->settings_api->register_fields(
			'graphql_general_settings',
			[
				[
					'name'    => 'restrict_endpoint_to_logged_in_users',
					'label'   => __( 'Restrict Endpoint to Authenticated Users', 'wp-graphql' ),
					'desc'    => __( 'Limit the execution of GraphQL operations to authenticated requests. Non-authenticated requests to the GraphQL endpoint will not execute and will return an error.', 'wp-graphql' ),
					'type'    => 'checkbox',
					'default' => 'off',
				],
				[
					'name'    => 'batch_queries_enabled',
					'label'   => __( 'Enable Batch Queries', 'wp-graphql' ),
					'desc'    => __( 'WPGraphQL supports batch queries, or the ability to send multiple GraphQL operations in a single HTTP request. Batch requests are enabled by default.', 'wp-graphql' ),
					'type'    => 'checkbox',
					'default' => 'on',
				],
				[
					'name'    => 'batch_limit',
					'label'   => __( 'Batch Query Limit', 'wp-graphql' ),
					'desc'    => __( 'If Batch Queries are enabled, this value sets the max number of batch operations to allow per request. Requests containing more batch operations than allowed will be rejected before execution.', 'wp-graphql' ),
					'type'    => 'number',
					'default' => 10,
				],
				[
					'name'    => 'query_depth_enabled',
					'label'   => __( 'Enable Query Depth Limiting', 'wp-graphql' ),
					'desc'    => __( 'Enabling this will limit the depth of queries WPGraphQL will execute using the value of the Max Depth setting.', 'wp-graphql' ),
					'type'    => 'checkbox',
					'default' => 'off',
				],
				[
					'name'              => 'query_depth_max',
					'label'             => __( 'Max Depth to allow for GraphQL Queries', 'wp-graphql' ),
					'desc'              => __( 'If Query Depth limiting is enabled, this is the number of levels WPGraphQL will allow. Queries with deeper nesting will be rejected. Must be a positive integer value. Default 10.', 'wp-graphql' ),
					'type'              => 'number',
					'default'           => 10,
					'sanitize_callback' => static function ( $value ) {
						// if the entered value is not a positive integer, default to 10
						if ( ! absint( $value ) ) {
							$value = 10;
						}
						return absint( $value );
					},
				],
				[
					'name'     => 'query_analyzer_enabled',
					'label'    => __( 'Enable GraphQL Type Tracking', 'wp-graphql' ),
					'desc'     => sprintf(
						// translators: %s is either empty or a string with a note about force enabling.
						__( 'When enabled, WPGraphQL will track the Types, Models, and Nodes used in the request, and return those values in the headers for use in debugging or header-based cache invalidation. %s', 'wp-graphql' ),
						true === \WPGraphQL::debug() ? '<br /><strong>' . __( 'NOTE: This setting is force enabled because GraphQL Debug Mode is enabled. ', 'wp-graphql' ) . '</strong>' : ''
					),
					'type'     => 'checkbox',
					'disabled' => true === \WPGraphQL::debug(),
					'value'    => true === \WPGraphQL\Utils\QueryAnalyzer::is_enabled() ? 'on' : get_graphql_setting( 'query_analyzer_enabled', 'off' ),
				],
				[
					'name'    => 'graphiql_enabled',
					'label'   => __( 'Enable GraphiQL IDE', 'wp-graphql' ),
					'desc'    => __( 'GraphiQL IDE is a tool for exploring the GraphQL Schema and test GraphQL operations. Uncheck this to disable GraphiQL in the Dashboard.', 'wp-graphql' ),
					'type'    => 'checkbox',
					'default' => 'on',
				],
				[
					'name'    => 'show_graphiql_link_in_admin_bar',
					'label'   => __( 'GraphiQL IDE Admin Bar Link', 'wp-graphql' ),
					'desc'    => __( 'Show GraphiQL IDE Link in the WordPress Admin Bar', 'wp-graphql' ),
					'type'    => 'checkbox',
					'default' => 'on',
				],
				[
					'name'    => 'delete_data_on_deactivate',
					'label'   => __( 'Delete Data on Deactivation', 'wp-graphql' ),
					'desc'    => __( 'Delete settings and any other data stored by WPGraphQL upon de-activation of the plugin. Un-checking this will keep data after the plugin is de-activated.', 'wp-graphql' ),
					'type'    => 'checkbox',
					'default' => 'on',
				],
				[
					'name'     => 'debug_mode_enabled',
					'label'    => __( 'Enable GraphQL Debug Mode', 'wp-graphql' ),
					'desc'     => defined( 'GRAPHQL_DEBUG' )
						// translators: %s is the value of the GRAPHQL_DEBUG constant
						? sprintf( __( 'This setting is disabled. "GRAPHQL_DEBUG" has been set to "%s" with code', 'wp-graphql' ), GRAPHQL_DEBUG ? 'true' : 'false' )
						: __( 'Whether GraphQL requests should execute in "debug" mode. This setting is disabled if <strong>GRAPHQL_DEBUG</strong> is defined in wp-config.php. <br/>This will provide more information in GraphQL errors but can leak server implementation details so this setting is <strong>NOT RECOMMENDED FOR PRODUCTION ENVIRONMENTS</strong>.', 'wp-graphql' ),
					'type'     => 'checkbox',
					'value'    => true === \WPGraphQL::debug() ? 'on' : get_graphql_setting( 'debug_mode_enabled', 'off' ),
					'disabled' => defined( 'GRAPHQL_DEBUG' ),
					'default'  => 'off',
				],
				[
					'name'    => 'tracing_enabled',
					'label'   => __( 'Enable GraphQL Tracing', 'wp-graphql' ),
					'desc'    => __( 'Adds trace data to the extensions portion of GraphQL responses. This can help identify bottlenecks for specific fields.', 'wp-graphql' ),
					'type'    => 'checkbox',
					'default' => 'off',
				],
				[
					'name'    => 'tracing_user_role',
					'label'   => __( 'Tracing Role', 'wp-graphql' ),
					'desc'    => __( 'If Tracing is enabled, this limits it to requests from users with the specified User Role.', 'wp-graphql' ),
					'type'    => 'user_role_select',
					'default' => 'administrator',
				],
				[
					'name'    => 'query_logs_enabled',
					'label'   => __( 'Enable GraphQL Query Logs', 'wp-graphql' ),
					'desc'    => __( 'Adds SQL Query logs to the extensions portion of GraphQL responses. <br/><strong>Note:</strong> This is a debug tool that can have an impact on performance and is not recommended to have active in production.', 'wp-graphql' ),
					'type'    => 'checkbox',
					'default' => 'off',
				],
				[
					'name'    => 'query_log_user_role',
					'label'   => __( 'Query Log Role', 'wp-graphql' ),
					'desc'    => __( 'If Query Logs are enabled, this limits them to requests from users with the specified User Role.', 'wp-graphql' ),
					'type'    => 'user_role_select',
					'default' => 'administrator',
				],
				[
					'name'     => 'public_introspection_enabled',
					'label'    => __( 'Enable Public Introspection', 'wp-graphql' ),
					'desc'     => sprintf(
						// translators: %s is either empty or a string with a note about debug mode.
						__( 'GraphQL Introspection is a feature that allows the GraphQL Schema to be queried. For Production and Staging environments, WPGraphQL will by default limit introspection queries to authenticated requests. Checking this enables Introspection for public requests, regardless of environment. %s ', 'wp-graphql' ),
						true === \WPGraphQL::debug() ? '<strong>' . __( 'NOTE: This setting is force enabled because GraphQL Debug Mode is enabled. ', 'wp-graphql' ) . '</strong>' : ''
					),
					'type'     => 'checkbox',
					'default'  => ( 'local' === $this->get_wp_environment() || 'development' === $this->get_wp_environment() ) ? 'on' : 'off',
					'value'    => true === \WPGraphQL::debug() ? 'on' : get_graphql_setting( 'public_introspection_enabled', 'off' ),
					'disabled' => true === \WPGraphQL::debug(),
				],
			]
		);

		// Action to hook into to register settings
		do_action( 'graphql_register_settings', $this );
	}

	/**
	 * Initialize the settings admin page
	 *
	 * @return void
	 */
	public function initialize_settings_page() {
		$this->settings_api->admin_init();
	}

	/**
	 * Initialize the styles and scripts used on the settings admin page
	 *
	 * @param ?string $hook_suffix The current admin page.
	 */
	public function initialize_settings_page_scripts( ?string $hook_suffix ): void {

		if ( ! $hook_suffix ) {
			return;
		}

		$this->settings_api->admin_enqueue_scripts( $hook_suffix );
	}

	/**
	 * Render the settings page in the admin
	 *
	 * @return void
	 */
	public function render_settings_page() {
		?>
		<div class="wrap">
			<?php
			settings_errors();
			$this->settings_api->show_navigation();
			$this->settings_api->show_forms();
			?>
		</div>
		<?php
	}
}


// File: wp-graphql\src\Admin\Settings\SettingsRegistry.php
<?php

namespace WPGraphQL\Admin\Settings;

use WPGraphQL\Utils\Utils;

/**
 * Class SettingsRegistry
 *
 * This settings class is based on the WordPress Settings API Class v1.3 from Tareq Hasan of WeDevs
 *
 * @see     https://github.com/tareq1988/wordpress-settings-api-class
 * @author  Tareq Hasan <tareq@weDevs.com>
 * @link    https://tareq.co Tareq Hasan
 *
 * @package WPGraphQL\Admin\Settings
 */
class SettingsRegistry {

	/**
	 * Settings sections array
	 *
	 * @var array<string,array<string,mixed>>
	 */
	protected $settings_sections = [];

	/**
	 * Settings fields array
	 *
	 * @var array<string,array<string,mixed>[]>
	 */
	protected $settings_fields = [];

	/**
	 * Returns the settings sections.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public function get_settings_sections() {
		return $this->settings_sections;
	}

	/**
	 * Returns the settings fields.
	 *
	 * @return array<string,array<string,mixed>[]>
	 */
	public function get_settings_fields() {
		return $this->settings_fields;
	}

	/**
	 * Enqueue scripts and styles
	 *
	 * @param string $hook_suffix The current admin page.
	 *
	 * @return void
	 */
	public function admin_enqueue_scripts( string $hook_suffix ) {
		if ( 'graphql_page_graphql-settings' !== $hook_suffix ) {
			return;
		}

		wp_enqueue_style( 'wp-color-picker' );
		wp_enqueue_media();
		wp_enqueue_script( 'wp-color-picker' );
		wp_enqueue_script( 'jquery' );

		// Action to enqueue scripts on the WPGraphQL Settings page.
		do_action( 'graphql_settings_enqueue_scripts' );
	}

	/**
	 * Set settings sections
	 *
	 * @param string              $slug    Setting Section Slug
	 * @param array<string,mixed> $section setting section config.
	 *
	 * @return \WPGraphQL\Admin\Settings\SettingsRegistry
	 */
	public function register_section( string $slug, array $section ) {
		$section['id']                    = $slug;
		$this->settings_sections[ $slug ] = $section;

		return $this;
	}

	/**
	 * Register fields to a section
	 *
	 * @param string                $section The slug of the section to register a field to
	 * @param array<string,mixed>[] $fields  settings fields array
	 *
	 * @return \WPGraphQL\Admin\Settings\SettingsRegistry
	 */
	public function register_fields( string $section, array $fields ) {
		foreach ( $fields as $field ) {
			$this->register_field( $section, $field );
		}

		return $this;
	}

	/**
	 * Register a field to a section
	 *
	 * @param string              $section The slug of the section to register a field to
	 * @param array<string,mixed> $field   The config for the field being registered
	 *
	 * @return \WPGraphQL\Admin\Settings\SettingsRegistry
	 */
	public function register_field( string $section, array $field ) {
		$defaults = [
			'name'  => '',
			'label' => '',
			'desc'  => '',
			'type'  => 'text',
		];

		$field_config = wp_parse_args( $field, $defaults );

		// Get the field name before the filter is passed.
		$field_name = $field_config['name'];

		// Unset it, as we don't want it to be filterable
		unset( $field_config['name'] );

		/**
		 * Filter the setting field config
		 *
		 * @param array<string,mixed>  $field_config The field config for the setting
		 * @param string               $field_name   The name of the field (unfilterable in the config)
		 * @param string               $section      The slug of the section the field is registered to
		 */
		$field = apply_filters( 'graphql_setting_field_config', $field_config, $field_name, $section );

		// Add the field name back after the filter has been applied
		$field['name'] = $field_name;

		// Add the field to the section
		$this->settings_fields[ $section ][] = $field;

		return $this;
	}

	/**
	 * Initialize and registers the settings sections and fields to WordPress
	 *
	 * Usually this should be called at `admin_init` hook.
	 *
	 * This function gets the initiated settings sections and fields. Then
	 * registers them to WordPress and ready for use.
	 *
	 * @return void
	 */
	public function admin_init() {
		// Action that fires when settings are being initialized
		do_action( 'graphql_init_settings', $this );

		/**
		 * Filter the settings sections
		 *
		 * @param array<string,array<string,mixed>> $setting_sections The registered settings sections
		 */
		$setting_sections = apply_filters( 'graphql_settings_sections', $this->settings_sections );

		foreach ( $setting_sections as $id => $section ) {
			if ( false === get_option( $id ) ) {
				add_option( $id );
			}

			if ( isset( $section['desc'] ) && ! empty( $section['desc'] ) ) {
				$section['desc'] = '<div class="inside">' . $section['desc'] . '</div>';
				$callback        = static function () use ( $section ) {
					echo wp_kses( str_replace( '"', '\"', $section['desc'] ), Utils::get_allowed_wp_kses_html() );
				};
			} elseif ( isset( $section['callback'] ) ) {
				$callback = $section['callback'];
			} else {
				$callback = null;
			}

			add_settings_section( $id, $section['title'], $callback, $id );
		}

		// register settings fields
		foreach ( $this->settings_fields as $section => $field ) {
			foreach ( $field as $option ) {
				$name     = $option['name'];
				$type     = isset( $option['type'] ) ? $option['type'] : 'text';
				$label    = isset( $option['label'] ) ? $option['label'] : '';
				$callback = isset( $option['callback'] ) ? $option['callback'] : [
					$this,
					'callback_' . $type,
				];

				$args = [
					'id'                => $name,
					'class'             => isset( $option['class'] ) ? $option['class'] : $name,
					'label_for'         => "{$section}[{$name}]",
					'desc'              => isset( $option['desc'] ) ? $option['desc'] : '',
					'name'              => $label,
					'section'           => $section,
					'size'              => isset( $option['size'] ) ? $option['size'] : null,
					'options'           => isset( $option['options'] ) ? $option['options'] : '',
					'std'               => isset( $option['default'] ) ? $option['default'] : '',
					'sanitize_callback' => isset( $option['sanitize_callback'] ) ? $option['sanitize_callback'] : '',
					'type'              => $type,
					'placeholder'       => isset( $option['placeholder'] ) ? $option['placeholder'] : '',
					'min'               => isset( $option['min'] ) ? $option['min'] : '',
					'max'               => isset( $option['max'] ) ? $option['max'] : '',
					'step'              => isset( $option['step'] ) ? $option['step'] : '',
					'disabled'          => isset( $option['disabled'] ) ? (bool) $option['disabled'] : false,
					'value'             => isset( $option['value'] ) ? $option['value'] : null,
				];

				add_settings_field( "{$section}[{$name}]", $label, $callback, $section, $section, $args );
			}
		}

		// creates our settings in the options table
		foreach ( $this->settings_sections as $id => $section ) {
			register_setting( $id, $id, [ $this, 'sanitize_options' ] );
		}
	}

	/**
	 * Get field description for display
	 *
	 * @param array<string,string> $args settings field args
	 */
	public function get_field_description( array $args ): string {
		if ( ! empty( $args['desc'] ) ) {
			$desc = sprintf( '<p class="description">%s</p>', $args['desc'] );
		} else {
			$desc = '';
		}

		return $desc;
	}

	/**
	 * Displays a text field for a settings field
	 *
	 * @param array<string,mixed> $args settings field args
	 *
	 * @return void
	 */
	public function callback_text( array $args ) {
		$value       = isset( $args['value'] ) && ! empty( $args['value'] ) ? esc_attr( $args['value'] ) : esc_attr( $this->get_option( $args['id'], $args['section'], $args['std'] ) );
		$size        = isset( $args['size'] ) && ! is_null( $args['size'] ) ? $args['size'] : 'regular';
		$type        = isset( $args['type'] ) ? $args['type'] : 'text';
		$placeholder = empty( $args['placeholder'] ) ? '' : ' placeholder="' . $args['placeholder'] . '"';
		$disabled    = isset( $args['disabled'] ) && true === $args['disabled'] ? 'disabled' : null;
		$html        = sprintf( '<input type="%1$s" class="%2$s-text" id="%3$s[%4$s]" name="%3$s[%4$s]" value="%5$s"%6$s %7$s>', $type, $size, $args['section'], $args['id'], $value, $placeholder, $disabled );
		$html       .= $this->get_field_description( $args );

		echo wp_kses( $html, Utils::get_allowed_wp_kses_html() );
	}

	/**
	 * Displays a url field for a settings field
	 *
	 * @param array<string,mixed> $args settings field args
	 *
	 * @return void
	 */
	public function callback_url( array $args ) {
		$this->callback_text( $args );
	}

	/**
	 * Displays a number field for a settings field
	 *
	 * @param array<string,mixed> $args settings field args
	 *
	 * @return void
	 */
	public function callback_number( array $args ) {
		$value       = esc_attr( $this->get_option( $args['id'], $args['section'], $args['std'] ) );
		$size        = isset( $args['size'] ) && ! is_null( $args['size'] ) ? $args['size'] : 'regular';
		$type        = isset( $args['type'] ) ? $args['type'] : 'number';
		$placeholder = empty( $args['placeholder'] ) ? '' : ' placeholder="' . $args['placeholder'] . '"';
		$min         = ( '' === $args['min'] ) ? '' : ' min="' . $args['min'] . '"';
		$max         = ( '' === $args['max'] ) ? '' : ' max="' . $args['max'] . '"';
		$step        = ( '' === $args['step'] ) ? '' : ' step="' . $args['step'] . '"';

		$html  = sprintf( '<input type="%1$s" class="%2$s-number" id="%3$s[%4$s]" name="%3$s[%4$s]" value="%5$s"%6$s%7$s%8$s%9$s>', $type, $size, $args['section'], $args['id'], $value, $placeholder, $min, $max, $step );
		$html .= $this->get_field_description( $args );

		echo wp_kses( $html, Utils::get_allowed_wp_kses_html() );
	}

	/**
	 * Displays a checkbox for a settings field
	 *
	 * @param array<string,mixed> $args settings field args
	 *
	 * @return void
	 */
	public function callback_checkbox( array $args ) {
		$value    = isset( $args['value'] ) && ! empty( $args['value'] ) ? esc_attr( $args['value'] ) : esc_attr( $this->get_option( $args['id'], $args['section'], $args['std'] ) );
		$disabled = isset( $args['disabled'] ) && true === $args['disabled'] ? 'disabled' : null;

		$html  = '<fieldset>';
		$html .= sprintf( '<label for="wpuf-%1$s[%2$s]">', $args['section'], $args['id'] );
		$html .= sprintf( '<input type="hidden" name="%1$s[%2$s]" value="off">', $args['section'], $args['id'] );
		$html .= sprintf( '<input type="checkbox" class="checkbox" id="wpuf-%1$s[%2$s]" name="%1$s[%2$s]" value="on" %3$s %4$s>', $args['section'], $args['id'], checked( $value, 'on', false ), $disabled );
		$html .= sprintf( '%1$s</label>', $args['desc'] );
		$html .= '</fieldset>';

		echo wp_kses( $html, Utils::get_allowed_wp_kses_html() );
	}

	/**
	 * Displays a multicheckbox for a settings field
	 *
	 * @param array<string,mixed> $args settings field args
	 *
	 * @return void
	 */
	public function callback_multicheck( array $args ) {
		$value = $this->get_option( $args['id'], $args['section'], $args['std'] );
		$html  = '<fieldset>';
		$html .= sprintf( '<input type="hidden" name="%1$s[%2$s]" value="">', $args['section'], $args['id'] );
		foreach ( $args['options'] as $key => $label ) {
			$checked = isset( $value[ $key ] ) ? $value[ $key ] : '0';
			$html   .= sprintf( '<label for="wpuf-%1$s[%2$s][%3$s]">', $args['section'], $args['id'], $key );
			$html   .= sprintf( '<input type="checkbox" class="checkbox" id="wpuf-%1$s[%2$s][%3$s]" name="%1$s[%2$s][%3$s]" value="%3$s" %4$s>', $args['section'], $args['id'], $key, checked( $checked, $key, false ) );
			$html   .= sprintf( '%1$s</label><br>', $label );
		}

		$html .= $this->get_field_description( $args );
		$html .= '</fieldset>';

		echo wp_kses( $html, Utils::get_allowed_wp_kses_html() );
	}

	/**
	 * Displays a radio button for a settings field
	 *
	 * @param array<string,mixed> $args settings field args
	 *
	 * @return void
	 */
	public function callback_radio( array $args ) {
		$value = $this->get_option( $args['id'], $args['section'], $args['std'] );
		$html  = '<fieldset>';

		foreach ( $args['options'] as $key => $label ) {
			$html .= sprintf( '<label for="wpuf-%1$s[%2$s][%3$s]">', $args['section'], $args['id'], $key );
			$html .= sprintf( '<input type="radio" class="radio" id="wpuf-%1$s[%2$s][%3$s]" name="%1$s[%2$s]" value="%3$s" %4$s>', $args['section'], $args['id'], $key, checked( $value, $key, false ) );
			$html .= sprintf( '%1$s</label><br>', $label );
		}

		$html .= $this->get_field_description( $args );
		$html .= '</fieldset>';

		echo wp_kses( $html, Utils::get_allowed_wp_kses_html() );
	}

	/**
	 * Displays a selectbox for a settings field
	 *
	 * @param array<string,mixed> $args settings field args
	 *
	 * @return void
	 */
	public function callback_select( array $args ) {
		$value = esc_attr( $this->get_option( $args['id'], $args['section'], $args['std'] ) );
		$size  = isset( $args['size'] ) && ! is_null( $args['size'] ) ? $args['size'] : 'regular';
		$html  = sprintf( '<select class="%1$s" name="%2$s[%3$s]" id="%2$s[%3$s]">', $size, $args['section'], $args['id'] );

		foreach ( $args['options'] as $key => $label ) {
			$html .= sprintf( '<option value="%s"%s>%s</option>', $key, selected( $value, $key, false ), $label );
		}

		$html .= sprintf( '</select>' );
		$html .= $this->get_field_description( $args );

		echo wp_kses( $html, Utils::get_allowed_wp_kses_html() );
	}

	/**
	 * Displays a textarea for a settings field
	 *
	 * @param array<string,mixed> $args settings field args
	 *
	 * @return void
	 */
	public function callback_textarea( array $args ) {
		$value       = esc_textarea( $this->get_option( $args['id'], $args['section'], $args['std'] ) );
		$size        = isset( $args['size'] ) && ! is_null( $args['size'] ) ? $args['size'] : 'regular';
		$placeholder = empty( $args['placeholder'] ) ? '' : ' placeholder="' . $args['placeholder'] . '"';

		$html  = sprintf( '<textarea rows="5" cols="55" class="%1$s-text" id="%2$s[%3$s]" name="%2$s[%3$s]"%4$s>%5$s</textarea>', $size, $args['section'], $args['id'], $placeholder, $value );
		$html .= $this->get_field_description( $args );

		echo wp_kses( $html, Utils::get_allowed_wp_kses_html() );
	}

	/**
	 * Displays the html for a settings field
	 *
	 * @param array<string,mixed> $args settings field args
	 *
	 * @return void
	 */
	public function callback_html( array $args ) {
		echo wp_kses( $this->get_field_description( $args ), Utils::get_allowed_wp_kses_html() );
	}

	/**
	 * Displays a rich text textarea for a settings field
	 *
	 * @param array<string,mixed> $args settings field args
	 *
	 * @return void
	 */
	public function callback_wysiwyg( array $args ) {
		$value = $this->get_option( $args['id'], $args['section'], $args['std'] );
		$size  = isset( $args['size'] ) && ! is_null( $args['size'] ) ? $args['size'] : '500px';

		echo '<div style="max-width: ' . esc_attr( $size ) . ';">';

		$editor_settings = [
			'teeny'         => true,
			'textarea_name' => $args['section'] . '[' . $args['id'] . ']',
			'textarea_rows' => 10,
		];

		if ( isset( $args['options'] ) && is_array( $args['options'] ) ) {
			$editor_settings = array_merge( $editor_settings, $args['options'] );
		}

		wp_editor( $value, $args['section'] . '-' . $args['id'], $editor_settings );

		echo '</div>';

		echo wp_kses( $this->get_field_description( $args ), Utils::get_allowed_wp_kses_html() );
	}

	/**
	 * Displays a file upload field for a settings field
	 *
	 * @param array<string,mixed> $args settings field args
	 *
	 * @return void
	 */
	public function callback_file( array $args ) {
		$value = esc_attr( $this->get_option( $args['id'], $args['section'], $args['std'] ) );
		$size  = isset( $args['size'] ) && ! is_null( $args['size'] ) ? $args['size'] : 'regular';
		$label = isset( $args['options']['button_label'] ) ? $args['options']['button_label'] : __( 'Choose File', 'wp-graphql' );

		$html  = sprintf( '<input type="text" class="%1$s-text wpsa-url" id="%2$s[%3$s]" name="%2$s[%3$s]" value="%4$s">', $size, $args['section'], $args['id'], $value );
		$html .= '<input type="button" class="button wpsa-browse" value="' . $label . '">';
		$html .= $this->get_field_description( $args );

		echo wp_kses( $html, Utils::get_allowed_wp_kses_html() );
	}

	/**
	 * Displays a password field for a settings field
	 *
	 * @param array<string,mixed> $args settings field args
	 *
	 * @return void
	 */
	public function callback_password( array $args ) {
		$value = esc_attr( $this->get_option( $args['id'], $args['section'], $args['std'] ) );
		$size  = isset( $args['size'] ) && ! is_null( $args['size'] ) ? $args['size'] : 'regular';

		$html  = sprintf( '<input type="password" class="%1$s-text" id="%2$s[%3$s]" name="%2$s[%3$s]" value="%4$s">', $size, $args['section'], $args['id'], $value );
		$html .= $this->get_field_description( $args );

		echo wp_kses( $html, Utils::get_allowed_wp_kses_html() );
	}

	/**
	 * Displays a color picker field for a settings field
	 *
	 * @param array<string,mixed> $args settings field args
	 *
	 * @return void
	 */
	public function callback_color( $args ) {
		$value = esc_attr( $this->get_option( $args['id'], $args['section'], $args['std'] ) );
		$size  = isset( $args['size'] ) && ! is_null( $args['size'] ) ? $args['size'] : 'regular';

		$html  = sprintf( '<input type="text" class="%1$s-text wp-color-picker-field" id="%2$s[%3$s]" name="%2$s[%3$s]" value="%4$s" data-default-color="%5$s">', $size, $args['section'], $args['id'], $value, $args['std'] );
		$html .= $this->get_field_description( $args );

		echo wp_kses( $html, Utils::get_allowed_wp_kses_html() );
	}

	/**
	 * Displays a select box for creating the pages select box
	 *
	 * @param array<string,mixed> $args settings field args
	 *
	 * @return void
	 */
	public function callback_pages( array $args ) {
		$dropdown_args = array_merge(
			[
				'selected' => esc_attr( $this->get_option( $args['id'], $args['section'], $args['std'] ) ),
				'name'     => $args['section'] . '[' . $args['id'] . ']',
				'id'       => $args['section'] . '[' . $args['id'] . ']',
				'echo'     => 0,
			],
			$args
		);

		$clean_args = [];
		foreach ( $dropdown_args as $key => $arg ) {
			$clean_args[ $key ] = wp_kses( $arg, Utils::get_allowed_wp_kses_html() );
		}

		// Ignore phpstan as this is providing an array as expected
		// @phpstan-ignore-next-line
		echo wp_dropdown_pages( $clean_args ); // phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped
	}

	/**
	 * Displays a select box for user roles
	 *
	 * @param array<string,mixed> $args settings field args
	 *
	 * @return void
	 */
	public function callback_user_role_select( array $args ) {
		$selected = esc_attr( $this->get_option( $args['id'], $args['section'], $args['std'] ) );

		if ( empty( $selected ) ) {
			$selected = isset( $args['default'] ) ? $args['default'] : null;
		}

		$name = $args['section'] . '[' . $args['id'] . ']';
		$id   = $args['section'] . '[' . $args['id'] . ']';

		echo '<select id="' . esc_attr( $id ) . '" name="' . esc_attr( $name ) . '">';
		echo '<option value="any">Any</option>';
		wp_dropdown_roles( $selected );
		echo '</select>';
		echo wp_kses( $this->get_field_description( $args ), Utils::get_allowed_wp_kses_html() );
	}

	/**
	 * Sanitize callback for Settings API
	 *
	 * @param array<string,mixed> $options settings field args
	 *
	 * @return array<string,mixed>
	 */
	public function sanitize_options( array $options ) {
		if ( ! $options ) {
			return $options;
		}

		foreach ( $options as $option_slug => $option_value ) {
			$sanitize_callback = $this->get_sanitize_callback( $option_slug );

			// If callback is set, call it
			if ( $sanitize_callback ) {
				$options[ $option_slug ] = call_user_func( $sanitize_callback, $option_value );
				continue;
			}
		}

		return $options;
	}

	/**
	 * Get sanitization callback for given option slug
	 *
	 * @param string $slug option slug
	 *
	 * @return callable|false
	 */
	public function get_sanitize_callback( $slug = '' ) {
		if ( empty( $slug ) ) {
			return false;
		}

		// Iterate over registered fields and see if we can find proper callback
		foreach ( $this->settings_fields as $options ) {
			foreach ( $options as $option ) {
				if ( $slug !== $option['name'] ) {
					continue;
				}

				// Return the callback name
				return isset( $option['sanitize_callback'] ) && is_callable( $option['sanitize_callback'] ) ? $option['sanitize_callback'] : false;
			}
		}

		return false;
	}

	/**
	 * Get the value of a settings field
	 *
	 * @param string $option  settings field name
	 * @param string $section the section name this field belongs to
	 * @param string $default_value default text if it's not found
	 *
	 * @return string
	 */
	public function get_option( $option, $section, $default_value = '' ) {
		$options = get_option( $section );

		if ( isset( $options[ $option ] ) ) {
			return $options[ $option ];
		}

		return $default_value;
	}

	/**
	 * Show navigations as tab
	 *
	 * Shows all the settings section labels as tab
	 *
	 * @return void
	 */
	public function show_navigation() {
		$html = '<h2 class="nav-tab-wrapper">';

		$count = count( $this->settings_sections );

		// don't show the navigation if only one section exists
		if ( 1 === $count ) {
			return;
		}

		foreach ( $this->settings_sections as $tab ) {
			$html .= sprintf( '<a href="#%1$s" class="nav-tab" id="%1$s-tab">%2$s</a>', $tab['id'], $tab['title'] );
		}

		$html .= '</h2>';

		echo wp_kses( $html, Utils::get_allowed_wp_kses_html() );
	}

	/**
	 * Show the section settings forms
	 *
	 * This function displays every sections in a different form
	 *
	 * @return void
	 */
	public function show_forms() {
		?>
		<div class="metabox-holder">
			<?php foreach ( $this->settings_sections as $id => $form ) { ?>
				<div id="<?php echo esc_attr( $id ); ?>" class="group" style="display: none;">
					<form method="post" action="options.php">
						<?php
						do_action( 'graphql_settings_form_top', $form );
						settings_fields( $id );
						do_settings_sections( $id );
						do_action( 'graphql_settings_form_bottom', $form );
						if ( isset( $this->settings_fields[ $id ] ) ) :
							?>
							<div style="padding-left: 10px">
								<?php submit_button(); ?>
							</div>
						<?php endif; ?>
					</form>
				</div>
			<?php } ?>
		</div>
		<?php
		$this->script();
	}

	/**
	 * Tabbable JavaScript codes & Initiate Color Picker
	 *
	 * This code uses localstorage for displaying active tabs
	 *
	 * @return void
	 */
	public function script() {
		?>
		<script>
			jQuery(document).ready(function ($) {
				//Initiate Color Picker
				$('.wp-color-picker-field').wpColorPicker();

				// Switches option sections
				$('.group').hide();
				var activetab = '';
				if (typeof (localStorage) != 'undefined') {
					activetab = localStorage.getItem("activetab");
				}

				//if url has section id as hash then set it as active or override the current local storage value
				if (window.location.hash) {
					activetab = window.location.hash;
					if (typeof (localStorage) != 'undefined') {
						localStorage.setItem("activetab", activetab);
					}
				}

				if (activetab != '' && $(activetab).length) {
					$(activetab).fadeIn();
				} else {
					$('.group:first').fadeIn();
				}
				$('.group .collapsed').each(function () {
					$(this).find('input:checked').parent().parent().parent().nextAll().each(
						function () {
							if ($(this).hasClass('last')) {
								$(this).removeClass('hidden');
								return false;
							}
							$(this).filter('.hidden').removeClass('hidden');
						});
				});

				if (activetab != '' && $(activetab + '-tab').length) {
					$(activetab + '-tab').addClass('nav-tab-active');
				} else {
					$('.nav-tab-wrapper a:first').addClass('nav-tab-active');
				}
				$('.nav-tab-wrapper a').click(function (evt) {
					$('.nav-tab-wrapper a').removeClass('nav-tab-active');
					$(this).addClass('nav-tab-active').blur();
					var clicked_group = $(this).attr('href');
					if (typeof (localStorage) != 'undefined') {
						localStorage.setItem("activetab", $(this).attr('href'));
					}
					$('.group').hide();
					$(clicked_group).fadeIn();
					evt.preventDefault();
				});

				$('.wpsa-browse').on('click', function (event) {
					event.preventDefault();

					var self = $(this);

					// Create the media frame.
					var file_frame = wp.media.frames.file_frame = wp.media({
						title: self.data('uploader_title'),
						button: {
							text: self.data('uploader_button_text'),
						},
						multiple: false
					});

					file_frame.on('select', function () {
						attachment = file_frame.state().get('selection').first().toJSON();
						self.prev('.wpsa-url').val(attachment.url).change();
					});

					// Finally, open the modal
					file_frame.open();
				});
			});
		</script>
		<?php
		$this->_style_fix();
	}

	/**
	 * Add styles to adjust some settings
	 *
	 * @return void
	 */
	public function _style_fix() { // phpcs:ignore PSR2.Methods.MethodDeclaration.Underscore
		global $wp_version;

		if ( version_compare( $wp_version, '3.8', '<=' ) ) :
			?>
			<style type="text/css">
				/** WordPress 3.8 Fix **/
				.form-table th {
					padding: 20px 10px;
				}

				#wpbody-content .metabox-holder {
					padding-top: 5px;
				}
			</style>
			<?php
		endif;
	}
}


// File: wp-graphql\src\Connection\Comments.php
<?php

namespace WPGraphQL\Connection;

/**
 * Deprecated class for backwards compatibility.
 */
class Comments extends \WPGraphQL\Type\Connection\Comments {
	/**
	 * {@inheritDoc}
	 *
	 * @deprecated 1.13.0
	 */
	public static function register_connections() {
		_deprecated_function( __METHOD__, '1.13.0', '\WPGraphQL\Type\Connection\Comments::register_connections' );
		parent::register_connections();
	}

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated 1.13.0
	 */
	public static function get_connection_config( $args = [] ) {
		_deprecated_function( __METHOD__, '1.13.0', '\WPGraphQL\Type\Connection\Comments::get_connection_config' );
		return parent::get_connection_config( $args );
	}

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated 1.13.0
	 */
	public static function get_connection_args() {
		_deprecated_function( __METHOD__, '1.13.0', '\WPGraphQL\Type\Connection\Comments::get_connection_args' );
		return parent::get_connection_args();
	}
}


// File: wp-graphql\src\Connection\MenuItems.php
<?php

namespace WPGraphQL\Connection;

/**
 * Deprecated class for backwards compatibility.
 */
class MenuItems extends \WPGraphQL\Type\Connection\MenuItems {
	/**
	 * {@inheritDoc}
	 *
	 * @deprecated 1.13.0
	 */
	public static function register_connections() {
		_deprecated_function( __METHOD__, '1.13.0', '\WPGraphQL\Type\Connection\MenuItems::register_connections' );
		parent::register_connections();
	}

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated 1.13.0
	 */
	public static function get_connection_config( $args = [] ) {
		_deprecated_function( __METHOD__, '1.13.0', '\WPGraphQL\Type\Connection\MenuItems::get_connection_config' );
		return parent::get_connection_config( $args );
	}
}


// File: wp-graphql\src\Connection\PostObjects.php
<?php

namespace WPGraphQL\Connection;

/**
 * Deprecated class for backwards compatibility.
 */
class PostObjects extends \WPGraphQL\Type\Connection\PostObjects {
	/**
	 * {@inheritDoc}
	 *
	 * @deprecated 1.13.0
	 */
	public static function register_connections() {
		_deprecated_function( __METHOD__, '1.13.0', '\WPGraphQL\Type\Connection\PostObjects::register_connections' );
		parent::register_connections();
	}

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated 1.13.0
	 */
	public static function get_connection_config( $graphql_object, $args = [] ) {
		_deprecated_function( __METHOD__, '1.13.0', '\WPGraphQL\Type\Connection\PostObjects::get_connection_config' );
		return parent::get_connection_config( $graphql_object, $args );
	}

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated 1.13.0
	 */
	public static function get_connection_args( $args = [], $post_type_object = null ) {
		_deprecated_function( __METHOD__, '1.13.0', '\WPGraphQL\Type\Connection\PostObjects::get_connection_args' );
		return parent::get_connection_args( $args, $post_type_object );
	}
}


// File: wp-graphql\src\Connection\Taxonomies.php
<?php

namespace WPGraphQL\Connection;

/**
 * Deprecated class for backwards compatibility.
 */
class Taxonomies extends \WPGraphQL\Type\Connection\Taxonomies {
	/**
	 * {@inheritDoc}
	 *
	 * @deprecated 1.13.0
	 */
	public static function register_connections() {
		_deprecated_function( __METHOD__, '1.13.0', '\WPGraphQL\Type\Connection\Taxonomies::register_connections' );
		parent::register_connections();
	}
}


// File: wp-graphql\src\Connection\TermObjects.php
<?php

namespace WPGraphQL\Connection;

/**
 * Deprecated class for backwards compatibility.
 */
class TermObjects extends \WPGraphQL\Type\Connection\TermObjects {
	/**
	 * {@inheritDoc}
	 *
	 * @deprecated 1.13.0
	 */
	public static function register_connections() {
		_deprecated_function( __METHOD__, '1.13.0', '\WPGraphQL\Type\Connection\TermObjects::register_connections' );
		parent::register_connections();
	}

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated 1.13.0
	 */
	public static function get_connection_config( $tax_object, $args = [] ) {
		_deprecated_function( __METHOD__, '1.13.0', '\WPGraphQL\Type\Connection\TermObjects::get_connection_config' );
		return parent::get_connection_config( $tax_object, $args );
	}

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated 1.13.0
	 */
	public static function get_connection_args( $args = [] ) {
		_deprecated_function( __METHOD__, '1.13.0', '\WPGraphQL\Type\Connection\TermObjects::get_connection_args' );
		return parent::get_connection_args( $args );
	}
}


// File: wp-graphql\src\Connection\Users.php
<?php

namespace WPGraphQL\Connection;

/**
 * Deprecated class for backwards compatibility.
 */
class Users extends \WPGraphQL\Type\Connection\Users {
	/**
	 * {@inheritDoc}
	 *
	 * @deprecated 1.13.0
	 */
	public static function register_connections() {
		_deprecated_function( __METHOD__, '1.13.0', '\WPGraphQL\Type\Connection\Users::register_connections' );
		parent::register_connections();
	}

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated 1.13.0
	 */
	public static function get_connection_args() {
		_deprecated_function( __METHOD__, '1.13.0', '\WPGraphQL\Type\Connection\Users::get_connection_args' );
		return parent::get_connection_args();
	}
}


// File: wp-graphql\src\Data\CommentMutation.php
<?php

namespace WPGraphQL\Data;

use GraphQL\Error\UserError;
use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Utils\Utils;

/**
 * Class CommentMutation
 *
 * @package WPGraphQL\Type\Comment\Mutation
 */
class CommentMutation {

	/**
	 * This handles inserting the comment and creating
	 *
	 * @param array<string,mixed> $input         The input for the mutation
	 * @param array<string,mixed> $output_args   The output args
	 * @param string              $mutation_name The name of the mutation being performed
	 * @param bool                $update        Whether it's an update action
	 *
	 * @return array<string,mixed>
	 * @throws \GraphQL\Error\UserError If the comment author is not provided.
	 */
	public static function prepare_comment_object( array $input, array &$output_args, string $mutation_name, $update = false ) {
		/**
		 * Prepare the data for inserting the comment
		 * NOTE: These are organized in the same order as: https://developer.wordpress.org/reference/functions/wp_insert_comment/
		 *
		 *  Ex.
		 *    'comment_post_ID' => 1,
		 *    'comment_author' => 'admin',
		 *    'comment_author_email' => 'admin@admin.com',
		 *    'comment_author_url' => 'http://',
		 *    'comment_content' => 'content here',
		 *    'comment_type' => '',
		 *    'comment_parent' => 0,
		 *    'comment_date' => $time,
		 *    'comment_approved' => 1,
		 */

		$user = self::get_comment_author( $input['authorEmail'] ?? null );

		if ( false !== $user ) {
			$output_args['user_id'] = $user->ID;

			$input['author']      = ! empty( $input['author'] ) ? $input['author'] : $user->display_name;
			$input['authorEmail'] = ! empty( $input['authorEmail'] ) ? $input['authorEmail'] : $user->user_email;
			$input['authorUrl']   = ! empty( $input['authorUrl'] ) ? $input['authorUrl'] : $user->user_url;
		}

		if ( empty( $input['author'] ) ) {
			if ( ! $update ) {
				throw new UserError( esc_html__( 'Comment must include an authorName.', 'wp-graphql' ) );
			}
		} else {
			$output_args['comment_author'] = $input['author'];
		}

		if ( ! empty( $input['authorEmail'] ) ) {
			if ( false === is_email( apply_filters( 'pre_user_email', $input['authorEmail'] ) ) ) {
				throw new UserError( esc_html__( 'The email address you are trying to use is invalid', 'wp-graphql' ) );
			}
			$output_args['comment_author_email'] = $input['authorEmail'];
		}

		if ( ! empty( $input['authorUrl'] ) ) {
			$output_args['comment_author_url'] = $input['authorUrl'];
		}

		if ( ! empty( $input['commentOn'] ) ) {
			$output_args['comment_post_ID'] = $input['commentOn'];
		}

		if ( ! empty( $input['date'] ) && false !== strtotime( $input['date'] ) ) {
			$output_args['comment_date'] = gmdate( 'Y-m-d H:i:s', strtotime( $input['date'] ) );
		}

		if ( ! empty( $input['content'] ) ) {
			$output_args['comment_content'] = $input['content'];
		}

		if ( ! empty( $input['parent'] ) ) {
			$output_args['comment_parent'] = Utils::get_database_id_from_id( $input['parent'] );
		}

		if ( ! empty( $input['type'] ) ) {
			$output_args['comment_type'] = $input['type'];
		}

		if ( ! empty( $input['status'] ) ) {
			$output_args['comment_approved'] = $input['status'];
		}

		// Fallback to deprecated `approved` input.
		if ( empty( $output_args['comment_approved'] ) && isset( $input['approved'] ) ) {
			$output_args['comment_approved'] = $input['approved'];
		}

		/**
		 * Filter the $insert_post_args
		 *
		 * @param array<string,mixed> $output_args   The array of $input_post_args that will be passed to wp_new_comment
		 * @param array<string,mixed> $input         The data that was entered as input for the mutation
		 * @param string              $mutation_type The type of mutation being performed ( create, edit, etc )
		 */
		$output_args = apply_filters( 'graphql_comment_insert_post_args', $output_args, $input, $mutation_name );

		return $output_args;
	}

	/**
	 * This updates commentmeta.
	 *
	 * @param int                                  $comment_id    The ID of the postObject the comment is connected to
	 * @param array<string,mixed>                  $input         The input for the mutation
	 * @param string                               $mutation_name The name of the mutation ( ex: create, update, delete )
	 * @param \WPGraphQL\AppContext                $context The AppContext passed down to all resolvers
	 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo passed down to all resolvers
	 *
	 * @return void
	 */
	public static function update_additional_comment_data( int $comment_id, array $input, string $mutation_name, AppContext $context, ResolveInfo $info ) {

		/**
		 * @todo: should account for authentication
		 */
		$intended_comment_status = 0;
		$default_comment_status  = 0;

		do_action( 'graphql_comment_object_mutation_update_additional_data', $comment_id, $input, $mutation_name, $context, $info, $intended_comment_status, $default_comment_status );
	}

	/**
	 * Gets the user object for the comment author.
	 *
	 * @param ?string $author_email The authorEmail provided to the mutation input.
	 *
	 * @return \WP_User|false
	 */
	protected static function get_comment_author( ?string $author_email = null ) {
		$user = wp_get_current_user();

		// Fail if no logged in user.
		if ( 0 === $user->ID ) {
			return false;
		}

		// Return the current user if they can only handle their own comments or if there's no specified author.
		if ( empty( $author_email ) || ! $user->has_cap( 'moderate_comments' ) ) {
			return $user;
		}

		$author = get_user_by( 'email', $author_email );

		return ! empty( $author->ID ) ? $author : false;
	}
}


// File: wp-graphql\src\Data\Config.php
<?php

namespace WPGraphQL\Data;

use WPGraphQL\Data\Cursor\CommentObjectCursor;
use WPGraphQL\Data\Cursor\PostObjectCursor;
use WPGraphQL\Data\Cursor\TermObjectCursor;
use WPGraphQL\Data\Cursor\UserCursor;
use WP_Comment_Query;
use WP_Query;

/**
 * Class Config
 *
 * This class contains configurations for various data-related things, such as query filters for
 * cursor pagination.
 *
 * @package WPGraphQL\Data
 */
class Config {

	/**
	 * Config constructor.
	 */
	public function __construct() {

		/**
		 * Filter the term_clauses in the WP_Term_Query to allow for cursor pagination support where a Term ID
		 * can be used as a point of comparison when slicing the results to return.
		 */
		add_filter(
			'comments_clauses',
			[
				$this,
				'graphql_wp_comments_query_cursor_pagination_support',
			],
			10,
			2
		);

		/**
		 * Filter the WP_Query to support cursor based pagination where a post ID can be used
		 * as a point of comparison when slicing the results to return.
		 */
		add_filter( 'posts_where', [ $this, 'graphql_wp_query_cursor_pagination_support' ], 10, 2 );

		/**
		 * Filter the term_clauses in the WP_Term_Query to allow for cursor pagination support where a Term ID
		 * can be used as a point of comparison when slicing the results to return.
		 */
		add_filter(
			'terms_clauses',
			[
				$this,
				'graphql_wp_term_query_cursor_pagination_support',
			],
			10,
			3
		);

		/**
		 * Filter WP_Query order by add some stability to meta query ordering
		 */
		add_filter(
			'posts_orderby',
			[
				$this,
				'graphql_wp_query_cursor_pagination_stability',
			],
			10,
			2
		);

		if ( ! defined( 'ABSPATH' ) ) {
			exit;
		}

		/**
		 * Copied from https://github.com/wp-graphql/wp-graphql/issues/274#issuecomment-510150571
		 * Shoutouts to epeli!
		 *
		 * Add missing filters to WP_User_Query class.
		 */
		add_filter(
			'pre_user_query',
			static function ( $query ) {
				if ( ! $query->get( 'suppress_filters' ) ) {
					$query->set( 'suppress_filters', 0 );
				}

				if ( ! $query->get( 'suppress_filters' ) ) {

					/**
					 * Filters the WHERE clause of the query.
					 *
					 * Specifically for manipulating paging queries.
					 **
					 *
					 * @param string        $where The WHERE clause of the query.
					 * @param \WPGraphQL\Data\WP_User_Query $query The WP_User_Query instance (passed by reference).
					 */
					$query->query_where = apply_filters_ref_array(
						'graphql_users_where',
						[
							$query->query_where,
							&$query,
						]
					);

					/**
					 * Filters the ORDER BY clause of the query.
					 *
					 * @param string        $orderby The ORDER BY clause of the query.
					 * @param \WPGraphQL\Data\WP_User_Query $query The WP_User_Query instance (passed by reference).
					 */
					$query->query_orderby = apply_filters_ref_array(
						'graphql_users_orderby',
						[
							$query->query_orderby,
							&$query,
						]
					);
				}

				return $query;
			}
		);

		/**
		 * Filter the WP_User_Query to support cursor based pagination where a user ID can be used
		 * as a point of comparison when slicing the results to return.
		 */
		add_filter(
			'graphql_users_where',
			[
				$this,
				'graphql_wp_user_query_cursor_pagination_support',
			],
			10,
			2
		);

		/**
		 * Filter WP_User_Query order by add some stability to meta query ordering
		 */
		add_filter(
			'graphql_users_orderby',
			[
				$this,
				'graphql_wp_user_query_cursor_pagination_stability',
			],
			10,
			2
		);
	}

	/**
	 * When posts are ordered by fields that have duplicate values, we need to consider
	 * another field to "stabilize" the query order. We use IDs as they're always unique.
	 *
	 * This allows for posts with the same title or same date or same meta value to exist
	 * and for their cursors to properly go forward/backward to the proper place in the database.
	 *
	 * @param string    $orderby  The ORDER BY clause of the query.
	 * @param \WP_Query $query    The WP_Query instance executing.
	 *
	 * @return string
	 */
	public function graphql_wp_query_cursor_pagination_stability( string $orderby, WP_Query $query ) {
		// Bail early if it's not a GraphQL Request.
		if ( true !== is_graphql_request() ) {
			return $orderby;
		}

		/**
		 * If pre-filter hooked, return $pre_orderby.
		 *
		 * @param string|null $pre_orderby The pre-filtered ORDER BY clause of the query.
		 * @param string      $orderby     The ORDER BY clause of the query.
		 * @param \WP_Query   $query       The WP_Query instance (passed by reference).
		 *
		 * @return string|null
		 */
		$pre_orderby = apply_filters( 'graphql_pre_wp_query_cursor_pagination_stability', null, $orderby, $query );
		if ( null !== $pre_orderby ) {
			return $pre_orderby;
		}

		// Bail early if disabled by connection.
		if ( isset( $query->query_vars['graphql_apply_cursor_pagination_orderby'] )
			&& false === $query->query_vars['graphql_apply_cursor_pagination_orderby'] ) {
			return $orderby;
		}

		// Bail early if the cursor "graphql_cursor_compare" arg is not in the query,
		if ( ! isset( $query->query_vars['graphql_cursor_compare'] ) ) {
			return $orderby;
		}

		// Check the cursor compare order
		$order = '>' === $query->query_vars['graphql_cursor_compare'] ? 'ASC' : 'DESC';

		// Get Cursor ID key.
		$cursor = new PostObjectCursor( $query->query_vars );
		$key    = $cursor->get_cursor_id_key();

		// If there is a cursor compare in the arguments, use it as the stablizer for cursors.
		return ( $orderby ? "{$orderby}, " : '' ) . "{$key} {$order}";
	}

	/**
	 * This filters the WPQuery 'where' $args, enforcing the query to return results before or
	 * after the referenced cursor
	 *
	 * @param string    $where The WHERE clause of the query.
	 * @param \WP_Query $query The WP_Query instance (passed by reference).
	 *
	 * @return string
	 */
	public function graphql_wp_query_cursor_pagination_support( string $where, WP_Query $query ) {
		// Bail early if it's not a GraphQL Request.
		if ( true !== is_graphql_request() ) {
			return $where;
		}

		/**
		 * If pre-filter hooked, return $pre_where.
		 *
		 * @param string|null $pre_where The pre-filtered WHERE clause of the query.
		 * @param string     $where     The WHERE clause of the query.
		 * @param \WP_Query  $query     The WP_Query instance (passed by reference).
		 *
		 * @return string|null
		 */
		$pre_where = apply_filters( 'graphql_pre_wp_query_cursor_pagination_support', null, $where, $query );
		if ( null !== $pre_where ) {
			return $pre_where;
		}

		// Bail early if disabled by connection.
		if ( isset( $query->query_vars['graphql_apply_cursor_pagination_where'] )
			&& false === $query->query_vars['graphql_apply_cursor_pagination_where'] ) {
			return $where;
		}

		// Apply the after cursor, moving forward through results
		if ( ! empty( $query->query_vars['graphql_after_cursor'] ) ) {
			$after_cursor = new PostObjectCursor( $query->query_vars, 'after' );
			$where       .= $after_cursor->get_where();
		}

		// Apply the after cursor, moving backward through results.
		if ( ! empty( $query->query_vars['graphql_before_cursor'] ) ) {
			$before_cursor = new PostObjectCursor( $query->query_vars, 'before' );
			$where        .= $before_cursor->get_where();
		}

		return $where;
	}

	/**
	 * When users are ordered by a meta query the order might be random when
	 * the meta values have same values multiple times. This filter adds a
	 * secondary ordering by the post ID which forces stable order in such cases.
	 *
	 * @param string         $orderby The ORDER BY clause of the query.
	 * @param \WP_User_Query $query The WP_User_Query instance (passed by reference).
	 *
	 * @return string
	 */
	public function graphql_wp_user_query_cursor_pagination_stability( $orderby, \WP_User_Query $query ) {

		// Bail early if it's not a GraphQL Request.
		if ( true !== is_graphql_request() ) {
			return $orderby;
		}

		/**
		 * If pre-filter hooked, return $pre_orderby.
		 *
		 * @param string|null     $pre_orderby The pre-filtered ORDER BY clause of the query.
		 * @param string          $orderby     The ORDER BY clause of the query.
		 * @param \WP_User_Query  $query       The WP_User_Query instance (passed by reference).
		 *
		 * @return string|null
		 */
		$pre_orderby = apply_filters( 'graphql_pre_wp_user_query_cursor_pagination_stability', null, $orderby, $query );
		if ( null !== $pre_orderby ) {
			return $pre_orderby;
		}

		// Bail early if disabled by connection.
		if ( isset( $query->query_vars['graphql_apply_cursor_pagination_orderby'] )
			&& false === $query->query_vars['graphql_apply_cursor_pagination_orderby'] ) {
			return $orderby;
		}

		// Bail early if the cursor "graphql_cursor_compare" arg is not in the query,
		if ( ! isset( $query->query_vars['graphql_cursor_compare'] ) ) {
			return $orderby;
		}

		// Check the cursor compare order
		$order = '>' === $query->query_vars['graphql_cursor_compare'] ? 'ASC' : 'DESC';

		// Get Cursor ID key.
		$cursor = new UserCursor( $query->query_vars );
		$key    = $cursor->get_cursor_id_key();

		return ( $orderby ? "{$orderby}, " : '' ) . "{$key} {$order}";
	}

	/**
	 * This filters the WP_User_Query 'where' $args, enforcing the query to return results before or
	 * after the referenced cursor
	 *
	 * @param string         $where The WHERE clause of the query.
	 * @param \WP_User_Query $query The WP_User_Query instance (passed by reference).
	 *
	 * @return string
	 */
	public function graphql_wp_user_query_cursor_pagination_support( $where, \WP_User_Query $query ) {

		// Bail early if it's not a GraphQL Request.
		if ( true !== is_graphql_request() ) {
			return $where;
		}

		/**
		 * If pre-filter hooked, return $pre_where.
		 *
		 * @param string|null    $pre_where The pre-filtered WHERE clause of the query.
		 * @param string         $where     The WHERE clause of the query.
		 * @param \WP_User_Query $query     The WP_Query instance (passed by reference).
		 *
		 * @return string|null
		 */
		$pre_where = apply_filters( 'graphql_pre_wp_user_query_cursor_pagination_support', null, $where, $query );
		if ( null !== $pre_where ) {
			return $pre_where;
		}

		// Bail early if disabled by connection.
		if ( isset( $query->query_vars['graphql_apply_cursor_pagination_where'] )
			&& false === $query->query_vars['graphql_apply_cursor_pagination_where'] ) {
			return $where;
		}

		// Apply the after cursor.
		if ( ! empty( $query->query_vars['graphql_after_cursor'] ) ) {
			$after_cursor = new UserCursor( $query->query_vars, 'after' );
			$where        = $where . $after_cursor->get_where();
		}

		// Apply the after cursor.
		if ( ! empty( $query->query_vars['graphql_before_cursor'] ) ) {
			$before_cursor = new UserCursor( $query->query_vars, 'before' );
			$where         = $where . $before_cursor->get_where();
		}

		return $where;
	}

	/**
	 * This filters the term_clauses in the WP_Term_Query to support cursor based pagination, where
	 * we can move forward or backward from a particular record, instead of typical offset
	 * pagination which can be much more expensive and less accurate.
	 *
	 * @param array<string,mixed> $pieces     Terms query SQL clauses.
	 * @param string[]            $taxonomies An array of taxonomies.
	 * @param array<string,mixed> $args       An array of terms query arguments.
	 *
	 * @return array<string,mixed> $pieces
	 */
	public function graphql_wp_term_query_cursor_pagination_support( array $pieces, array $taxonomies, array $args ) {

		// Bail early if it's not a GraphQL Request.
		if ( true !== is_graphql_request() ) {
			return $pieces;
		}

		/**
		 * If pre-filter hooked, return $pre_pieces.
		 *
		 * @param ?array<string,mixed> $pre_pieces The pre-filtered term query SQL clauses.
		 * @param array<string,mixed>  $pieces     Terms query SQL clauses.
		 * @param string[]             $taxonomies An array of taxonomies.
		 * @param array<string,mixed>  $args       An array of terms query arguments.
		 */
		$pre_pieces = apply_filters( 'graphql_pre_wp_term_query_cursor_pagination_support', null, $pieces, $taxonomies, $args );
		if ( null !== $pre_pieces ) {
			return $pre_pieces;
		}

		// Bail early if disabled by connection.
		if ( isset( $args['graphql_apply_cursor_pagination_where'] )
			&& false === $args['graphql_apply_cursor_pagination_where'] ) {
			return $pieces;
		}

		// Bail early if the cursor "graphql_cursor_compare" arg is not in the query,
		if ( ! isset( $args['graphql_cursor_compare'] ) ) {
			return $pieces;
		}

		// Determine the limit for the query
		if ( isset( $args['number'] ) && absint( $args['number'] ) ) {
			$pieces['limits'] = sprintf( ' LIMIT 0, %d', absint( $args['number'] ) );
		}

		// Apply the after cursor.
		if ( ! empty( $args['graphql_after_cursor'] ) ) {
			$after_cursor    = new TermObjectCursor( $args, 'after' );
			$pieces['where'] = $pieces['where'] . $after_cursor->get_where();
		}

		// Apply the before cursor.
		if ( ! empty( $args['graphql_before_cursor'] ) ) {
			$before_cursor   = new TermObjectCursor( $args, 'before' );
			$pieces['where'] = $pieces['where'] . $before_cursor->get_where();
		}

		// Check the cursor compare order.
		$order = '>' === $args['graphql_cursor_compare'] ? 'ASC' : 'DESC';

		// Get Cursor ID key.
		$cursor = new TermObjectCursor( $args );
		$key    = $cursor->get_cursor_id_key();

		// If there is a cursor compare in the arguments, use it as the stabilizer for cursors.
		if ( ! empty( $pieces['orderby'] ) ) {
			$pieces['orderby'] = "{$pieces['orderby']} {$pieces['order']}, {$key} {$order}";
		} else {
			$pieces['orderby'] = "ORDER BY {$key} {$order}";
		}

		$pieces['order'] = '';

		return $pieces;
	}

	/**
	 * This returns a modified version of the $pieces of the comment query clauses if the request
	 * is a GraphQL Request and before or after cursors are passed to the query
	 *
	 * @param array<string,mixed> $pieces A compacted array of comment query clauses.
	 * @param \WP_Comment_Query   $query Current instance of WP_Comment_Query, passed by reference.
	 *
	 * @return array<string,mixed> $pieces
	 */
	public function graphql_wp_comments_query_cursor_pagination_support( array $pieces, WP_Comment_Query $query ) {

		// Bail early if it's not a GraphQL Request.
		if ( true !== is_graphql_request() ) {
			return $pieces;
		}

		/**
		 * If pre-filter hooked, return $pre_pieces.
		 *
		 * @param ?array<string,mixed> $pre_pieces The pre-filtered comment query clauses.
		 * @param array<string,mixed>  $pieces     A compacted array of comment query clauses.
		 * @param \WP_Comment_Query    $query      Current instance of WP_Comment_Query, passed by reference.
		 */
		$pre_pieces = apply_filters( 'graphql_pre_wp_comments_query_cursor_pagination_support', null, $pieces, $query );
		if ( null !== $pre_pieces ) {
			return $pre_pieces;
		}

		// Bail early if disabled by connection.
		if ( isset( $query->query_vars['graphql_apply_cursor_pagination_where'] )
			&& false === $query->query_vars['graphql_apply_cursor_pagination_where'] ) {
			return $pieces;
		}

		// Apply the after cursor, moving forward through results.
		if ( ! empty( $query->query_vars['graphql_after_cursor'] ) ) {
			$after_cursor     = new CommentObjectCursor( $query->query_vars, 'after' );
			$pieces['where'] .= $after_cursor->get_where();
		}

		// Apply the after cursor, moving backward through results.
		if ( ! empty( $query->query_vars['graphql_before_cursor'] ) ) {
			$before_cursor    = new CommentObjectCursor( $query->query_vars, 'before' );
			$pieces['where'] .= $before_cursor->get_where();
		}

		return $pieces;
	}
}


// File: wp-graphql\src\Data\DataSource.php
<?php

namespace WPGraphQL\Data;

use GraphQL\Error\UserError;
use GraphQL\Type\Definition\ResolveInfo;
use GraphQLRelay\Relay;
use WPGraphQL\AppContext;
use WPGraphQL\Data\Connection\CommentConnectionResolver;
use WPGraphQL\Data\Connection\PluginConnectionResolver;
use WPGraphQL\Data\Connection\PostObjectConnectionResolver;
use WPGraphQL\Data\Connection\TermObjectConnectionResolver;
use WPGraphQL\Data\Connection\ThemeConnectionResolver;
use WPGraphQL\Data\Connection\UserConnectionResolver;
use WPGraphQL\Data\Connection\UserRoleConnectionResolver;
use WPGraphQL\Model\Avatar;
use WPGraphQL\Model\Comment;
use WPGraphQL\Model\CommentAuthor;
use WPGraphQL\Model\Menu;
use WPGraphQL\Model\Plugin;
use WPGraphQL\Model\Post;
use WPGraphQL\Model\PostType;
use WPGraphQL\Model\Taxonomy;
use WPGraphQL\Model\Term;
use WPGraphQL\Model\Theme;
use WPGraphQL\Model\User;
use WPGraphQL\Model\UserRole;
use WPGraphQL\Registry\TypeRegistry;

/**
 * Class DataSource
 *
 * This class serves as a factory for all the resolvers for queries and mutations. This layer of
 * abstraction over the actual resolve functions allows easier, granular control over versioning as
 * we can change big things behind the scenes if/when needed, and we just need to ensure the
 * call to the DataSource method returns the expected data later on. This should make it easy
 * down the road to version resolvers if/when changes to the WordPress API are rolled out.
 *
 * @package WPGraphQL\Data
 * @since   0.0.4
 */
class DataSource {

	/**
	 * Stores an array of node definitions
	 *
	 * @var mixed[] $node_definition
	 * @since  0.0.4
	 */
	protected static $node_definition;

	/**
	 * Retrieves a WP_Comment object for the id that gets passed
	 *
	 * @param int                   $id      ID of the comment we want to get the object for.
	 * @param \WPGraphQL\AppContext $context The context of the request.
	 *
	 * @return \GraphQL\Deferred object
	 * @throws \GraphQL\Error\UserError Throws UserError.
	 * @throws \Exception Throws UserError.
	 *
	 * @since 0.0.5
	 *
	 * @deprecated Use the Loader passed in $context instead
	 */
	public static function resolve_comment( $id, $context ) {
		_deprecated_function( __METHOD__, '0.8.4', 'Use $context->get_loader( \'comment\' )->load_deferred( $id ) instead.' );

		return $context->get_loader( 'comment' )->load_deferred( $id );
	}

	/**
	 * Retrieves a WP_Comment object for the ID that gets passed
	 *
	 * @param int $comment_id The ID of the comment the comment author is associated with.
	 *
	 * @return \WPGraphQL\Model\CommentAuthor|null
	 * @throws \Exception Throws Exception.
	 */
	public static function resolve_comment_author( int $comment_id ) {
		$comment_author = get_comment( $comment_id );

		return ! empty( $comment_author ) ? new CommentAuthor( $comment_author ) : null;
	}

	/**
	 * Wrapper for the CommentsConnectionResolver class
	 *
	 * @param mixed                                $source  The object the connection is coming from
	 * @param array<string,mixed>                  $args    Query args to pass to the connection resolver
	 * @param \WPGraphQL\AppContext                $context The context of the query to pass along
	 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo object
	 *
	 * @return \GraphQL\Deferred
	 * @throws \Exception
	 * @since 0.0.5
	 */
	public static function resolve_comments_connection( $source, array $args, AppContext $context, ResolveInfo $info ) {
		$resolver = new CommentConnectionResolver( $source, $args, $context, $info );

		return $resolver->get_connection();
	}

	/**
	 * Wrapper for PluginsConnectionResolver::resolve
	 *
	 * @param mixed                                $source  The object the connection is coming from
	 * @param array<string,mixed>                  $args    Array of arguments to pass to resolve method
	 * @param \WPGraphQL\AppContext                $context AppContext object passed down
	 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo object
	 *
	 * @return \GraphQL\Deferred
	 * @throws \Exception
	 * @since  0.0.5
	 */
	public static function resolve_plugins_connection( $source, array $args, AppContext $context, ResolveInfo $info ) {
		$resolver = new PluginConnectionResolver( $source, $args, $context, $info );
		return $resolver->get_connection();
	}

	/**
	 * Returns the post object for the ID and post type passed
	 *
	 * @param int                   $id      ID of the post you are trying to retrieve
	 * @param \WPGraphQL\AppContext $context The context of the GraphQL Request
	 *
	 * @return \GraphQL\Deferred
	 *
	 * @throws \GraphQL\Error\UserError
	 * @throws \Exception
	 *
	 * @since      0.0.5
	 * @deprecated Use the Loader passed in $context instead
	 */
	public static function resolve_post_object( int $id, AppContext $context ) {
		_deprecated_function( __METHOD__, '0.8.4', 'Use $context->get_loader( \'post\' )->load_deferred( $id ) instead.' );
		return $context->get_loader( 'post' )->load_deferred( $id );
	}

	/**
	 * @param int                   $id      The ID of the menu item to load
	 * @param \WPGraphQL\AppContext $context The context of the GraphQL request
	 *
	 * @return \GraphQL\Deferred|null
	 * @throws \Exception
	 *
	 * @deprecated Use the Loader passed in $context instead
	 */
	public static function resolve_menu_item( int $id, AppContext $context ) {
		_deprecated_function( __METHOD__, '0.8.4', 'Use $context->get_loader( \'post\' )->load_deferred( $id ) instead.' );
		return $context->get_loader( 'post' )->load_deferred( $id );
	}

	/**
	 * Wrapper for PostObjectsConnectionResolver
	 *
	 * @param mixed                                $source    The object the connection is coming from
	 * @param array<string,mixed>                  $args      Arguments to pass to the resolve method
	 * @param \WPGraphQL\AppContext                $context AppContext object to pass down
	 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo object
	 * @param mixed|string|string[]                $post_type Post type of the post we are trying to resolve
	 *
	 * @return \GraphQL\Deferred
	 * @throws \Exception
	 * @since  0.0.5
	 */
	public static function resolve_post_objects_connection( $source, array $args, AppContext $context, ResolveInfo $info, $post_type ) {
		$resolver = new PostObjectConnectionResolver( $source, $args, $context, $info, $post_type );

		return $resolver->get_connection();
	}

	/**
	 * Retrieves the taxonomy object for the name of the taxonomy passed
	 *
	 * @param string $taxonomy Name of the taxonomy you want to retrieve the taxonomy object for
	 *
	 * @return \WPGraphQL\Model\Taxonomy object
	 * @throws \GraphQL\Error\UserError If no taxonomy is found with the name passed.
	 * @since  0.0.5
	 */
	public static function resolve_taxonomy( $taxonomy ) {

		/**
		 * Get the allowed_taxonomies
		 *
		 * @var string[] $allowed_taxonomies
		 */
		$allowed_taxonomies = \WPGraphQL::get_allowed_taxonomies();

		if ( ! in_array( $taxonomy, $allowed_taxonomies, true ) ) {
			// translators: %s is the name of the taxonomy.
			throw new UserError( esc_html( sprintf( __( 'No taxonomy was found with the name %s', 'wp-graphql' ), $taxonomy ) ) );
		}

		$tax_object = get_taxonomy( $taxonomy );

		if ( ! $tax_object instanceof \WP_Taxonomy ) {
			// translators: %s is the name of the taxonomy.
			throw new UserError( esc_html( sprintf( __( 'No taxonomy was found with the name %s', 'wp-graphql' ), $taxonomy ) ) );
		}

		return new Taxonomy( $tax_object );
	}

	/**
	 * Get the term object for a term
	 *
	 * @param int                   $id      ID of the term you are trying to retrieve the object for
	 * @param \WPGraphQL\AppContext $context The context of the GraphQL Request
	 *
	 * @return \GraphQL\Deferred
	 * @throws \Exception
	 * @since      0.0.5
	 *
	 * @deprecated Use the Loader passed in $context instead
	 */
	public static function resolve_term_object( $id, AppContext $context ) {
		_deprecated_function( __METHOD__, '0.8.4', 'Use $context->get_loader( \'term\' )->load_deferred( $id ) instead.' );
		return $context->get_loader( 'term' )->load_deferred( $id );
	}

	/**
	 * Wrapper for TermObjectConnectionResolver::resolve
	 *
	 * @param mixed                                $source   The object the connection is coming from
	 * @param array<string,mixed>                  $args     Array of args to be passed to the resolve method
	 * @param \WPGraphQL\AppContext                $context The AppContext object to be passed down
	 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo object
	 * @param string                               $taxonomy The name of the taxonomy the term belongs to
	 *
	 * @return \GraphQL\Deferred
	 * @throws \Exception
	 * @since  0.0.5
	 */
	public static function resolve_term_objects_connection( $source, array $args, AppContext $context, ResolveInfo $info, string $taxonomy ) {
		$resolver = new TermObjectConnectionResolver( $source, $args, $context, $info, $taxonomy );

		return $resolver->get_connection();
	}

	/**
	 * Retrieves the theme object for the theme you are looking for
	 *
	 * @param string $stylesheet Directory name for the theme.
	 *
	 * @return \WPGraphQL\Model\Theme object
	 * @throws \GraphQL\Error\UserError
	 * @since  0.0.5
	 */
	public static function resolve_theme( $stylesheet ) {
		$theme = wp_get_theme( $stylesheet );
		if ( $theme->exists() ) {
			return new Theme( $theme );
		} else {
			// translators: %s is the name of the theme stylesheet.
			throw new UserError( esc_html( sprintf( __( 'No theme was found with the stylesheet: %s', 'wp-graphql' ), $stylesheet ) ) );
		}
	}

	/**
	 * Wrapper for the ThemesConnectionResolver::resolve method
	 *
	 * @param mixed                                $source  The object the connection is coming from
	 * @param array<string,mixed>                  $args    Passes an array of arguments to the resolve method
	 * @param \WPGraphQL\AppContext                $context The AppContext object to be passed down
	 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo object
	 *
	 * @return \GraphQL\Deferred
	 * @throws \Exception
	 * @since  0.0.5
	 */
	public static function resolve_themes_connection( $source, array $args, AppContext $context, ResolveInfo $info ) {
		$resolver = new ThemeConnectionResolver( $source, $args, $context, $info );
		return $resolver->get_connection();
	}

	/**
	 * Gets the user object for the user ID specified
	 *
	 * @param int                   $id      ID of the user you want the object for
	 * @param \WPGraphQL\AppContext $context The AppContext
	 *
	 * @return \GraphQL\Deferred
	 * @throws \Exception
	 *
	 * @since      0.0.5
	 * @deprecated Use the Loader passed in $context instead
	 */
	public static function resolve_user( $id, AppContext $context ) {
		_deprecated_function( __METHOD__, '0.8.4', 'Use $context->get_loader( \'user\' )->load_deferred( $id ) instead.' );
		return $context->get_loader( 'user' )->load_deferred( $id );
	}

	/**
	 * Wrapper for the UsersConnectionResolver::resolve method
	 *
	 * @param mixed                                $source  The object the connection is coming from
	 * @param array<string,mixed>                  $args    Array of args to be passed down to the resolve method
	 * @param \WPGraphQL\AppContext                $context The AppContext object to be passed down
	 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo object
	 *
	 * @return \GraphQL\Deferred
	 * @throws \Exception
	 * @since  0.0.5
	 */
	public static function resolve_users_connection( $source, array $args, AppContext $context, ResolveInfo $info ) {
		$resolver = new UserConnectionResolver( $source, $args, $context, $info );

		return $resolver->get_connection();
	}

	/**
	 * Returns an array of data about the user role you are requesting
	 *
	 * @param string $name Name of the user role you want info for
	 *
	 * @return \WPGraphQL\Model\UserRole
	 * @throws \GraphQL\Error\UserError If no user role is found with the name passed.
	 * @since  0.0.30
	 */
	public static function resolve_user_role( $name ) {
		$role = isset( wp_roles()->roles[ $name ] ) ? wp_roles()->roles[ $name ] : null;

		if ( null === $role ) {
			// translators: %s is the name of the user role.
			throw new UserError( esc_html( sprintf( __( 'No user role was found with the name %s', 'wp-graphql' ), $name ) ) );
		} else {
			$role                = (array) $role;
			$role['id']          = $name;
			$role['displayName'] = $role['name'];
			$role['name']        = $name;

			return new UserRole( $role );
		}
	}

	/**
	 * Resolve the avatar for a user
	 *
	 * @param int                 $user_id ID of the user to get the avatar data for
	 * @param array<string,mixed> $args    The args to pass to the get_avatar_data function
	 *
	 * @return \WPGraphQL\Model\Avatar|null
	 * @throws \Exception
	 */
	public static function resolve_avatar( int $user_id, array $args ) {
		$avatar = get_avatar_data( absint( $user_id ), $args );

		// if there's no url returned, return null
		if ( empty( $avatar['url'] ) ) {
			return null;
		}

		$avatar = new Avatar( $avatar );

		if ( 'private' === $avatar->get_visibility() ) {
			return null;
		}

		return $avatar;
	}

	/**
	 * Resolve the connection data for user roles
	 *
	 * @param mixed[]                              $source  The Query results
	 * @param array<string,mixed>                  $args    The query arguments
	 * @param \WPGraphQL\AppContext                $context The AppContext passed down to the query
	 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo object
	 *
	 * @return \GraphQL\Deferred
	 * @throws \Exception
	 */
	public static function resolve_user_role_connection( $source, array $args, AppContext $context, ResolveInfo $info ) {
		$resolver = new UserRoleConnectionResolver( $source, $args, $context, $info );

		return $resolver->get_connection();
	}

	/**
	 * Format the setting group name to our standard.
	 *
	 * @param string $group
	 *
	 * @return string $group
	 */
	public static function format_group_name( string $group ) {
		$replaced_group = graphql_format_name( $group, ' ', '/[^a-zA-Z0-9 -]/' );

		if ( ! empty( $replaced_group ) ) {
			$group = $replaced_group;
		}

		$group = lcfirst( str_replace( '_', ' ', ucwords( $group, '_' ) ) );
		$group = lcfirst( str_replace( '-', ' ', ucwords( $group, '_' ) ) );
		$group = lcfirst( str_replace( ' ', '', ucwords( $group, ' ' ) ) );

		return $group;
	}

	/**
	 * Get all of the allowed settings by group and return the
	 * settings group that matches the group param
	 *
	 * @param string                           $group
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry The WPGraphQL TypeRegistry
	 *
	 * @return array<string,mixed>
	 */
	public static function get_setting_group_fields( string $group, TypeRegistry $type_registry ) {

		/**
		 * Get all of the settings, sorted by group
		 */
		$settings_groups = self::get_allowed_settings_by_group( $type_registry );

		return ! empty( $settings_groups[ $group ] ) ? $settings_groups[ $group ] : [];
	}

	/**
	 * Get all of the allowed settings by group
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry The WPGraphQL TypeRegistry
	 *
	 * @return array<string,array<string,mixed>> $allowed_settings_by_group
	 */
	public static function get_allowed_settings_by_group( TypeRegistry $type_registry ) {

		/**
		 * Get all registered settings
		 */
		$registered_settings = get_registered_settings();

		/**
		 * Loop through the $registered_settings array and build an array of
		 * settings for each group ( general, reading, discussion, writing, reading, etc. )
		 * if the setting is allowed in REST or GraphQL
		 */
		$allowed_settings_by_group = [];
		foreach ( $registered_settings as $key => $setting ) {
			// Bail if the setting doesn't have a group.
			if ( empty( $setting['group'] ) ) {
				continue;
			}

			$group = self::format_group_name( $setting['group'] );

			if ( ! isset( $setting['type'] ) || ! $type_registry->get_type( $setting['type'] ) ) {
				continue;
			}

			if ( ! isset( $setting['show_in_graphql'] ) ) {
				if ( isset( $setting['show_in_rest'] ) && false !== $setting['show_in_rest'] ) {
					$setting['key']                              = $key;
					$allowed_settings_by_group[ $group ][ $key ] = $setting;
				}
			} elseif ( true === $setting['show_in_graphql'] ) {
				$setting['key']                              = $key;
				$allowed_settings_by_group[ $group ][ $key ] = $setting;
			}
		}

		/**
		 * Set the setting groups that are allowed
		 */
		$allowed_settings_by_group = ! empty( $allowed_settings_by_group ) ? $allowed_settings_by_group : [];

		/**
		 * Filter the $allowed_settings_by_group to allow enabling or disabling groups in the GraphQL Schema.
		 *
		 * @param array<string,array<string,mixed>> $allowed_settings_by_group
		 */
		return apply_filters( 'graphql_allowed_settings_by_group', $allowed_settings_by_group );
	}

	/**
	 * Get all of the $allowed_settings
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry The WPGraphQL TypeRegistry
	 *
	 * @return array<string,array<string,mixed>> $allowed_settings
	 */
	public static function get_allowed_settings( TypeRegistry $type_registry ) {

		/**
		 * Get all registered settings
		 */
		$registered_settings = get_registered_settings();

		/**
		 * Set allowed settings variable.
		 */
		$allowed_settings = [];

		if ( ! empty( $registered_settings ) ) {

			/**
			 * Loop through the $registered_settings and if the setting is allowed in REST or GraphQL
			 * add it to the $allowed_settings array
			 */
			foreach ( $registered_settings as $key => $setting ) {
				if ( ! isset( $setting['type'] ) || ! $type_registry->get_type( $setting['type'] ) ) {
					continue;
				}

				if ( ! isset( $setting['show_in_graphql'] ) ) {
					if ( isset( $setting['show_in_rest'] ) && false !== $setting['show_in_rest'] ) {
						$setting['key']           = $key;
						$allowed_settings[ $key ] = $setting;
					}
				} elseif ( true === $setting['show_in_graphql'] ) {
					$setting['key']           = $key;
					$allowed_settings[ $key ] = $setting;
				}
			}
		}

		/**
		 * Verify that we have the allowed settings
		 */
		$allowed_settings = ! empty( $allowed_settings ) ? $allowed_settings : [];

		/**
		 * Filter the $allowed_settings to allow some to be enabled or disabled from showing in
		 * the GraphQL Schema.
		 *
		 * @param array<string,array<string,mixed>> $allowed_settings
		 */
		return apply_filters( 'graphql_allowed_setting_groups', $allowed_settings );
	}

	/**
	 * We get the node interface and field from the relay library.
	 *
	 * The first method is the way we resolve an ID to its object. The second is the way we resolve
	 * an object that implements node to its type.
	 *
	 * @return mixed[]
	 * @throws \GraphQL\Error\UserError
	 */
	public static function get_node_definition() {
		if ( null === self::$node_definition ) {
			$node_definition = Relay::nodeDefinitions(
			// The ID fetcher definition
				static function ( $global_id, AppContext $context, ResolveInfo $info ) {
					self::resolve_node( $global_id, $context, $info );
				},
				// Type resolver
				static function ( $node ) {
					self::resolve_node_type( $node );
				}
			);

			self::$node_definition = $node_definition;
		}

		return self::$node_definition;
	}

	/**
	 * Given a node, returns the GraphQL Type
	 *
	 * @param mixed $node The node to resolve the type of
	 *
	 * @return string
	 * @throws \GraphQL\Error\UserError If no type is found for the node.
	 */
	public static function resolve_node_type( $node ) {
		$type = null;

		if ( true === is_object( $node ) ) {
			switch ( true ) {
				case $node instanceof Post:
					if ( $node->isRevision ) {
						$parent_post = get_post( $node->parentDatabaseId );
						if ( ! empty( $parent_post ) ) {
							$parent_post_type = $parent_post->post_type;
							/** @var \WP_Post_Type $post_type_object */
							$post_type_object = get_post_type_object( $parent_post_type );
							$type             = $post_type_object->graphql_single_name;
						}
					} else {
						/** @var \WP_Post_Type $post_type_object */
						$post_type_object = get_post_type_object( $node->post_type );
						$type             = $post_type_object->graphql_single_name;
					}
					break;
				case $node instanceof Term:
					/** @var \WP_Taxonomy $tax_object */
					$tax_object = get_taxonomy( $node->taxonomyName );
					$type       = $tax_object->graphql_single_name;
					break;
				case $node instanceof Comment:
					$type = 'Comment';
					break;
				case $node instanceof PostType:
					$type = 'ContentType';
					break;
				case $node instanceof Taxonomy:
					$type = 'Taxonomy';
					break;
				case $node instanceof Theme:
					$type = 'Theme';
					break;
				case $node instanceof User:
					$type = 'User';
					break;
				case $node instanceof Plugin:
					$type = 'Plugin';
					break;
				case $node instanceof CommentAuthor:
					$type = 'CommentAuthor';
					break;
				case $node instanceof Menu:
					$type = 'Menu';
					break;
				case $node instanceof \_WP_Dependency:
					$type = isset( $node->type ) ? $node->type : null;
					break;
				default:
					$type = null;
			}
		}

		/**
		 * Add a filter to allow externally registered node types to return the proper type
		 * based on the node_object that's returned
		 *
		 * @param mixed|object|array $type The type definition the node should resolve to.
		 * @param mixed|object|array $node The $node that is being resolved
		 *
		 * @since 0.0.6
		 */
		$type = apply_filters( 'graphql_resolve_node_type', $type, $node );
		$type = ucfirst( $type );

		/**
		 * If the $type is not properly resolved, throw an exception
		 *
		 * @since 0.0.6
		 */
		if ( empty( $type ) ) {
			throw new UserError( esc_html__( 'No type was found matching the node', 'wp-graphql' ) );
		}

		/**
		 * Return the resolved $type for the $node
		 *
		 * @since 0.0.5
		 */
		return $type;
	}

	/**
	 * Given the ID of a node, this resolves the data
	 *
	 * @param string                               $global_id The Global ID of the node
	 * @param \WPGraphQL\AppContext                $context The Context of the GraphQL Request
	 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo for the GraphQL Request
	 *
	 * @return string|null
	 * @throws \GraphQL\Error\UserError If no ID is passed.
	 */
	public static function resolve_node( $global_id, AppContext $context, ResolveInfo $info ) {
		if ( empty( $global_id ) ) {
			throw new UserError( esc_html__( 'An ID needs to be provided to resolve a node.', 'wp-graphql' ) );
		}

		/**
		 * Convert the encoded ID into an array we can work with
		 *
		 * @since 0.0.4
		 */
		$id_components = Relay::fromGlobalId( $global_id );

		/**
		 * If the $id_components is a proper array with a type and id
		 *
		 * @since 0.0.5
		 */
		if ( is_array( $id_components ) && ! empty( $id_components['id'] ) && ! empty( $id_components['type'] ) ) {

			/**
			 * Get the allowed_post_types and allowed_taxonomies
			 *
			 * @since 0.0.5
			 */

			$loader = $context->get_loader( $id_components['type'] );

			if ( $loader ) {
				return $loader->load_deferred( $id_components['id'] );
			}

			return null;
		} else {
			// translators: %s is the global ID.
			throw new UserError( esc_html( sprintf( __( 'The global ID isn\'t recognized ID: %s', 'wp-graphql' ), $global_id ) ) );
		}
	}

	/**
	 * Returns array of nav menu location names
	 *
	 * @return string[]
	 */
	public static function get_registered_nav_menu_locations() {
		global $_wp_registered_nav_menus;

		return ! empty( $_wp_registered_nav_menus ) && is_array( $_wp_registered_nav_menus ) ? array_keys( $_wp_registered_nav_menus ) : [];
	}

	/**
	 * This resolves a resource, given a URI (the path / permalink to a resource)
	 *
	 * Based largely on the core parse_request function in wp-includes/class-wp.php
	 *
	 * @param string                               $uri     The URI to fetch a resource from
	 * @param \WPGraphQL\AppContext                $context The AppContext passed through the GraphQL Resolve Tree
	 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo passed through the GraphQL Resolve tree
	 *
	 * @return \GraphQL\Deferred
	 * @throws \Exception
	 */
	public static function resolve_resource_by_uri( $uri, $context, $info ) {
		$node_resolver = new NodeResolver( $context );

		return $node_resolver->resolve_uri( $uri );
	}
}


// File: wp-graphql\src\Data\MediaItemMutation.php
<?php

namespace WPGraphQL\Data;

use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Utils\Utils;
use WP_Post_Type;

/**
 * Class MediaItemMutation
 *
 * @package WPGraphQL\Type\MediaItem
 */
class MediaItemMutation {

	/**
	 * This prepares the media item for insertion
	 *
	 * @param array<string,mixed>       $input            The input for the mutation from the GraphQL request
	 * @param \WP_Post_Type             $post_type_object The post_type_object for the mediaItem (attachment)
	 * @param string                    $mutation_name    The name of the mutation being performed (create, update, etc.)
	 * @param array<string,mixed>|false $file             The mediaItem (attachment) file
	 *
	 * @return array<string,mixed>
	 */
	public static function prepare_media_item( array $input, WP_Post_Type $post_type_object, string $mutation_name, $file ) {
		$insert_post_args = [];

		/**
		 * Set the post_type (attachment) for the insert
		 */
		$insert_post_args['post_type'] = $post_type_object->name;

		/**
		 * Prepare the data for inserting the mediaItem
		 * NOTE: These are organized in the same order as: http://v2.wp-api.org/reference/media/#schema-meta
		 */
		if ( ! empty( $input['date'] ) && false !== strtotime( $input['date'] ) ) {
			$insert_post_args['post_date'] = gmdate( 'Y-m-d H:i:s', strtotime( $input['date'] ) );
		}

		if ( ! empty( $input['dateGmt'] ) && false !== strtotime( $input['dateGmt'] ) ) {
			$insert_post_args['post_date_gmt'] = gmdate( 'Y-m-d H:i:s', strtotime( $input['dateGmt'] ) );
		}

		if ( ! empty( $input['slug'] ) ) {
			$insert_post_args['post_name'] = $input['slug'];
		}

		if ( ! empty( $input['status'] ) ) {
			$insert_post_args['post_status'] = $input['status'];
		} else {
			$insert_post_args['post_status'] = 'inherit';
		}

		if ( ! empty( $input['title'] ) ) {
			$insert_post_args['post_title'] = $input['title'];
		} elseif ( ! empty( $file['file'] ) ) {
			$insert_post_args['post_title'] = basename( $file['file'] );
		}

		if ( ! empty( $input['authorId'] ) ) {
			$insert_post_args['post_author'] = Utils::get_database_id_from_id( $input['authorId'] );
		}

		if ( ! empty( $input['commentStatus'] ) ) {
			$insert_post_args['comment_status'] = $input['commentStatus'];
		}

		if ( ! empty( $input['pingStatus'] ) ) {
			$insert_post_args['ping_status'] = $input['pingStatus'];
		}

		if ( ! empty( $input['caption'] ) ) {
			$insert_post_args['post_excerpt'] = $input['caption'];
		}

		if ( ! empty( $input['description'] ) ) {
			$insert_post_args['post_content'] = $input['description'];
		} else {
			$insert_post_args['post_content'] = '';
		}

		if ( ! empty( $file['type'] ) ) {
			$insert_post_args['post_mime_type'] = $file['type'];
		} elseif ( ! empty( $input['fileType'] ) ) {
			$insert_post_args['post_mime_type'] = $input['fileType'];
		}

		if ( ! empty( $input['parentId'] ) ) {
			$insert_post_args['post_parent'] = Utils::get_database_id_from_id( $input['parentId'] );
		}

		/**
		 * Filter the $insert_post_args
		 *
		 * @param array<string,mixed> $insert_post_args The array of $input_post_args that will be passed to wp_insert_attachment
		 * @param array<string,mixed> $input            The data that was entered as input for the mutation
		 * @param \WP_Post_Type       $post_type_object The post_type_object that the mutation is affecting
		 * @param string              $mutation_type    The type of mutation being performed (create, update, delete)
		 */
		$insert_post_args = apply_filters( 'graphql_media_item_insert_post_args', $insert_post_args, $input, $post_type_object, $mutation_name );

		return $insert_post_args;
	}

	/**
	 * This updates additional data related to a mediaItem, such as postmeta.
	 *
	 * @param int                                  $media_item_id    The ID of the media item being mutated
	 * @param array<string,mixed>                  $input            The input on the mutation
	 * @param \WP_Post_Type                        $post_type_object The Post Type Object for the item being mutated
	 * @param string                               $mutation_name    The name of the mutation
	 * @param \WPGraphQL\AppContext                $context The AppContext that is passed down the resolve tree
	 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo that is passed down the resolve tree
	 *
	 * @return void
	 */
	public static function update_additional_media_item_data( int $media_item_id, array $input, WP_Post_Type $post_type_object, string $mutation_name, AppContext $context, ResolveInfo $info ) {

		/**
		 * Update alt text postmeta for the mediaItem
		 */
		if ( ! empty( $input['altText'] ) ) {
			update_post_meta( $media_item_id, '_wp_attachment_image_alt', $input['altText'] );
		}

		/**
		 * Run an action after the additional data has been updated. This is a great spot to hook into to
		 * update additional data related to mediaItems, such as updating additional postmeta,
		 * or sending emails to Kevin. . .whatever you need to do with the mediaItem.
		 *
		 * @param int                                  $media_item_id    The ID of the mediaItem being mutated
		 * @param array<string,mixed>                  $input            The input for the mutation
		 * @param \WP_Post_Type                        $post_type_object The Post Type Object for the type of post being mutated
		 * @param string                               $mutation_name    The name of the mutation (ex: create, update, delete)
		 * @param \WPGraphQL\AppContext                $context The AppContext that is passed down the resolve tree
		 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo that is passed down the resolve tree
		 */
		do_action( 'graphql_media_item_mutation_update_additional_data', $media_item_id, $input, $post_type_object, $mutation_name, $context, $info );
	}
}


// File: wp-graphql\src\Data\NodeResolver.php
<?php

namespace WPGraphQL\Data;

use GraphQL\Deferred;
use GraphQL\Error\UserError;
use WPGraphQL\AppContext;
use WPGraphQL\Router;
use WPGraphQL\Utils\Utils;
use WP_Post;

class NodeResolver {

	/**
	 * @var \WP
	 */
	protected $wp;

	/**
	 * @var \WPGraphQL\AppContext
	 */
	protected $context;

	/**
	 * NodeResolver constructor.
	 *
	 * @param \WPGraphQL\AppContext $context
	 *
	 * @return void
	 */
	public function __construct( AppContext $context ) {
		global $wp;
		$this->wp               = $wp;
		$this->wp->matched_rule = Router::$route . '/?$';
		$this->context          = $context;
	}

	/**
	 * Given a Post object, validates it before returning it.
	 *
	 * @param \WP_Post $post
	 *
	 * @return \WP_Post|null
	 */
	public function validate_post( WP_Post $post ) {
		if ( isset( $this->wp->query_vars['post_type'] ) && ( $post->post_type !== $this->wp->query_vars['post_type'] ) ) {
			return null;
		}

		if ( ! $this->is_valid_node_type( 'ContentNode' ) ) {
			return null;
		}

		/**
		 * Disabling the following code for now, since add_rewrite_uri() would cause a request to direct to a different valid permalink.
		 */
		/* phpcs:disable
		if ( ! isset( $this->wp->query_vars['uri'] ) ) {
			return $post;
		}
		$permalink    = get_permalink( $post );
		$parsed_path  = $permalink ? wp_parse_url( $permalink, PHP_URL_PATH ) : null;
		$trimmed_path = $parsed_path ? rtrim( ltrim( $parsed_path, '/' ), '/' ) : null;
		$uri_path     = rtrim( ltrim( $this->wp->query_vars['uri'], '/' ), '/' );
		if ( $trimmed_path !== $uri_path ) {
			return null;
		}
		phpcs:enable */

		if ( empty( $this->wp->query_vars['uri'] ) ) {
			return $post;
		}

		// if the uri doesn't have the post's urlencoded name or ID in it, we must've found something we didn't expect
		// so we will return null
		if ( false === strpos( $this->wp->query_vars['uri'], (string) $post->ID ) && false === strpos( $this->wp->query_vars['uri'], urldecode( sanitize_title( $post->post_name ) ) ) ) {
			return null;
		}

		return $post;
	}

	/**
	 * Given a Term object, validates it before returning it.
	 *
	 * @param \WP_Term $term
	 *
	 * @return \WP_Term|null
	 */
	public function validate_term( \WP_Term $term ) {
		if ( ! $this->is_valid_node_type( 'TermNode' ) ) {
			return null;
		}

		if ( isset( $this->wp->query_vars['taxonomy'] ) && $term->taxonomy !== $this->wp->query_vars['taxonomy'] ) {
			return null;
		}

		return $term;
	}

	/**
	 * Given the URI of a resource, this method attempts to resolve it and return the
	 * appropriate related object
	 *
	 * @param string                     $uri              The path to be used as an identifier for the resource.
	 * @param array<string,mixed>|string $extra_query_vars Any extra query vars to consider
	 *
	 * @return mixed
	 * @throws \GraphQL\Error\UserError If the query class does not exist.
	 */
	public function resolve_uri( string $uri, $extra_query_vars = '' ) {

		/**
		 * When this filter return anything other than null, it will be used as a resolved node
		 * and the execution will be skipped.
		 *
		 * This is to be used in extensions to resolve their own nodes which might not use
		 * WordPress permalink structure.
		 *
		 * @param mixed|null $node The node, defaults to nothing.
		 * @param string $uri The uri being searched.
		 * @param \WPGraphQL\AppContext $content The app context.
		 * @param \WP $wp WP object.
		 * @param array<string,mixed>|string $extra_query_vars Any extra query vars to consider.
		 */
		$node = apply_filters( 'graphql_pre_resolve_uri', null, $uri, $this->context, $this->wp, $extra_query_vars );

		if ( ! empty( $node ) ) {
			return $node;
		}

		/**
		 * Comments are embedded as a #comment-{$id} in the post's content.
		 *
		 * If the URI is for a comment, we can resolve it now.
		 */
		$comment_id = $this->maybe_parse_comment_uri( $uri );
		if ( null !== $comment_id ) {
			return $this->context->get_loader( 'comment' )->load_deferred( $comment_id );
		}

		/**
		 * Try to resolve the URI with WP_Query.
		 *
		 * This is the way WordPress native permalinks are resolved.
		 *
		 * @see \WP::main()
		 */

		// Parse the URI and sets the $wp->query_vars property.
		$uri = $this->parse_request( $uri, $extra_query_vars );

		/**
		 * If the URI is '/', we can resolve it now.
		 *
		 * We don't rely on $this->parse_request(), since the home page doesn't get a rewrite rule.
		 */
		if ( '/' === $uri ) {
			return $this->resolve_home_page();
		}

		/**
		 * Filter the query class used to resolve the URI. By default this is WP_Query.
		 *
		 * This can be used by Extensions which use a different query class to resolve data.
		 *
		 * @param class-string               $query_class The query class used to resolve the URI. Defaults to WP_Query.
		 * @param ?string                    $uri The uri being searched.
		 * @param \WPGraphQL\AppContext      $content The app context.
		 * @param \WP                        $wp WP object.
		 * @param array<string,mixed>|string $extra_query_vars Any extra query vars to consider.
		 */
		$query_class = apply_filters( 'graphql_resolve_uri_query_class', 'WP_Query', $uri, $this->context, $this->wp, $extra_query_vars );

		if ( ! class_exists( $query_class ) ) {
			throw new UserError(
				esc_html(
					sprintf(
					/* translators: %s: The query class used to resolve the URI */
						__( 'The query class %s used to resolve the URI does not exist.', 'wp-graphql' ),
						$query_class
					)
				)
			);
		}

		$query_vars = $this->wp->query_vars;

		/** @var \WP_Query $query */
		$query = new $query_class( $query_vars );

		// is the query is an archive
		if ( isset( $query->posts[0] ) && $query->posts[0] instanceof WP_Post && ! $query->is_archive() ) {
			$queried_object = $query->posts[0];
		} else {
			$queried_object = $query->get_queried_object();
		}

		/**
		 * When this filter return anything other than null, it will be used as a resolved node
		 * and the execution will be skipped.
		 *
		 * This is to be used in extensions to resolve their own nodes which might not use
		 * WordPress permalink structure.
		 *
		 * It differs from 'graphql_pre_resolve_uri' in that it has been called after the query has been run using the query vars.
		 *
		 * @param mixed|null                                    $node             The node, defaults to nothing.
		 * @param ?string                                       $uri              The uri being searched.
		 * @param \WP_Term|\WP_Post_Type|\WP_Post|\WP_User|null $queried_object   The queried object, if WP_Query returns one.
		 * @param \WP_Query                                     $query            The query object.
		 * @param \WPGraphQL\AppContext                         $content          The app context.
		 * @param \WP                                           $wp               WP object.
		 * @param array<string,mixed>|string                    $extra_query_vars Any extra query vars to consider.
		 */
		$node = apply_filters( 'graphql_resolve_uri', null, $uri, $queried_object, $query, $this->context, $this->wp, $extra_query_vars );

		if ( ! empty( $node ) ) {
			return $node;
		}

		// Resolve Post Objects.
		if ( $queried_object instanceof WP_Post ) {
			// If Page for Posts is set, we need to return the Page archive, not the page.
			if ( $query->is_posts_page ) {
				// If were intentionally querying for a something other than a ContentType, we need to return null instead of the archive.
				if ( ! $this->is_valid_node_type( 'ContentType' ) ) {
					return null;
				}

				$post_type_object = get_post_type_object( 'post' );

				if ( ! $post_type_object ) {
					return null;
				}

				return ! empty( $post_type_object->name ) ? $this->context->get_loader( 'post_type' )->load_deferred( $post_type_object->name ) : null;
			}

			// Validate the post before returning it.
			if ( ! $this->validate_post( $queried_object ) ) {
				return null;
			}

			$post_id = $queried_object->ID;

			$as_preview = false;

			// if asPreview isn't passed explicitly as an argument on a node,
			// attempt to fill the value from the $query_vars passed on the URI as a query param
			if ( is_array( $extra_query_vars ) && array_key_exists( 'asPreview', $extra_query_vars ) && null === $extra_query_vars['asPreview'] && isset( $query_vars['preview'] ) ) {
				// note, the "preview" arg comes through as a string, not a boolean so we need to check 'true' as a string
				$as_preview = 'true' === $query_vars['preview'];
			}

			$as_preview = isset( $extra_query_vars['asPreview'] ) && true === $extra_query_vars['asPreview'] ? true : $as_preview;

			if ( true === $as_preview ) {
				$post_id = Utils::get_post_preview_id( $post_id );
			}

			return ! empty( $post_id ) ? $this->context->get_loader( 'post' )->load_deferred( $post_id ) : null;
		}

		// Resolve Terms.
		if ( $queried_object instanceof \WP_Term ) {
			// Validate the term before returning it.
			if ( ! $this->validate_term( $queried_object ) ) {
				return null;
			}

			return ! empty( $queried_object->term_id ) ? $this->context->get_loader( 'term' )->load_deferred( $queried_object->term_id ) : null;
		}

		// Resolve Post Types.
		if ( $queried_object instanceof \WP_Post_Type ) {

			// Bail if we're explicitly requesting a different GraphQL type.
			if ( ! $this->is_valid_node_type( 'ContentType' ) ) {
				return null;
			}

			return ! empty( $queried_object->name ) ? $this->context->get_loader( 'post_type' )->load_deferred( $queried_object->name ) : null;
		}

		// Resolve Users
		if ( $queried_object instanceof \WP_User ) {
			// Bail if we're explicitly requesting a different GraphQL type.
			if ( ! $this->is_valid_node_type( 'User' ) ) {
				return null;
			}

			return ! empty( $queried_object->ID ) ? $this->context->get_loader( 'user' )->load_deferred( $queried_object->ID ) : null;
		}

		/**
		 * This filter provides a fallback for resolving nodes that were unable to be resolved by NodeResolver::resolve_uri.
		 *
		 * This can be used by Extensions to resolve edge cases that are not handled by the core NodeResolver.
		 *
		 * @param mixed|null                                    $node             The node, defaults to nothing.
		 * @param ?string                                       $uri              The uri being searched.
		 * @param \WP_Term|\WP_Post_Type|\WP_Post|\WP_User|null $queried_object   The queried object, if WP_Query returns one.
		 * @param \WP_Query                                     $query            The query object.
		 * @param \WPGraphQL\AppContext                         $content          The app context.
		 * @param \WP                                           $wp               WP object.
		 * @param array<string,mixed>|string                    $extra_query_vars Any extra query vars to consider.
		 */
		return apply_filters( 'graphql_post_resolve_uri', $node, $uri, $queried_object, $query, $this->context, $this->wp, $extra_query_vars );
	}

	/**
	 * Parses a URL to produce an array of query variables.
	 *
	 * Mimics WP::parse_request()
	 *
	 * @param string                     $uri
	 * @param array<string,mixed>|string $extra_query_vars
	 *
	 * @return string|null The parsed uri.
	 */
	public function parse_request( string $uri, $extra_query_vars = '' ) {
		// Attempt to parse the provided URI.
		$parsed_url = wp_parse_url( $uri );

		if ( false === $parsed_url ) {
			graphql_debug(
				__( 'Cannot parse provided URI', 'wp-graphql' ),
				[
					'uri' => $uri,
				]
			);
			return null;
		}

		// Bail if external URI.
		if ( isset( $parsed_url['host'] ) ) {
			$site_url = wp_parse_url( site_url() );
			$home_url = wp_parse_url( home_url() );

			/**
			 * @var array<string,mixed> $home_url
			 * @var array<string,mixed> $site_url
			 */
			if ( ! in_array(
				$parsed_url['host'],
				[
					$site_url['host'],
					$home_url['host'],
				],
				true
			) ) {
				graphql_debug(
					__( 'Cannot return a resource for an external URI', 'wp-graphql' ),
					[
						'uri' => $uri,
					]
				);
				return null;
			}
		}

		if ( isset( $parsed_url['query'] ) && ( empty( $parsed_url['path'] ) || '/' === $parsed_url['path'] ) ) {
			$uri = $parsed_url['query'];
		} elseif ( isset( $parsed_url['path'] ) ) {
			$uri = $parsed_url['path'];
		}

		/**
		 * Follows pattern from WP::parse_request()
		 *
		 * @see https://github.com/WordPress/wordpress-develop/blob/6.0.2/src/wp-includes/class-wp.php#L135
		 */
		global $wp_rewrite;

		$this->wp->query_vars = [];
		$post_type_query_vars = [];

		if ( is_array( $extra_query_vars ) ) {
			$this->wp->query_vars = &$extra_query_vars;
		} elseif ( ! empty( $extra_query_vars ) ) {
			parse_str( $extra_query_vars, $this->wp->extra_query_vars );
		}

		// Set uri to Query vars.
		$this->wp->query_vars['uri'] = $uri;

		// Process PATH_INFO, REQUEST_URI, and 404 for permalinks.

		// Fetch the rewrite rules.
		$rewrite = $wp_rewrite->wp_rewrite_rules();
		if ( ! empty( $rewrite ) ) {
			// If we match a rewrite rule, this will be cleared.
			$error                   = '404';
			$this->wp->did_permalink = true;

			$pathinfo         = ! empty( $uri ) ? $uri : '';
			list( $pathinfo ) = explode( '?', $pathinfo );
			$pathinfo         = str_replace( '%', '%25', $pathinfo );

			list( $req_uri ) = explode( '?', $pathinfo );
			$home_path       = parse_url( home_url(), PHP_URL_PATH ); // phpcs:ignore WordPress.WP.AlternativeFunctions.parse_url_parse_url
			$home_path_regex = '';
			if ( is_string( $home_path ) && '' !== $home_path ) {
				$home_path       = trim( $home_path, '/' );
				$home_path_regex = sprintf( '|^%s|i', preg_quote( $home_path, '|' ) );
			}

			/*
			 * Trim path info from the end and the leading home path from the front.
			 * For path info requests, this leaves us with the requesting filename, if any.
			 * For 404 requests, this leaves us with the requested permalink.
			 */
			$query    = '';
			$matches  = null;
			$req_uri  = str_replace( $pathinfo, '', $req_uri );
			$req_uri  = trim( $req_uri, '/' );
			$pathinfo = trim( $pathinfo, '/' );

			if ( ! empty( $home_path_regex ) ) {
				$req_uri  = preg_replace( $home_path_regex, '', $req_uri );
				$req_uri  = trim( $req_uri, '/' ); // @phpstan-ignore-line
				$pathinfo = preg_replace( $home_path_regex, '', $pathinfo );
				$pathinfo = trim( $pathinfo, '/' ); // @phpstan-ignore-line
			}

			// The requested permalink is in $pathinfo for path info requests and
			// $req_uri for other requests.
			if ( ! empty( $pathinfo ) && ! preg_match( '|^.*' . $wp_rewrite->index . '$|', $pathinfo ) ) {
				$requested_path = $pathinfo;
			} else {
				// If the request uri is the index, blank it out so that we don't try to match it against a rule.
				if ( $req_uri === $wp_rewrite->index ) {
					$req_uri = '';
				}
				$requested_path = $req_uri;
			}
			$requested_file = $req_uri;

			$this->wp->request = $requested_path;

			// Look for matches.
			$request_match = $requested_path;
			if ( empty( $request_match ) ) {
				// An empty request could only match against ^$ regex
				if ( isset( $rewrite['$'] ) ) {
					$this->wp->matched_rule = '$';
					$query                  = $rewrite['$'];
					$matches                = [ '' ];
				}
			} else {
				foreach ( (array) $rewrite as $match => $query ) {
					// If the requested file is the anchor of the match, prepend it to the path info.
					if ( ! empty( $requested_file ) && strpos( $match, $requested_file ) === 0 && $requested_file !== $requested_path ) {
						$request_match = $requested_file . '/' . $requested_path;
					}

					if (
						preg_match( "#^$match#", $request_match, $matches ) ||
						preg_match( "#^$match#", urldecode( $request_match ), $matches )
					) {
						if ( $wp_rewrite->use_verbose_page_rules && preg_match( '/pagename=\$matches\[([0-9]+)\]/', $query, $varmatch ) ) {
							// This is a verbose page match, let's check to be sure about it.
							$page = get_page_by_path( $matches[ $varmatch[1] ] ); // phpcs:ignore WordPressVIPMinimum.Functions.RestrictedFunctions.get_page_by_path_get_page_by_path
							if ( ! $page ) {
								continue;
							}

							$post_status_obj = get_post_status_object( $page->post_status );
							if (
								( ! isset( $post_status_obj->public ) || ! $post_status_obj->public ) &&
								( ! isset( $post_status_obj->protected ) || ! $post_status_obj->protected ) &&
								( ! isset( $post_status_obj->private ) || ! $post_status_obj->private ) &&
								( ! isset( $post_status_obj->exclude_from_search ) || $post_status_obj->exclude_from_search )
							) {
								continue;
							}
						}

						// Got a match.
						$this->wp->matched_rule = $match;
						break;
					}
				}
			}

			if ( ! empty( $this->wp->matched_rule ) ) {
				// Trim the query of everything up to the '?'.
				$query = preg_replace( '!^.+\?!', '', $query );

				// Substitute the substring matches into the query.
				$query = addslashes( \WP_MatchesMapRegex::apply( $query, $matches ) ); // @phpstan-ignore-line

				$this->wp->matched_query = $query;

				// Parse the query.
				parse_str( $query, $perma_query_vars );

				// If we're processing a 404 request, clear the error var since we found something.
				// @phpstan-ignore-next-line
				if ( '404' == $error ) { // phpcs:ignore Universal.Operators.StrictComparisons.LooseEqual
					unset( $error );
				}
			}
		}

		/**
		 * Filters the query variables allowed before processing.
		 *
		 * Allows (publicly allowed) query vars to be added, removed, or changed prior
		 * to executing the query. Needed to allow custom rewrite rules using your own arguments
		 * to work, or any other custom query variables you want to be publicly available.
		 *
		 * @since 1.5.0
		 *
		 * @param string[] $public_query_vars The array of allowed query variable names.
		 */
		$this->wp->public_query_vars = apply_filters( 'query_vars', $this->wp->public_query_vars );

		foreach ( get_post_types( [ 'show_in_graphql' => true ], 'objects' )  as $post_type => $t ) {
			/** @var \WP_Post_Type $t */
			if ( $t->query_var ) {
				$post_type_query_vars[ $t->query_var ] = $post_type;
			}
		}

		foreach ( $this->wp->public_query_vars as $wpvar ) {
			$parsed_query = [];
			if ( isset( $parsed_url['query'] ) ) {
				parse_str( $parsed_url['query'], $parsed_query );
			}

			if ( isset( $this->wp->extra_query_vars[ $wpvar ] ) ) {
				$this->wp->query_vars[ $wpvar ] = $this->wp->extra_query_vars[ $wpvar ];
			} elseif ( isset( $_GET[ $wpvar ] ) ) { // phpcs:ignore WordPress.Security.NonceVerification
				$this->wp->query_vars[ $wpvar ] = $_GET[ $wpvar ]; // phpcs:ignore WordPress.Security.ValidatedSanitizedInput.MissingUnslash,WordPress.Security.ValidatedSanitizedInput.InputNotSanitized,WordPress.Security.NonceVerification.Recommended
			} elseif ( isset( $perma_query_vars[ $wpvar ] ) ) {
				$this->wp->query_vars[ $wpvar ] = $perma_query_vars[ $wpvar ];
			} elseif ( isset( $parsed_query[ $wpvar ] ) ) {
				$this->wp->query_vars[ $wpvar ] = $parsed_query[ $wpvar ];
			}

			if ( ! empty( $this->wp->query_vars[ $wpvar ] ) ) {
				if ( ! is_array( $this->wp->query_vars[ $wpvar ] ) ) {
					$this->wp->query_vars[ $wpvar ] = (string) $this->wp->query_vars[ $wpvar ];
				} else {
					foreach ( $this->wp->query_vars[ $wpvar ] as $vkey => $v ) {
						if ( is_scalar( $v ) ) {
							$this->wp->query_vars[ $wpvar ][ $vkey ] = (string) $v;
						}
					}
				}

				if ( isset( $post_type_query_vars[ $wpvar ] ) ) {
					$this->wp->query_vars['post_type'] = $post_type_query_vars[ $wpvar ];
					$this->wp->query_vars['name']      = $this->wp->query_vars[ $wpvar ];
				}
			}
		}

		// Convert urldecoded spaces back into '+'.
		foreach ( get_taxonomies( [ 'show_in_graphql' => true ], 'objects' ) as $t ) {
			if ( $t->query_var && isset( $this->wp->query_vars[ $t->query_var ] ) ) {
				$this->wp->query_vars[ $t->query_var ] = str_replace( ' ', '+', $this->wp->query_vars[ $t->query_var ] );
			}
		}

		// Limit publicly queried post_types to those that are publicly_queryable
		if ( isset( $this->wp->query_vars['post_type'] ) ) {
			$queryable_post_types = get_post_types( [ 'show_in_graphql' => true ] );
			if ( ! is_array( $this->wp->query_vars['post_type'] ) ) {
				if ( ! in_array( $this->wp->query_vars['post_type'], $queryable_post_types, true ) ) {
					unset( $this->wp->query_vars['post_type'] );
				}
			} else {
				$this->wp->query_vars['post_type'] = array_intersect( $this->wp->query_vars['post_type'], $queryable_post_types );
			}
		}

		// Resolve conflicts between posts with numeric slugs and date archive queries.
		$this->wp->query_vars = wp_resolve_numeric_slug_conflicts( $this->wp->query_vars );

		foreach ( (array) $this->wp->private_query_vars as $var ) {
			if ( isset( $this->wp->extra_query_vars[ $var ] ) ) {
				$this->wp->query_vars[ $var ] = $this->wp->extra_query_vars[ $var ];
			}
		}

		if ( isset( $error ) ) {
			$this->wp->query_vars['error'] = $error;
		}

		// if the parsed url is ONLY a query, unset the pagename query var
		if ( isset( $this->wp->query_vars['pagename'], $parsed_url['query'] ) && ( $parsed_url['query'] === $this->wp->query_vars['pagename'] ) ) {
			unset( $this->wp->query_vars['pagename'] );
		}

		/**
		 * Filters the array of parsed query variables.
		 *
		 * @param array<string,mixed> $query_vars The array of requested query variables.
		 *
		 * @since 2.1.0
		 */
		$this->wp->query_vars = apply_filters( 'request', $this->wp->query_vars );

		// We don't need the GraphQL args anymore.
		unset( $this->wp->query_vars['graphql'] );

		do_action_ref_array( 'parse_request', [ &$this->wp ] );

		return $uri;
	}

	/**
	 * Checks if the node type is set in the query vars and, if so, whether it matches the node type.
	 *
	 * @param string $node_type The node type to check.
	 */
	protected function is_valid_node_type( string $node_type ): bool {
		return ! isset( $this->wp->query_vars['nodeType'] ) || $this->wp->query_vars['nodeType'] === $node_type;
	}

	/**
	 * Resolves the home page.
	 *
	 * If the homepage is a static page, return the page, otherwise we return the Posts `ContentType`.
	 *
	 * @todo Replace `ContentType` with an `Archive` type.
	 */
	protected function resolve_home_page(): ?Deferred {
		$page_id       = get_option( 'page_on_front', 0 );
		$show_on_front = get_option( 'show_on_front', 'posts' );

		// If the homepage is a static page, return the page.
		if ( 'page' === $show_on_front && ! empty( $page_id ) ) {
			$page = get_post( $page_id );

			if ( empty( $page ) ) {
				return null;
			}

			return $this->context->get_loader( 'post' )->load_deferred( $page->ID );
		}

		// If the homepage is set to latest posts, we need to make sure not to resolve it when when for other types.
		if ( ! $this->is_valid_node_type( 'ContentType' ) ) {
			return null;
		}

		// We dont have an 'Archive' type, so we resolve to the ContentType.
		return $this->context->get_loader( 'post_type' )->load_deferred( 'post' );
	}

	/**
	 * Checks if the URI is a comment URI and, if so, returns the comment ID.
	 *
	 * @param string $uri The URI to check.
	 */
	protected function maybe_parse_comment_uri( string $uri ): ?int {
		$comment_match = [];
		// look for a #comment-{$id} anywhere in the uri.
		if ( preg_match( '/#comment-(\d+)/', $uri, $comment_match ) ) {
			$comment_id = isset( $comment_match[1] ) ? absint( $comment_match[1] ) : null;

			return ! empty( $comment_id ) ? $comment_id : null;
		}

		return null;
	}
}


// File: wp-graphql\src\Data\PostObjectMutation.php
<?php

namespace WPGraphQL\Data;

use GraphQL\Type\Definition\ResolveInfo;
use GraphQLRelay\Relay;
use WPGraphQL\AppContext;
use WPGraphQL\Utils\Utils;
use WP_Post_Type;

/**
 * Class PostObjectMutation
 *
 * @package WPGraphQL\Type\PostObject
 */
class PostObjectMutation {

	/**
	 * This handles inserting the post object
	 *
	 * @param array<string,mixed> $input            The input for the mutation
	 * @param \WP_Post_Type       $post_type_object The post_type_object for the type of post being mutated
	 * @param string              $mutation_name    The name of the mutation being performed
	 *
	 * @return array<string,mixed>
	 * @throws \Exception
	 */
	public static function prepare_post_object( $input, $post_type_object, $mutation_name ) {
		$insert_post_args = [];

		/**
		 * Set the post_type for the insert
		 */
		$insert_post_args['post_type'] = $post_type_object->name;

		/**
		 * Prepare the data for inserting the post
		 * NOTE: These are organized in the same order as: https://developer.wordpress.org/reference/functions/wp_insert_post/
		 */
		if ( ! empty( $input['authorId'] ) ) {
			$insert_post_args['post_author'] = Utils::get_database_id_from_id( $input['authorId'] );
		}

		if ( ! empty( $input['date'] ) && false !== strtotime( $input['date'] ) ) {
			$insert_post_args['post_date'] = gmdate( 'Y-m-d H:i:s', strtotime( $input['date'] ) );
		}

		if ( ! empty( $input['content'] ) ) {
			$insert_post_args['post_content'] = $input['content'];
		}

		if ( ! empty( $input['title'] ) ) {
			$insert_post_args['post_title'] = $input['title'];
		}

		if ( ! empty( $input['excerpt'] ) ) {
			$insert_post_args['post_excerpt'] = $input['excerpt'];
		}

		if ( ! empty( $input['status'] ) ) {
			$insert_post_args['post_status'] = $input['status'];
		}

		if ( ! empty( $input['commentStatus'] ) ) {
			$insert_post_args['comment_status'] = $input['commentStatus'];
		}

		if ( ! empty( $input['pingStatus'] ) ) {
			$insert_post_args['ping_status'] = $input['pingStatus'];
		}

		if ( ! empty( $input['password'] ) ) {
			$insert_post_args['post_password'] = $input['password'];
		}

		if ( ! empty( $input['slug'] ) ) {
			$insert_post_args['post_name'] = $input['slug'];
		}

		if ( ! empty( $input['toPing'] ) ) {
			$insert_post_args['to_ping'] = $input['toPing'];
		}

		if ( ! empty( $input['pinged'] ) ) {
			$insert_post_args['pinged'] = $input['pinged'];
		}

		if ( ! empty( $input['parentId'] ) ) {
			$insert_post_args['post_parent'] = Utils::get_database_id_from_id( $input['parentId'] );
		}

		if ( ! empty( $input['menuOrder'] ) ) {
			$insert_post_args['menu_order'] = $input['menuOrder'];
		}

		if ( ! empty( $input['mimeType'] ) ) {
			$insert_post_args['post_mime_type'] = $input['mimeType'];
		}

		if ( ! empty( $input['commentCount'] ) ) {
			$insert_post_args['comment_count'] = $input['commentCount'];
		}

		/**
		 * Filter the $insert_post_args
		 *
		 * @param array<string,mixed> $insert_post_args The array of $input_post_args that will be passed to wp_insert_post
		 * @param array<string,mixed> $input            The data that was entered as input for the mutation
		 * @param \WP_Post_Type       $post_type_object The post_type_object that the mutation is affecting
		 * @param string              $mutation_type    The type of mutation being performed (create, edit, etc)
		 */
		$insert_post_args = apply_filters( 'graphql_post_object_insert_post_args', $insert_post_args, $input, $post_type_object, $mutation_name );

		/**
		 * Return the $args
		 */
		return $insert_post_args;
	}

	/**
	 * This updates additional data related to a post object, such as postmeta, term relationships,
	 * etc.
	 *
	 * @param int                                  $post_id              The ID of the postObject being mutated
	 * @param array<string,mixed>                  $input                The input for the mutation
	 * @param \WP_Post_Type                        $post_type_object     The Post Type Object for the type of post being mutated
	 * @param string                               $mutation_name        The name of the mutation (ex: create, update, delete)
	 * @param \WPGraphQL\AppContext                $context              The AppContext passed down to all resolvers
	 * @param \GraphQL\Type\Definition\ResolveInfo $info                 The ResolveInfo passed down to all resolvers
	 * @param string                               $default_post_status  The default status posts should use if an intended status wasn't set
	 * @param string                               $intended_post_status The intended post_status the post should have according to the mutation input
	 *
	 * @return void
	 */
	public static function update_additional_post_object_data( $post_id, $input, $post_type_object, $mutation_name, AppContext $context, ResolveInfo $info, $default_post_status = null, $intended_post_status = null ) {

		/**
		 * Sets the post lock
		 *
		 * @param bool                                 $is_locked            Whether the post is locked
		 * @param int                                  $post_id              The ID of the postObject being mutated
		 * @param array<string,mixed>                  $input                The input for the mutation
		 * @param \WP_Post_Type                        $post_type_object The Post Type Object for the type of post being mutated
		 * @param string                               $mutation_name        The name of the mutation (ex: create, update, delete)
		 * @param \WPGraphQL\AppContext                $context The AppContext passed down to all resolvers
		 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo passed down to all resolvers
		 * @param ?string                              $intended_post_status The intended post_status the post should have according to the mutation input
		 * @param ?string                              $default_post_status  The default status posts should use if an intended status wasn't set
		 */
		if ( true === apply_filters( 'graphql_post_object_mutation_set_edit_lock', true, $post_id, $input, $post_type_object, $mutation_name, $context, $info, $default_post_status, $intended_post_status ) ) {
			/**
			 * Set the post_lock for the $new_post_id
			 */
			self::set_edit_lock( $post_id );
		}

		/**
		 * Update the _edit_last field
		 */
		update_post_meta( $post_id, '_edit_last', get_current_user_id() );

		/**
		 * Update the postmeta fields
		 */
		if ( ! empty( $input['desiredSlug'] ) ) {
			update_post_meta( $post_id, '_wp_desired_post_slug', $input['desiredSlug'] );
		}

		/**
		 * Set the object terms
		 *
		 * @param int                 $post_id          The ID of the postObject being mutated
		 * @param array<string,mixed> $input            The input for the mutation
		 * @param \WP_Post_Type       $post_type_object The Post Type Object for the type of post being mutated
		 * @param string              $mutation_name    The name of the mutation (ex: create, update, delete)
		 */
		self::set_object_terms( $post_id, $input, $post_type_object, $mutation_name );

		/**
		 * Run an action after the additional data has been updated. This is a great spot to hook into to
		 * update additional data related to postObjects, such as setting relationships, updating additional postmeta,
		 * or sending emails to Kevin. . .whatever you need to do with the postObject.
		 *
		 * @param int                                  $post_id              The ID of the postObject being mutated
		 * @param array<string,mixed>                  $input                The input for the mutation
		 * @param \WP_Post_Type                        $post_type_object     The Post Type Object for the type of post being mutated
		 * @param string                               $mutation_name        The name of the mutation (ex: create, update, delete)
		 * @param \WPGraphQL\AppContext                $context              The AppContext passed down to all resolvers
		 * @param \GraphQL\Type\Definition\ResolveInfo $info                 The ResolveInfo passed down to all resolvers
		 * @param ?string                              $intended_post_status The intended post_status the post should have according to the mutation input
		 * @param ?string                              $default_post_status  The default status posts should use if an intended status wasn't set
		 */
		do_action( 'graphql_post_object_mutation_update_additional_data', $post_id, $input, $post_type_object, $mutation_name, $context, $info, $default_post_status, $intended_post_status );

		/**
		 * Sets the post lock
		 *
		 * @param bool                                 $is_locked            Whether the post is locked.
		 * @param int                                  $post_id              The ID of the postObject being mutated
		 * @param array<string,mixed>                  $input                The input for the mutation
		 * @param \WP_Post_Type                        $post_type_object     The Post Type Object for the type of post being mutated
		 * @param string                               $mutation_name        The name of the mutation (ex: create, update, delete)
		 * @param \WPGraphQL\AppContext                $context              The AppContext passed down to all resolvers
		 * @param \GraphQL\Type\Definition\ResolveInfo $info                 The ResolveInfo passed down to all resolvers
		 * @param ?string                              $intended_post_status The intended post_status the post should have according to the mutation input
		 * @param ?string                              $default_post_status  The default status posts should use if an intended status wasn't set
		 *
		 * @return bool
		 */
		if ( true === apply_filters( 'graphql_post_object_mutation_set_edit_lock', true, $post_id, $input, $post_type_object, $mutation_name, $context, $info, $default_post_status, $intended_post_status ) ) {
			/**
			 * Set the post_lock for the $new_post_id
			 */
			self::remove_edit_lock( $post_id );
		}
	}

	/**
	 * Given a $post_id and $input from the mutation, check to see if any term associations are
	 * being made, and properly set the relationships
	 *
	 * @param int                 $post_id           The ID of the postObject being mutated
	 * @param array<string,mixed> $input             The input for the mutation
	 * @param \WP_Post_Type       $post_type_object The Post Type Object for the type of post being mutated
	 * @param string              $mutation_name     The name of the mutation (ex: create, update, delete)
	 *
	 * @return void
	 */
	protected static function set_object_terms( int $post_id, array $input, WP_Post_Type $post_type_object, string $mutation_name ) {

		/**
		 * Fire an action before setting object terms during a GraphQL Post Object Mutation.
		 *
		 * One example use for this hook would be to create terms from the input that may not exist yet, so that they can be set as a relation below.
		 *
		 * @param int                 $post_id          The ID of the postObject being mutated
		 * @param array<string,mixed> $input            The input for the mutation
		 * @param \WP_Post_Type       $post_type_object The Post Type Object for the type of post being mutated
		 * @param string              $mutation_name    The name of the mutation (ex: create, update, delete)
		 */
		do_action( 'graphql_post_object_mutation_set_object_terms', $post_id, $input, $post_type_object, $mutation_name );

		/**
		 * Get the allowed taxonomies and iterate through them to find the term inputs to use for setting relationships
		 *
		 * @var \WP_Taxonomy[] $allowed_taxonomies
		 */
		$allowed_taxonomies = \WPGraphQL::get_allowed_taxonomies( 'objects' );

		foreach ( $allowed_taxonomies as $tax_object ) {

			/**
			 * If the taxonomy is in the array of taxonomies registered to the post_type
			 */
			if ( in_array( $tax_object->name, get_object_taxonomies( $post_type_object->name ), true ) ) {

				/**
				 * If there is input for the taxonomy, process it
				 */
				if ( isset( $input[ lcfirst( $tax_object->graphql_plural_name ) ] ) ) {
					$term_input = $input[ lcfirst( $tax_object->graphql_plural_name ) ];

					/**
					 * Default append to true, but allow input to set it to false.
					 */
					$append = ! isset( $term_input['append'] ) || false !== $term_input['append'];

					/**
					 * Start an array of terms to connect
					 */
					$terms_to_connect = [];

					/**
					 * Filter whether to allow terms to be created during a post mutation.
					 *
					 * If a post mutation includes term input for a term that does not already exist,
					 * this will allow terms to be created in order to connect the term to the post object,
					 * but if filtered to false, this will prevent the term that doesn't already exist
					 * from being created during the mutation of the post.
					 *
					 * @param bool         $allow_term_creation Whether new terms should be created during the post object mutation
					 * @param \WP_Taxonomy $tax_object          The Taxonomy object for the term being added to the Post Object
					 */
					$allow_term_creation = apply_filters( 'graphql_post_object_mutations_allow_term_creation', true, $tax_object );

					/**
					 * If there are nodes in the term_input
					 */
					if ( ! empty( $term_input['nodes'] ) && is_array( $term_input['nodes'] ) ) {
						foreach ( $term_input['nodes'] as $node ) {
							$term_exists = false;

							/**
							 * Handle the input for ID first.
							 */
							if ( ! empty( $node['id'] ) ) {
								if ( ! absint( $node['id'] ) ) {
									$id_parts = Relay::fromGlobalId( $node['id'] );

									if ( ! empty( $id_parts['id'] ) ) {
										$term_exists = get_term_by( 'id', absint( $id_parts['id'] ), $tax_object->name );
										if ( isset( $term_exists->term_id ) ) {
											$terms_to_connect[] = $term_exists->term_id;
										}
									}
								} else {
									$term_exists = get_term_by( 'id', absint( $node['id'] ), $tax_object->name );
									if ( isset( $term_exists->term_id ) ) {
										$terms_to_connect[] = $term_exists->term_id;
									}
								}

								/**
								 * Next, handle the input for slug if there wasn't an ID input
								 */
							} elseif ( ! empty( $node['slug'] ) ) {
								$sanitized_slug = sanitize_text_field( $node['slug'] );
								$term_exists    = get_term_by( 'slug', $sanitized_slug, $tax_object->name );
								if ( isset( $term_exists->term_id ) ) {
									$terms_to_connect[] = $term_exists->term_id;
								}
								/**
								 * If the input for the term isn't an existing term, check to make sure
								 * we're allowed to create new terms during a Post Object mutation
								 */
							}

							/**
							 * If no term exists so far, and terms are set to be allowed to be created
							 * during a post object mutation, create the term to connect based on the
							 * input
							 */
							if ( ! $term_exists && true === $allow_term_creation ) {

								/**
								 * If the current user cannot edit terms, don't create terms to connect
								 */
								if ( ! isset( $tax_object->cap->edit_terms ) || ! current_user_can( $tax_object->cap->edit_terms ) ) {
									return;
								}

								$created_term = self::create_term_to_connect( $node, $tax_object->name );

								if ( ! empty( $created_term ) ) {
									$terms_to_connect[] = $created_term;
								}
							}
						}
					}

					/**
					 * If the current user cannot edit terms, don't create terms to connect
					 */
					if ( ! isset( $tax_object->cap->assign_terms ) || ! current_user_can( $tax_object->cap->assign_terms ) ) {
						return;
					}

					wp_set_object_terms( $post_id, $terms_to_connect, $tax_object->name, $append );
				}
			}
		}
	}

	/**
	 * Given an array of Term properties (slug, name, description, etc), create the term and return
	 * a term_id
	 *
	 * @param array<string,mixed> $node     The node input for the term
	 * @param string              $taxonomy The taxonomy the term input is for
	 *
	 * @return int $term_id The ID of the created term. 0 if no term was created.
	 */
	protected static function create_term_to_connect( $node, $taxonomy ) {
		$created_term   = [];
		$term_to_create = [];
		$term_args      = [];

		if ( ! empty( $node['name'] ) ) {
			$term_to_create['name'] = sanitize_text_field( $node['name'] );
		} elseif ( ! empty( $node['slug'] ) ) {
			$term_to_create['name'] = sanitize_text_field( $node['slug'] );
		}

		if ( ! empty( $node['slug'] ) ) {
			$term_args['slug'] = sanitize_text_field( $node['slug'] );
		}

		if ( ! empty( $node['description'] ) ) {
			$term_args['description'] = sanitize_text_field( $node['description'] );
		}

		/**
		 * @todo: consider supporting "parent" input in $term_args
		 */

		if ( isset( $term_to_create['name'] ) && ! empty( $term_to_create['name'] ) ) {
			$created_term = wp_insert_term( $term_to_create['name'], $taxonomy, $term_args );
		}

		if ( is_wp_error( $created_term ) ) {
			if ( isset( $created_term->error_data['term_exists'] ) ) {
				return $created_term->error_data['term_exists'];
			}

			return 0;
		}

		/**
		 * Return the created term, or 0
		 */
		return isset( $created_term['term_id'] ) ? absint( $created_term['term_id'] ) : 0;
	}

	/**
	 * This is a copy of the wp_set_post_lock function that exists in WordPress core, but is not
	 * accessible because that part of WordPress is never loaded for WPGraphQL executions
	 *
	 * Mark the post as currently being edited by the current user
	 *
	 * @param int $post_id ID of the post being edited.
	 *
	 * @return int[]|false Array of the lock time and user ID. False if the post does not exist, or
	 *                     there is no current user.
	 */
	public static function set_edit_lock( $post_id ) {
		$post    = get_post( $post_id );
		$user_id = get_current_user_id();

		if ( empty( $post ) ) {
			return false;
		}

		if ( 0 === $user_id ) {
			return false;
		}

		$now  = time();
		$lock = "$now:$user_id";
		update_post_meta( $post->ID, '_edit_lock', $lock );

		return [ $now, $user_id ];
	}

	/**
	 * Remove the edit lock for a post
	 *
	 * @param int $post_id ID of the post to delete the lock for
	 *
	 * @return bool
	 */
	public static function remove_edit_lock( int $post_id ) {
		$post = get_post( $post_id );

		if ( empty( $post ) ) {
			return false;
		}

		return delete_post_meta( $post->ID, '_edit_lock' );
	}

	/**
	 * Check the edit lock for a post
	 *
	 * @param false|int           $post_id ID of the post to delete the lock for
	 * @param array<string,mixed> $input             The input for the mutation
	 *
	 * @return false|int Return false if no lock or the user_id of the owner of the lock
	 */
	public static function check_edit_lock( $post_id, array $input ) {
		if ( false === $post_id ) {
			return false;
		}

		// If override the edit lock is set, return early
		if ( isset( $input['ignoreEditLock'] ) && true === $input['ignoreEditLock'] ) {
			return false;
		}

		require_once ABSPATH . 'wp-admin/includes/post.php';

		if ( function_exists( 'wp_check_post_lock' ) ) {
			return wp_check_post_lock( $post_id );
		}

		return false;
	}
}


// File: wp-graphql\src\Data\TermObjectMutation.php
<?php

namespace WPGraphQL\Data;

use GraphQL\Error\UserError;
use WPGraphQL\Utils\Utils;
use WP_Taxonomy;

class TermObjectMutation {

	/**
	 * This prepares the object to be mutated - ensures data is safe to be saved,
	 * and mapped from input args to WordPress $args
	 *
	 * @throws \GraphQL\Error\UserError User error for invalid term.
	 *
	 * @param array<string,mixed> $input         The input from the GraphQL Request
	 * @param \WP_Taxonomy        $taxonomy The Taxonomy object for the type of term being mutated
	 * @param string              $mutation_name The name of the mutation (create, update, etc)
	 *
	 * @return array<string,mixed>
	 */
	public static function prepare_object( array $input, WP_Taxonomy $taxonomy, string $mutation_name ) {
		$insert_args = [];

		/**
		 * Set the taxonomy for insert
		 */
		$insert_args['taxonomy'] = $taxonomy->name;

		/**
		 * Prepare the data for inserting the term
		 */
		if ( ! empty( $input['aliasOf'] ) ) {
			$insert_args['alias_of'] = $input['aliasOf'];
		}

		if ( ! empty( $input['name'] ) ) {
			$insert_args['name'] = $input['name'];
		}

		if ( ! empty( $input['description'] ) ) {
			$insert_args['description'] = $input['description'];
		}

		if ( ! empty( $input['slug'] ) ) {
			$insert_args['slug'] = $input['slug'];
		}

		/**
		 * If the parentId argument was entered, we need to validate that it's actually a legit term that can
		 * be set as a parent
		 */
		if ( ! empty( $input['parentId'] ) ) {

			/**
			 * Convert parent ID to WordPress ID
			 */
			$parent_id = Utils::get_database_id_from_id( $input['parentId'] );

			if ( empty( $parent_id ) ) {
				throw new UserError( esc_html__( 'The parent ID is not a valid ID', 'wp-graphql' ) );
			}

			/**
			 * Ensure there's actually a parent term to be associated with
			 */
			$parent_term = get_term( absint( $parent_id ), $taxonomy->name );

			if ( ! $parent_term instanceof \WP_Term ) {
				throw new UserError( esc_html__( 'The parent does not exist', 'wp-graphql' ) );
			}

			$insert_args['parent'] = $parent_term->term_id;
		}

		/**
		 * Filter the $insert_args
		 *
		 * @param array<string,mixed> $insert_args   The array of input args that will be passed to the functions that insert terms
		 * @param array<string,mixed> $input         The data that was entered as input for the mutation
		 * @param \WP_Taxonomy        $taxonomy      The taxonomy object of the term being mutated
		 * @param string              $mutation_name The name of the mutation being performed (create, edit, etc)
		 */
		return apply_filters( 'graphql_term_object_insert_term_args', $insert_args, $input, $taxonomy, $mutation_name );
	}
}


// File: wp-graphql\src\Data\UserMutation.php
<?php

namespace WPGraphQL\Data;

use Exception;
use GraphQL\Error\UserError;
use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;

/**
 * Class UserMutation
 *
 * @package WPGraphQL\Type\User\Mutation
 */
class UserMutation {

	/**
	 * Stores the input fields static definition
	 *
	 * @var array<string,array<string,mixed>>
	 */
	private static $input_fields = [];

	/**
	 * Defines the accepted input arguments
	 *
	 * @return array<string,array<string,mixed>>|null
	 */
	public static function input_fields() {
		if ( empty( self::$input_fields ) ) {
			$input_fields = [
				'password'    => [
					'type'        => 'String',
					'description' => __( 'A string that contains the plain text password for the user.', 'wp-graphql' ),
				],
				'nicename'    => [
					'type'        => 'String',
					'description' => __( 'A string that contains a URL-friendly name for the user. The default is the user\'s username.', 'wp-graphql' ),
				],
				'websiteUrl'  => [
					'type'        => 'String',
					'description' => __( 'A string containing the user\'s URL for the user\'s web site.', 'wp-graphql' ),
				],
				'email'       => [
					'type'        => 'String',
					'description' => __( 'A string containing the user\'s email address.', 'wp-graphql' ),
				],
				'displayName' => [
					'type'        => 'String',
					'description' => __( 'A string that will be shown on the site. Defaults to user\'s username. It is likely that you will want to change this, for both appearance and security through obscurity (that is if you dont use and delete the default admin user).', 'wp-graphql' ),
				],
				'nickname'    => [
					'type'        => 'String',
					'description' => __( 'The user\'s nickname, defaults to the user\'s username.', 'wp-graphql' ),
				],
				'firstName'   => [
					'type'        => 'String',
					'description' => __( '	The user\'s first name.', 'wp-graphql' ),
				],
				'lastName'    => [
					'type'        => 'String',
					'description' => __( 'The user\'s last name.', 'wp-graphql' ),
				],
				'description' => [
					'type'        => 'String',
					'description' => __( 'A string containing content about the user.', 'wp-graphql' ),
				],
				'richEditing' => [
					'type'        => 'String',
					'description' => __( 'A string for whether to enable the rich editor or not. False if not empty.', 'wp-graphql' ),
				],
				'registered'  => [
					'type'        => 'String',
					'description' => __( 'The date the user registered. Format is Y-m-d H:i:s.', 'wp-graphql' ),
				],
				'roles'       => [
					'type'        => [ 'list_of' => 'String' ],
					'description' => __( 'An array of roles to be assigned to the user.', 'wp-graphql' ),
				],
				'jabber'      => [
					'type'        => 'String',
					'description' => __( 'User\'s Jabber account.', 'wp-graphql' ),
				],
				'aim'         => [
					'type'        => 'String',
					'description' => __( 'User\'s AOL IM account.', 'wp-graphql' ),
				],
				'yim'         => [
					'type'        => 'String',
					'description' => __( 'User\'s Yahoo IM account.', 'wp-graphql' ),
				],
				'locale'      => [
					'type'        => 'String',
					'description' => __( 'User\'s locale.', 'wp-graphql' ),
				],
			];

			/**
			 * Filters all of the fields available for input
			 *
			 * @var array<string,array<string,mixed>> $input_fields
			 */
			self::$input_fields = apply_filters( 'graphql_user_mutation_input_fields', $input_fields );
		}

		return ( ! empty( self::$input_fields ) ) ? self::$input_fields : null;
	}

	/**
	 * Maps the GraphQL input to a format that the WordPress functions can use
	 *
	 * @param array<string,mixed> $input         Data coming from the GraphQL mutation query input
	 * @param string              $mutation_name Name of the mutation being performed
	 *
	 * @return array<string,mixed>
	 * @throws \GraphQL\Error\UserError If the passed email address is invalid.
	 */
	public static function prepare_user_object( $input, $mutation_name ) {
		$insert_user_args = [];

		/**
		 * Optional fields
		 */
		if ( isset( $input['nicename'] ) ) {
			$insert_user_args['user_nicename'] = $input['nicename'];
		}

		if ( isset( $input['websiteUrl'] ) ) {
			$insert_user_args['user_url'] = esc_url( $input['websiteUrl'] );
		}

		if ( isset( $input['displayName'] ) ) {
			$insert_user_args['display_name'] = $input['displayName'];
		}

		if ( isset( $input['nickname'] ) ) {
			$insert_user_args['nickname'] = $input['nickname'];
		}

		if ( isset( $input['firstName'] ) ) {
			$insert_user_args['first_name'] = $input['firstName'];
		}

		if ( isset( $input['lastName'] ) ) {
			$insert_user_args['last_name'] = $input['lastName'];
		}

		if ( isset( $input['description'] ) ) {
			$insert_user_args['description'] = $input['description'];
		}

		if ( isset( $input['richEditing'] ) ) {
			$insert_user_args['rich_editing'] = $input['richEditing'];
		}

		if ( isset( $input['registered'] ) ) {
			$insert_user_args['user_registered'] = $input['registered'];
		}

		if ( isset( $input['locale'] ) ) {
			$insert_user_args['locale'] = $input['locale'];
		}

		/**
		 * Required fields
		 */
		if ( ! empty( $input['email'] ) ) {
			if ( false === is_email( apply_filters( 'pre_user_email', $input['email'] ) ) ) {
				throw new UserError( esc_html__( 'The email address you are trying to use is invalid', 'wp-graphql' ) );
			}
			$insert_user_args['user_email'] = $input['email'];
		}

		if ( ! empty( $input['password'] ) ) {
			$insert_user_args['user_pass'] = $input['password'];
		} else {
			$insert_user_args['user_pass'] = null;
		}

		if ( ! empty( $input['username'] ) ) {
			$insert_user_args['user_login'] = $input['username'];
		}

		if ( ! empty( $input['roles'] ) ) {
			/**
			 * Pluck the first role out of the array since the insert and update functions only
			 * allow one role to be set at a time. We will add all of the roles passed to the
			 * mutation later on after the initial object has been created or updated.
			 */
			$insert_user_args['role'] = $input['roles'][0];
		}

		/**
		 * Filters the mappings for input to arguments
		 *
		 * @param array<string,mixed> $insert_user_args The arguments to ultimately be passed to the WordPress function
		 * @param array<string,mixed> $input            Input data from the GraphQL mutation
		 * @param string              $mutation_name    What user mutation is being performed for context
		 */
		$insert_user_args = apply_filters( 'graphql_user_insert_post_args', $insert_user_args, $input, $mutation_name );

		return $insert_user_args;
	}

	/**
	 * This updates additional data related to the user object after the initial mutation has
	 * happened
	 *
	 * @param int                                  $user_id       The ID of the user being mutated
	 * @param array<string,mixed>                  $input         The input data from the GraphQL query
	 * @param string                               $mutation_name Name of the mutation currently being run
	 * @param \WPGraphQL\AppContext                $context The AppContext passed down the resolve tree
	 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo passed down the Resolve Tree
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function update_additional_user_object_data( $user_id, $input, $mutation_name, AppContext $context, ResolveInfo $info ) {
		$roles = ! empty( $input['roles'] ) ? $input['roles'] : [];
		self::add_user_roles( $user_id, $roles );

		/**
		 * Run an action after the additional data has been updated. This is a great spot to hook into to
		 * update additional data related to users, such as setting relationships, updating additional usermeta,
		 * or sending emails to Kevin... whatever you need to do with the userObject.
		 *
		 * @param int                                  $user_id       The ID of the user being mutated
		 * @param array<string,mixed>                  $input         The input for the mutation
		 * @param string                               $mutation_name The name of the mutation (ex: create, update, delete)
		 * @param \WPGraphQL\AppContext                $context       The AppContext passed down the resolve tree
		 * @param \GraphQL\Type\Definition\ResolveInfo $info          The ResolveInfo passed down the Resolve Tree
		 */
		do_action( 'graphql_user_object_mutation_update_additional_data', $user_id, $input, $mutation_name, $context, $info );
	}

	/**
	 * Method to add user roles to a user object
	 *
	 * @param int      $user_id The ID of the user
	 * @param string[] $roles   List of roles that need to get added to the user
	 *
	 * @return void
	 * @throws \Exception
	 */
	private static function add_user_roles( $user_id, $roles ) {
		if ( empty( $roles ) || ! is_array( $roles ) || ! current_user_can( 'edit_user', $user_id ) ) {
			return;
		}

		$user = get_user_by( 'ID', $user_id );

		if ( false !== $user ) {
			foreach ( $roles as $role ) {
				$verified = self::verify_user_role( $role, $user_id );

				if ( true === $verified ) {
					$user->add_role( $role );
				} elseif ( is_wp_error( $verified ) ) {
					throw new Exception( esc_html( $verified->get_error_message() ) );
				} elseif ( false === $verified ) {
					// Translators: The placeholder is the name of the user role
					throw new Exception( esc_html( sprintf( __( 'The %s role cannot be added to this user', 'wp-graphql' ), $role ) ) );
				}
			}
		}
	}

	/**
	 * Method to check if the user role is valid, and if the current user has permission to add, or
	 * remove it from a user.
	 *
	 * @param string $role    Name of the role trying to get added to a user object
	 * @param int    $user_id The ID of the user being mutated
	 *
	 * @return bool|\WP_Error
	 */
	private static function verify_user_role( $role, $user_id ) {
		global $wp_roles;

		$potential_role = isset( $wp_roles->role_objects[ $role ] ) ? $wp_roles->role_objects[ $role ] : '';

		if ( empty( $wp_roles->role_objects[ $role ] ) ) {
			// Translators: The placeholder is the name of the user role
			return new \WP_Error( 'wpgraphql_user_invalid_role', sprintf( __( 'The role %s does not exist', 'wp-graphql' ), $role ) );
		}

		/*
		 * Don't let anyone with 'edit_users' (admins) edit their own role to something without it.
		 * Multisite super admins can freely edit their blog roles -- they possess all caps.
		 */
		if (
			! ( is_multisite() && current_user_can( 'manage_sites' ) ) &&
			get_current_user_id() === $user_id &&
			! $potential_role->has_cap( 'edit_users' )
		) {
			return new \WP_Error( 'wpgraphql_user_invalid_role', __( 'Sorry, you cannot remove user editing permissions for your own account.', 'wp-graphql' ) );
		}

		/**
		 * The function for this is only loaded on admin pages. See note: https://codex.wordpress.org/Function_Reference/get_editable_roles#Notes
		 */
		if ( ! function_exists( 'get_editable_roles' ) ) {
			require_once ABSPATH . 'wp-admin/includes/admin.php';
		}

		$editable_roles = get_editable_roles();

		if ( empty( $editable_roles[ $role ] ) ) {
			// Translators: %s is the name of the role that can't be added to the user.
			return new \WP_Error( 'wpgraphql_user_invalid_role', sprintf( __( 'Sorry, you are not allowed to give this the following role: %s.', 'wp-graphql' ), $role ) );
		} else {
			return true;
		}
	}
}


// File: wp-graphql\src\Data\Connection\AbstractConnectionResolver.php
<?php

namespace WPGraphQL\Data\Connection;

use GraphQL\Deferred;
use GraphQL\Error\InvariantViolation;
use GraphQL\Error\UserError;
use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Model\Post;

/**
 * Class AbstractConnectionResolver
 *
 * Individual Connection Resolvers should extend this to make returning data in proper shape for Relay-compliant connections easier, ensure data is passed through consistent filters, etc.
 *
 * @package WPGraphQL\Data\Connection
 *
 * The template type `TQueryClass` is used by static analysis tools to correctly typehint the query class used by the Connection Resolver.
 * Classes that extend `AbstractConnectionResolver` should add `@extends @extends \WPGraphQL\Data\Connection\AbstractConnectionResolver<\MY_QUERY_CLASS>` to the class dockblock to get proper hinting.
 * E.g. `@extends \WPGraphQL\Data\Connection\AbstractConnectionResolver<\WP_Term_Query>`
 *
 * @template TQueryClass
 */
abstract class AbstractConnectionResolver {
	/**
	 * The source from the field calling the connection.
	 *
	 * @var \WPGraphQL\Model\Model|mixed[]|mixed
	 */
	protected $source;

	/**
	 * The args input before it is filtered and prepared by the constructor.
	 *
	 * @var array<string,mixed>
	 */
	protected $unfiltered_args;

	/**
	 * The args input on the field calling the connection.
	 *
	 * Filterable by `graphql_connection_args`.
	 *
	 * @var ?array<string,mixed>
	 */
	protected $args;

	/**
	 * The AppContext for the GraphQL Request
	 *
	 * @var \WPGraphQL\AppContext
	 */
	protected $context;

	/**
	 * The ResolveInfo for the GraphQL Request
	 *
	 * @var \GraphQL\Type\Definition\ResolveInfo
	 */
	protected $info;

	/**
	 * The query args used to query for data to resolve the connection.
	 *
	 * Filterable by `graphql_connection_query_args`.
	 *
	 * @var ?array<string,mixed>
	 */
	protected $query_args;

	/**
	 * Whether the connection resolver should execute.
	 *
	 * If `false`, the connection resolve will short-circuit and return an empty array.
	 *
	 * Filterable by `graphql_connection_pre_should_execute` and `graphql_connection_should_execute`.
	 *
	 * @var ?bool
	 */
	protected $should_execute;

	/**
	 * The loader name.
	 *
	 * Defaults to `loader_name()` and filterable by `graphql_connection_loader_name`.
	 *
	 * @var ?string
	 */
	protected $loader_name;

	/**
	 * The loader the resolver is configured to use.
	 *
	 * @var ?\WPGraphQL\Data\Loader\AbstractDataLoader
	 */
	protected $loader;

	/**
	 * Whether the connection is a one to one connection. Default false.
	 *
	 * @var bool
	 */
	public $one_to_one = false;

	/**
	 * The class name of the query to instantiate. Set to `null` if the Connection Resolver does not rely on a query class to fetch data.
	 *
	 * Examples `WP_Query`, `WP_Comment_Query`, `WC_Query`, `/My/Namespaced/CustomQuery`, etc.
	 *
	 * @var ?class-string<TQueryClass>
	 */
	protected $query_class;

	/**
	 * The instantiated query array/object used to fetch the data.
	 *
	 * Examples:
	 *   return new WP_Query( $this->get_query_args() );
	 *   return new WP_Comment_Query( $this->get_query_args() );
	 *   return new WP_Term_Query( $this->get_query_args() );
	 *
	 * Whatever it is will be passed through filters so that fields throughout
	 * have context from what was queried and can make adjustments as needed, such
	 * as exposing `totalCount` in pageInfo, etc.
	 *
	 * Filterable by `graphql_connection_pre_get_query` and `graphql_connection_query`.
	 *
	 * @var ?TQueryClass
	 */
	protected $query;

	/**
	 * @var mixed[]
	 *
	 * @deprecated 1.26.0 This is an artifact and is unused. It will be removed in a future release.
	 */
	protected $items;

	/**
	 * The IDs returned from the query.
	 *
	 * The IDs are sliced to confirm with the pagination args, and overfetched by one.
	 *
	 * Filterable by `graphql_connection_ids`.
	 *
	 * @var int[]|string[]|null
	 */
	protected $ids;

	/**
	 * The nodes (usually GraphQL models) returned from the query.
	 *
	 * Filterable by `graphql_connection_nodes`.
	 *
	 * @var \WPGraphQL\Model\Model[]|mixed[]|null
	 */
	protected $nodes;

	/**
	 * The edges for the connection.
	 *
	 * Filterable by `graphql_connection_edges`.
	 *
	 * @var ?array<string,mixed>[]
	 */
	protected $edges;

	/**
	 * The page info for the connection.
	 *
	 * Filterable by `graphql_connection_page_info`.
	 *
	 * @var ?array<string,mixed>
	 */
	protected $page_info;

	/**
	 * The query amount to return for the connection.
	 *
	 * @var ?int
	 */
	protected $query_amount;

	/**
	 * ConnectionResolver constructor.
	 *
	 * @param mixed                                $source  Source passed down from the resolve tree
	 * @param array<string,mixed>                  $args    Array of arguments input in the field as part of the GraphQL query.
	 * @param \WPGraphQL\AppContext                $context The app context that gets passed down the resolve tree.
	 * @param \GraphQL\Type\Definition\ResolveInfo $info    Info about fields passed down the resolve tree.
	 */
	public function __construct( $source, array $args, AppContext $context, ResolveInfo $info ) {
		// Set the source (the root object), context, resolveInfo, and unfiltered args for the resolver.
		$this->source          = $source;
		$this->unfiltered_args = $args;
		$this->context         = $context;
		$this->info            = $info;

		/**
		 * @todo This exists for b/c, where extenders may be directly accessing `$this->args` in ::get_loader() or even `::get_args()`.
		 * We can call it later in the lifecycle once that's no longer the case.
		 */
		$this->args = $this->get_args();

		// Pre-check if the connection should execute so we can skip expensive logic if we already know it shouldn't execute.
		if ( ! $this->get_pre_should_execute( $this->source, $this->unfiltered_args, $this->context, $this->info ) ) {
			$this->should_execute = false;
		}

		// Get the loader for the Connection.
		$this->loader = $this->get_loader();

		/**
		 * Filters the GraphQL args before they are used in get_query_args().
		 *
		 * @todo We reinstantate this here for b/c. Once that is not a concern, we should relocate this filter to ::get_args().
		 *
		 * @param array<string,mixed>                                   $args                The GraphQL args passed to the resolver.
		 * @param \WPGraphQL\Data\Connection\AbstractConnectionResolver $connection_resolver Instance of the ConnectionResolver.
		 * @param array<string,mixed>                                   $unfiltered_args     Array of arguments input in the field as part of the GraphQL query.
		 *
		 * @since 1.11.0
		 */
		$this->args = apply_filters( 'graphql_connection_args', $this->args, $this, $this->get_unfiltered_args() );

		// Get the query amount for the connection.
		$this->query_amount = $this->get_query_amount();

		/**
		 * Filters the query args before they are used in the query.
		 *
		 *  @todo We reinstantate this here for b/c. Once that is not a concern, we should relocate this filter to ::get_query_args().
		 *
		 * @param array<string,mixed>                                   $query_args          The query args to be used with the executable query to get data.
		 * @param \WPGraphQL\Data\Connection\AbstractConnectionResolver $connection_resolver Instance of the ConnectionResolver
		 * @param array<string,mixed>                                   $unfiltered_args     Array of arguments input in the field as part of the GraphQL query.
		 */
		$this->query_args = apply_filters( 'graphql_connection_query_args', $this->get_query_args(), $this, $this->get_unfiltered_args() );

		// Get the query class for the connection.
		$this->query_class = $this->get_query_class();

		// The rest of the class properties are set when `$this->get_connection()` is called.
	}

	/**
	 * ====================
	 * Required/Abstract Methods
	 *
	 * These methods must be implemented or overloaded in the extending class.
	 *
	 * The reason not all methods are abstract is to prevent backwards compatibility issues.
	 * ====================
	 */

	/**
	 * The name of the loader to use for this connection.
	 *
	 * Filterable by `graphql_connection_loader_name`.
	 *
	 * @todo This is protected for backwards compatibility, but should be abstract and implemented by the child classes.
	 */
	protected function loader_name(): string {
		return '';
	}

	/**
	 * Prepares the query args used to fetch the data for the connection.
	 *
	 * This accepts the GraphQL args and maps them to a format that can be read by our query class.
	 * For example, if the ConnectionResolver uses WP_Query to fetch the data, this should return $args for use in `new WP_Query( $args );`
	 *
	 * @todo This is protected for backwards compatibility, but should be abstract and implemented by the child classes.
	 *
	 * @param array<string,mixed> $args The GraphQL input args passed to the connection.
	 *
	 * @return array<string,mixed>
	 *
	 * @throws \GraphQL\Error\InvariantViolation If the method is not implemented.
	 *
	 * @codeCoverageIgnore
	 */
	protected function prepare_query_args( array $args ): array {
		throw new InvariantViolation(
			sprintf(
				// translators: %s is the name of the connection resolver class.
				esc_html__( 'Class %s does not implement a valid method `prepare_query_args()`.', 'wp-graphql' ),
				static::class
			)
		);
	}

	/**
	 * Return an array of ids from the query
	 *
	 * Each Query class in WP and potential datasource handles this differently,
	 * so each connection resolver should handle getting the items into a uniform array of items.
	 *
	 * @todo: This is not an abstract function to prevent backwards compatibility issues, so it instead throws an exception.
	 *
	 * Classes that extend AbstractConnectionResolver should
	 * override this method instead of ::get_ids().
	 *
	 * @since 1.9.0
	 *
	 * @throws \GraphQL\Error\InvariantViolation If child class forgot to implement this.
	 * @return int[]|string[] the array of IDs.
	 */
	public function get_ids_from_query() {
		throw new InvariantViolation(
			sprintf(
				// translators: %s is the name of the connection resolver class.
				esc_html__( 'Class %s does not implement a valid method `get_ids_from_query()`.', 'wp-graphql' ),
				static::class
			)
		);
	}
	/**
	 * Determine whether or not the the offset is valid, i.e the item corresponding to the offset exists.
	 *
	 * Offset is equivalent to WordPress ID (e.g post_id, term_id). So this is equivalent to checking if the WordPress object exists for the given ID.
	 *
	 * @param mixed $offset The offset to validate. Typically a WordPress Database ID
	 *
	 * @return bool
	 */
	abstract public function is_valid_offset( $offset );

	/**
	 * ====================
	 * The following methods handle the underlying behavior of the connection, and are intended to be overloaded by the child class.
	 *
	 * These methods are wrapped in getters which apply the filters and set the properties of the class instance.
	 * ====================
	 */

	/**
	 * Used to determine whether the connection query should be executed. This is useful for short-circuiting the connection resolver before executing the query.
	 *
	 * When `pre_should_excecute()` returns false, that's a sign the Resolver shouldn't execute the query. Otherwise, the more expensive logic logic in `should_execute()` will run later in the lifecycle.
	 *
	 * @param mixed                                $source  Source passed down from the resolve tree
	 * @param array<string,mixed>                  $args    Array of arguments input in the field as part of the GraphQL query.
	 * @param \WPGraphQL\AppContext                $context The app context that gets passed down the resolve tree.
	 * @param \GraphQL\Type\Definition\ResolveInfo $info    Info about fields passed down the resolve tree.
	 */
	protected function pre_should_execute( $source, array $args, AppContext $context, ResolveInfo $info ): bool {
		$should_execute = true;

		/**
		 * If the source is a Post and the ID is empty (i.e. if the user doesn't have permissions to view the source), we should not execute the query.
		 *
		 * @todo This can probably be abstracted to check if _any_ source is private, and not just `PostObject` models.
		 */
		if ( $source instanceof Post && empty( $source->ID ) ) {
			$should_execute = false;
		}

		return $should_execute;
	}

	/**
	 * Prepares the GraphQL args for use by the connection.
	 *
	 * Useful for modifying the $args before they are passed to $this->get_query_args().
	 *
	 * @param array<string,mixed> $args The GraphQL input args to prepare.
	 *
	 * @return array<string,mixed>
	 */
	protected function prepare_args( array $args ): array {
		return $args;
	}

	/**
	 * The maximum number of items that should be returned by the query.
	 *
	 * This is filtered by `graphql_connection_max_query_amount` in ::get_query_amount().
	 */
	protected function max_query_amount(): int {
		return 100;
	}

	/**
	 * The default query class to use for the connection.
	 *
	 * Should return null if the resolver does not use a query class to fetch the data.
	 *
	 * @return ?class-string<TQueryClass>
	 */
	protected function query_class(): ?string {
		return null;
	}

	/**
	 * Validates the query class. Will be ignored if the Connection Resolver does not use a query class.
	 *
	 * By default this checks if the query class has a `query()` method. If the query class requires the `query()` method to be named something else (e.g. $query_class->get_results()` ) this method should be overloaded.
	 *
	 * @param string $query_class The query class to validate.
	 */
	protected function is_valid_query_class( string $query_class ): bool {
		return method_exists( $query_class, 'query' );
	}

	/**
	 * Executes the query and returns the results.
	 *
	 * Usually, the returned value is an instantiated `$query_class` (e.g. `WP_Query`), but it can be any collection of data. The `get_ids_from_query()` method will be used to extract the IDs from the returned value.
	 *
	 * If the resolver does not rely on a query class, this should be overloaded to return the data directly.
	 *
	 * @param array<string,mixed> $query_args The query args to use to query the data.
	 *
	 * @return TQueryClass
	 *
	 * @throws \GraphQL\Error\InvariantViolation If the query class is not valid.
	 */
	protected function query( array $query_args ) {
		// If there is no query class, we need the child class to overload this method.
		$query_class = $this->get_query_class();

		if ( empty( $query_class ) ) {
			throw new InvariantViolation(
				sprintf(
					// translators: %s is the name of the connection resolver class.
					esc_html__( 'The %s class does not rely on a query class. Please define a `query()` method to return the data directly.', 'wp-graphql' ),
					static::class
				)
			);
		}

		return new $query_class( $query_args );
	}

	/**
	 * Determine whether or not the query should execute.
	 *
	 * Return true to exeucte, return false to prevent execution.
	 *
	 * Various criteria can be used to determine whether a Connection Query should be executed.
	 *
	 * For example, if a user is requesting revisions of a Post, and the user doesn't have permission to edit the post, they don't have permission to view the revisions, and therefore we can prevent the query to fetch revisions from executing in the first place.
	 *
	 * Runs only if `pre_should_execute()` returns true.
	 *
	 * @todo This is public for b/c but it should be protected.
	 *
	 * @return bool
	 */
	public function should_execute() {
		return true;
	}

	/**
	 * Returns the offset for a given cursor.
	 *
	 * Connections that use a string-based offset should override this method.
	 *
	 * @param ?string $cursor The cursor to convert to an offset.
	 *
	 * @return int|mixed
	 */
	public function get_offset_for_cursor( string $cursor = null ) { // phpcs:ignore PHPCompatibility.FunctionDeclarations.RemovedImplicitlyNullableParam.Deprecated -- This is a breaking change to fix.
		$offset = false;

		// We avoid using ArrayConnection::cursorToOffset() because it assumes an `int` offset.
		if ( ! empty( $cursor ) ) {
			$offset = substr( base64_decode( $cursor ), strlen( 'arrayconnection:' ) );
		}

		/**
		 * We assume a numeric $offset is an integer ID.
		 * If it isn't this method should be overridden by the child class.
		 */
		return is_numeric( $offset ) ? absint( $offset ) : $offset;
	}

	/**
	 * Validates Model.
	 *
	 * If model isn't a class with a `fields` member, this function with have be overridden in
	 * the Connection class.
	 *
	 * @param \WPGraphQL\Model\Model|mixed $model The model being validated.
	 *
	 * @return bool
	 */
	protected function is_valid_model( $model ) {
		return isset( $model->fields ) && ! empty( $model->fields );
	}

	/**
	 * ====================
	 * Public Getters
	 *
	 * These methods are used to get the properties of the class instance.
	 *
	 * You shouldn't need to overload these, but if you do, take care to ensure that the overloaded method applies the same filters and sets the same properties as the methods here.
	 * ====================
	 */

	/**
	 * Returns the source of the connection
	 *
	 * @return mixed
	 */
	public function get_source() {
		return $this->source;
	}

	/**
	 * Returns the AppContext of the connection.
	 */
	public function get_context(): AppContext {
		return $this->context;
	}

	/**
	 * Returns the ResolveInfo of the connection.
	 */
	public function get_info(): ResolveInfo {
		return $this->info;
	}

	/**
	 * Returns the loader name.
	 *
	 * If $loader_name is not initialized, this plugin will initialize it.
	 *
	 * @return string
	 *
	 * @throws \GraphQL\Error\InvariantViolation
	 */
	public function get_loader_name() {
		// Only initialize the loader_name property once.
		if ( ! isset( $this->loader_name ) ) {
			$name = $this->loader_name();

			// This is a b/c check because `loader_name()` is not abstract.
			if ( empty( $name ) ) {
				throw new InvariantViolation(
					sprintf(
						// translators: %s is the name of the connection resolver class.
						esc_html__( 'Class %s does not implement a valid method `loader_name()`.', 'wp-graphql' ),
						esc_html( static::class )
					)
				);
			}

			/**
			 * Filters the loader name.
			 * This is the name of the registered DataLoader that will be used to load the data for the connection.
			 *
			 * @param string $loader_name The name of the loader.
			 * @param self   $resolver    The AbstractConnectionResolver instance.
			 */
			$name = apply_filters( 'graphql_connection_loader_name', $name, $this );

			// Bail if the loader name is invalid.
			if ( empty( $name ) || ! is_string( $name ) ) {
				throw new InvariantViolation( esc_html__( 'The Connection Resolver needs to define a loader name', 'wp-graphql' ) );
			}

			$this->loader_name = $name;
		}

		return $this->loader_name;
	}

	/**
	 * Returns the $args passed to the connection, before any modifications.
	 *
	 * @return array<string,mixed>
	 */
	public function get_unfiltered_args(): array {
		return $this->unfiltered_args;
	}

	/**
	 * Returns the $args passed to the connection.
	 *
	 * @return array<string,mixed>
	 */
	public function get_args(): array {
		if ( ! isset( $this->args ) ) {
			$this->args = $this->prepare_args( $this->get_unfiltered_args() );
		}

		return $this->args;
	}

	/**
	 * Returns the amount of items to query from the database.
	 *
	 * The amount is calculated as the the max between what was requested and what is defined as the $max_query_amount to ensure that queries don't exceed unwanted limits when querying data.
	 *
	 * If the amount requested is greater than the max query amount, a debug message will be included in the GraphQL response.
	 *
	 * @return int
	 */
	public function get_query_amount() {
		if ( ! isset( $this->query_amount ) ) {
			/**
			 * Filter the maximum number of posts per page that should be queried. This prevents queries from being exceedingly resource intensive.
			 *
			 * The default is 100 - unless overloaded by ::max_query_amount() in the child class.
			 *
			 * @param int                                  $max_posts  the maximum number of posts per page.
			 * @param mixed                                $source     source passed down from the resolve tree
			 * @param array<string,mixed>                  $args       array of arguments input in the field as part of the GraphQL query
			 * @param \WPGraphQL\AppContext                $context    Object containing app context that gets passed down the resolve tree
			 * @param \GraphQL\Type\Definition\ResolveInfo $info       Info about fields passed down the resolve tree
			 *
			 * @since 0.0.6
			 */
			$max_query_amount = (int) apply_filters( 'graphql_connection_max_query_amount', $this->max_query_amount(), $this->source, $this->get_args(), $this->context, $this->info );

			// We don't want the requested amount to be lower than 0.
			$requested_query_amount = (int) max(
				0,
				/**
				 * This filter allows to modify the number of nodes the connection should return.
				 *
				 * @param int                        $amount   the requested amount
				 * @param self $resolver Instance of the connection resolver class
				 */
				apply_filters( 'graphql_connection_amount_requested', $this->get_amount_requested(), $this )
			);

			if ( $requested_query_amount > $max_query_amount ) {
				graphql_debug(
					sprintf( 'The number of items requested by the connection (%s) exceeds the max query amount. Only the first %s items will be returned.', $requested_query_amount, $max_query_amount ),
					[ 'connection' => static::class ]
				);
			}

			$this->query_amount = (int) min( $max_query_amount, $requested_query_amount );
		}

		return $this->query_amount;
	}

	/**
	 * Gets the query args used by the connection to fetch the data.
	 *
	 * @return array<string,mixed>
	 */
	public function get_query_args() {
		if ( ! isset( $this->query_args ) ) {
			// We pass $this->get_args() to ensure we're using the filtered args.
			$this->query_args = $this->prepare_query_args( $this->get_args() );
		}

		return $this->query_args;
	}

	/**
	 * Gets the query class to be instantiated by the `query()` method.
	 *
	 * If null, the `query()` method will be overloaded to return the data.
	 *
	 * @return ?class-string<TQueryClass>
	 */
	public function get_query_class(): ?string {
		if ( ! isset( $this->query_class ) ) {
			$default_query_class = $this->query_class();

			// Attempt to get the query class from the context.
			$context = $this->get_context();

			$query_class = ! empty( $context->queryClass ) ? $context->queryClass : $default_query_class;

			/**
			 * Filters the `$query_class` that will be used to execute the query.
			 *
			 * This is useful for replacing the default query (e.g `WP_Query` ) with a custom one (E.g. `WP_Term_Query` or WooCommerce's `WC_Query`).
			 *
			 * @param ?class-string<TQueryClass> $query_class The query class to be used with the executable query to get data. `null` if the AbstractConnectionResolver does not use a query class.
			 * @param self        $resolver    Instance of the AbstractConnectionResolver
			 */
			$this->query_class = apply_filters( 'graphql_connection_query_class', $query_class, $this );
		}

		return $this->query_class;
	}

	/**
	 * Returns whether the connection should execute.
	 *
	 * If conditions are met that should prevent the execution, we can bail from resolving early, before the query is executed.
	 */
	public function get_should_execute(): bool {
		// If `pre_should_execute()` or other logic has yet to run, we should run the full `should_execute()` logic.
		if ( ! isset( $this->should_execute ) ) {
			$this->should_execute = $this->should_execute();
		}

		return $this->should_execute;
	}

	/**
	 * Gets the results of the executed query.
	 *
	 * @return TQueryClass
	 */
	public function get_query() {
		if ( ! isset( $this->query ) ) {
			/**
			 * When this filter returns anything but null, it will be used as the resolved query, and the default query execution will be skipped.
			 *
			 * @param null $query               The query to return. Return null to use the default query execution.
			 * @param self $resolver The connection resolver instance.
			 */
			$query = apply_filters( 'graphql_connection_pre_get_query', null, $this );

			if ( null === $query ) {

				// Validates the query class before it is used in the query() method.
				$this->validate_query_class();

				$query = $this->query( $this->get_query_args() );
			}

			$this->query = $query;
		}

		return $this->query;
	}

	/**
	 * Returns an array of IDs for the connection.
	 *
	 * These IDs have been fetched from the query with all the query args applied,
	 * then sliced (overfetching by 1) by pagination args.
	 *
	 * @return int[]|string[]
	 */
	public function get_ids() {
		if ( ! isset( $this->ids ) ) {
			$this->ids = $this->prepare_ids();
		}

		return $this->ids;
	}

	/**
	 * Get the nodes from the query.
	 *
	 * @uses AbstractConnectionResolver::get_ids_for_nodes()
	 *
	 * @return array<int|string,mixed|\WPGraphQL\Model\Model|null>
	 */
	public function get_nodes() {
		if ( ! isset( $this->nodes ) ) {
			$this->nodes = $this->prepare_nodes();
		}

		return $this->nodes;
	}

	/**
	 * Get the edges from the nodes.
	 *
	 * @return array<string,mixed>[]
	 */
	public function get_edges() {
		if ( ! isset( $this->edges ) ) {
			$this->edges = $this->prepare_edges( $this->get_nodes() );
		}

		return $this->edges;
	}

	/**
	 * Returns pageInfo for the connection
	 *
	 * @return array<string,mixed>
	 */
	public function get_page_info() {
		if ( ! isset( $this->page_info ) ) {
			$page_info = $this->prepare_page_info();

			/**
			 * Filter the pageInfo that is returned to the connection.
			 *
			 * This filter allows for additional fields to be filtered into the pageInfo
			 * of a connection, such as "totalCount", etc, because the filter has enough
			 * context of the query, args, request, etc to be able to calcuate and return
			 * that information.
			 *
			 * example:
			 *
			 * You would want to register a "total" field to the PageInfo type, then filter
			 * the pageInfo to return the total for the query, something to this tune:
			 *
			 * add_filter( 'graphql_connection_page_info', function( $page_info, $connection ) {
			 *
			 *   $page_info['total'] = null;
			 *
			 *   if ( $connection->query instanceof WP_Query ) {
			 *      if ( isset( $connection->query->found_posts ) {
			 *          $page_info['total'] = (int) $connection->query->found_posts;
			 *      }
			 *   }
			 *
			 *   return $page_info;
			 *
			 * });
			 */
			$this->page_info = apply_filters( 'graphql_connection_page_info', $page_info, $this );
		}

		return $this->page_info;
	}

	/**
	 * ===============================
	 * Public setters
	 *
	 * These are used to directly modify the instance properties from outside the class.
	 * ===============================
	 */

	/**
	 * Given a key and value, this sets a query_arg which will modify the query_args used by ::get_query();
	 *
	 * @param string $key   The key of the query arg to set
	 * @param mixed  $value The value of the query arg to set
	 *
	 * @return static
	 */
	public function set_query_arg( $key, $value ) {
		$this->query_args[ $key ] = $value;

		return $this;
	}

	/**
	 * Overloads the query_class which will be used to instantiate the query.
	 *
	 * @param class-string<TQueryClass> $query_class The class to use for the query. If empty, this will reset to the default query class.
	 *
	 * @return static
	 */
	public function set_query_class( string $query_class ) {
		$this->query_class = $query_class ?: $this->query_class();

		return $this;
	}

	/**
	 * Whether the connection should resolve as a one-to-one connection.
	 *
	 * @return static
	 */
	public function one_to_one() {
		$this->one_to_one = true;

		return $this;
	}

	/**
	 * Gets whether or not the query should execute, BEFORE any data is fetched or altered, filtered by 'graphql_connection_pre_should_execute'.
	 *
	 * @param mixed                                $source  The source that's passed down the GraphQL queries.
	 * @param array<string,mixed>                  $args    The inputArgs on the field.
	 * @param \WPGraphQL\AppContext                $context The AppContext passed down the GraphQL tree.
	 * @param \GraphQL\Type\Definition\ResolveInfo $info    The ResolveInfo passed down the GraphQL tree.
	 */
	protected function get_pre_should_execute( $source, array $args, AppContext $context, ResolveInfo $info ): bool {
		$should_execute = $this->pre_should_execute( $source, $args, $context, $info );

		/**
		 * Filters whether or not the query should execute, BEFORE any data is fetched or altered.
		 *
		 * This is evaluated based solely on the values passed to the constructor, before any data is fetched or altered, and is useful for shortcircuiting the Connection Resolver before any heavy logic is executed.
		 *
		 * For more in-depth checks, use the `graphql_connection_should_execute` filter instead.
		 *
		 * @param bool                                 $should_execute Whether or not the query should execute.
		 * @param mixed                                $source         The source that's passed down the GraphQL queries.
		 * @param array                                $args           The inputArgs on the field.
		 * @param \WPGraphQL\AppContext                $context        The AppContext passed down the GraphQL tree.
		 * @param \GraphQL\Type\Definition\ResolveInfo $info           The ResolveInfo passed down the GraphQL tree.
		 */
		return apply_filters( 'graphql_connection_pre_should_execute', $should_execute, $source, $args, $context, $info );
	}

	/**
	 * Returns the loader.
	 *
	 * If $loader is not initialized, this method will initialize it.
	 *
	 * @return \WPGraphQL\Data\Loader\AbstractDataLoader
	 */
	protected function get_loader() {
		// If the loader isn't set, set it.
		if ( ! isset( $this->loader ) ) {
			$name = $this->get_loader_name();

			$this->loader = $this->context->get_loader( $name );
		}

		return $this->loader;
	}

	/**
	 * Returns the amount of items requested from the connection.
	 *
	 * @return int
	 *
	 * @throws \GraphQL\Error\UserError If the `first` or `last` args are used together.
	 */
	public function get_amount_requested() {
		/**
		 * Filters the default query amount for a connection, if no `first` or `last` GraphQL argument is supplied.
		 *
		 * @param int  $amount_requested The default query amount for a connection.
		 * @param self $resolver         Instance of the Connection Resolver.
		 */
		$amount_requested = apply_filters( 'graphql_connection_default_query_amount', 10, $this );

		// @todo This should use  ::get_args() when b/c is not a concern.
		$args = $this->args;

		/**
		 * If both first & last are used in the input args, throw an exception.
		 */
		if ( ! empty( $args['first'] ) && ! empty( $args['last'] ) ) {
			throw new UserError( esc_html__( 'The `first` and `last` connection args cannot be used together. For forward pagination, use `first` & `after`. For backward pagination, use `last` & `before`.', 'wp-graphql' ) );
		}

		/**
		 * Get the key to use for the query amount.
		 * We avoid a ternary here for unit testing.
		 */
		$args_key = ! empty( $args['first'] ) && is_int( $args['first'] ) ? 'first' : null;
		if ( null === $args_key ) {
			$args_key = ! empty( $args['last'] ) && is_int( $args['last'] ) ? 'last' : null;
		}

		/**
		 * If the key is set, and is a positive integer, use it for the $amount_requested
		 * but if it's set to anything that isn't a positive integer, throw an exception
		 */
		if ( null !== $args_key && isset( $args[ $args_key ] ) ) {
			if ( 0 > $args[ $args_key ] ) {
				throw new UserError(
					sprintf(
						// translators: %s: The name of the arg that was invalid
						esc_html__( '%s must be a positive integer.', 'wp-graphql' ),
						esc_html( $args_key )
					)
				);
			}

			$amount_requested = $args[ $args_key ];
		}

		return (int) $amount_requested;
	}

	/**
	 * =====================
	 * Resolver lifecycle methods
	 *
	 * These methods are used internally by the class to resolve the connection. They rarely should be overloaded by the child class, but if you do, make sure to preserve any WordPress hooks included in the parent method.
	 * =====================
	 */

	/**
	 * Get the connection to return to the Connection Resolver
	 *
	 * @return \GraphQL\Deferred
	 */
	public function get_connection() {
		$this->execute_and_get_ids();

		/**
		 * Return a Deferred function to load all buffered nodes before
		 * returning the connection.
		 */
		return new Deferred(
			function () {
				// @todo This should use ::get_ids() when b/c is not a concern.
				$ids = $this->ids;

				if ( ! empty( $ids ) ) {
					// Load the ids.
					$this->get_loader()->load_many( $ids );
				}

				/**
				 * Set the items. These are the "nodes" that make up the connection.
				 *
				 * Filters the nodes in the connection
				 *
				 * @todo We reinstantate this here for b/c. Once that is not a concern, we should relocate this filter to ::get_nodes().
				 *
				 * @param \WPGraphQL\Model\Model[]|mixed[]|null $nodes   The nodes in the connection
				 * @param self                                 $resolver Instance of the Connection Resolver
				 */
				$this->nodes = apply_filters( 'graphql_connection_nodes', $this->get_nodes(), $this );

				/**
				 * Filters the edges in the connection.
				 *
				 * @todo We reinstantate this here for b/c. Once that is not a concern, we should relocate this filter to ::get_edges().
				 *
				 * @param array<string,mixed> $edges    The edges in the connection
				 * @param self                $resolver Instance of the Connection Resolver
				 */
				$this->edges = apply_filters( 'graphql_connection_edges', $this->get_edges(), $this );

				// @todo: we should also shortcircuit fetching/populating the actual nodes/edges if we only need one result.
				if ( true === $this->one_to_one ) {
					// For one to one connections, return the first edge.
					$first_edge_key = array_key_first( $this->edges );
					$connection     = isset( $first_edge_key ) && ! empty( $this->edges[ $first_edge_key ] ) ? $this->edges[ $first_edge_key ] : null;
				} else {
					// For plural connections (default) return edges/nodes/pageInfo
					$connection = [
						'nodes'    => $this->nodes,
						'edges'    => $this->edges,
						'pageInfo' => $this->get_page_info(),
					];
				}

				/**
				 * Filter the connection. In some cases, connections will want to provide
				 * additional information other than edges, nodes, and pageInfo
				 *
				 * This filter allows additional fields to be returned to the connection resolver
				 *
				 * @param ?array<string,mixed> $connection The connection data being returned. A single edge or null if the connection is one-to-one.
				 * @param self                 $resolver   The instance of the connection resolver
				 */
				return apply_filters( 'graphql_connection', $connection, $this );
			}
		);
	}

	/**
	 * Execute the resolver query and get the data for the connection
	 *
	 * @return int[]|string[]
	 */
	public function execute_and_get_ids() {
		/**
		 * If should_execute is explicitly set to false already, we can prevent execution quickly.
		 * If it's not, we need to call the should_execute() method to execute any situational logic to determine if the connection query should execute.
		 */
		$should_execute = false === $this->should_execute ? false : $this->should_execute();

		/**
		 * Check if the connection should execute. If conditions are met that should prevent
		 * the execution, we can bail from resolving early, before the query is executed.
		 *
		 * Filter whether the connection should execute.
		 *
		 * @param bool                       $should_execute      Whether the connection should execute
		 * @param \WPGraphQL\Data\Connection\AbstractConnectionResolver $connection_resolver Instance of the Connection Resolver
		 */
		$this->should_execute = apply_filters( 'graphql_connection_should_execute', $should_execute, $this );

		if ( false === $this->should_execute ) {
			return [];
		}

		/**
		 * Set the query for the resolver, for use as reference in filters, etc
		 *
		 * Filter the query. For core data, the query is typically an instance of:
		 *
		 *   WP_Query
		 *   WP_Comment_Query
		 *   WP_User_Query
		 *   WP_Term_Query
		 *   ...
		 *
		 * But in some cases, the actual mechanism for querying data should be overridden. For
		 * example, perhaps you're using ElasticSearch or Solr (hypothetical) and want to offload
		 * the query to that instead of a native WP_Query class. You could override this with a
		 * query to that datasource instead.
		 *
		 *  @todo We reinstantate this here for b/c. Once that is not a concern, we should relocate this filter to ::get_query_args().
		 *
		 * @param mixed                      $query               Instance of the Query for the resolver
		 * @param \WPGraphQL\Data\Connection\AbstractConnectionResolver $connection_resolver Instance of the Connection Resolver
		 */
		$this->query = apply_filters( 'graphql_connection_query', $this->get_query(), $this );

		/**
		 * Filter the connection IDs
		 *
		 * @todo We filter the IDs here for b/c. Once that is not a concern, we should relocate this filter to ::get_ids().
		 *
		 * @param int[]|string[]                                        $ids                 Array of IDs this connection will be resolving
		 * @param \WPGraphQL\Data\Connection\AbstractConnectionResolver $connection_resolver Instance of the Connection Resolver
		 */
		$this->ids = apply_filters( 'graphql_connection_ids', $this->get_ids(), $this );

		if ( empty( $this->ids ) ) {
			return [];
		}

		/**
		 * Buffer the IDs for deferred resolution
		 */
		$this->get_loader()->buffer( $this->ids );

		return $this->ids;
	}

	/**
	 * Validates the $query_class set on the resolver.
	 *
	 * This runs before the query is executed to ensure that the query class is valid.
	 *
	 * @throws \GraphQL\Error\InvariantViolation If the query class is invalid.
	 */
	protected function validate_query_class(): void {
		$default_query_class = $this->query_class();
		$query_class         = $this->get_query_class();

		// If the default query class is null, then the resolver should not use a query class.
		if ( null === $default_query_class ) {
			// If the query class is null, then we're good.
			if ( null === $query_class ) {
				return;
			}

			throw new InvariantViolation(
				sprintf(
					// translators: %1$s: The name of the class that should not use a query class. %2$s: The name of the query class that is set by the resolver.
					esc_html__( 'Class %1$s should not use a query class, but is attempting to use the %2$s query class.', 'wp-graphql' ),
					static::class,
					esc_html( $query_class )
				)
			);
		}

		// If there's no query class set, throw an error.
		if ( null === $query_class ) {
			throw new InvariantViolation(
				sprintf(
					// translators: %s: The connection resolver class name.
					esc_html__( '%s requires a query class, but no query class is set.', 'wp-graphql' ),
					static::class
				)
			);
		}

		// If the class is invalid, throw an error.
		if ( ! class_exists( $query_class ) ) {
			throw new InvariantViolation(
				sprintf(
					// translators: %s: The name of the query class that is set by the resolver.
					esc_html__( 'The query class %s does not exist.', 'wp-graphql' ),
					esc_html( $query_class )
				)
			);
		}

		// If the class is not compatible with our AbstractConnectionResolver::query() method, throw an error.
		if ( ! $this->is_valid_query_class( $query_class ) ) {
			throw new InvariantViolation(
				sprintf(
					// translators: %1$s: The name of the query class that is set by the resolver. %2$s: The name of the resolver class.
					esc_html__( 'The query class %1$s is not compatible with %2$s.', 'wp-graphql' ),
					esc_html( $this->query_class ?? 'unknown-class' ),
					static::class
				)
			);
		}
	}

	/**
	 * Returns an array slice of IDs, per the Relay Cursor Connection spec.
	 *
	 * The resulting array should be overfetched by 1.
	 *
	 * @see https://relay.dev/graphql/connections.htm#sec-Pagination-algorithm
	 *
	 * @param int[]|string[] $ids The array of IDs from the query to slice, ordered as expected by the GraphQL query.
	 *
	 * @since 1.9.0
	 *
	 * @return int[]|string[]
	 */
	public function apply_cursors_to_ids( array $ids ) {
		if ( empty( $ids ) ) {
			return [];
		}

		// @todo This should use ::get_args() when b/c is not a concern.
		$args = $this->args;

		// First we slice the array from the front.
		if ( ! empty( $args['after'] ) ) {
			$offset = $this->get_offset_for_cursor( $args['after'] );
			$index  = $this->get_array_index_for_offset( $offset, $ids );

			if ( false !== $index ) {
				// We want to start with the first id after the index.
				$ids = array_slice( $ids, $index + 1, null, true );
			}
		}

		// Then we slice the array from the back.
		if ( ! empty( $args['before'] ) ) {
			$offset = $this->get_offset_for_cursor( $args['before'] );
			$index  = $this->get_array_index_for_offset( $offset, $ids );

			if ( false !== $index ) {
				// Because array indexes start at 0, we can overfetch without adding 1 to $index.
				$ids = array_slice( $ids, 0, $index, true );
			}
		}

		return $ids;
	}

	/**
	 * Gets the array index for the given offset.
	 *
	 * @param int|string|false $offset The cursor pagination offset.
	 * @param int[]|string[]   $ids    The array of ids from the query.
	 *
	 * @return int|false $index The array index of the offset.
	 */
	public function get_array_index_for_offset( $offset, $ids ) {
		if ( false === $offset ) {
			return false;
		}

		// We use array_values() to ensure we're getting a positional index, and not a key.
		return array_search( $offset, array_values( $ids ), true );
	}

	/**
	 * Prepares the nodes for the connection.
	 *
	 * @used-by self::get_nodes()
	 *
	 * @return array<int|string,mixed|\WPGraphQL\Model\Model|null>
	 */
	protected function prepare_nodes(): array {
		$nodes = [];

		// These are already sliced and ordered, we're just populating node data.
		$ids = $this->get_ids_for_nodes();

		foreach ( $ids as $id ) {
			$model = $this->get_node_by_id( $id );
			if ( true === $this->get_is_valid_model( $model ) ) {
				$nodes[ $id ] = $model;
			}
		}

		return $nodes;
	}

	/**
	 * Prepares the IDs for the connection.
	 *
	 * @used-by self::get_ids()
	 *
	 * @return int[]|string[]
	 */
	protected function prepare_ids(): array {
		$ids = $this->get_ids_from_query();

		return $this->apply_cursors_to_ids( $ids );
	}

	/**
	 * Gets the IDs for the currently-paginated slice of nodes.
	 *
	 * We slice the array to match the amount of items that was asked for, as we over-fetched by 1 item to calculate pageInfo.
	 *
	 * @used-by AbstractConnectionResolver::get_nodes()
	 *
	 * @return int[]|string[]
	 */
	public function get_ids_for_nodes() {
		// @todo This should use ::get_ids() and get_args() when b/c is not a concern.
		$ids = $this->ids;

		if ( empty( $ids ) ) {
			return [];
		}

		$args = $this->args;

		// If we're going backwards then our overfetched ID is at the front.
		if ( ! empty( $args['last'] ) && count( $ids ) > absint( $args['last'] ) ) {
			return array_slice( $ids, count( $ids ) - absint( $args['last'] ), $this->get_query_amount(), true );
		}

		// If we're going forwards, our overfetched ID is at the back.
		return array_slice( $ids, 0, $this->get_query_amount(), true );
	}

	/**
	 * Given an ID, return the model for the entity or null
	 *
	 * @param int|string|mixed $id The ID to identify the object by. Could be a database ID or an in-memory ID (like post_type name)
	 *
	 * @return mixed|\WPGraphQL\Model\Model|null
	 */
	public function get_node_by_id( $id ) {
		return $this->get_loader()->load( $id );
	}

	/**
	 * Gets whether or not the model is valid.
	 *
	 * @param mixed $model The model being validated.
	 */
	protected function get_is_valid_model( $model ): bool {
		$is_valid = $this->is_valid_model( $model );

		/**
		 * Filters whether or not the model is valid.
		 *
		 * This is useful when the dataloader is overridden and uses a different model than expected by default.
		 *
		 * @param bool  $is_valid Whether or not the model is valid.
		 * @param mixed $model    The model being validated
		 * @param self  $resolver The connection resolver instance
		 */
		return apply_filters( 'graphql_connection_is_valid_model', $is_valid, $model, $this );
	}

	/**
	 * Prepares the edges for the connection.
	 *
	 * @used-by self::get_edges()
	 *
	 * @param array<int|string,mixed|\WPGraphQL\Model\Model|null> $nodes The nodes for the connection.
	 *
	 * @return array<string,mixed>[]
	 */
	protected function prepare_edges( array $nodes ): array {
		// Bail early if there are no nodes.
		if ( empty( $nodes ) ) {
			return [];
		}

		// The nodes are already ordered, sliced, and populated. What's left is to populate the edge data for each one.
		$edges = [];
		foreach ( $nodes as $id => $node ) {
			$edge = $this->prepare_edge( $id, $node );

			/**
			 * Filter the edge within the connection.
			 *
			 * @param array<string,mixed> $edge     The edge within the connection
			 * @param self                $resolver Instance of the connection resolver class
			 */
			$edge = apply_filters(
				'graphql_connection_edge',
				$edge,
				$this
			);

			$edges[] = $edge;
		}

		return $edges;
	}

	/**
	 * Prepares a single edge for the connection.
	 *
	 * @used-by self::prepare_edges()
	 *
	 * @param int|string                        $id   The ID of the node.
	 * @param mixed|\WPGraphQL\Model\Model|null $node The node for the edge.
	 *
	 * @return array<string,mixed>
	 */
	protected function prepare_edge( $id, $node ): array {
		return [
			'cursor'     => $this->get_cursor_for_node( $id ),
			'node'       => $node,
			'source'     => $this->get_source(),
			'connection' => $this,
		];
	}

	/**
	 * Given an ID, a cursor is returned.
	 *
	 * @param int|string $id The ID to get the cursor for.
	 *
	 * @return string
	 */
	protected function get_cursor_for_node( $id ) {
		return base64_encode( 'arrayconnection:' . (string) $id );
	}

	/**
	 * Prepares the page info for the connection.
	 *
	 * @used-by self::get_page_info()
	 *
	 * @return array<string,mixed>
	 */
	protected function prepare_page_info(): array {
		return [
			'startCursor'     => $this->get_start_cursor(),
			'endCursor'       => $this->get_end_cursor(),
			'hasNextPage'     => $this->has_next_page(),
			'hasPreviousPage' => $this->has_previous_page(),
		];
	}

	/**
	 * Determine the start cursor from the connection
	 *
	 * @return mixed|string|null
	 */
	public function get_start_cursor() {
		$first_edge = $this->edges && ! empty( $this->edges ) ? $this->edges[0] : null;

		return isset( $first_edge['cursor'] ) ? $first_edge['cursor'] : null;
	}

	/**
	 * Determine the end cursor from the connection
	 *
	 * @return mixed|string|null
	 */
	public function get_end_cursor() {
		$last_edge = ! empty( $this->edges ) ? $this->edges[ count( $this->edges ) - 1 ] : null;

		return isset( $last_edge['cursor'] ) ? $last_edge['cursor'] : null;
	}

	/**
	 * Gets the offset for the `after` cursor.
	 *
	 * @return int|string|null
	 */
	public function get_after_offset() {
		// @todo This should use ::get_args() when b/c is not a concern.
		$args = $this->args;

		if ( ! empty( $args['after'] ) ) {
			return $this->get_offset_for_cursor( $args['after'] );
		}

		return null;
	}

	/**
	 * Gets the offset for the `before` cursor.
	 *
	 * @return int|string|null
	 */
	public function get_before_offset() {
		// @todo This should use ::get_args() when b/c is not a concern.
		$args = $this->args;

		if ( ! empty( $args['before'] ) ) {
			return $this->get_offset_for_cursor( $args['before'] );
		}

		return null;
	}

	/**
	 * Whether there is a next page in the connection.
	 *
	 * If there are more "items" than were asked for in the "first" argument or if there are more "items" after the "before" argument, has_next_page() will be set to true.
	 *
	 * @return bool
	 */
	public function has_next_page() {
		// @todo This should use ::get_ids() and ::get_args() when b/c is not a concern.
		$args = $this->args;

		if ( ! empty( $args['first'] ) ) {
			$ids = $this->ids;

			return ! empty( $ids ) && count( $ids ) > $this->get_query_amount();
		}

		$before_offset = $this->get_before_offset();

		if ( $before_offset ) {
			return $this->is_valid_offset( $before_offset );
		}

		return false;
	}

	/**
	 * Whether there is a previous page in the connection.
	 *
	 * If there are more "items" than were asked for in the "last" argument or if there are more "items" before the "after" argument, has_previous_page() will be set to true.
	 *
	 * @return bool
	 */
	public function has_previous_page() {
		// @todo This should use ::get_ids() and ::get_args() when b/c is not a concern.
		$args = $this->args;

		if ( ! empty( $args['last'] ) ) {
			$ids = $this->ids;

			return ! empty( $ids ) && count( $ids ) > $this->get_query_amount();
		}

		$after_offset = $this->get_after_offset();
		if ( $after_offset ) {
			return $this->is_valid_offset( $after_offset );
		}

		return false;
	}

	/**
	 * DEPRECATED METHODS
	 *
	 * These methods are deprecated and will be removed in a future release.
	 */

	/**
	 * Returns the $args passed to the connection
	 *
	 * @deprecated Deprecated since v1.11.0 in favor of $this->get_args();
	 *
	 * @return array<string,mixed>
	 *
	 * @codeCoverageIgnore
	 */
	public function getArgs(): array {
		_deprecated_function( __METHOD__, '1.11.0', static::class . '::get_args()' );
		return $this->get_args();
	}

	/**
	 * @param string $key   The key of the query arg to set
	 * @param mixed  $value The value of the query arg to set
	 *
	 * @return static
	 *
	 * @deprecated 0.3.0
	 *
	 * @codeCoverageIgnore
	 */
	public function setQueryArg( $key, $value ) {
		_deprecated_function( __METHOD__, '0.3.0', static::class . '::set_query_arg()' );

		return $this->set_query_arg( $key, $value );
	}

	/**
	 * Get_offset
	 *
	 * This returns the offset to be used in the $query_args based on the $args passed to the
	 * GraphQL query.
	 *
	 * @deprecated 1.9.0
	 *
	 * @codeCoverageIgnore
	 *
	 * @return int|mixed
	 */
	public function get_offset() {
		_deprecated_function( __METHOD__, '1.9.0', static::class . '::get_offset_for_cursor()' );

		// Using shorthand since this is for deprecated code.
		$cursor = $this->args['after'] ?? null;
		$cursor = $cursor ?: ( $this->args['before'] ?? null );

		return $this->get_offset_for_cursor( $cursor );
	}

	/**
	 * Returns the source of the connection.
	 *
	 * @deprecated 1.24.0 in favor of $this->get_source().
	 *
	 * @return mixed
	 */
	public function getSource() {
		_deprecated_function( __METHOD__, '1.24.0', static::class . '::get_source()' );

		return $this->get_source();
	}

	/**
	 * Returns the AppContext of the connection.
	 *
	 * @deprecated 1.24.0 in favor of $this->get_context().
	 */
	public function getContext(): AppContext {
		_deprecated_function( __METHOD__, '1.24.0', static::class . '::get_context()' );

		return $this->get_context();
	}

	/**
	 * Returns the ResolveInfo of the connection.
	 *
	 * @deprecated 1.24.0 in favor of $this->get_info().
	 */
	public function getInfo(): ResolveInfo {
		_deprecated_function( __METHOD__, '1.24.0', static::class . '::get_info()' );

		return $this->get_info();
	}

	/**
	 * Returns whether the connection should execute.
	 *
	 * @deprecated 1.24.0 in favor of $this->get_should_execute().
	 */
	public function getShouldExecute(): bool {
		_deprecated_function( __METHOD__, '1.24.0', static::class . '::should_execute()' );

		return $this->get_should_execute();
	}

	/**
	 * Returns the loader.
	 *
	 * @deprecated 1.24.0 in favor of $this->get_loader().
	 *
	 * @return \WPGraphQL\Data\Loader\AbstractDataLoader
	 */
	protected function getLoader() {
		_deprecated_function( __METHOD__, '1.24.0', static::class . '::get_loader()' );

		return $this->get_loader();
	}
}


// File: wp-graphql\src\Data\Connection\CommentConnectionResolver.php
<?php

namespace WPGraphQL\Data\Connection;

use GraphQL\Error\UserError;
use WPGraphQL\Utils\Utils;

/**
 * Class CommentConnectionResolver
 *
 * @package WPGraphQL\Data\Connection
 * @extends \WPGraphQL\Data\Connection\AbstractConnectionResolver<\WP_Comment_Query>
 */
class CommentConnectionResolver extends AbstractConnectionResolver {

	/**
	 * {@inheritDoc}
	 *
	 * @throws \GraphQL\Error\UserError
	 */
	protected function prepare_query_args( array $args ): array {
		/**
		 * Prepare for later use
		 */
		$last = ! empty( $args['last'] ) ? $args['last'] : null;

		$query_args = [];

		/**
		 * Don't calculate the total rows, it's not needed and can be expensive
		 */
		$query_args['no_found_rows'] = true;

		/**
		 * Set the default comment_status for Comment Queries to be "comment_approved"
		 */
		$query_args['status'] = 'approve';

		/**
		 * Set the number, ensuring it doesn't exceed the amount set as the $max_query_amount
		 *
		 * @since 0.0.6
		 */
		$query_args['number'] = $this->get_query_amount() + 1;

		/**
		 * Set the default order
		 */
		$query_args['orderby'] = 'comment_date';

		/**
		 * Take any of the $args that were part of the GraphQL query and map their
		 * GraphQL names to the WP_Term_Query names to be used in the WP_Term_Query
		 *
		 * @since 0.0.5
		 */
		$input_fields = [];
		if ( ! empty( $args['where'] ) ) {
			$input_fields = $this->sanitize_input_fields( $args['where'] );
		}

		/**
		 * Merge the default $query_args with the $args that were entered
		 * in the query.
		 *
		 * @since 0.0.5
		 */
		if ( ! empty( $input_fields ) ) {
			$query_args = array_merge( $query_args, $input_fields );
		}

		/**
		 * If the current user cannot moderate comments, do not include unapproved comments
		 */
		if ( ! current_user_can( 'moderate_comments' ) ) {
			$query_args['status']             = [ 'approve' ];
			$query_args['include_unapproved'] = get_current_user_id() ? [ get_current_user_id() ] : [];
			if ( empty( $query_args['include_unapproved'] ) ) {
				unset( $query_args['include_unapproved'] );
			}
		}

		/**
		 * Throw an exception if the query is attempted to be queried by
		 */
		if ( 'comment__in' === $query_args['orderby'] && empty( $query_args['comment__in'] ) ) {
			throw new UserError( esc_html__( 'In order to sort by comment__in, an array of IDs must be passed as the commentIn argument', 'wp-graphql' ) );
		}

		/**
		 * If there's no orderby params in the inputArgs, set order based on the first/last argument
		 */
		if ( empty( $query_args['order'] ) ) {
			$query_args['order'] = ! empty( $last ) ? 'ASC' : 'DESC';
		}

		/**
		 * Set the graphql_cursor_compare to determine
		 * whether the data is being paginated forward (>) or backward (<)
		 * default to forward
		 */
		$query_args['graphql_cursor_compare'] = ( isset( $last ) ) ? '>' : '<';

		// these args are used by the cursor builder to generate the proper SQL needed to respect the cursors
		$query_args['graphql_after_cursor']  = $this->get_after_offset();
		$query_args['graphql_before_cursor'] = $this->get_before_offset();

		/**
		 * Pass the graphql $args to the WP_Query
		 */
		$query_args['graphql_args'] = $args;

		// encode the graphql args as a cache domain to ensure the
		// graphql_args are used to identify different queries.
		// see: https://core.trac.wordpress.org/ticket/35075
		$encoded_args               = wp_json_encode( $args );
		$query_args['cache_domain'] = ! empty( $encoded_args ) ? 'graphql:' . md5( $encoded_args ) : 'graphql';

		/**
		 * We only want to query IDs because deferred resolution will resolve the full
		 * objects.
		 */
		$query_args['fields'] = 'ids';

		/**
		 * Filters the query args used by the connection.
		 *
		 * @param array<string,mixed>                  $query_args array of query_args being passed to the
		 * @param mixed                                $source     source passed down from the resolve tree
		 * @param array<string,mixed>                  $args       array of arguments input in the field as part of the GraphQL query
		 * @param \WPGraphQL\AppContext                $context object passed down the resolve tree
		 * @param \GraphQL\Type\Definition\ResolveInfo $info info about fields passed down the resolve tree
		 *
		 * @since 0.0.6
		 */
		return apply_filters( 'graphql_comment_connection_query_args', $query_args, $this->source, $args, $this->context, $this->info );
	}

	/**
	 * {@inheritDoc}
	 */
	protected function query_class(): string {
		return \WP_Comment_Query::class;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function loader_name(): string {
		return 'comment';
	}

	/**
	 * {@inheritDoc}
	 */
	public function get_ids_from_query() {
		/**
		 * @todo This is for b/c. We can just use $this->get_query().
		 */
		$queried  = isset( $this->query ) ? $this->query : $this->get_query();
		$comments = $queried->get_comments();

		/** @var int[]|string[] $ids */
		$ids = ! empty( $comments ) ? $comments : [];

		// If we're going backwards, we need to reverse the array.
		$args = $this->get_args();

		if ( ! empty( $args['last'] ) ) {
			$ids = array_reverse( $ids );
		}

		return $ids;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function prepare_args( array $args ): array {
		if ( ! empty( $args['where'] ) ) {
			// Ensure all IDs are converted to database IDs.
			foreach ( $args['where'] as $input_key => $input_value ) {
				if ( empty( $input_value ) ) {
					continue;
				}

				switch ( $input_key ) {
					case 'authorIn':
					case 'authorNotIn':
					case 'commentIn':
					case 'commentNotIn':
					case 'parentIn':
					case 'parentNotIn':
					case 'contentAuthorIn':
					case 'contentAuthorNotIn':
					case 'contentId':
					case 'contentIdIn':
					case 'contentIdNotIn':
					case 'contentAuthor':
					case 'userId':
						if ( is_array( $input_value ) ) {
							$args['where'][ $input_key ] = array_map(
								static function ( $id ) {
									return Utils::get_database_id_from_id( $id );
								},
								$input_value
							);
							break;
						}
						$args['where'][ $input_key ] = Utils::get_database_id_from_id( $input_value );
						break;
					case 'includeUnapproved':
						if ( is_string( $input_value ) ) {
							$input_value = [ $input_value ];
						}
						$args['where'][ $input_key ] = array_map(
							static function ( $id ) {
								if ( is_email( $id ) ) {
									return $id;
								}

								return Utils::get_database_id_from_id( $id );
							},
							$input_value
						);
						break;
				}
			}
		}

		/**
		 * Filters the GraphQL args before they are used in get_query_args().
		 *
		 * @param array<string,mixed> $args     The GraphQL args passed to the resolver.
		 * @param self                $resolver Instance of the ConnectionResolver
		 *
		 * @since 1.11.0
		 */
		return apply_filters( 'graphql_comment_connection_args', $args, $this );
	}

	/**
	 * This sets up the "allowed" args, and translates the GraphQL-friendly keys to
	 * WP_Comment_Query friendly keys.
	 *
	 * There's probably a cleaner/more dynamic way to approach this, but this was quick. I'd be
	 * down to explore more dynamic ways to map this, but for now this gets the job done.
	 *
	 * @param array<string,mixed> $args The array of query arguments
	 *
	 * @since  0.0.5
	 * @return array<string,mixed>
	 */
	public function sanitize_input_fields( array $args ) {
		$arg_mapping = [
			'authorEmail'        => 'author_email',
			'authorIn'           => 'author__in',
			'authorNotIn'        => 'author__not_in',
			'authorUrl'          => 'author_url',
			'commentIn'          => 'comment__in',
			'commentNotIn'       => 'comment__not_in',
			'commentType'        => 'type',
			'commentTypeIn'      => 'type__in',
			'commentTypeNotIn'   => 'type__not_in',
			'contentAuthor'      => 'post_author',
			'contentAuthorIn'    => 'post_author__in',
			'contentAuthorNotIn' => 'post_author__not_in',
			'contentId'          => 'post_id',
			'contentIdIn'        => 'post__in',
			'contentIdNotIn'     => 'post__not_in',
			'contentName'        => 'post_name',
			'contentParent'      => 'post_parent',
			'contentStatus'      => 'post_status',
			'contentType'        => 'post_type',
			'includeUnapproved'  => 'include_unapproved',
			'parentIn'           => 'parent__in',
			'parentNotIn'        => 'parent__not_in',
			'userId'             => 'user_id',
		];

		/**
		 * Map and sanitize the input args to the WP_Comment_Query compatible args
		 */
		$query_args = Utils::map_input( $args, $arg_mapping );

		/**
		 * Filter the input fields
		 *
		 * This allows plugins/themes to hook in and alter what $args should be allowed to be passed
		 * from a GraphQL Query to the get_terms query
		 *
		 * @since 0.0.5
		 */
		$query_args = apply_filters( 'graphql_map_input_fields_to_wp_comment_query', $query_args, $args, $this->source, $this->get_args(), $this->context, $this->info );

		return ! empty( $query_args ) && is_array( $query_args ) ? $query_args : [];
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param int $offset The ID of the node used for the cursor offset.
	 */
	public function is_valid_offset( $offset ) {
		return ! empty( get_comment( $offset ) );
	}
}


// File: wp-graphql\src\Data\Connection\ContentTypeConnectionResolver.php
<?php
namespace WPGraphQL\Data\Connection;

/**
 * Class ContentTypeConnectionResolver
 *
 * @package WPGraphQL\Data\Connection
 * @extends \WPGraphQL\Data\Connection\AbstractConnectionResolver<string[]>
 */
class ContentTypeConnectionResolver extends AbstractConnectionResolver {
	/**
	 * {@inheritDoc}
	 */
	public function get_ids_from_query() {
		$ids     = [];
		$queried = $this->query;

		if ( empty( $queried ) ) {
			return $ids;
		}

		foreach ( $queried as $item ) {
			$ids[] = $item;
		}

		return $ids;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function prepare_query_args( array $args ): array {
		// If any args are added to filter/sort the connection
		return [];
	}

	/**
	 * {@inheritDoc}
	 */
	protected function query( array $query_args ) {
		if ( isset( $query_args['contentTypeNames'] ) && is_array( $query_args['contentTypeNames'] ) ) {
			return $query_args['contentTypeNames'];
		}

		if ( isset( $query_args['name'] ) ) {
			return [ $query_args['name'] ];
		}

		return \WPGraphQL::get_allowed_post_types( 'names', $query_args );
	}

	/**
	 * {@inheritDoc}
	 */
	protected function loader_name(): string {
		return 'post_type';
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param string $offset The offset (post type name) to check.
	 */
	public function is_valid_offset( $offset ) {
		return (bool) get_post_type_object( $offset );
	}
}


// File: wp-graphql\src\Data\Connection\EnqueuedScriptsConnectionResolver.php
<?php
namespace WPGraphQL\Data\Connection;

/**
 * Class EnqueuedScriptsConnectionResolver
 *
 * @package WPGraphQL\Data\Connection
 * @extends \WPGraphQL\Data\Connection\AbstractConnectionResolver<string[]>
 */
class EnqueuedScriptsConnectionResolver extends AbstractConnectionResolver {
	/**
	 * {@inheritDoc}
	 */
	public function get_ids_from_query() {
		$ids     = [];
		$queried = $this->get_query();

		if ( empty( $queried ) ) {
			return $ids;
		}

		foreach ( $queried as $key => $item ) {
			$ids[ $key ] = $item;
		}

		return $ids;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function prepare_query_args( array $args ): array {
		// If any args are added to filter/sort the connection
		return [];
	}

	/**
	 * {@inheritDoc}
	 */
	protected function query( array $query_args ) {
		return $this->source->enqueuedScriptsQueue ? $this->source->enqueuedScriptsQueue : [];
	}

	/**
	 * {@inheritDoc}
	 */
	protected function loader_name(): string {
		return 'enqueued_script';
	}

	/**
	 * {@inheritDoc}
	 */
	protected function max_query_amount(): int {
		return 1000;
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param ?\_WP_Dependency $model The model to check.
	 */
	protected function is_valid_model( $model ) {
		return isset( $model->handle );
	}

	/**
	 * {@inheritDoc}
	 */
	public function is_valid_offset( $offset ) {
		global $wp_scripts;
		return isset( $wp_scripts->registered[ $offset ] );
	}
}


// File: wp-graphql\src\Data\Connection\EnqueuedStylesheetConnectionResolver.php
<?php
namespace WPGraphQL\Data\Connection;

/**
 * Class EnqueuedStylesheetConnectionResolver
 *
 * @package WPGraphQL\Data\Connection
 * @extends \WPGraphQL\Data\Connection\AbstractConnectionResolver<string[]>
 */
class EnqueuedStylesheetConnectionResolver extends AbstractConnectionResolver {
	/**
	 * {@inheritDoc}
	 */
	public function get_ids_from_query() {
		$ids     = [];
		$queried = $this->get_query();

		if ( empty( $queried ) ) {
			return $ids;
		}

		foreach ( $queried as $key => $item ) {
			$ids[ $key ] = $item;
		}

		return $ids;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function prepare_query_args( array $args ): array {
		// If any args are added to filter/sort the connection
		return [];
	}

	/**
	 * {@inheritDoc}
	 */
	protected function query( array $query_args ) {
		return $this->source->enqueuedStylesheetsQueue ? $this->source->enqueuedStylesheetsQueue : [];
	}

	/**
	 * {@inheritDoc}
	 */
	protected function loader_name(): string {
		return 'enqueued_stylesheet';
	}

	/**
	 * {@inheritDoc}
	 */
	protected function max_query_amount(): int {
		return 1000;
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param ?\_WP_Dependency $model
	 */
	protected function is_valid_model( $model ) {
		return isset( $model->handle );
	}

	/**
	 * {@inheritDoc}
	 */
	public function is_valid_offset( $offset ) {
		global $wp_styles;
		return isset( $wp_styles->registered[ $offset ] );
	}
}


// File: wp-graphql\src\Data\Connection\MenuConnectionResolver.php
<?php

namespace WPGraphQL\Data\Connection;

/**
 * Class MenuConnectionResolver
 *
 * @package WPGraphQL\Data\Connection
 */
class MenuConnectionResolver extends TermObjectConnectionResolver {

	/**
	 * {@inheritDoc}
	 *
	 * @throws \Exception
	 */
	protected function prepare_query_args( array $args ): array {
		$term_args = [
			'hide_empty' => false,
			'include'    => [],
			'taxonomy'   => 'nav_menu',
			'fields'     => 'ids',
		];

		if ( ! empty( $args['where']['slug'] ) ) {
			$term_args['slug']    = $args['where']['slug'];
			$term_args['include'] = null;
		}

		$theme_locations = get_nav_menu_locations();

		// If a location is specified in the args, use it
		if ( ! empty( $args['where']['location'] ) ) {
			// Exclude unset and non-existent locations
			$term_args['include'] = ! empty( $theme_locations[ $args['where']['location'] ] ) ? $theme_locations[ $args['where']['location'] ] : -1;
			// If the current user cannot edit theme options
		} elseif ( ! current_user_can( 'edit_theme_options' ) ) {
			$term_args['include'] = array_values( $theme_locations );
		}

		if ( ! empty( $args['where']['id'] ) ) {
			$term_args['include'] = $args['where']['id'];
		}

		$query_args = parent::prepare_query_args( $args );

		return array_merge( $query_args, $term_args );
	}
}


// File: wp-graphql\src\Data\Connection\MenuItemConnectionResolver.php
<?php
namespace WPGraphQL\Data\Connection;

use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Utils\Utils;

/**
 * Class MenuItemConnectionResolver
 *
 * @package WPGraphQL\Data\Connection
 */
class MenuItemConnectionResolver extends PostObjectConnectionResolver {

	/**
	 * {@inheritDoc}
	 */
	public function __construct( $source, array $args, AppContext $context, ResolveInfo $info ) {
		parent::__construct( $source, $args, $context, $info, 'nav_menu_item' );
	}

	/**
	 * {@inheritDoc}
	 */
	protected function prepare_query_args( array $args ): array {
		/**
		 * Prepare for later use
		 */
		$last = ! empty( $args['last'] ) ? $args['last'] : null;

		$menu_locations = get_theme_mod( 'nav_menu_locations' );

		$query_args            = parent::prepare_query_args( $args );
		$query_args['orderby'] = 'menu_order';
		$query_args['order']   = isset( $last ) ? 'DESC' : 'ASC';

		if ( isset( $args['where']['parentDatabaseId'] ) ) {
			$query_args['meta_key']   = '_menu_item_menu_item_parent';
			$query_args['meta_value'] = (int) $args['where']['parentDatabaseId']; // phpcs:ignore WordPress.DB.SlowDBQuery.slow_db_query_meta_value
		}

		if ( ! empty( $args['where']['parentId'] ) || ( isset( $args['where']['parentId'] ) && 0 === (int) $args['where']['parentId'] ) ) {
			$query_args['meta_key']   = '_menu_item_menu_item_parent';
			$query_args['meta_value'] = $args['where']['parentId']; // phpcs:ignore WordPress.DB.SlowDBQuery.slow_db_query_meta_value
		}

		// Get unique list of location term IDs as the default limitation of locations to allow public queries for.
		// Public queries should only be allowed to query for Menu Items assigned to a Menu Location.
		$locations = is_array( $menu_locations ) && ! empty( $menu_locations ) ? array_unique( array_values( $menu_locations ) ) : [];

		// If the location argument is set, set the argument to the input argument
		if ( ! empty( $args['where']['location'] ) ) {
			$locations = isset( $menu_locations[ $args['where']['location'] ] ) ? [ $menu_locations[ $args['where']['location'] ] ] : []; // We use an empty array to prevent fetching all media items if the location has no items assigned.

		} elseif ( current_user_can( 'edit_theme_options' ) ) {
			// If the $locations are NOT set, let a user with proper capability query all menu items.
			$locations = null;
		}

		// Only query for menu items in assigned locations.
		if ( isset( $locations ) ) {

			// unset the location arg
			// we don't need this passed as a taxonomy parameter to wp_query
			unset( $query_args['location'] );

			$query_args['tax_query'][] = [
				'taxonomy'         => 'nav_menu',
				'field'            => 'term_id',
				'terms'            => $locations,
				'include_children' => false,
				'operator'         => 'IN',
			];
		}

		return $query_args;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function prepare_args( array $args ): array {
		if ( ! empty( $args['where'] ) ) {
			// Ensure all IDs are converted to database IDs.
			foreach ( $args['where'] as $input_key => $input_value ) {
				if ( empty( $input_value ) ) {
					continue;
				}

				switch ( $input_key ) {
					case 'parentId':
						$args['where'][ $input_key ] = Utils::get_database_id_from_id( $input_value );
						break;
				}
			}
		}

		/**
		 *
		 * Filters the GraphQL args before they are used in get_query_args().
		 *
		 * @param array<string,mixed> $args            The GraphQL args passed to the resolver.
		 * @param array<string,mixed> $unfiltered_args Array of arguments input in the field as part of the GraphQL query.
		 *
		 * @since 1.11.0
		 */
		return apply_filters( 'graphql_menu_item_connection_args', $args, $this->get_unfiltered_args() );
	}
}


// File: wp-graphql\src\Data\Connection\PluginConnectionResolver.php
<?php
namespace WPGraphQL\Data\Connection;

/**
 * Class PluginConnectionResolver - Connects plugins to other objects
 *
 * @package WPGraphQL\Data\Connection
 * @since 0.0.5
 * @extends \WPGraphQL\Data\Connection\AbstractConnectionResolver<array<string,array<string,mixed>>>
 */
class PluginConnectionResolver extends AbstractConnectionResolver {

	/**
	 * A list of all the installed plugins, keyed by their type.
	 *
	 * @var ?array{site:array<string,mixed>,mustuse:array<string,mixed>,dropins:array<string,mixed>}
	 */
	protected $all_plugins;

	/**
	 * {@inheritDoc}
	 */
	public function get_ids_from_query() {
		$ids     = [];
		$queried = ! empty( $this->query ) ? $this->query : [];

		if ( empty( $queried ) ) {
			return $ids;
		}

		foreach ( $queried as $key => $item ) {
			$ids[ $key ] = $key;
		}

		return $ids;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function prepare_query_args( array $args ): array {
		if ( ! empty( $args['where']['status'] ) ) {
			$args['where']['stati'] = [ $args['where']['status'] ];
		} elseif ( ! empty( $args['where']['stati'] ) && is_string( $args['where']['stati'] ) ) {
			$args['where']['stati'] = [ $args['where']['stati'] ];
		}

		return $args;
	}

	/**
	 * {@inheritDoc}
	 *
	 * @return array<string,array<string,mixed>>
	 */
	protected function query( array $query_args ) {
		// Get all plugins.
		$plugins = $this->get_all_plugins();

		$all_plugins = array_merge( $plugins['site'], $plugins['mustuse'], $plugins['dropins'] );

		// Bail early if no plugins.
		if ( empty( $all_plugins ) ) {
			return [];
		}

		// Holds the plugin names sorted by status. The other ` status =>  [ plugin_names ] ` will be added later.
		$plugins_by_status = [
			'mustuse' => array_flip( array_keys( $plugins['mustuse'] ) ),
			'dropins' => array_flip( array_keys( $plugins['mustuse'] ) ),
		];

		// Permissions.
		$can_update           = current_user_can( 'update_plugins' );
		$can_view_autoupdates = $can_update && function_exists( 'wp_is_auto_update_enabled_for_type' ) && wp_is_auto_update_enabled_for_type( 'plugin' );
		$show_network_plugins = apply_filters( 'show_network_active_plugins', current_user_can( 'manage_network_plugins' ) );

		// Store the plugin stati as array keys for performance.
		$active_stati = ! empty( $query_args['where']['stati'] ) ? array_flip( $query_args['where']['stati'] ) : [];

		// Get additional plugin info.
		$upgradable_list         = $can_update && isset( $active_stati['upgrade'] ) ? get_site_transient( 'update_plugins' ) : [];
		$recently_activated_list = isset( $active_stati['recently_activated'] ) ? get_site_option( 'recently_activated', [] ) : [];

		// Loop through the plugins, add additional data, and store them in $plugins_by_status.
		foreach ( $all_plugins as $plugin_file => $plugin_data ) {
			if ( ! file_exists( WP_PLUGIN_DIR . '/' . $plugin_file ) ) {
				unset( $all_plugins[ $plugin_file ] );
				continue;
			}

			// Handle multisite plugins.
			if ( is_multisite() && is_network_only_plugin( $plugin_file ) && ! is_plugin_active( $plugin_file ) ) {

				// Check for inactive network plugins.
				if ( $show_network_plugins ) {

					// add the plugin to the network_inactive and network_inactive list since "network_inactive" are considered inactive
					$plugins_by_status['inactive'][ $plugin_file ]         = $plugin_file;
					$plugins_by_status['network_inactive'][ $plugin_file ] = $plugin_file;
				} else {
					// Unset and skip to next plugin.
					unset( $all_plugins[ $plugin_file ] );
					continue;
				}
			} elseif ( is_plugin_active_for_network( $plugin_file ) ) {
				// Check for active network plugins.
				if ( $show_network_plugins ) {
					// add the plugin to the network_activated and active list, since "network_activated" are active
					$plugins_by_status['active'][ $plugin_file ]            = $plugin_file;
					$plugins_by_status['network_activated'][ $plugin_file ] = $plugin_file;
				} else {
					// Unset and skip to next plugin.
					unset( $all_plugins[ $plugin_file ] );
					continue;
				}
			}

			// Populate active/inactive lists.
			// @todo should this include MU/Dropins?
			if ( is_plugin_active( $plugin_file ) ) {
				$plugins_by_status['active'][ $plugin_file ] = $plugin_file;
			} else {
				$plugins_by_status['inactive'][ $plugin_file ] = $plugin_file;
			}

			// Populate recently activated list.
			if ( isset( $recently_activated_list[ $plugin_file ] ) ) {
				$plugins_by_status['recently_activated'][ $plugin_file ] = $plugin_file;
			}

			// Populate paused list.
			if ( is_plugin_paused( $plugin_file ) ) {
				$plugins_by_status['paused'][ $plugin_file ] = $plugin_file;
			}

			// Get update information.
			if ( $can_update && isset( $upgradable_list->response[ $plugin_file ] ) ) {
				// An update is available.
				$plugin_data['update'] = true;
				// Extra info if known.
				$plugin_data = array_merge( (array) $upgradable_list->response[ $plugin_file ], [ 'update-supported' => true ], $plugin_data );

				// Populate upgradable list.
				$plugins_by_status['upgrade'][ $plugin_file ] = $plugin_file;
			} elseif ( isset( $upgradable_list->no_update[ $plugin_file ] ) ) {
				$plugin_data = array_merge( (array) $upgradable_list->no_update[ $plugin_file ], [ 'update-supported' => true ], $plugin_data );
			} elseif ( empty( $plugin_data['update-supported'] ) ) {
				$plugin_data['update-supported'] = false;
			}

			// Get autoupdate information.
			if ( $can_view_autoupdates ) {
				/*
				* Create the payload that's used for the auto_update_plugin filter.
				* This is the same data contained within $upgradable_list->(response|no_update) however
				* not all plugins will be contained in those keys, this avoids unexpected warnings.
				*/
				$filter_payload = [
					'id'            => $plugin_file,
					'slug'          => '',
					'plugin'        => $plugin_file,
					'new_version'   => '',
					'url'           => '',
					'package'       => '',
					'icons'         => [],
					'banners'       => [],
					'banners_rtl'   => [],
					'tested'        => '',
					'requires_php'  => '',
					'compatibility' => new \stdClass(),
				];
				$filter_payload = (object) wp_parse_args( $plugin_data, $filter_payload );

				if ( function_exists( 'wp_is_auto_update_forced_for_item' ) ) {
					$auto_update_forced                = wp_is_auto_update_forced_for_item( 'plugin', null, $filter_payload );
					$plugin_data['auto-update-forced'] = $auto_update_forced;
				}
			}

			// Save any changes to the plugin data.
			$all_plugins[ $plugin_file ] = $plugin_data;
		}

		$plugins_by_status['all'] = array_flip( array_keys( $all_plugins ) );

		/**
		 * Filters the plugins by status.
		 * */
		$filtered_plugins = ! empty( $active_stati ) ? array_values( array_intersect_key( $plugins_by_status, $active_stati ) ) : [];
		// If plugins exist for the filter, flatten and return them. Otherwise, return the full list.
		$filtered_plugins = ! empty( $filtered_plugins ) ? array_merge( [], ...$filtered_plugins ) : $plugins_by_status['all'];

		if ( ! empty( $query_args['where']['search'] ) ) {
			// Filter by search args.
			$s       = sanitize_text_field( $query_args['where']['search'] );
			$matches = array_keys(
				array_filter(
					$all_plugins,
					static function ( $plugin ) use ( $s ) {
						foreach ( $plugin as $value ) {
							if ( is_string( $value ) && false !== stripos( wp_strip_all_tags( $value ), $s ) ) {
								return true;
							}
						}

						return false;
					}
				)
			);
			if ( ! empty( $matches ) ) {
				$filtered_plugins = array_intersect_key( $filtered_plugins, array_flip( $matches ) );
			}
		}

		// Return plugin data filtered by args.
		return ! empty( $filtered_plugins ) ? array_intersect_key( $all_plugins, $filtered_plugins ) : [];
	}

	/**
	 * {@inheritDoc}
	 */
	protected function loader_name(): string {
		return 'plugin';
	}

	/**
	 * {@inheritDoc}
	 */
	public function is_valid_offset( $offset ) {
		$plugins = $this->get_all_plugins();

		$all_plugins = array_merge( $plugins['site'], $plugins['mustuse'], $plugins['dropins'] );

		return array_key_exists( $offset, $all_plugins );
	}

	/**
	 * {@inheritDoc}
	 */
	public function should_execute() {
		if ( is_multisite() ) {
			// update_, install_, and delete_ are handled above with is_super_admin().
			$menu_perms = get_site_option( 'menu_items', [] );
			if ( empty( $menu_perms['plugins'] ) && ! current_user_can( 'manage_network_plugins' ) ) {
				return false;
			}
		} elseif ( ! current_user_can( 'activate_plugins' ) ) {
			return false;
		}

		return true;
	}

	/**
	 * Gets all the installed plugins, including must use and drop in plugins.
	 *
	 * The result is cached in the ConnectionResolver instance.
	 *
	 * @return array{site:array<string,mixed>,mustuse:array<string,mixed>,dropins:array<string,mixed>}
	 */
	protected function get_all_plugins(): array {
		if ( ! isset( $this->all_plugins ) ) {
			// File has not loaded.
			require_once ABSPATH . 'wp-admin/includes/plugin.php';

			// This is missing must use and drop in plugins, so we need to fetch and merge them separately.
			$site_plugins   = apply_filters( 'all_plugins', get_plugins() );
			$mu_plugins     = apply_filters( 'show_advanced_plugins', true, 'mustuse' ) ? get_mu_plugins() : [];
			$dropin_plugins = apply_filters( 'show_advanced_plugins', true, 'dropins' ) ? get_dropins() : [];

			$this->all_plugins = [
				'site'    => is_array( $site_plugins ) ? $site_plugins : [],
				'mustuse' => $mu_plugins,
				'dropins' => $dropin_plugins,
			];
		}

		return $this->all_plugins;
	}
}


// File: wp-graphql\src\Data\Connection\PostObjectConnectionResolver.php
<?php

namespace WPGraphQL\Data\Connection;

use GraphQL\Error\InvariantViolation;
use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Model\Post;
use WPGraphQL\Utils\Utils;

/**
 * Class PostObjectConnectionResolver
 *
 * @package WPGraphQL\Data\Connection
 * @extends \WPGraphQL\Data\Connection\AbstractConnectionResolver<\WP_Query>
 */
class PostObjectConnectionResolver extends AbstractConnectionResolver {

	/**
	 * The name of the post type, or array of post types the connection resolver is resolving for
	 *
	 * @var mixed|string|string[]
	 */
	protected $post_type;

	/**
	 * {@inheritDoc}
	 *
	 * @param mixed|string|string[] $post_type The post type to resolve for
	 */
	public function __construct( $source, array $args, AppContext $context, ResolveInfo $info, $post_type = 'any' ) {

		/**
		 * The $post_type can either be a single value or an array of post_types to
		 * pass to WP_Query.
		 *
		 * If the value is revision or attachment, we will leave the value
		 * as a string, as we validate against this later.
		 *
		 * If the value is anything else, we cast as an array. For example
		 *
		 * $post_type = 'post' would become [ 'post ' ], as we check later
		 * for `in_array()` if the $post_type is not "attachment" or "revision"
		 */
		if ( 'revision' === $post_type || 'attachment' === $post_type ) {
			$this->post_type = $post_type;
		} elseif ( 'any' === $post_type ) {
			$post_types      = \WPGraphQL::get_allowed_post_types();
			$this->post_type = ! empty( $post_types ) ? array_values( $post_types ) : [];
		} else {
			$post_type = is_array( $post_type ) ? $post_type : [ $post_type ];
			unset( $post_type['attachment'] );
			unset( $post_type['revision'] );
			$this->post_type = $post_type;
		}

		/**
		 * Call the parent construct to setup class data
		 */
		parent::__construct( $source, $args, $context, $info );
	}

	/**
	 * {@inheritDoc}
	 */
	protected function loader_name(): string {
		return 'post';
	}

	/**
	 * {@inheritDoc}
	 */
	protected function query_class(): string {
		return \WP_Query::class;
	}

	/**
	 * {@inheritDoc}
	 *
	 * @throws \GraphQL\Error\InvariantViolation If the query has been modified to suppress_filters.
	 */
	protected function query( array $query_args ) {
		$query = parent::query( $query_args );

		if ( isset( $query->query_vars['suppress_filters'] ) && true === $query->query_vars['suppress_filters'] ) {
			throw new InvariantViolation( esc_html__( 'WP_Query has been modified by a plugin or theme to suppress_filters, which will cause issues with WPGraphQL Execution. If you need to suppress filters for a specific reason within GraphQL, consider registering a custom field to the WPGraphQL Schema with a custom resolver.', 'wp-graphql' ) );
		}

		return $query;
	}

	/**
	 * {@inheritDoc}
	 */
	public function get_ids_from_query() {
		/**
		 * @todo This is for b/c. We can just use $this->get_query().
		 */
		$query = isset( $this->query ) ? $this->query : $this->get_query();

		/** @var int[] */
		$ids = ! empty( $query->posts ) ? $query->posts : [];

		// If we're going backwards, we need to reverse the array.
		$args = $this->get_args();

		if ( ! empty( $args['last'] ) ) {
			$ids = array_reverse( $ids );
		}

		return $ids;
	}

	/**
	 * {@inheritDoc}
	 */
	public function should_execute() {
		/**
		 * If the post_type is not revision we can just return the parent::should_execute().
		 *
		 * @todo This works because AbstractConnectionResolver::pre_should_execute does a permission check on the `Post` model )
		 */
		if ( ! isset( $this->post_type ) || 'revision' !== $this->post_type ) {
			return parent::should_execute();
		}

		// If the connection is from the RootQuery (i.e. it doesn't have a `Post` source), check if the user has the 'edit_posts' capability.
		if ( ! $this->source instanceof Post && current_user_can( 'edit_posts' ) ) {
			return true;
		}

		// For revisions, we only want to execute the connection query if the user has access to edit the parent post.
		if ( $this->source instanceof Post ) {
			$parent_post_type_obj = get_post_type_object( $this->source->post_type );

			if ( isset( $parent_post_type_obj->cap->edit_post ) && current_user_can( $parent_post_type_obj->cap->edit_post, $this->source->ID ) ) {
				return true;
			}
		}

		return false;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function prepare_query_args( array $args ): array {
		/**
		 * Prepare for later use
		 */
		$last = ! empty( $args['last'] ) ? $args['last'] : null;

		$query_args = [];
		/**
		 * Ignore sticky posts by default
		 */
		$query_args['ignore_sticky_posts'] = true;

		/**
		 * Set the post_type for the query based on the type of post being queried
		 */
		$query_args['post_type'] = ! empty( $this->post_type ) ? $this->post_type : 'post';

		/**
		 * Don't calculate the total rows, it's not needed and can be expensive
		 */
		$query_args['no_found_rows'] = true;

		/**
		 * Set the post_status to "publish" by default
		 */
		$query_args['post_status'] = 'publish';

		/**
		 * Set posts_per_page the highest value of $first and $last, with a (filterable) max of 100
		 */
		$query_args['posts_per_page'] = $this->one_to_one ? 1 : $this->get_query_amount() + 1;

		// set the graphql cursor args
		$query_args['graphql_cursor_compare'] = ! empty( $last ) ? '>' : '<';
		$query_args['graphql_after_cursor']   = $this->get_after_offset();
		$query_args['graphql_before_cursor']  = $this->get_before_offset();

		/**
		 * If the cursor offsets not empty,
		 * ignore sticky posts on the query
		 */
		if ( ! empty( $this->get_after_offset() ) || ! empty( $this->get_after_offset() ) ) {
			$query_args['ignore_sticky_posts'] = true;
		}

		/**
		 * Pass the graphql $args to the WP_Query
		 */
		$query_args['graphql_args'] = $args;

		/**
		 * Collect the input_fields and sanitize them to prepare them for sending to the WP_Query
		 */
		$input_fields = [];
		if ( ! empty( $args['where'] ) ) {
			$input_fields = $this->sanitize_input_fields( $args['where'] );
		}

		/**
		 * If the post_type is "attachment" set the default "post_status" $query_arg to "inherit"
		 */
		if ( 'attachment' === $this->post_type || 'revision' === $this->post_type ) {
			$query_args['post_status'] = 'inherit';
		}

		/**
		 * Unset the "post_parent" for attachments, as we don't really care if they
		 * have a post_parent set by default
		 */
		if ( 'attachment' === $this->post_type && isset( $input_fields['parent'] ) ) {
			unset( $input_fields['parent'] );
		}

		/**
		 * Merge the input_fields with the default query_args
		 */
		if ( ! empty( $input_fields ) ) {
			$query_args = array_merge( $query_args, $input_fields );
		}

		/**
		 * If the query is a search, the source is not another Post, and the parent input $arg is not
		 * explicitly set in the query, unset the $query_args['post_parent'] so the search
		 * can search all posts, not just top level posts.
		 */
		if ( ! $this->source instanceof \WP_Post && isset( $query_args['search'] ) && ! isset( $input_fields['parent'] ) ) {
			unset( $query_args['post_parent'] );
		}

		/**
		 * If the query contains search default the results to
		 */
		if ( isset( $query_args['search'] ) && ! empty( $query_args['search'] ) ) {
			/**
			 * Don't order search results by title (causes funky issues with cursors)
			 */
			$query_args['search_orderby_title'] = false;
			$query_args['orderby']              = 'date';
			$query_args['order']                = isset( $last ) ? 'ASC' : 'DESC';
		}

		if ( empty( $args['where']['orderby'] ) && ! empty( $query_args['post__in'] ) ) {
			$post_in = $query_args['post__in'];
			// Make sure the IDs are integers
			$post_in = array_map(
				static function ( $id ) {
					return absint( $id );
				},
				$post_in
			);

			// If we're coming backwards, let's reverse the IDs
			if ( ! empty( $args['last'] ) || ! empty( $args['before'] ) ) {
				$post_in = array_reverse( $post_in );
			}

			$cursor_offset = $this->get_offset_for_cursor( $args['after'] ?? ( $args['before'] ?? 0 ) );

			if ( ! empty( $cursor_offset ) ) {
				// Determine if the offset is in the array
				$key = array_search( $cursor_offset, $post_in, true );

				// If the offset is in the array
				if ( false !== $key ) {
					$key     = absint( $key );
					$post_in = array_slice( $post_in, $key + 1, null, true );
				}
			}

			$query_args['post__in'] = $post_in;
			$query_args['orderby']  = 'post__in';
			$query_args['order']    = isset( $last ) ? 'ASC' : 'DESC';
		}

		/**
		 * Map the orderby inputArgs to the WP_Query
		 */
		if ( isset( $args['where']['orderby'] ) && is_array( $args['where']['orderby'] ) ) {
			$query_args['orderby'] = [];

			foreach ( $args['where']['orderby'] as $orderby_input ) {
				// Create a type hint for orderby_input. This is an array with a field and order key.
				/** @var array<string,string> $orderby_input */
				if ( empty( $orderby_input['field'] ) ) {
					continue;
				}

				/**
				 * These orderby options should not include the order parameter.
				 */
				if ( in_array(
					$orderby_input['field'],
					[
						'post__in',
						'post_name__in',
						'post_parent__in',
					],
					true
				) ) {
					$query_args['orderby'] = esc_sql( $orderby_input['field'] );

					// If we're ordering explicitly, there's no reason to check other orderby inputs.
					break;
				}

				$order = $orderby_input['order'];

				if ( isset( $query_args['graphql_args']['last'] ) && ! empty( $query_args['graphql_args']['last'] ) ) {
					if ( 'ASC' === $order ) {
						$order = 'DESC';
					} else {
						$order = 'ASC';
					}
				}

				$query_args['orderby'][ esc_sql( $orderby_input['field'] ) ] = esc_sql( $order );
			}
		}

		/**
		 * Convert meta_value_num to separate meta_value value field which our
		 * graphql_wp_term_query_cursor_pagination_support knowns how to handle
		 */
		if ( isset( $query_args['orderby'] ) && 'meta_value_num' === $query_args['orderby'] ) {
			$query_args['orderby'] = [
				'meta_value' => empty( $query_args['order'] ) ? 'DESC' : $query_args['order'], // phpcs:ignore WordPress.DB.SlowDBQuery.slow_db_query_meta_value
			];
			unset( $query_args['order'] );
			$query_args['meta_type'] = 'NUMERIC';
		}

		/**
		 * If there's no orderby params in the inputArgs, set order based on the first/last argument
		 */
		if ( empty( $query_args['orderby'] ) ) {
			$query_args['order'] = ! empty( $last ) ? 'ASC' : 'DESC';
		}

		/**
		 * NOTE: Only IDs should be queried here as the Deferred resolution will handle
		 * fetching the full objects, either from cache of from a follow-up query to the DB
		 */
		$query_args['fields'] = 'ids';

		/**
		 * Filter the $query args to allow folks to customize queries programmatically
		 *
		 * @param array<string,mixed>                  $query_args The args that will be passed to the WP_Query
		 * @param mixed                                $source     The source that's passed down the GraphQL queries
		 * @param array<string,mixed>                  $args       The inputArgs on the field
		 * @param \WPGraphQL\AppContext                $context    The AppContext passed down the GraphQL tree
		 * @param \GraphQL\Type\Definition\ResolveInfo $info       The ResolveInfo passed down the GraphQL tree
		 */
		return apply_filters( 'graphql_post_object_connection_query_args', $query_args, $this->source, $args, $this->context, $this->info );
	}

	/**
	 * This sets up the "allowed" args, and translates the GraphQL-friendly keys to WP_Query
	 * friendly keys. There's probably a cleaner/more dynamic way to approach this, but
	 * this was quick. I'd be down to explore more dynamic ways to map this, but for
	 * now this gets the job done.
	 *
	 * @param array<string,mixed> $where_args The args passed to the connection
	 *
	 * @return array<string,mixed>
	 * @since  0.0.5
	 */
	public function sanitize_input_fields( array $where_args ) {
		$arg_mapping = [
			'authorIn'      => 'author__in',
			'authorName'    => 'author_name',
			'authorNotIn'   => 'author__not_in',
			'categoryId'    => 'cat',
			'categoryIn'    => 'category__in',
			'categoryName'  => 'category_name',
			'categoryNotIn' => 'category__not_in',
			'contentTypes'  => 'post_type',
			'dateQuery'     => 'date_query',
			'hasPassword'   => 'has_password',
			'id'            => 'p',
			'in'            => 'post__in',
			'mimeType'      => 'post_mime_type',
			'nameIn'        => 'post_name__in',
			'notIn'         => 'post__not_in',
			'parent'        => 'post_parent',
			'parentIn'      => 'post_parent__in',
			'parentNotIn'   => 'post_parent__not_in',
			'password'      => 'post_password',
			'search'        => 's',
			'stati'         => 'post_status',
			'status'        => 'post_status',
			'tagId'         => 'tag_id',
			'tagIds'        => 'tag__and',
			'tagIn'         => 'tag__in',
			'tagNotIn'      => 'tag__not_in',
			'tagSlugAnd'    => 'tag_slug__and',
			'tagSlugIn'     => 'tag_slug__in',
		];

		/**
		 * Map and sanitize the input args to the WP_Query compatible args
		 */
		$query_args = Utils::map_input( $where_args, $arg_mapping );

		if ( ! empty( $query_args['post_status'] ) ) {
			$allowed_stati             = $this->sanitize_post_stati( $query_args['post_status'] );
			$query_args['post_status'] = ! empty( $allowed_stati ) ? $allowed_stati : [ 'publish' ];
		}

		/**
		 * Filter the input fields
		 * This allows plugins/themes to hook in and alter what $args should be allowed to be passed
		 * from a GraphQL Query to the WP_Query
		 *
		 * @param array<string,mixed>                  $query_args The mapped query arguments
		 * @param array<string,mixed>                  $args       Query "where" args
		 * @param mixed                                $source     The query results for a query calling this
		 * @param array<string,mixed>                  $all_args   All of the arguments for the query (not just the "where" args)
		 * @param \WPGraphQL\AppContext                $context    The AppContext object
		 * @param \GraphQL\Type\Definition\ResolveInfo $info       The ResolveInfo object
		 * @param mixed|string|string[]                $post_type  The post type for the query
		 *
		 * @since 0.0.5
		 */
		$query_args = apply_filters( 'graphql_map_input_fields_to_wp_query', $query_args, $where_args, $this->source, $this->get_args(), $this->context, $this->info, $this->post_type );

		/**
		 * Return the Query Args
		 */
		return ! empty( $query_args ) && is_array( $query_args ) ? $query_args : [];
	}

	/**
	 * Limit the status of posts a user can query.
	 *
	 * By default, published posts are public, and other statuses require permission to access.
	 *
	 * This strips the status from the query_args if the user doesn't have permission to query for
	 * posts of that status.
	 *
	 * @param string[]|string $stati The status(es) to sanitize.
	 *
	 * @return string[]|null
	 */
	public function sanitize_post_stati( $stati ) {
		/**
		 * If no stati is explicitly set by the input, default to publish. This will be the
		 * most common scenario.
		 */
		if ( empty( $stati ) ) {
			$stati = [ 'publish' ];
		}

		/**
		 * Parse the list of stati
		 */
		$statuses = wp_parse_slug_list( $stati );

		/**
		 * Get the Post Type object
		 */
		$post_type_objects = [];
		if ( is_array( $this->post_type ) ) {
			foreach ( $this->post_type as $post_type ) {
				$post_type_objects[] = get_post_type_object( $post_type );
			}
		} else {
			$post_type_objects[] = get_post_type_object( $this->post_type );
		}

		/**
		 * Make sure the statuses are allowed to be queried by the current user. If so, allow it,
		 * otherwise return null, effectively removing it from the $allowed_statuses that will
		 * be passed to WP_Query
		 */
		$allowed_statuses = array_filter(
			array_map(
				static function ( $status ) use ( $post_type_objects ) {
					foreach ( $post_type_objects as $post_type_object ) {
						if ( 'publish' === $status ) {
							return $status;
						}

						if ( 'private' === $status && ( ! isset( $post_type_object->cap->read_private_posts ) || ! current_user_can( $post_type_object->cap->read_private_posts ) ) ) {
							return null;
						}

						if ( ! isset( $post_type_object->cap->edit_posts ) || ! current_user_can( $post_type_object->cap->edit_posts ) ) {
							return null;
						}

						return $status;
					}
				},
				$statuses
			)
		);

		/**
		 * If there are no allowed statuses to pass to WP_Query, prevent the connection
		 * from executing
		 *
		 * For example, if a subscriber tries to query:
		 *
		 * {
		 *   posts( where: { stati: [ DRAFT ] } ) {
		 *     ...fields
		 *   }
		 * }
		 *
		 * We can safely prevent the execution of the query because they are asking for content
		 * in a status that we know they can't ask for.
		 */
		if ( empty( $allowed_statuses ) ) {
			$this->should_execute = false;
		}

		/**
		 * Return the $allowed_statuses to the query args
		 */
		return $allowed_statuses;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function prepare_args( array $args ): array {
		if ( ! empty( $args['where'] ) ) {
			// Ensure all IDs are converted to database IDs.
			foreach ( $args['where'] as $input_key => $input_value ) {
				if ( empty( $input_value ) ) {
					continue;
				}

				switch ( $input_key ) {
					case 'in':
					case 'notIn':
					case 'parent':
					case 'parentIn':
					case 'parentNotIn':
					case 'authorIn':
					case 'authorNotIn':
					case 'categoryIn':
					case 'categoryNotIn':
					case 'tagId':
					case 'tagIn':
					case 'tagNotIn':
						if ( is_array( $input_value ) ) {
							$args['where'][ $input_key ] = array_map(
								static function ( $id ) {
									return Utils::get_database_id_from_id( $id );
								},
								$input_value
							);
							break;
						}

						$args['where'][ $input_key ] = Utils::get_database_id_from_id( $input_value );
						break;
				}
			}
		}

		/**
		 * Filters the GraphQL args before they are used in get_query_args().
		 *
		 * @param array<string,mixed> $args            The GraphQL args passed to the resolver.
		 * @param self                $resolver        Instance of the ConnectionResolver.
		 * @param array<string,mixed> $unfiltered_args Array of arguments input in the field as part of the GraphQL query.
		 *
		 * @since 1.11.0
		 */
		return apply_filters( 'graphql_post_object_connection_args', $args, $this, $this->get_unfiltered_args() );
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param int $offset The ID of the node used in the cursor offset.
	 */
	public function is_valid_offset( $offset ) {
		return (bool) get_post( absint( $offset ) );
	}
}


// File: wp-graphql\src\Data\Connection\TaxonomyConnectionResolver.php
<?php
namespace WPGraphQL\Data\Connection;

/**
 * Class TaxonomyConnectionResolver
 *
 * @package WPGraphQL\Data\Connection
 * @extends \WPGraphQL\Data\Connection\AbstractConnectionResolver<string[]>
 */
class TaxonomyConnectionResolver extends AbstractConnectionResolver {

	/**
	 * {@inheritDoc}
	 */
	public function get_ids_from_query() {
		/**
		 * @todo This is for b/c. We can just use $this->get_query().
		 */
		$queried = isset( $this->query ) ? $this->query : $this->get_query();

		$ids = [];

		if ( empty( $queried ) ) {
			return $ids;
		}

		foreach ( $queried as $item ) {
			$ids[] = $item;
		}

		return $ids;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function prepare_query_args( array $args ): array {
		// If any args are added to filter/sort the connection.
		return [];
	}

	/**
	 * {@inheritDoc}
	 */
	protected function query( array $query_args ) {
		if ( isset( $query_args['name'] ) ) {
			return [ $query_args['name'] ];
		}

		if ( isset( $query_args['in'] ) ) {
			return is_array( $query_args['in'] ) ? $query_args['in'] : [ $query_args['in'] ];
		}

		return \WPGraphQL::get_allowed_taxonomies( 'names', $query_args );
	}

	/**
	 * {@inheritDoc}
	 */
	protected function loader_name(): string {
		return 'taxonomy';
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param string $offset The offset (taxonomy name) to check.
	 */
	public function is_valid_offset( $offset ) {
		return (bool) get_taxonomy( $offset );
	}
}


// File: wp-graphql\src\Data\Connection\TermObjectConnectionResolver.php
<?php

namespace WPGraphQL\Data\Connection;

use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Utils\Utils;

/**
 * Class TermObjectConnectionResolver
 *
 * @package WPGraphQL\Data\Connection
 * @extends \WPGraphQL\Data\Connection\AbstractConnectionResolver<\WP_Term_Query>
 */
class TermObjectConnectionResolver extends AbstractConnectionResolver {
	/**
	 * The name of the Taxonomy the resolver is intended to be used for
	 *
	 * @var string
	 */
	protected $taxonomy;

	/**
	 * {@inheritDoc}
	 *
	 * @param mixed|string|null $taxonomy The name of the Taxonomy the resolver is intended to be used for.
	 */
	public function __construct( $source, array $args, AppContext $context, ResolveInfo $info, $taxonomy = null ) {
		$this->taxonomy = $taxonomy;
		parent::__construct( $source, $args, $context, $info );
	}

	/**
	 * {@inheritDoc}
	 */
	protected function prepare_query_args( array $args ): array {
		$all_taxonomies = \WPGraphQL::get_allowed_taxonomies();
		$taxonomy       = ! empty( $this->taxonomy ) && in_array( $this->taxonomy, $all_taxonomies, true ) ? [ $this->taxonomy ] : $all_taxonomies;

		if ( ! empty( $args['where']['taxonomies'] ) ) {
			/**
			 * Set the taxonomy for the $args
			 */
			$requested_taxonomies = $args['where']['taxonomies'];
			$taxonomy             = array_intersect( $all_taxonomies, $requested_taxonomies );
		}

		$query_args = [
			'taxonomy' => $taxonomy,
		];

		/**
		 * Prepare for later use
		 */
		$last = ! empty( $args['last'] ) ? $args['last'] : null;

		/**
		 * Set hide_empty as false by default
		 */
		$query_args['hide_empty'] = false;

		/**
		 * Set the number, ensuring it doesn't exceed the amount set as the $max_query_amount
		 */
		$query_args['number'] = $this->get_query_amount() + 1;

		/**
		 * Don't calculate the total rows, it's not needed and can be expensive
		 */
		$query_args['count'] = false;

		/**
		 * Take any of the $args that were part of the GraphQL query and map their
		 * GraphQL names to the WP_Term_Query names to be used in the WP_Term_Query
		 *
		 * @since 0.0.5
		 */
		$input_fields = [];
		if ( ! empty( $args['where'] ) ) {
			$input_fields = $this->sanitize_input_fields();
		}

		/**
		 * Merge the default $query_args with the $args that were entered
		 * in the query.
		 *
		 * @since 0.0.5
		 */
		if ( ! empty( $input_fields ) ) {
			$query_args = array_merge( $query_args, $input_fields );
		}

		$query_args['graphql_cursor_compare'] = ( ! empty( $last ) ) ? '>' : '<';
		$query_args['graphql_after_cursor']   = $this->get_after_offset();
		$query_args['graphql_before_cursor']  = $this->get_before_offset();

		/**
		 * Pass the graphql $args to the WP_Query
		 */
		$query_args['graphql_args'] = $args;

		/**
		 * NOTE: We query for JUST the IDs here as deferred resolution of the nodes gets the full
		 * object from the cache or a follow-up request for the full object if it's not cached.
		 */
		$query_args['fields'] = 'ids';

		/**
		 * If there's no orderby params in the inputArgs, default to ordering by name.
		 */
		if ( empty( $query_args['orderby'] ) ) {
			$query_args['orderby'] = 'name';
		}

		/**
		 * If orderby params set but not order, default to ASC if going forward, DESC if going backward.
		 */
		if ( empty( $query_args['order'] ) && 'name' === $query_args['orderby'] ) {
			$query_args['order'] = ! empty( $last ) ? 'DESC' : 'ASC';
		} elseif ( empty( $query_args['order'] ) ) {
			$query_args['order'] = ! empty( $last ) ? 'ASC' : 'DESC';
		}

		/**
		 * Filters the query args used by the connection.
		 *
		 * @param array<string,mixed>                  $query_args array of query_args being passed to the
		 * @param mixed                                $source     source passed down from the resolve tree
		 * @param array<string,mixed>                  $args       array of arguments input in the field as part of the GraphQL query
		 * @param \WPGraphQL\AppContext                $context    object passed down the resolve tree
		 * @param \GraphQL\Type\Definition\ResolveInfo $info       info about fields passed down the resolve tree
		 *
		 * @since 0.0.6
		 */
		$query_args = apply_filters( 'graphql_term_object_connection_query_args', $query_args, $this->source, $args, $this->context, $this->info );

		return $query_args;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function query_class(): string {
		return \WP_Term_Query::class;
	}

	/**
	 * {@inheritDoc}
	 */
	public function get_ids_from_query() {
		/**
		 * @todo This is for b/c. We can just use $this->get_query().
		 */
		$queried = isset( $this->query ) ? $this->query : $this->get_query();

		/** @var string[] $ids */
		$ids = ! empty( $queried->get_terms() ) ? $queried->get_terms() : [];

		// If we're going backwards, we need to reverse the array.
		$args = $this->get_args();
		if ( ! empty( $args['last'] ) ) {
			$ids = array_reverse( $ids );
		}

		return $ids;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function loader_name(): string {
		return 'term';
	}

	/**
	 * This maps the GraphQL "friendly" args to get_terms $args.
	 * There's probably a cleaner/more dynamic way to approach this, but this was quick. I'd be down
	 * to explore more dynamic ways to map this, but for now this gets the job done.
	 *
	 * @since  0.0.5
	 * @return array<string,mixed>
	 */
	public function sanitize_input_fields() {
		$arg_mapping = [
			'objectIds'           => 'object_ids',
			'hideEmpty'           => 'hide_empty',
			'excludeTree'         => 'exclude_tree',
			'termTaxonomId'       => 'term_taxonomy_id',
			'termTaxonomyId'      => 'term_taxonomy_id',
			'nameLike'            => 'name__like',
			'descriptionLike'     => 'description__like',
			'padCounts'           => 'pad_counts',
			'childOf'             => 'child_of',
			'cacheDomain'         => 'cache_domain',
			'updateTermMetaCache' => 'update_term_meta_cache',
			'taxonomies'          => 'taxonomy',
		];

		$args       = $this->get_args();
		$where_args = ! empty( $args['where'] ) ? $args['where'] : null;

		// Deprecate usage of 'termTaxonomId'.
		if ( ! empty( $where_args['termTaxonomId'] ) ) {
			_deprecated_argument( 'where.termTaxonomId', '1.11.0', 'The `termTaxonomId` where arg is deprecated. Use `termTaxonomyId` instead.' );

			// Only convert value if 'termTaxonomyId' isnt already set.
			if ( empty( $where_args['termTaxonomyId'] ) ) {
				$where_args['termTaxonomyId'] = $where_args['termTaxonomId'];
			}
		}

		/**
		 * Map and sanitize the input args to the WP_Term_Query compatible args
		 */
		$query_args = Utils::map_input( $where_args, $arg_mapping );

		/**
		 * Filter the input fields
		 * This allows plugins/themes to hook in and alter what $args should be allowed to be passed
		 * from a GraphQL Query to the get_terms query
		 *
		 * @param array<string,mixed>                  $query_args Array of mapped query args
		 * @param array<string,mixed>                  $where_args Array of query "where" args
		 * @param string                               $taxonomy   The name of the taxonomy
		 * @param mixed                                $source     The query results
		 * @param array<string,mixed>                  $all_args   All of the query arguments (not just the "where" args)
		 * @param \WPGraphQL\AppContext                $context   The AppContext object
		 * @param \GraphQL\Type\Definition\ResolveInfo $info      The ResolveInfo object
		 *
		 * @since 0.0.5
		 */
		$query_args = apply_filters( 'graphql_map_input_fields_to_get_terms', $query_args, $where_args, $this->taxonomy, $this->source, $args, $this->context, $this->info );

		return ! empty( $query_args ) && is_array( $query_args ) ? $query_args : [];
	}

	/**
	 * {@inheritDoc}
	 */
	protected function prepare_args( array $args ): array {
		if ( ! empty( $args['where'] ) ) {
			// Ensure all IDs are converted to database IDs.
			foreach ( $args['where'] as $input_key => $input_value ) {
				if ( empty( $input_value ) ) {
					continue;
				}

				switch ( $input_key ) {
					case 'exclude':
					case 'excludeTree':
					case 'include':
					case 'objectIds':
					case 'termTaxonomId':
					case 'termTaxonomyId':
						if ( is_array( $input_value ) ) {
							$args['where'][ $input_key ] = array_map(
								static function ( $id ) {
									return Utils::get_database_id_from_id( $id );
								},
								$input_value
							);
							break;
						}

						$args['where'][ $input_key ] = Utils::get_database_id_from_id( $input_value );
						break;
				}
			}
		}

		/**
		 * Filters the GraphQL args before they are used in get_query_args().
		 *
		 * @param array<string,mixed> $args            The GraphQL args passed to the resolver.
		 * @param self                $resolver        Instance of the ConnectionResolver.
		 * @param array<string,mixed> $unfiltered_args Array of arguments input in the field as part of the GraphQL query.
		 *
		 * @since 1.11.0
		 */
		return apply_filters( 'graphql_term_object_connection_args', $args, $this, $this->get_unfiltered_args() );
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param int $offset The ID of the node used in the cursor for offset.
	 */
	public function is_valid_offset( $offset ) {
		return get_term( absint( $offset ) ) instanceof \WP_Term;
	}
}


// File: wp-graphql\src\Data\Connection\ThemeConnectionResolver.php
<?php
namespace WPGraphQL\Data\Connection;

/**
 * Class ThemeConnectionResolver
 *
 * @package WPGraphQL\Data\Resolvers
 * @since 0.5.0
 * @extends \WPGraphQL\Data\Connection\AbstractConnectionResolver<string[]>
 */
class ThemeConnectionResolver extends AbstractConnectionResolver {
	/**
	 * {@inheritDoc}
	 */
	public function get_ids_from_query() {
		/**
		 * @todo This is for b/c. We can just use $this->get_query().
		 */
		$queried = isset( $this->query ) ? $this->query : $this->get_query();

		$ids = [];

		if ( empty( $queried ) ) {
			return $ids;
		}

		foreach ( $queried as $key => $item ) {
			$ids[ $key ] = $item;
		}

		return $ids;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function prepare_query_args( array $args ): array {
		return [
			'allowed' => null,
		];
	}

	/**
	 * {@inheritDoc}
	 */
	protected function query( array $query_args ) {
		return array_keys( wp_get_themes( $query_args ) );
	}

	/**
	 * {@inheritDoc}
	 */
	protected function loader_name(): string {
		return 'theme';
	}

	/**
	 * {@inheritDoc}
	 */
	public function is_valid_offset( $offset ) {
		$theme = wp_get_theme( $offset );
		return $theme->exists();
	}
}


// File: wp-graphql\src\Data\Connection\UserConnectionResolver.php
<?php

namespace WPGraphQL\Data\Connection;

use GraphQL\Error\UserError;
use WPGraphQL\Utils\Utils;

/**
 * Class UserConnectionResolver
 *
 * @package WPGraphQL\Data\Connection
 * @extends \WPGraphQL\Data\Connection\AbstractConnectionResolver<\WP_User_Query>
 */
class UserConnectionResolver extends AbstractConnectionResolver {
	/**
	 * {@inheritDoc}
	 */
	protected function loader_name(): string {
		return 'user';
	}

	/**
	 * {@inheritDoc}
	 *
	 * @throws \Exception
	 */
	protected function prepare_query_args( array $args ): array {
		$query_args = [];

		/**
		 * Prepare for later use
		 */
		$last = ! empty( $args['last'] ) ? $args['last'] : null;

		/**
		 * Set the $query_args based on various defaults and primary input $args
		 */
		$query_args['count_total'] = false;

		/**
		 * Pass the graphql $args to the WP_Query
		 */
		$query_args['graphql_args'] = $args;

		/**
		 * Set the graphql_cursor_compare to determine what direction the
		 * query should be paginated
		 */
		$query_args['graphql_cursor_compare'] = ( ! empty( $last ) ) ? '>' : '<';

		$query_args['graphql_after_cursor']  = $this->get_after_offset();
		$query_args['graphql_before_cursor'] = $this->get_before_offset();

		/**
		 * Set the number, ensuring it doesn't exceed the amount set as the $max_query_amount
		 *
		 * We query one extra than what is being asked for so that we can determine if there is a next
		 * page.
		 */
		$query_args['number'] = $this->get_query_amount() + 1;

		/**
		 * Take any of the input $args (under the "where" input) that were part of the GraphQL query and map and
		 * sanitize their GraphQL input to apply to the WP_Query
		 */
		$input_fields = [];
		if ( ! empty( $args['where'] ) ) {
			$input_fields = $this->sanitize_input_fields( $args['where'] );
		}

		/**
		 * Merge the default $query_args with the $args that were entered in the query.
		 *
		 * @since 0.0.5
		 */
		if ( ! empty( $input_fields ) ) {
			$query_args = array_merge( $query_args, $input_fields );
		}

		/**
		 * Only query the IDs and let deferred resolution query the nodes
		 */
		$query_args['fields'] = 'ID';

		/**
		 * If the request is not authenticated, limit the query to users that have
		 * published posts, as they're considered publicly facing users.
		 */
		if ( ! is_user_logged_in() && empty( $query_args['has_published_posts'] ) ) {
			$query_args['has_published_posts'] = true;
		}

		/**
		 * If `has_published_posts` is set to `attachment`, throw a warning.
		 *
		 * @todo Remove this when the `hasPublishedPosts` enum type changes.
		 *
		 * @see https://github.com/wp-graphql/wp-graphql/issues/2963
		 */
		if ( ! empty( $query_args['has_published_posts'] ) && 'attachment' === $query_args['has_published_posts'] ) {
			graphql_debug(
				__( 'The `hasPublishedPosts` where arg does not support the `ATTACHMENT` value, and will be removed from the possible enum values in a future release.', 'wp-graphql' ),
				[
					'operationName' => $this->context->operationName ?? '',
					'query'         => $this->context->query ?? '',
					'variables'     => $this->context->variables ?? '',
				]
			);
		}

		if ( ! empty( $query_args['search'] ) ) {
			$query_args['search']  = '*' . $query_args['search'] . '*';
			$query_args['orderby'] = 'user_login';
			$query_args['order']   = ! empty( $last ) ? 'DESC' : 'ASC';
		}

		/**
		 * Map the orderby inputArgs to the WP_User_Query
		 */
		if ( ! empty( $args['where']['orderby'] ) && is_array( $args['where']['orderby'] ) ) {
			foreach ( $args['where']['orderby'] as $orderby_input ) {
				/**
				 * These orderby options should not include the order parameter.
				 */
				if ( in_array(
					$orderby_input['field'],
					[
						'login__in',
						'nicename__in',
					],
					true
				) ) {
					$query_args['orderby'] = esc_sql( $orderby_input['field'] );
				} elseif ( ! empty( $orderby_input['field'] ) ) {
					$order = $orderby_input['order'];
					if ( ! empty( $args['last'] ) ) {
						if ( 'ASC' === $order ) {
							$order = 'DESC';
						} else {
							$order = 'ASC';
						}
					}

					$query_args['orderby'] = esc_sql( $orderby_input['field'] );
					$query_args['order']   = esc_sql( $order );
				}
			}
		}

		/**
		 * Convert meta_value_num to separate meta_value value field which our
		 * graphql_wp_term_query_cursor_pagination_support knowns how to handle
		 */
		if ( isset( $query_args['orderby'] ) && 'meta_value_num' === $query_args['orderby'] ) {
			$query_args['orderby'] = [
				'meta_value' => empty( $query_args['order'] ) ? 'DESC' : $query_args['order'], // phpcs:ignore WordPress.DB.SlowDBQuery.slow_db_query_meta_value
			];
			unset( $query_args['order'] );
			$query_args['meta_type'] = 'NUMERIC';
		}

		/**
		 * If there's no orderby params in the inputArgs, set order based on the first/last argument
		 */
		if ( empty( $query_args['order'] ) ) {
			$query_args['order'] = ! empty( $last ) ? 'DESC' : 'ASC';
		}

		return $query_args;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function query_class(): string {
		return \WP_User_Query::class;
	}

	/**
	 * {@inheritDoc}
	 */
	public function get_ids_from_query() {
		/**
		 * @todo This is for b/c. We can just use $this->get_query().
		 */
		$queried = isset( $this->query ) ? $this->query : $this->get_query();

		/** @var int[] $ids */
		$ids = $queried->get_results();

		// If we're going backwards, we need to reverse the array.
		$args = $this->get_args();
		if ( ! empty( $args['last'] ) ) {
			$ids = array_reverse( $ids );
		}

		return $ids;
	}

	/**
	 * This sets up the "allowed" args, and translates the GraphQL-friendly keys to WP_User_Query
	 * friendly keys.
	 *
	 * There's probably a cleaner/more dynamic way to approach this, but this was quick. I'd be
	 * down to explore more dynamic ways to map this, but for now this gets the job done.
	 *
	 * @param array<string,mixed> $args The query "where" args
	 *
	 * @return array<string,mixed>
	 * @throws \GraphQL\Error\UserError If the user does not have the "list_users" capability.
	 * @since  0.0.5
	 */
	protected function sanitize_input_fields( array $args ) {

		/**
		 * Only users with the "list_users" capability can filter users by roles
		 */
		if (
			(
				! empty( $args['roleIn'] ) ||
				! empty( $args['roleNotIn'] ) ||
				! empty( $args['role'] )
			) &&
			! current_user_can( 'list_users' )
		) {
			throw new UserError( esc_html__( 'Sorry, you are not allowed to filter users by role.', 'wp-graphql' ) );
		}

		$arg_mapping = [
			'roleIn'            => 'role__in',
			'roleNotIn'         => 'role__not_in',
			'searchColumns'     => 'search_columns',
			'hasPublishedPosts' => 'has_published_posts',
			'nicenameIn'        => 'nicename__in',
			'nicenameNotIn'     => 'nicename__not_in',
			'loginIn'           => 'login__in',
			'loginNotIn'        => 'login__not_in',
		];

		/**
		 * Map and sanitize the input args to the WP_User_Query compatible args
		 */
		$query_args = Utils::map_input( $args, $arg_mapping );

		/**
		 * Filter the input fields
		 *
		 * This allows plugins/themes to hook in and alter what $args should be allowed to be passed
		 * from a GraphQL Query to the WP_User_Query
		 *
		 * @param array<string,mixed>                  $query_args The mapped query args
		 * @param array<string,mixed>                  $args       The query "where" args
		 * @param mixed                                $source     The query results of the query calling this relation
		 * @param array<string,mixed>                  $all_args   Array of all the query args (not just the "where" args)
		 * @param \WPGraphQL\AppContext                $context The AppContext object
		 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo object
		 *
		 * @since 0.0.5
		 */
		$query_args = apply_filters( 'graphql_map_input_fields_to_wp_user_query', $query_args, $args, $this->source, $this->get_args(), $this->context, $this->info );

		return ! empty( $query_args ) && is_array( $query_args ) ? $query_args : [];
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param int $offset The ID of the node used as the offset in the cursor.
	 */
	public function is_valid_offset( $offset ) {
		return (bool) get_user_by( 'ID', absint( $offset ) );
	}
}


// File: wp-graphql\src\Data\Connection\UserRoleConnectionResolver.php
<?php

namespace WPGraphQL\Data\Connection;

use WPGraphQL\Model\User;

/**
 * Class PluginConnectionResolver - Connects plugins to other objects
 *
 * @package WPGraphQL\Data\Resolvers
 * @since   0.0.5
 * @extends \WPGraphQL\Data\Connection\AbstractConnectionResolver<string[]>
 */
class UserRoleConnectionResolver extends AbstractConnectionResolver {
	/**
	 * {@inheritDoc}
	 */
	public function get_ids_from_query() {

		// Given a list of role slugs
		$query_args = $this->get_query_args();
		if ( isset( $query_args['slugIn'] ) ) {
			return $query_args['slugIn'];
		}

		$ids     = [];
		$queried = $this->get_query();

		if ( empty( $queried ) ) {
			return $ids;
		}

		foreach ( $queried as $key => $item ) {
			$ids[ $key ] = $item;
		}

		return $ids;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function prepare_query_args( array $args ): array {
		// If any args are added to filter/sort the connection
		return [];
	}

	/**
	 * {@inheritDoc}
	 */
	protected function query( array $query_args ) {
		$wp_roles = wp_roles();

		return ! empty( $wp_roles->get_names() ) ? array_keys( $wp_roles->get_names() ) : [];
	}

	/**
	 * {@inheritDoc}
	 */
	protected function loader_name(): string {
		return 'user_role';
	}

	/**
	 * {@inheritDoc}
	 */
	public function is_valid_offset( $offset ) {
		return (bool) get_role( $offset );
	}

	/**
	 * {@inheritDoc}
	 */
	public function should_execute() {
		if (
			current_user_can( 'list_users' ) ||
			(
				$this->source instanceof User &&
				get_current_user_id() === $this->source->userId
			)
		) {
			return true;
		}

		return false;
	}
}


// File: wp-graphql\src\Data\Cursor\AbstractCursor.php
<?php

namespace WPGraphQL\Data\Cursor;

use GraphQL\Error\InvariantViolation;

/**
 * Abstract Cursor
 *
 * @package WPGraphQL\Data\Loader
 * @since 1.9.0
 */
abstract class AbstractCursor {

	/**
	 * The global WordPress Database instance
	 *
	 * @var \wpdb $wpdb
	 */
	public $wpdb;

	/**
	 * @var \WPGraphQL\Data\Cursor\CursorBuilder
	 */
	public $builder;

	/**
	 * @var string
	 */
	public $compare;

	/**
	 * Our current cursor offset.
	 * For example, the term, post, user, or comment ID.
	 *
	 * @var int
	 */
	public $cursor_offset;

	/**
	 * @var string|null
	 */
	public $cursor;

	/**
	 * The WP object instance for the cursor.
	 *
	 * @var mixed
	 */
	public $cursor_node;

	/**
	 * Copy of query vars so we can modify them safely
	 *
	 * @var array<string,mixed>
	 */
	public $query_vars = [];

	/**
	 * Stores SQL statement alias for the ID column applied to the cutoff
	 *
	 * @var string
	 */
	protected $id_key = '';

	/**
	 * The constructor
	 *
	 * @param array<string,mixed> $query_vars         Query variable for the query to be executed.
	 * @param string|null         $cursor             Cursor type. Either 'after' or 'before'.
	 */
	public function __construct( $query_vars, $cursor = 'after' ) {
		global $wpdb;

		$this->wpdb       = $wpdb;
		$this->query_vars = $query_vars;
		$this->cursor     = $cursor;

		/**
		 * Get the cursor offset if any
		 */
		$offset = $this->get_query_var( 'graphql_' . $cursor . '_cursor' );

		// Handle deprecated use of `graphql_cursor_offset`.
		if ( empty( $offset ) ) {
			$offset = $this->get_query_var( 'graphql_cursor_offset' );

			if ( ! empty( $offset ) ) {
				_doing_it_wrong( self::class . "::get_query_var('graphql_cursor_offset')", "Use 'graphql_before_cursor' or 'graphql_after_cursor' instead.", '1.9.0' );
			}
		}

		$this->cursor_offset = ! empty( $offset ) ? absint( $offset ) : 0;

		// Get the WP Object for the cursor.
		$this->cursor_node = $this->get_cursor_node();

		// Get the direction for the builder query.
		$this->compare = $this->get_cursor_compare();

		$this->builder = new CursorBuilder( $this->compare );
	}

	/**
	 * Get the query variable for the provided name.
	 *
	 * @param string $name .
	 *
	 * @return mixed|null
	 */
	public function get_query_var( string $name ) {
		if ( isset( $this->query_vars[ $name ] ) && '' !== $this->query_vars[ $name ] ) {
			return $this->query_vars[ $name ];
		}
		return null;
	}

	/**
	 * Get the direction pagination is going in.
	 *
	 * @return string
	 */
	public function get_cursor_compare() {
		if ( 'before' === $this->cursor ) {
			return '>';
		}

		return '<';
	}

	/**
	 * Ensure the cursor_offset is a positive integer and we have a valid object for our cursor node.
	 *
	 * @return bool
	 */
	protected function is_valid_offset_and_node() {
		if (
			! is_int( $this->cursor_offset ) ||
			0 >= $this->cursor_offset ||
			! $this->cursor_node
		) {
			return false;
		}

		return true;
	}

	/**
	 * Validates cursor compare field configuration. Validation failure results in a fatal
	 * error because query execution is guaranteed to fail.
	 *
	 * @param array<string,mixed>|mixed $field  Threshold configuration.
	 *
	 * @throws \GraphQL\Error\InvariantViolation Invalid configuration format.
	 */
	protected function validate_cursor_compare_field( $field ): void {
		// Throw if an array not provided.
		if ( ! is_array( $field ) ) {
			throw new InvariantViolation(
				esc_html(
					sprintf(
						/* translators: %1$s: Cursor class name. %2$s: value type. */
						__( 'Invalid value provided for %1$s cursor compare field. Expected Array, %2$s given.', 'wp-graphql' ),
						static::class,
						gettype( $field )
					)
				)
			);
		}

		// Guard against missing or invalid "table column".
		if ( empty( $field['key'] ) || ! is_string( $field['key'] ) ) {
			throw new InvariantViolation(
				esc_html(
					sprintf(
						/* translators: %s: Cursor class name. */
						__( 'Expected "key" value to be provided for %s cursor compare field. A string value must be given.', 'wp-graphql' ),
						static::class
					)
				)
			);
		}

		// Guard against missing or invalid "by".
		if ( ! isset( $field['value'] ) ) {
			throw new InvariantViolation(
				esc_html(
					sprintf(
						/* translators: %s: Cursor class name. */
						__( 'Expected "value" value to be provided for %s cursor compare field. A scalar value must be given.', 'wp-graphql' ),
						static::class
					)
				)
			);
		}

		// Guard against invalid "type".
		if ( ! empty( $field['type'] ) && ! is_string( $field['type'] ) ) {
			throw new InvariantViolation(
				esc_html(
					sprintf(
					/* translators: %s: Cursor class name. */
						__( 'Invalid value provided for "type" value to be provided for type of %s cursor compare field. A string value must be given.', 'wp-graphql' ),
						static::class
					)
				)
			);
		}

		// Guard against invalid "order".
		if ( ! empty( $field['order'] ) && ! in_array( strtoupper( $field['order'] ), [ 'ASC', 'DESC' ], true ) ) {
			throw new InvariantViolation(
				esc_html(
					sprintf(
					/* translators: %s: Cursor class name. */
						__( 'Invalid value provided for "order" value to be provided for type of %s cursor compare field. Either "ASC" or "DESC" must be given.', 'wp-graphql' ),
						static::class
					)
				)
			);
		}
	}

	/**
	 * Returns the ID key.
	 *
	 * @return string
	 */
	public function get_cursor_id_key() {
		$key = $this->get_query_var( 'graphql_cursor_id_key' );
		if ( null === $key ) {
			$key = $this->id_key;
		}

		return $key;
	}

	/**
	 * Applies cursor compare fields to the cursor cutoff.
	 *
	 * @param array<string,mixed>[] $fallback Fallback cursor compare fields.
	 *
	 * @throws \GraphQL\Error\InvariantViolation Invalid configuration format.
	 */
	protected function compare_with_cursor_fields( $fallback = [] ): void {
		/**
		 * Get cursor compare fields from query vars.
		 *
		 * @var array<string,mixed>[]|null $cursor_compare_fields
		 */
		$cursor_compare_fields = $this->get_query_var( 'graphql_cursor_compare_fields' );
		if ( null === $cursor_compare_fields ) {
			$cursor_compare_fields = $fallback;
		}
		// Bail early if no cursor compare fields.
		if ( empty( $cursor_compare_fields ) ) {
			return;
		}

		if ( ! is_array( $cursor_compare_fields ) ) {
			throw new InvariantViolation(
				esc_html(
					sprintf(
						/* translators: %s: value type. */
						__( 'Invalid value provided for graphql_cursor_compare_fields. Expected Array, %s given.', 'wp-graphql' ),
						gettype( $cursor_compare_fields )
					)
				)
			);
		}

		// Check if only one cursor compare field provided, wrap it in an array.
		if ( ! isset( $cursor_compare_fields[0] ) ) {
			$cursor_compare_fields = [ $cursor_compare_fields ];
		}

		foreach ( $cursor_compare_fields as $field ) {
			$this->validate_cursor_compare_field( $field );

			$key   = $field['key'];
			$value = $field['value'];
			$type  = ! empty( $field['type'] ) ? $field['type'] : null;
			$order = ! empty( $field['order'] ) ? $field['order'] : null;

			$this->builder->add_field( $key, $value, $type, $order );
		}
	}

	/**
	 * Applies ID field to the cursor builder.
	 */
	protected function compare_with_id_field(): void {
		// Get ID value.
		$value = $this->get_query_var( 'graphql_cursor_id_value' );
		if ( null === $value ) {
			$value = (string) $this->cursor_offset;
		}

		// Get ID SQL Query alias.
		$key = $this->get_cursor_id_key();

		$this->builder->add_field( $key, $value, 'ID' );
	}

	/**
	 * Get the WP Object instance for the cursor.
	 *
	 * This is cached internally so it should not generate additionl queries.
	 *
	 * @return mixed|null;
	 */
	abstract public function get_cursor_node();

	/**
	 * Return the additional AND operators for the where statement
	 *
	 * @return string
	 */
	abstract public function get_where();

	/**
	 * Generate the final SQL string to be appended to WHERE clause
	 *
	 * @return string
	 */
	abstract public function to_sql();
}


// File: wp-graphql\src\Data\Cursor\CommentObjectCursor.php
<?php

namespace WPGraphQL\Data\Cursor;

use WP_Comment;

/**
 * Comment Cursor
 *
 * This class generates the SQL and operators for cursor based pagination for comments
 *
 * @package WPGraphQL\Data\Cursor
 */
class CommentObjectCursor extends AbstractCursor {

	/**
	 * @var ?\WP_Comment
	 */
	public $cursor_node;

	/**
	 * {@inheritDoc}
	 *
	 * @param array<string,mixed>|\WP_Comment_Query $query_vars The query vars to use when building the SQL statement.
	 */
	public function __construct( $query_vars, $cursor = 'after' ) {
		// Handle deprecated use of $query.
		if ( $query_vars instanceof \WP_Comment_Query ) {
			_doing_it_wrong( __METHOD__, 'The first argument should be an array of $query_vars, not the WP_Comment_Query object', '1.9.0' );
			$query_vars = $query_vars->query_vars;
		}

		// Initialize the class properties.
		parent::__construct( $query_vars, $cursor );

		// Set ID Key.
		$this->id_key = "{$this->wpdb->comments}.comment_ID";
	}

	/**
	 * {@inheritDoc}
	 *
	 * @return ?\WP_Comment
	 */
	public function get_cursor_node() {
		// Bail if no offset.
		if ( ! $this->cursor_offset ) {
			return null;
		}

		/**
		 * If pre-hooked, return filtered node.
		 *
		 * @param \WP_Comment|null                           $pre_comment The pre-filtered comment node.
		 * @param int                                        $offset      The cursor offset.
		 * @param \WPGraphQL\Data\Cursor\CommentObjectCursor $node        The cursor instance.
		 *
		 * @return \WP_Comment|null
		 */
		$pre_comment = apply_filters( 'graphql_pre_comment_cursor_node', null, $this->cursor_offset, $this );
		if ( null !== $pre_comment ) {
			return $pre_comment;
		}

		// Get cursor node.
		$comment = WP_Comment::get_instance( $this->cursor_offset );

		return false !== $comment ? $comment : null;
	}

	/**
	 * {@inheritDoc}
	 */
	public function get_where() {
		// If we have a bad cursor, just skip.
		if ( ! $this->is_valid_offset_and_node() ) {
			return '';
		}

		$orderby = $this->get_query_var( 'orderby' );
		$order   = $this->get_query_var( 'order' );

		// if there's custom ordering, use it to determine the cursor
		if ( ! empty( $orderby ) ) {
			$this->compare_with( $orderby, $order );
		}

		/**
		 * If there's no orderby specified yet, compare with the following fields.
		 */
		if ( ! $this->builder->has_fields() ) {
			$this->compare_with_cursor_fields(
				[
					[
						'key'  => "{$this->wpdb->comments}.comment_date",
						'by'   => $this->cursor_node ? $this->cursor_node->comment_date : null,
						'type' => 'DATETIME',
					],
				]
			);
		}

		$this->compare_with_id_field();

		return $this->to_sql();
	}

	/**
	 * Get AND operator for given order by key
	 *
	 * @param string $by    The order by key
	 * @param string $order The order direction ASC or DESC
	 *
	 * @return void
	 */
	public function compare_with( $by, $order ) {
		// Bail early, if "key" and "value" provided in query_vars.
		$key   = $this->get_query_var( "graphql_cursor_compare_by_{$by}_key" );
		$value = $this->get_query_var( "graphql_cursor_compare_by_{$by}_value" );
		if ( ! empty( $key ) && ! empty( $value ) ) {
			$this->builder->add_field( $key, $value, null, $order );
			return;
		}

		$key   = "{$this->wpdb->comments}.{$by}";
		$value = $this->cursor_node->{$by};
		$type  = null;

		if ( 'comment_date' === $by ) {
			$type = 'DATETIME';
		}

		$value = $this->cursor_node->{$by} ?? null;
		if ( ! empty( $value ) ) {
			$this->builder->add_field( $key, $value, $type );
			return;
		}
	}

	/**
	 * {@inheritDoc}
	 */
	public function to_sql() {
		$sql = $this->builder->to_sql();
		return ! empty( $sql ) ? ' AND ' . $sql : '';
	}
}


// File: wp-graphql\src\Data\Cursor\CursorBuilder.php
<?php

namespace WPGraphQL\Data\Cursor;

/**
 * Generic class for building AND&OR operators for cursor based paginators
 */
class CursorBuilder {

	/**
	 * The field by which the cursor should order the results
	 *
	 * @var array<string,mixed>[]
	 */
	public $fields;

	/**
	 * Default comparison operator. < or >
	 *
	 * @var string
	 */
	public $compare;

	/**
	 * CursorBuilder constructor.
	 *
	 * @param string $compare
	 *
	 * @return void
	 */
	public function __construct( $compare = '>' ) {
		$this->compare = $compare;
		$this->fields  = [];
	}

	/**
	 * Add ordering field. The order you call this method matters. First field
	 * will be the primary field and latter ones will be used if the primary
	 * field has duplicate values
	 *
	 * @param string           $key           database column
	 * @param mixed|string|int $value         value from the current cursor
	 * @param string|null      $type          type cast
	 * @param string|null      $order         custom order
	 * @param object|null      $object_cursor The Cursor class
	 *
	 * @return void
	 */
	public function add_field( string $key, $value, ?string $type = null, ?string $order = null, $object_cursor = null ) {

		/**
		 * Filters the field used for ordering when cursors are used for pagination
		 *
		 * @param array<string,mixed>                  $field          The field key, value, type and order
		 * @param \WPGraphQL\Data\Cursor\CursorBuilder $cursor_builder The CursorBuilder class
		 * @param ?object                              $object_cursor  The Cursor class
		 */
		$field = apply_filters(
			'graphql_cursor_ordering_field',
			[
				'key'   => esc_sql( $key ),
				'value' => esc_sql( $value ),
				'type'  => ! empty( $type ) ? esc_sql( $type ) : '',
				'order' => ! empty( $order ) ? esc_sql( $order ) : '',
			],
			$this,
			$object_cursor
		);

		// Bail if the filtered field comes back empty
		if ( empty( $field ) ) {
			return;
		}

		// Bail if the filtered field doesn't come back as an array
		if ( ! is_array( $field ) ) {
			return;
		}

		$escaped_field = [];

		// Escape the filtered array
		foreach ( $field as $field_key => $value ) {
			$escaped_field[ $field_key ] = esc_sql( $value );
		}

		$this->fields[] = $escaped_field;
	}

	/**
	 * Returns true at least one ordering field has been added
	 *
	 * @return bool
	 */
	public function has_fields() {
		return count( $this->fields ) > 0;
	}

	/**
	 * Generate the final SQL string to be appended to WHERE clause
	 *
	 * @param mixed|array<string,mixed>[]|null $fields
	 *
	 * @return string
	 */
	public function to_sql( $fields = null ) {
		if ( null === $fields ) {
			$fields = $this->fields;
		}

		if ( count( $fields ) === 0 ) {
			return '';
		}

		$field = $fields[0];

		$key   = $field['key'];
		$value = $field['value'];
		$type  = $field['type'];
		$order = $field['order'];

		$compare = $this->compare;

		if ( $order ) {
			$compare = 'DESC' === $order ? '<' : '>';
		}

		if ( 'ID' !== $type ) {
			$cast = $this->get_cast_for_type( $type );
			if ( 'CHAR' === $cast ) {
				$value = '"' . wp_unslash( $value ) . '"';
			} elseif ( $cast ) {
				$key   = "CAST( $key as $cast )";
				$value = "CAST( '$value' as $cast )";
			}
		}

		if ( count( $fields ) === 1 ) {
			return " {$key} {$compare} {$value} ";
		}

		$nest = $this->to_sql( \array_slice( $fields, 1 ) );

		$sql = ' %1$s %2$s= %3$s AND ( %1$s %2$s %3$s OR ( %4$s ) ) ';

		return sprintf( $sql, $key, $compare, $value, $nest );
	}

	/**
	 * Copied from
	 * https://github.com/WordPress/WordPress/blob/c4f8bc468db56baa2a3bf917c99cdfd17c3391ce/wp-includes/class-wp-meta-query.php#L272-L296
	 *
	 * It's an instance method. No way to call it without creating the instance?
	 *
	 * Return the appropriate alias for the given meta type if applicable.
	 *
	 * @param string $type MySQL type to cast meta_value.
	 *
	 * @return string MySQL type.
	 */
	public function get_cast_for_type( $type = '' ) {
		if ( empty( $type ) ) {
			return 'CHAR';
		}
		$meta_type = strtoupper( $type );
		if ( ! preg_match( '/^(?:BINARY|CHAR|DATE|DATETIME|SIGNED|UNSIGNED|TIME|NUMERIC(?:\(\d+(?:,\s?\d+)?\))?|DECIMAL(?:\(\d+(?:,\s?\d+)?\))?)$/', $meta_type ) ) {
			return 'CHAR';
		}
		if ( 'NUMERIC' === $meta_type ) {
			$meta_type = 'SIGNED';
		}

		return $meta_type;
	}
}


// File: wp-graphql\src\Data\Cursor\PostObjectCursor.php
<?php

namespace WPGraphQL\Data\Cursor;

/**
 * Post Cursor
 *
 * This class generates the SQL AND operators for cursor based pagination for posts
 *
 * @package WPGraphQL\Data\Cursor
 */
class PostObjectCursor extends AbstractCursor {
	/**
	 * @var ?\WP_Post
	 */
	public $cursor_node;

	/**
	 * Counter for meta value joins
	 *
	 * @var int
	 */
	public $meta_join_alias = 0;

	/**
	 * {@inheritDoc}
	 */
	public function __construct( $query_vars, $cursor = 'after' ) {
		// Handle deprecated use of $query.
		if ( $query_vars instanceof \WP_Query ) {
			_doing_it_wrong( __METHOD__, 'The first argument should be an array of $query_vars, not the WP_Query object', '1.9.0' );
			$query_vars = $query_vars->query_vars;
		}

		// Initialize the class properties.
		parent::__construct( $query_vars, $cursor );

		// Set ID key.
		$this->id_key = "{$this->wpdb->posts}.ID";
	}

	/**
	 * {@inheritDoc}
	 *
	 * @return ?\WP_Post
	 */
	public function get_cursor_node() {
		// Bail if no offset.
		if ( ! $this->cursor_offset ) {
			return null;
		}

		/**
		 * If pre-hooked, return filtered node.
		 *
		 * @param \WP_Post|null                           $pre_post The pre-filtered post node.
		 * @param int                                     $offset   The cursor offset.
		 * @param \WPGraphQL\Data\Cursor\PostObjectCursor $node     The cursor instance.
		 *
		 * @return \WP_Post|null
		 */
		$pre_post = apply_filters( 'graphql_pre_post_cursor_node', null, $this->cursor_offset, $this );
		if ( null !== $pre_post ) {
			return $pre_post;
		}

		// Get cursor node.
		$post = \WP_Post::get_instance( $this->cursor_offset );

		return false !== $post ? $post : null;
	}

	/**
	 * @deprecated 1.9.0
	 *
	 * @return ?\WP_Post
	 */
	public function get_cursor_post() {
		_deprecated_function( __METHOD__, '1.9.0', self::class . '::get_cursor_node()' );

		return $this->cursor_node;
	}

	/**
	 * {@inheritDoc}
	 */
	public function to_sql() {
		$orderby = isset( $this->query_vars['orderby'] ) ? $this->query_vars['orderby'] : null;

		$orderby_should_not_convert_to_sql = isset( $orderby ) && in_array(
			$orderby,
			[
				'post__in',
				'post_name__in',
				'post_parent__in',
			],
			true
		);

		if ( true === $orderby_should_not_convert_to_sql ) {
			return '';
		}

		$sql = $this->builder->to_sql();

		if ( empty( $sql ) ) {
			return '';
		}

		return ' AND ' . $sql;
	}

	/**
	 * {@inheritDoc}
	 */
	public function get_where() {
		// If we have a bad cursor, just skip.
		if ( ! $this->is_valid_offset_and_node() ) {
			return '';
		}

		$orderby = $this->get_query_var( 'orderby' );
		$order   = $this->get_query_var( 'order' );

		if ( 'menu_order' === $orderby ) {
			if ( '>' === $this->compare ) {
				$order         = 'DESC';
				$this->compare = '<';
			} elseif ( '<' === $this->compare ) {
				$this->compare = '>';
				$order         = 'ASC';
			}
		}

		if ( ! empty( $orderby ) && is_array( $orderby ) ) {

			/**
			 * Loop through all order keys if it is an array
			 */
			foreach ( $orderby as $by => $order ) {
				$this->compare_with( $by, $order );
			}
		} elseif ( ! empty( $orderby ) && is_string( $orderby ) ) {

			/**
			 * If $orderby is just a string just compare with it directly as DESC
			 */
			$this->compare_with( $orderby, $order );
		}

		/**
		 * If there's no orderby specified yet, compare with the following fields.
		 */
		if ( ! $this->builder->has_fields() ) {
			$this->compare_with_cursor_fields(
				[
					[
						'key'   => "{$this->wpdb->posts}.post_date",
						'value' => $this->cursor_node ? $this->cursor_node->post_date : null,
						'type'  => 'DATETIME',
					],
				]
			);
		}

		$this->compare_with_id_field();

		return $this->to_sql();
	}

	/**
	 * Get AND operator for given order by key
	 *
	 * @param string $by    The order by key
	 * @param string $order The order direction ASC or DESC
	 *
	 * @return void
	 */
	private function compare_with( $by, $order ) {
		// Bail early, if "key" and "value" provided in query_vars.
		$key   = $this->get_query_var( "graphql_cursor_compare_by_{$by}_key" );
		$value = $this->get_query_var( "graphql_cursor_compare_by_{$by}_value" );
		if ( ! empty( $key ) && ! empty( $value ) ) {
			$this->builder->add_field( $key, $value, null, $order );
			return;
		}

		/**
		 * Find out whether this is a post field
		 */
		$orderby_post_fields = [
			'post_author',
			'post_title',
			'post_type',
			'post_name',
			'post_modified',
			'post_date',
			'post_parent',
			'menu_order',
		];
		if ( in_array( $by, $orderby_post_fields, true ) ) {
			$key   = "{$this->wpdb->posts}.{$by}";
			$value = $this->cursor_node->{$by} ?? null;
		}

		/**
		 * If key or value are null, check whether this is a meta key based ordering before bailing.
		 */
		if ( null === $key || null === $value ) {
			$meta_key = $this->get_meta_key( $by );
			if ( $meta_key ) {
				$this->compare_with_meta_field( $meta_key, $order );
			}
			return;
		}

		// Add field to build.
		$this->builder->add_field( $key, $value, null, $order );
	}

	/**
	 * Compare with meta key field
	 *
	 * @param string $meta_key post meta key
	 * @param string $order    The comparison string
	 *
	 * @return void
	 */
	private function compare_with_meta_field( string $meta_key, string $order ) {
		$meta_type  = $this->get_query_var( 'meta_type' );
		$meta_value = get_post_meta( $this->cursor_offset, $meta_key, true );

		$key = "{$this->wpdb->postmeta}.meta_value";

		/**
		 * WP uses mt1, mt2 etc. style aliases for additional meta value joins.
		 */
		$meta_query = $this->get_query_var( 'meta_query' );
		if ( ! empty( $meta_query ) && is_array( $meta_query ) ) {
			if ( ! empty( $meta_query['relation'] ) ) {
				unset( $meta_query['relation'] );
			}

			$meta_keys = array_column( $meta_query, 'key' );
			$index     = array_search( $meta_key, $meta_keys, true );

			if ( $index && 1 < count( $meta_query ) ) {
				$key = "mt{$index}.meta_value";
			}
		}

		/**
		 * Allow filtering the meta key used for cursor based pagination
		 *
		 * @param string $key       The meta key to use for cursor based pagination
		 * @param string $meta_key  The original meta key
		 * @param string $meta_type The meta type
		 * @param string $order     The order direction
		 * @param object $cursor    The PostObjectCursor instance
		 */
		$key = apply_filters( 'graphql_post_object_cursor_meta_key', $key, $meta_key, $meta_type, $order, $this );

		$this->builder->add_field( $key, $meta_value, $meta_type, $order, $this );
	}

	/**
	 * Get the actual meta key if any
	 *
	 * @param string $by The order by key
	 *
	 * @return string|null
	 */
	private function get_meta_key( $by ) {
		if ( 'meta_value' === $by || 'meta_value_num' === $by ) {
			return $this->get_query_var( 'meta_key' );
		}

		/**
		 * Check for the WP 4.2+ style meta clauses
		 * https://make.wordpress.org/core/2015/03/30/query-improvements-in-wp-4-2-orderby-and-meta_query/
		 */
		if ( ! isset( $this->query_vars['meta_query'][ $by ] ) ) {
			return null;
		}

		$clause = $this->query_vars['meta_query'][ $by ];

		return empty( $clause['key'] ) ? null : $clause['key'];
	}
}


// File: wp-graphql\src\Data\Cursor\TermObjectCursor.php
<?php
namespace WPGraphQL\Data\Cursor;

use WP_Term;

class TermObjectCursor extends AbstractCursor {

	/**
	 * @var ?\WP_Term ;
	 */
	public $cursor_node;

	/**
	 * Counter for meta value joins
	 *
	 * @var int
	 */
	public $meta_join_alias = 0;

	/**
	 * {@inheritDoc}
	 *
	 * @var string
	 */
	protected $id_key = 't.term_id';

	/**
	 * Deprecated in favor of get_query_var()
	 *
	 * @param string $name The name of the query var to get
	 *
	 * @deprecated 1.9.0
	 *
	 * @return mixed|null
	 */
	public function get_query_arg( string $name ) {
		_deprecated_function( __METHOD__, '1.9.0', self::class . '::get_query_var()' );

		return $this->get_query_var( $name );
	}

	/**
	 * {@inheritDoc}
	 *
	 * @return ?\WP_Term ;
	 */
	public function get_cursor_node() {
		// Bail if no offset.
		if ( ! $this->cursor_offset ) {
			return null;
		}

		/**
		 * If pre-hooked, return filtered node.
		 *
		 * @param \WP_Term|null                           $pre_term The pre-filtered term node.
		 * @param int                                     $offset   The cursor offset.
		 * @param \WPGraphQL\Data\Cursor\TermObjectCursor $node     The cursor instance.
		 *
		 * @return \WP_Term|null
		 */
		$pre_term = apply_filters( 'graphql_pre_term_cursor_node', null, $this->cursor_offset, $this );
		if ( null !== $pre_term ) {
			return $pre_term;
		}

		// Get cursor node.
		$term = WP_Term::get_instance( $this->cursor_offset );

		return $term instanceof WP_Term ? $term : null;
	}

	/**
	 * Deprecated in favor of get_cursor_node().
	 *
	 * @return ?\WP_Term
	 * @deprecated 1.9.0
	 */
	public function get_cursor_term() {
		_deprecated_function( __METHOD__, '1.9.0', self::class . '::get_cursor_node()' );

		return $this->cursor_node;
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param array<array<string,mixed>>[]|null $fields The fields from the CursorBuilder to convert to SQL.
	 */
	public function to_sql( $fields = null ) {
		$sql = $this->builder->to_sql( $fields );
		if ( empty( $sql ) ) {
			return '';
		}
		return ' AND ' . $sql;
	}

	/**
	 * {@inheritDoc}
	 */
	public function get_where() {
		// If we have a bad cursor, just skip.
		if ( ! $this->is_valid_offset_and_node() ) {
			return '';
		}

		$orderby = $this->get_query_var( 'orderby' );
		$order   = $this->get_query_var( 'order' );

		if ( 'name' === $orderby ) {
			if ( '>' === $this->compare ) {
				$order         = 'DESC';
				$this->compare = '<';
			} elseif ( '<' === $this->compare ) {
				$this->compare = '>';
				$order         = 'ASC';
			}
		}

		/**
		 * If $orderby is just a string just compare with it directly as DESC
		 */
		if ( ! empty( $orderby ) && is_string( $orderby ) ) {
			$this->compare_with( $orderby, $order );
		}

		/**
		 * If there's no orderby specified yet, compare with the following fields.
		 */
		if ( ! $this->builder->has_fields() ) {
			$this->compare_with_cursor_fields();
		}

		/**
		 * Stabilize cursor by consistently comparing with the ID.
		 */
		$this->compare_with_id_field();

		return $this->to_sql();
	}

	/**
	 * Get AND operator for given order by key
	 *
	 * @param string $by    The order by key
	 * @param string $order The order direction ASC or DESC
	 *
	 * @return void
	 */
	private function compare_with( string $by, string $order ) {

		// Bail early, if "key" and "value" provided in query_vars.
		$key   = $this->get_query_var( "graphql_cursor_compare_by_{$by}_key" );
		$value = $this->get_query_var( "graphql_cursor_compare_by_{$by}_value" );
		if ( ! empty( $key ) && ! empty( $value ) ) {
			$this->builder->add_field( $key, $value, null, $order );
			return;
		}

		// Set "key" as term table column and get "value" from cursor node.
		$key   = "t.{$by}";
		$value = $this->cursor_node->{$by};

		/**
		 * If key or value are null, check whether this is a meta key based ordering before bailing.
		 */
		if ( null === $value ) {
			$meta_key = $this->get_meta_key( $by );
			if ( $meta_key ) {
				$this->compare_with_meta_field( $meta_key, $order );
			}
			return;
		}

		$this->builder->add_field( $key, $value, null, $order );
	}

	/**
	 * Compare with meta key field
	 *
	 * @param string $meta_key meta key
	 * @param string $order    The comparison string
	 *
	 * @return void
	 */
	private function compare_with_meta_field( string $meta_key, string $order ) {
		$meta_type  = $this->get_query_var( 'meta_type' );
		$meta_value = get_term_meta( $this->cursor_offset, $meta_key, true );

		$key = "{$this->wpdb->termmeta}.meta_value";

		/**
		 * WP uses mt1, mt2 etc. style aliases for additional meta value joins.
		 */
		if ( 0 !== $this->meta_join_alias ) {
			$key = "mt{$this->meta_join_alias}.meta_value";
		}

		++$this->meta_join_alias;

		$this->builder->add_field( $key, $meta_value, $meta_type, $order, $this );
	}

	/**
	 * Get the actual meta key if any
	 *
	 * @param string $by The order by key
	 *
	 * @return string|null
	 */
	private function get_meta_key( string $by ) {
		if ( 'meta_value' === $by || 'meta_value_num' === $by ) {
			return $this->get_query_var( 'meta_key' );
		}

		/**
		 * Check for the WP 4.2+ style meta clauses
		 * https://make.wordpress.org/core/2015/03/30/query-improvements-in-wp-4-2-orderby-and-meta_query/
		 */
		if ( ! isset( $this->query_vars['meta_query'][ $by ] ) ) {
			return null;
		}

		$clause = $this->query_vars['meta_query'][ $by ];

		return empty( $clause['key'] ) ? null : $clause['key'];
	}
}


// File: wp-graphql\src\Data\Cursor\UserCursor.php
<?php

namespace WPGraphQL\Data\Cursor;

use WP_User_Query;

/**
 * User Cursor
 *
 * This class generates the SQL AND operators for cursor based pagination for users
 *
 * @package WPGraphQL\Data\Cursor
 */
class UserCursor extends AbstractCursor {

	/**
	 * @var ?\WP_User
	 */
	public $cursor_node;

	/**
	 * Counter for meta value joins
	 *
	 * @var int
	 */
	public $meta_join_alias = 0;

	/**
	 * {@inheritDoc}
	 *
	 * @param array<string,mixed>|\WP_User_Query $query_vars The query vars to use when building the SQL statement.
	 */
	public function __construct( $query_vars, $cursor = 'after' ) {
		// Handle deprecated use of $query.
		if ( $query_vars instanceof WP_User_Query ) {
			_doing_it_wrong( __FUNCTION__, 'The first argument should be an array of $query_vars, not the WP_Query object', '1.9.0' );
			$query_vars = $query_vars->query_vars;
		}

		// Initialize the class properties.
		parent::__construct( $query_vars, $cursor );

		// Set ID key.
		$this->id_key = "{$this->wpdb->users}.ID";
	}

	/**
	 * {@inheritDoc}
	 *
	 * Unlike most queries, users by default are in ascending order.
	 */
	public function get_cursor_compare() {
		if ( 'before' === $this->cursor ) {
			return '<';
		}
		return '>';
	}

	/**
	 * {@inheritDoc}
	 *
	 * @return ?\WP_User
	 */
	public function get_cursor_node() {
		// Bail if no offset.
		if ( ! $this->cursor_offset ) {
			return null;
		}

		/**
		 * If pre-hooked, return filtered node.
		 *
		 * @param \WP_User|null                        $pre_user The pre-filtered user node.
		 * @param int                                  $offset   The cursor offset.
		 * @param \WPGraphQL\Data\Cursor\UserCursor    $node     The cursor instance.
		 *
		 * @return \WP_User|null
		 */
		$pre_user = apply_filters( 'graphql_pre_user_cursor_node', null, $this->cursor_offset, $this );
		if ( null !== $pre_user ) {
			return $pre_user;
		}

		// Get cursor node.
		$user = get_user_by( 'id', $this->cursor_offset );

		return false !== $user ? $user : null;
	}

	/**
	 * Deprecated in favor of get_cursor_node().
	 *
	 * @return ?\WP_User
	 * @deprecated 1.9.0
	 */
	public function get_cursor_user() {
		_deprecated_function( __METHOD__, '1.9.0', self::class . '::get_cursor_node()' );

		return $this->cursor_node;
	}

	/**
	 * {@inheritDoc}
	 */
	public function to_sql() {
		return ' AND ' . $this->builder->to_sql();
	}

	/**
	 * {@inheritDoc}
	 */
	public function get_where() {
		// If we have a bad cursor, just skip.
		if ( ! $this->is_valid_offset_and_node() ) {
			return '';
		}

		$orderby = $this->get_query_var( 'orderby' );
		$order   = $this->get_query_var( 'order' );

		if ( ! empty( $orderby ) && is_array( $orderby ) ) {

			/**
			 * Loop through all order keys if it is an array
			 */
			foreach ( $orderby as $by => $order ) {
				$this->compare_with( $by, $order );
			}
		} elseif ( ! empty( $orderby ) && is_string( $orderby ) && 'login' !== $orderby ) {

			/**
			 * If $orderby is just a string just compare with it directly as DESC
			 */
			$this->compare_with( $orderby, $order );
		}

		/**
		 * If there's no orderby specified yet, compare with the following fields.
		 */
		if ( ! $this->builder->has_fields() ) {
			$this->compare_with_cursor_fields(
				[
					[
						'key'   => "{$this->wpdb->users}.user_login",
						'value' => $this->cursor_node ? $this->cursor_node->user_login : null,
						'type'  => 'CHAR',
					],
				]
			);
		}

		$this->compare_with_id_field();

		return $this->to_sql();
	}

	/**
	 * Get AND operator for given order by key
	 *
	 * @param string $by    The order by key
	 * @param string $order The order direction ASC or DESC
	 *
	 * @return void
	 */
	private function compare_with( $by, $order ) {
		// Bail early, if "key" and "value" provided in query_vars.
		$key   = $this->get_query_var( "graphql_cursor_compare_by_{$by}_key" );
		$value = $this->get_query_var( "graphql_cursor_compare_by_{$by}_value" );
		if ( ! empty( $key ) && ! empty( $value ) ) {
			$this->builder->add_field( $key, $value, null, $order );
			return;
		}

		/**
		 * Find out whether this is a user field
		 */
		$orderby_user_fields = [
			'user_email',
			'user_login',
			'user_nicename',
			'user_registered',
			'user_url',
		];
		if ( in_array( $by, $orderby_user_fields, true ) ) {
			$key   = "{$this->wpdb->users}.{$by}";
			$value = $this->cursor_node->{$by} ?? null;
		}

		/**
		 * If key or value are null, check whether this is a meta key based ordering before bailing.
		 */
		if ( null === $key || null === $value ) {
			$meta_key = $this->get_meta_key( $by );
			if ( $meta_key ) {
				$this->compare_with_meta_field( $meta_key, $order );
			}
			return;
		}

		// Add field to build.
		$this->builder->add_field( $key, $value, null, $order );
	}

	/**
	 * Compare with meta key field
	 *
	 * @param string $meta_key user meta key
	 * @param string $order    The comparison string
	 *
	 * @return void
	 */
	private function compare_with_meta_field( string $meta_key, string $order ) {
		$meta_type  = $this->get_query_var( 'meta_type' );
		$meta_value = get_user_meta( $this->cursor_offset, $meta_key, true );

		$key = "{$this->wpdb->usermeta}.meta_value";

		/**
		 * WP uses mt1, mt2 etc. style aliases for additional meta value joins.
		 */
		if ( 0 !== $this->meta_join_alias ) {
			$key = "mt{$this->meta_join_alias}.meta_value";
		}

		++$this->meta_join_alias;

		$this->builder->add_field( $key, $meta_value, $meta_type, $order );
	}

	/**
	 * Get the actual meta key if any
	 *
	 * @param string $by The order by key
	 *
	 * @return string|null
	 */
	private function get_meta_key( $by ) {
		if ( 'meta_value' === $by ) {
			return $this->get_query_var( 'meta_key' );
		}

		/**
		 * Check for the WP 4.2+ style meta clauses
		 * https://make.wordpress.org/core/2015/03/30/query-improvements-in-wp-4-2-orderby-and-meta_query/
		 */
		if ( ! isset( $this->query_vars['meta_query'][ $by ] ) ) {
			return null;
		}

		$clause = $this->query_vars['meta_query'][ $by ];

		return empty( $clause['key'] ) ? null : $clause['key'];
	}
}


// File: wp-graphql\src\Data\Loader\AbstractDataLoader.php
<?php

namespace WPGraphQL\Data\Loader;

use Exception;
use GraphQL\Deferred;
use GraphQL\Utils\Utils;
use WPGraphQL\AppContext;
use WPGraphQL\Model\Model;

/**
 * Class AbstractDataLoader
 *
 * @package WPGraphQL\Data\Loader
 */
abstract class AbstractDataLoader {

	/**
	 * Whether the loader should cache results or not. In some cases the loader may be used to just
	 * get content but not bother with caching it.
	 *
	 * Default: true
	 *
	 * @var bool
	 */
	private $shouldCache = true;

	/**
	 * This stores an array of items that have already been loaded
	 *
	 * @var array<int|string,mixed>
	 */
	private $cached = [];

	/**
	 * This stores an array of IDs that need to be loaded
	 *
	 * @var array<int|string,int|string>
	 */
	private $buffer = [];

	/**
	 * This stores a reference to the AppContext for the loader to make use of
	 *
	 * @var \WPGraphQL\AppContext
	 */
	protected $context;

	/**
	 * AbstractDataLoader constructor.
	 *
	 * @param \WPGraphQL\AppContext $context
	 */
	public function __construct( AppContext $context ) {
		$this->context = $context;
	}

	/**
	 * Given a Database ID, the particular loader will buffer it and resolve it deferred.
	 *
	 * @param mixed|int|string $database_id The database ID for a particular loader to load an object
	 *
	 * @return \GraphQL\Deferred|null
	 * @throws \Exception
	 */
	public function load_deferred( $database_id ) {
		if ( empty( $database_id ) ) {
			return null;
		}

		$database_id = absint( $database_id ) ? absint( $database_id ) : sanitize_text_field( $database_id );

		$this->buffer( [ $database_id ] );

		return new Deferred(
			function () use ( $database_id ) {
				return $this->load( $database_id );
			}
		);
	}

	/**
	 * Add keys to buffer to be loaded in single batch later.
	 *
	 * @param int[]|string[] $keys The keys of the objects to buffer
	 *
	 * @return $this
	 * @throws \Exception
	 */
	public function buffer( array $keys ) {
		foreach ( $keys as $index => $key ) {
			$key = $this->key_to_scalar( $key );
			if ( ! is_scalar( $key ) ) {
				throw new Exception(
					static::class . '::buffer expects all keys to be scalars, but key ' .
					'at position ' . esc_html( $index ) . ' is ' . esc_html(
						Utils::printSafe( $keys ) . '. ' .
						$this->get_scalar_key_hint( $key )
					)
				);
			}
			$this->buffer[ $key ] = 1;
		}

		return $this;
	}

	/**
	 * Loads a key and returns value represented by this key.
	 * Internally this method will load all currently buffered items and cache them locally.
	 *
	 * @param int|string|mixed $key
	 *
	 * @return ?\WPGraphQL\Model\Model
	 * @throws \Exception
	 */
	public function load( $key ) {
		$key = $this->key_to_scalar( $key );
		if ( ! is_scalar( $key ) ) {
			throw new Exception(
				static::class . '::load expects key to be scalar, but got ' . esc_html(
					Utils::printSafe( $key ) .
					$this->get_scalar_key_hint( $key )
				)
			);
		}
		if ( ! $this->shouldCache ) {
			$this->buffer = [];
		}
		$keys = [ $key ];
		$this->buffer( $keys );
		$result = $this->load_buffered();

		return isset( $result[ $key ] ) ? $this->normalize_entry( $result[ $key ], $key ) : null;
	}

	/**
	 * Adds the provided key and value to the cache. If the key already exists, no
	 * change is made. Returns itself for method chaining.
	 *
	 * @param mixed $key
	 * @param mixed $value
	 *
	 * @return $this
	 * @throws \Exception
	 */
	public function prime( $key, $value ) {
		$key = $this->key_to_scalar( $key );
		if ( ! is_scalar( $key ) ) {
			throw new Exception(
				static::class . '::prime is expecting scalar $key, but got ' . esc_html(
					Utils::printSafe( $key )
					. $this->get_scalar_key_hint( $key )
				)
			);
		}
		if ( null === $value ) {
			throw new Exception(
				static::class . '::prime is expecting non-null $value, but got null. Double-check for null or ' .
				' use `clear` if you want to clear the cache'
			);
		}
		if ( ! $this->get_cached( $key ) ) {
			/**
			 * For adding third-party caching support.
			 * Use this filter to store the queried value in a cache.
			 *
			 * @param mixed  $value         Queried object.
			 * @param mixed  $key           Object key.
			 * @param string $loader_class  Loader classname. Use as a means of identified the loader.
			 * @param mixed  $loader        Loader instance.
			 */
			$this->set_cached( $key, $value );
		}

		return $this;
	}

	/**
	 * Clears the value at `key` from the cache, if it exists. Returns itself for
	 * method chaining.
	 *
	 * @param int[]|string[] $keys
	 *
	 * @return $this
	 */
	public function clear( array $keys ) {
		foreach ( $keys as $key ) {
			$key = $this->key_to_scalar( $key );
			if ( isset( $this->cached[ $key ] ) ) {
				unset( $this->cached[ $key ] );
			}
		}

		return $this;
	}

	/**
	 * Clears the entire cache. To be used when some event results in unknown
	 * invalidations across this particular `DataLoader`. Returns itself for
	 * method chaining.
	 *
	 * @return \WPGraphQL\Data\Loader\AbstractDataLoader
	 * @deprecated in favor of clear_all
	 */
	public function clearAll() {
		_deprecated_function( __METHOD__, '0.8.4', static::class . '::clear_all()' );
		return $this->clear_all();
	}

	/**
	 * Clears the entire cache. To be used when some event results in unknown
	 * invalidations across this particular `DataLoader`. Returns itself for
	 * method chaining.
	 *
	 * @return \WPGraphQL\Data\Loader\AbstractDataLoader
	 */
	public function clear_all() {
		$this->cached = [];

		return $this;
	}

	/**
	 * Loads multiple keys. Returns generator where each entry directly corresponds to entry in
	 * $keys. If second argument $asArray is set to true, returns array instead of generator
	 *
	 * @param int[]|string[] $keys
	 * @param bool           $asArray
	 *
	 * @return \Generator|array<int|string,mixed>
	 * @throws \Exception
	 *
	 * @deprecated Use load_many instead
	 */
	public function loadMany( array $keys, $asArray = false ) {
		_deprecated_function( __METHOD__, '0.8.4', static::class . '::load_many()' );
		return $this->load_many( $keys, $asArray );
	}

	/**
	 * Loads multiple keys. Returns generator where each entry directly corresponds to entry in
	 * $keys. If second argument $asArray is set to true, returns array instead of generator
	 *
	 * @param int[]|string[] $keys
	 * @param bool           $asArray
	 *
	 * @return \Generator|array<int|string,mixed>
	 * @throws \Exception
	 */
	public function load_many( array $keys, $asArray = false ) {
		if ( empty( $keys ) ) {
			return [];
		}
		if ( ! $this->shouldCache ) {
			$this->buffer = [];
		}
		$this->buffer( $keys );
		$generator = $this->generate_many( $keys, $this->load_buffered() );

		return $asArray ? iterator_to_array( $generator ) : $generator;
	}

	/**
	 * Given an array of keys, this yields the object from the cached results
	 *
	 * @param int[]|string[]          $keys   The keys to generate results for
	 * @param array<int|string,mixed> $result The results for all keys
	 *
	 * @return \Generator
	 */
	private function generate_many( array $keys, array $result ) {
		foreach ( $keys as $key ) {
			$key = $this->key_to_scalar( $key );
			yield isset( $result[ $key ] ) ? $this->normalize_entry( $result[ $key ], $key ) : null;
		}
	}

	/**
	 * This checks to see if any items are in the buffer, and if there are this
	 * executes the loaders `loadKeys` method to load the items and adds them
	 * to the cache if necessary
	 *
	 * @return array<int|string,mixed>
	 * @throws \Exception
	 */
	private function load_buffered() {
		// Do not load previously-cached entries:
		$keysToLoad = [];
		foreach ( $this->buffer as $key => $unused ) {
			if ( ! $this->get_cached( $key ) ) {
				$keysToLoad[] = $key;
			}
		}

		$result = [];
		if ( ! empty( $keysToLoad ) ) {
			try {
				$loaded = $this->loadKeys( $keysToLoad );
			} catch ( \Throwable $e ) {
				throw new Exception(
					'Method ' . static::class . '::loadKeys is expected to return array, but it threw: ' .
					esc_html( $e->getMessage() ),
					0,
					$e // phpcs:ignore WordPress.Security.EscapeOutput.ExceptionNotEscaped
				);
			}

			if ( ! is_array( $loaded ) ) {
				throw new Exception(
					'Method ' . static::class . '::loadKeys is expected to return an array with keys ' .
					'but got: ' . esc_html( Utils::printSafe( $loaded ) )
				);
			}
			if ( $this->shouldCache ) {
				foreach ( $loaded as $key => $value ) {
					$this->set_cached( $key, $value );
				}
			}
		}

		// Re-include previously-cached entries to result:
		$result += array_intersect_key( $this->cached, $this->buffer );

		$this->buffer = [];

		return $result;
	}

	/**
	 * This helps to ensure null values aren't being loaded by accident.
	 *
	 * @param mixed $key
	 *
	 * @return string
	 */
	private function get_scalar_key_hint( $key ) {
		if ( null === $key ) {
			return ' Make sure to add additional checks for null values.';
		} else {
			return ' Try overriding ' . self::class . '::key_to_scalar if your keys are composite.';
		}
	}

	/**
	 * For loaders that need to decode keys, this method can help with that.
	 * For example, if we wanted to accept a list of RELAY style global IDs and pass them
	 * to the loader, we could have the loader centrally decode the keys into their
	 * integer values in the PostObjectLoader by overriding this method.
	 *
	 * @param int|string|mixed $key
	 *
	 * @return int|string
	 */
	protected function key_to_scalar( $key ) {
		return $key;
	}

	/**
	 * @param int|string|mixed $key
	 *
	 * @return int|string
	 * @deprecated Use key_to_scalar instead
	 */
	protected function keyToScalar( $key ) {
		_deprecated_function( __METHOD__, '0.8.4', static::class . '::key_to_scalar()' );
		return $this->key_to_scalar( $key );
	}

	/**
	 * @param mixed $entry The entry loaded from the dataloader to be used to generate a Model
	 * @param mixed $key   The Key used to identify the loaded entry
	 *
	 * @return \WPGraphQL\Model\Model|null
	 */
	protected function normalize_entry( $entry, $key ) {

		/**
		 * This filter allows the model generated by the DataLoader to be filtered.
		 *
		 * Returning anything other than null here will bypass the default model generation
		 * for an object.
		 *
		 * One example would be WooCommerce Products returning a custom Model for posts of post_type "product".
		 *
		 * @param null               $model                The filtered model to return. Default null
		 * @param mixed              $entry                The entry loaded from the dataloader to be used to generate a Model
		 * @param mixed              $key                  The Key used to identify the loaded entry
		 * @param \WPGraphQL\Data\Loader\AbstractDataLoader $abstract_data_loader The AbstractDataLoader instance
		 */
		$model         = null;
		$pre_get_model = apply_filters( 'graphql_dataloader_pre_get_model', $model, $entry, $key, $this );

		/**
		 * If a Model has been pre-loaded via filter, return it and skip the
		 */
		if ( ! empty( $pre_get_model ) ) {
			$model = $pre_get_model;
		} else {
			$model = $this->get_model( $entry, $key );
		}

		if ( $model instanceof Model && 'private' === $model->get_visibility() ) {
			return null;
		}

		/**
		 * Filter the model before returning.
		 *
		 * @param mixed              $model  The Model to be returned by the loader
		 * @param mixed              $entry  The entry loaded by dataloader that was used to create the Model
		 * @param mixed              $key    The Key that was used to load the entry
		 * @param \WPGraphQL\Data\Loader\AbstractDataLoader $loader The AbstractDataLoader Instance
		 */
		return apply_filters( 'graphql_dataloader_get_model', $model, $entry, $key, $this );
	}

	/**
	 * Returns a cached data object by key.
	 *
	 * @param int|string $key Key.
	 *
	 * @return mixed
	 */
	protected function get_cached( $key ) {
		$value = null;
		if ( isset( $this->cached[ $key ] ) ) {
			$value = $this->cached[ $key ];
		}

		/**
		 * Use this filter to retrieving cached data objects from third-party caching system.
		 *
		 * @param mixed       $value        Value to be cached.
		 * @param int|string  $key          Key identifying object.
		 * @param string      $loader_class Loader class name.
		 * @param mixed       $loader       Loader instance.
		 */
		$value = apply_filters(
			'graphql_dataloader_get_cached',
			$value,
			$key,
			static::class,
			$this
		);

		if ( $value && ! isset( $this->cached[ $key ] ) ) {
			$this->cached[ $key ] = $value;
		}

		return $value;
	}

	/**
	 * Caches a data object by key.
	 *
	 * @param int|string $key    Key.
	 * @param mixed      $value  Data object.
	 *
	 * @return void
	 */
	protected function set_cached( $key, $value ) {
		/**
		 * Use this filter to store entry in a third-party caching system.
		 *
		 * @param mixed  $value         Value to be cached.
		 * @param mixed  $key           Key identifying object.
		 * @param string $loader_class  Loader class name.
		 * @param mixed  $loader        Loader instance.
		 */
		$this->cached[ $key ] = apply_filters(
			'graphql_dataloader_set_cached',
			$value,
			$key,
			static::class,
			$this
		);
	}

	/**
	 * If the loader needs to do any tweaks between getting raw data from the DB and caching,
	 * this can be overridden by the specific loader and used for transformations, etc.
	 *
	 * @param mixed $entry The entry data to be used to generate a Model.
	 * @param mixed $key   The Key to identify the entry by.
	 *
	 * @return ?\WPGraphQL\Model\Model
	 */
	protected function get_model( $entry, $key ) {
		return $entry;
	}

	/**
	 * Given array of keys, loads and returns a map consisting of keys from `keys` array and loaded
	 * values
	 *
	 * Note that order of returned values must match exactly the order of keys.
	 * If some entry is not available for given key - it must include null for the missing key.
	 *
	 * For example:
	 * loadKeys(['a', 'b', 'c']) -> ['a' => 'value1, 'b' => null, 'c' => 'value3']
	 *
	 * @param int[]|string[] $keys
	 *
	 * @return array<int|string,mixed>
	 */
	abstract protected function loadKeys( array $keys );
}


// File: wp-graphql\src\Data\Loader\CommentAuthorLoader.php
<?php
namespace WPGraphQL\Data\Loader;

use WPGraphQL\Model\CommentAuthor;

/**
 * Class CommentAuthorLoader
 *
 * @package WPGraphQL\Data\Loader
 */
class CommentAuthorLoader extends AbstractDataLoader {

	/**
	 * {@inheritDoc}
	 *
	 * @return ?\WPGraphQL\Model\CommentAuthor
	 */
	protected function get_model( $entry, $key ) {
		if ( ! $entry instanceof \WP_Comment ) {
			return null;
		}

		return new CommentAuthor( $entry );
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param int[] $keys Array of IDs to load
	 */
	public function loadKeys( array $keys ) {
		/**
		 * Prepare the args for the query. We're provided a specific set of IDs of comments
		 * so we want to query as efficiently as possible with as little overhead to get the comment
		 * objects. No need to count the rows, etc.
		 */
		$args = [
			'comment__in'   => $keys,
			'orderby'       => 'comment__in',
			'number'        => count( $keys ),
			'no_found_rows' => true,
			'count'         => false,
		];

		/**
		 * Execute the query. Call get_comments() to add them to the cache.
		 */
		$query = new \WP_Comment_Query( $args );
		$query->get_comments();
		$loaded = [];
		foreach ( $keys as $key ) {
			$loaded[ $key ] = \WP_Comment::get_instance( $key );
		}
		return $loaded;
	}
}


// File: wp-graphql\src\Data\Loader\CommentLoader.php
<?php

namespace WPGraphQL\Data\Loader;

use WPGraphQL\Model\Comment;

/**
 * Class CommentLoader
 *
 * @package WPGraphQL\Data\Loader
 */
class CommentLoader extends AbstractDataLoader {

	/**
	 * {@inheritDoc}
	 *
	 * @return ?\WPGraphQL\Model\Comment
	 * @throws \Exception
	 */
	protected function get_model( $entry, $key ) {
		if ( ! $entry instanceof \WP_Comment ) {
			return null;
		}

		$comment_model = new Comment( $entry );
		if ( empty( $comment_model->fields ) ) {
			return null;
		}

		return $comment_model;
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param int[] $keys Array of IDs to load
	 */
	public function loadKeys( array $keys = [] ) {

		/**
		 * Prepare the args for the query. We're provided a specific set of IDs of comments
		 * so we want to query as efficiently as possible with as little overhead to get the comment
		 * objects. No need to count the rows, etc.
		 */
		$args = [
			'comment__in'   => $keys,
			'orderby'       => 'comment__in',
			'number'        => count( $keys ),
			'no_found_rows' => true,
			'count'         => false,
		];

		/**
		 * Execute the query. Call get_comments() to add them to the cache.
		 */
		$query = new \WP_Comment_Query( $args );
		$query->get_comments();
		$loaded = [];
		foreach ( $keys as $key ) {
			$loaded[ $key ] = \WP_Comment::get_instance( $key );
		}
		return $loaded;
	}
}


// File: wp-graphql\src\Data\Loader\EnqueuedScriptLoader.php
<?php
namespace WPGraphQL\Data\Loader;

/**
 * Class EnqueuedScriptLoader
 *
 * @package WPGraphQL\Data\Loader
 */
class EnqueuedScriptLoader extends AbstractDataLoader {

	/**
	 * {@inheritDoc}
	 *
	 * @param string[] $keys Array of script handles to load
	 *
	 * @return array<string,mixed>
	 */
	public function loadKeys( array $keys ) {
		/** @var \WP_Scripts $wp_scripts */
		global $wp_scripts;

		$loaded = [];
		foreach ( $keys as $key ) {
			if ( isset( $wp_scripts->registered[ $key ] ) ) {
				$script         = $wp_scripts->registered[ $key ];
				$script->type   = 'EnqueuedScript';
				$loaded[ $key ] = $script;
			} else {
				$loaded[ $key ] = null;
			}
		}
		return $loaded;
	}
}


// File: wp-graphql\src\Data\Loader\EnqueuedStylesheetLoader.php
<?php
namespace WPGraphQL\Data\Loader;

/**
 * Class EnqueuedStylesheetLoader
 *
 * @package WPGraphQL\Data\Loader
 */
class EnqueuedStylesheetLoader extends AbstractDataLoader {

	/**
	 * {@inheritDoc}
	 *
	 * @param string[] $keys Array of stylesheet handles to load
	 *
	 * @return array<string,mixed>
	 */
	public function loadKeys( array $keys ) {
		global $wp_styles;
		$loaded = [];
		foreach ( $keys as $key ) {
			if ( isset( $wp_styles->registered[ $key ] ) ) {
				$stylesheet       = $wp_styles->registered[ $key ];
				$stylesheet->type = 'EnqueuedStylesheet';
				$loaded[ $key ]   = $stylesheet;
			} else {
				$loaded[ $key ] = null;
			}
		}
		return $loaded;
	}
}


// File: wp-graphql\src\Data\Loader\PluginLoader.php
<?php

namespace WPGraphQL\Data\Loader;

use WPGraphQL\Model\Plugin;

/**
 * Class PluginLoader
 *
 * @package WPGraphQL\Data\Loader
 */
class PluginLoader extends AbstractDataLoader {

	/**
	 * {@inheritDoc}
	 *
	 * @param array<string,mixed> $entry The plugin data
	 *
	 * @return \WPGraphQL\Model\Plugin
	 * @throws \Exception
	 */
	protected function get_model( $entry, $key ) {
		return new Plugin( $entry );
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param string[] $keys Array of plugin names to load
	 *
	 * @return array<string,array<string,mixed>|null>
	 * @throws \Exception
	 */
	public function loadKeys( array $keys ) {
		if ( empty( $keys ) ) {
			return $keys;
		}
		require_once ABSPATH . 'wp-admin/includes/plugin.php';
		// This is missing must use and drop in plugins, so we need to fetch and merge them separately.
		$site_plugins   = apply_filters( 'all_plugins', get_plugins() );
		$mu_plugins     = apply_filters( 'show_advanced_plugins', true, 'mustuse' ) ? get_mu_plugins() : [];
		$dropin_plugins = apply_filters( 'show_advanced_plugins', true, 'dropins' ) ? get_dropins() : [];

		$plugins = array_merge( $site_plugins, $mu_plugins, $dropin_plugins );

		$loaded = [];
		if ( ! empty( $plugins ) ) {
			foreach ( $keys as $key ) {
				if ( isset( $plugins[ $key ] ) ) {
					$plugin         = $plugins[ $key ];
					$plugin['Path'] = $key;
					$loaded[ $key ] = $plugin;
				} else {
					$loaded[ $key ] = null;
				}
			}
		}

		return $loaded;
	}
}


// File: wp-graphql\src\Data\Loader\PostObjectLoader.php
<?php

namespace WPGraphQL\Data\Loader;

use WPGraphQL\Model\MenuItem;
use WPGraphQL\Model\Post;

/**
 * Class PostObjectLoader
 *
 * @package WPGraphQL\Data\Loader
 */
class PostObjectLoader extends AbstractDataLoader {

	/**
	 * {@inheritDoc}
	 *
	 * @param mixed|\WP_Post $entry The Post Object
	 *
	 * @return \WPGraphQL\Model\Post|\WPGraphQL\Model\MenuItem|null
	 */
	protected function get_model( $entry, $key ) {
		if ( ! $entry instanceof \WP_Post ) {
			return null;
		}

		/**
		 * If there's a Post Author connected to the post, we need to resolve the
		 * user as it gets set in the globals via `setup_post_data()` and doing it this way
		 * will batch the loading so when `setup_post_data()` is called the user
		 * is already in the cache.
		 */
		$context = $this->context;

		if ( ! empty( $entry->post_author ) && absint( $entry->post_author ) ) {
			$user_id = $entry->post_author;
			$context->get_loader( 'user' )->load_deferred( $user_id );
		}

		if ( 'revision' === $entry->post_type && ! empty( $entry->post_parent ) && absint( $entry->post_parent ) ) {
			$post_parent = $entry->post_parent;
			$context->get_loader( 'post' )->load_deferred( $post_parent );
		}

		if ( 'nav_menu_item' === $entry->post_type ) {
			return new MenuItem( $entry );
		}

		$post = new Post( $entry );
		if ( empty( $post->fields ) ) {
			return null;
		}

		return $post;
	}

	/**
	 * {@inheritDoc}
	 *
	 * @return array<string|int,\WP_Post|null>
	 */
	public function loadKeys( array $keys ) {
		if ( empty( $keys ) ) {
			return $keys;
		}

		/**
		 * Prepare the args for the query. We're provided a specific
		 * set of IDs, so we want to query as efficiently as possible with
		 * as little overhead as possible. We don't want to return post counts,
		 * we don't want to include sticky posts, and we want to limit the query
		 * to the count of the keys provided. The query must also return results
		 * in the same order the keys were provided in.
		 */
		$post_types = \WPGraphQL::get_allowed_post_types();
		$post_types = array_merge( $post_types, [ 'revision', 'nav_menu_item' ] );
		$args       = [
			'post_type'           => $post_types,
			'post_status'         => 'any',
			'posts_per_page'      => count( $keys ),
			'post__in'            => $keys,
			'orderby'             => 'post__in',
			'no_found_rows'       => true,
			'split_the_query'     => false,
			'ignore_sticky_posts' => true,
		];

		/**
		 * Ensure that WP_Query doesn't first ask for IDs since we already have them.
		 */
		add_filter(
			'split_the_query',
			static function ( $split, \WP_Query $query ) {
				if ( false === $query->get( 'split_the_query' ) ) {
					return false;
				}

				return $split;
			},
			10,
			2
		);
		new \WP_Query( $args );
		$loaded_posts = [];
		foreach ( $keys as $key ) {
			/**
			 * The query above has added our objects to the cache
			 * so now we can pluck them from the cache to return here
			 * and if they don't exist we can throw an error, otherwise
			 * we can proceed to resolve the object via the Model layer.
			 */
			$post_object = get_post( (int) $key );

			if ( ! $post_object instanceof \WP_Post ) {
				$loaded_posts[ $key ] = null;
			} else {

				/**
				 * Once dependencies are loaded, return the Post Object
				 */
				$loaded_posts[ $key ] = $post_object;
			}
		}
		return $loaded_posts;
	}
}


// File: wp-graphql\src\Data\Loader\PostTypeLoader.php
<?php
namespace WPGraphQL\Data\Loader;

use WPGraphQL\Model\PostType;

/**
 * Class PostTypeLoader
 *
 * @package WPGraphQL\Data\Loader
 */
class PostTypeLoader extends AbstractDataLoader {

	/**
	 * {@inheritDoc}
	 *
	 * @param mixed|\WP_Post_Type $entry The Post Type Object
	 *
	 * @return \WPGraphQL\Model\PostType
	 */
	protected function get_model( $entry, $key ) {
		return new PostType( $entry );
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param string[] $keys
	 * @return array<string,\WP_Post|null>
	 */
	public function loadKeys( array $keys ) {
		$post_types = \WPGraphQL::get_allowed_post_types( 'objects' );

		$loaded = [];
		if ( ! empty( $post_types ) && is_array( $post_types ) ) {
			foreach ( $keys as $key ) {
				if ( isset( $post_types[ $key ] ) ) {
					$loaded[ $key ] = $post_types[ $key ];
				} else {
					$loaded[ $key ] = null;
				}
			}
		}

		return $loaded;
	}
}


// File: wp-graphql\src\Data\Loader\TaxonomyLoader.php
<?php
namespace WPGraphQL\Data\Loader;

use WPGraphQL\Model\Taxonomy;

/**
 * Class TaxonomyLoader
 *
 * @package WPGraphQL\Data\Loader
 */
class TaxonomyLoader extends AbstractDataLoader {

	/**
	 * {@inheritDoc}
	 *
	 * @param mixed|\WP_Taxonomy $entry The Taxonomy Object
	 *
	 * @return \WPGraphQL\Model\Taxonomy
	 */
	protected function get_model( $entry, $key ) {
		return new Taxonomy( $entry );
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param string[] $keys
	 *
	 * @return array<string,\WP_Taxonomy|null>
	 */
	public function loadKeys( array $keys ) {
		$taxonomies = \WPGraphQL::get_allowed_taxonomies( 'objects' );

		$loaded = [];
		if ( ! empty( $taxonomies ) && is_array( $taxonomies ) ) {
			foreach ( $keys as $key ) {
				if ( isset( $taxonomies[ $key ] ) ) {
					$loaded[ $key ] = $taxonomies[ $key ];
				} else {
					$loaded[ $key ] = null;
				}
			}
		}

		return $loaded;
	}
}


// File: wp-graphql\src\Data\Loader\TermObjectLoader.php
<?php

namespace WPGraphQL\Data\Loader;

use WPGraphQL\Model\Menu;
use WPGraphQL\Model\Term;

/**
 * Class TermObjectLoader
 *
 * @package WPGraphQL\Data\Loader
 */
class TermObjectLoader extends AbstractDataLoader {

	/**
	 * {@inheritDoc}
	 *
	 * @param mixed|\WP_Term $entry The Term Object
	 *
	 * @return \WPGraphQL\Model\Term|\WPGraphQL\Model\Menu|null
	 * @throws \Exception
	 */
	protected function get_model( $entry, $key ) {
		if ( is_a( $entry, 'WP_Term' ) ) {

			/**
			 * For nav_menu terms, we want to pass through a different model
			 */
			if ( 'nav_menu' === $entry->taxonomy ) {
				$menu = new Menu( $entry );
				if ( empty( $menu->fields ) ) {
					return null;
				} else {
					return $menu;
				}
			} else {
				$term = new Term( $entry );
				if ( empty( $term->fields ) ) {
					return null;
				} else {
					return $term;
				}
			}
		}
		return null;
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param int[] $keys
	 *
	 * @return array<int,\WP_Term|\WP_Error|null>
	 */
	public function loadKeys( array $keys ) {
		if ( empty( $keys ) ) {
			return $keys;
		}

		/**
		 * Prepare the args for the query. We're provided a specific set of IDs for terms,
		 * so we want to query as efficiently as possible with as little overhead as possible.
		 */
		$args = [
			'include'    => $keys,
			'number'     => count( $keys ),
			'orderby'    => 'include',
			'hide_empty' => false,
		];

		/**
		 * Execute the query. This adds the terms to the cache
		 */
		$query = new \WP_Term_Query( $args );
		$terms = $query->get_terms();

		if ( empty( $terms ) || ! is_array( $terms ) ) {
			return [];
		}

		$loaded = [];

		/**
		 * Loop over the keys and return an array of loaded_terms, where the key is the ID and the value is
		 * the Term passed through the Model layer
		 */
		foreach ( $keys as $key ) {

			/**
			 * The query above has added our objects to the cache, so now we can pluck
			 * them from the cache to pass through the model layer, or return null if the
			 * object isn't in the cache, meaning it didn't come back when queried.
			 */
			$loaded[ $key ] = get_term( (int) $key );
		}

		return $loaded;
	}
}


// File: wp-graphql\src\Data\Loader\ThemeLoader.php
<?php
namespace WPGraphQL\Data\Loader;

use WPGraphQL\Model\Theme;

/**
 * Class ThemeLoader
 *
 * @package WPGraphQL\Data\Loader
 */
class ThemeLoader extends AbstractDataLoader {

	/**
	 * {@inheritDoc}
	 *
	 * @param mixed|\WP_Theme $entry The User Role object
	 *
	 * @return \WPGraphQL\Model\Theme
	 */
	protected function get_model( $entry, $key ) {
		return new Theme( $entry );
	}

	/**
	 * {@inheritDoc}
	 *
	 * @return array<int|string,?\WP_Theme>
	 */
	public function loadKeys( array $keys ) {
		$themes = wp_get_themes();
		$loaded = [];

		if ( is_array( $themes ) && ! empty( $themes ) ) {
			foreach ( $keys as $key ) {
				$loaded[ $key ] = null;

				if ( isset( $themes[ $key ] ) ) {
					$stylesheet = $themes[ $key ]->get_stylesheet();
					$theme      = wp_get_theme( $stylesheet );
					if ( $theme->exists() ) {
						$loaded[ $key ] = $theme;
					} else {
						$loaded[ $key ] = null;
					}
				}
			}
		}

		return $loaded;
	}
}


// File: wp-graphql\src\Data\Loader\UserLoader.php
<?php
namespace WPGraphQL\Data\Loader;

use WPGraphQL\Model\User;

/**
 * Class UserLoader
 *
 * @package WPGraphQL\Data\Loader
 */
class UserLoader extends AbstractDataLoader {

	/**
	 * {@inheritDoc}
	 *
	 * @param mixed|\WP_User $entry The User object
	 *
	 * @return ?\WPGraphQL\Model\User
	 * @throws \Exception
	 */
	protected function get_model( $entry, $key ) {
		if ( $entry instanceof \WP_User ) {
			return new User( $entry );
		} else {
			return null;
		}
	}

	/**
	 * The data loader always returns a user object if it exists, but we need to
	 * separately determine whether the user should be considered private. The
	 * WordPress frontend does not expose authors without published posts, so our
	 * privacy model follows that same convention.
	 *
	 * Example return format for input "[ 1, 2 ]":
	 *
	 * [
	 *   2 => true,  // User 2 is public (has published posts)
	 * ]
	 *
	 * In this example, user 1 is not public (has no published posts) and is
	 * omitted from the returned array.
	 *
	 * @param int[] $keys Array of author IDs (int).
	 *
	 * @return array<int,bool> Associative array of author IDs (int) to boolean.
	 */
	public function get_public_users( array $keys ) {

		// Get public post types that are set to show in GraphQL
		// as public users are determined by whether they've published
		// content in one of these post types
		$post_types = \WPGraphQL::get_allowed_post_types(
			'names',
			[
				'public' => true,
			]
		);

		/**
		 * Exclude revisions and attachments, since neither ever receive the
		 * "publish" post status.
		 */
		unset( $post_types['revision'], $post_types['attachment'] );

		/**
		 * Only retrieve public posts by the provided author IDs. Also,
		 * get_posts_by_author_sql only accepts a single author ID, so we'll need to
		 * add our own IN statement.
		 */
		$author_id   = null;
		$public_only = true;

		$where = get_posts_by_author_sql( $post_types, true, $author_id, $public_only );
		$ids   = implode( ', ', array_fill( 0, count( $keys ), '%d' ) );
		$count = count( $keys );

		global $wpdb;

		$results = $wpdb->get_results( // phpcs:ignore WordPress.DB.DirectDatabaseQuery.NoCaching,WordPress.DB.DirectDatabaseQuery.DirectQuery
			$wpdb->prepare(
				"SELECT DISTINCT `post_author` FROM $wpdb->posts $where AND `post_author` IN ( $ids ) LIMIT $count", // phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared,WordPress.DB.PreparedSQLPlaceholders.UnfinishedPrepare
				$keys
			)
		);

		/**
		 * Empty results or error.
		 */
		if ( ! is_array( $results ) ) {
			return [];
		}

		/**
		 * Reduce to an associative array that can be easily consumed.
		 */
		return array_reduce(
			$results,
			static function ( $carry, $result ) {
				$carry[ (int) $result->post_author ] = true;
				return $carry;
			},
			[]
		);
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param int[] $keys
	 *
	 * @return array<int,\WP_User|null>
	 */
	public function loadKeys( array $keys ) {
		if ( empty( $keys ) ) {
			return $keys;
		}

		/**
		 * Prepare the args for the query. We're provided a specific
		 * set of IDs, so we want to query as efficiently as possible with
		 * as little overhead as possible. We don't want to return post counts,
		 * we don't want to include sticky posts, and we want to limit the query
		 * to the count of the keys provided. We don't care about the order since we
		 * will reorder them ourselves to match the order of the provided keys.
		 */
		$args = [
			'include'     => $keys,
			'number'      => count( $keys ),
			'count_total' => false,
			'fields'      => 'all_with_meta',
		];

		/**
		 * Query for the users and get the results
		 */
		$query = new \WP_User_Query( $args );
		$query->get_results();

		/**
		 * Determine which of the users are public (have published posts).
		 */
		$public_users = $this->get_public_users( $keys );

		/**
		 * Loop over the keys and reduce to an associative array, providing the
		 * WP_User instance (if found) or null. This ensures that the returned array
		 * has the same keys that were provided and in the same order.
		 */
		return array_reduce(
			$keys,
			static function ( $carry, $key ) use ( $public_users ) {
				$user = get_user_by( 'id', $key ); // Cached via previous WP_User_Query.

				if ( $user instanceof \WP_User ) {
					/**
					 * Set a property on the user that can be accessed by the User model.
					 */
					// @phpstan-ignore-next-line
					$user->is_private = ! isset( $public_users[ $key ] );

					$carry[ $key ] = $user;
				} else {
					$carry[ $key ] = null;
				}

				return $carry;
			},
			[]
		);
	}
}


// File: wp-graphql\src\Data\Loader\UserRoleLoader.php
<?php

namespace WPGraphQL\Data\Loader;

use WPGraphQL\Model\UserRole;

/**
 * Class UserRoleLoader
 *
 * @package WPGraphQL\Data\Loader
 */
class UserRoleLoader extends AbstractDataLoader {

	/**
	 * {@inheritDoc}
	 *
	 * @return \WPGraphQL\Model\UserRole
	 */
	protected function get_model( $entry, $key ) {
		return new UserRole( $entry );
	}

	/**
	 * {@inheritDoc}
	 */
	public function loadKeys( array $keys ) {
		$wp_roles = wp_roles()->roles;

		$loaded = [];
		if ( ! empty( $wp_roles ) && is_array( $wp_roles ) ) {
			foreach ( $keys as $key ) {
				if ( isset( $wp_roles[ $key ] ) ) {
					$role                = $wp_roles[ $key ];
					$role['slug']        = $key;
					$role['id']          = $key;
					$role['displayName'] = $role['name'];
					$role['name']        = $key;
					$loaded[ $key ]      = $role;
				} else {
					$loaded[ $key ] = null;
				}
			}
		}

		return $loaded;
	}
}


// File: wp-graphql\src\Model\Avatar.php
<?php

namespace WPGraphQL\Model;

/**
 * Class Avatar - Models data for avatars
 *
 * @property int    $size
 * @property int    $height
 * @property int    $width
 * @property string $default
 * @property bool   $forceDefault
 * @property string $rating
 * @property string $scheme
 * @property string $extraAttr
 * @property bool   $foundAvatar
 * @property string $url
 *
 * @package WPGraphQL\Model
 */
class Avatar extends Model {

	/**
	 * Stores the incoming avatar to be modeled
	 *
	 * @var array<string,mixed>
	 */
	protected $data;

	/**
	 * Avatar constructor.
	 *
	 * @param array<string,mixed> $avatar The incoming avatar to be modeled.
	 */
	public function __construct( array $avatar ) {
		$this->data = $avatar;
		parent::__construct();
	}

	/**
	 * @return bool
	 */
	protected function is_private() {
		$show_avatars = get_option( 'show_avatars' );
		return ! (bool) $show_avatars;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function init() {
		if ( empty( $this->fields ) ) {
			$this->fields = [
				'size'         => function () {
					return ! empty( $this->data['size'] ) ? absint( $this->data['size'] ) : null;
				},
				'height'       => function () {
					return ! empty( $this->data['height'] ) ? absint( $this->data['height'] ) : null;
				},
				'width'        => function () {
					return ! empty( $this->data['width'] ) ? absint( $this->data['width'] ) : null;
				},
				'default'      => function () {
					return ! empty( $this->data['default'] ) ? $this->data['default'] : null;
				},
				'forceDefault' => function () {
					return ! empty( $this->data['force_default'] );
				},
				'rating'       => function () {
					return ! empty( $this->data['rating'] ) ? $this->data['rating'] : null;
				},
				'scheme'       => function () {
					return ! empty( $this->data['scheme'] ) ? $this->data['scheme'] : null;
				},
				'extraAttr'    => function () {
					return ! empty( $this->data['extra_attr'] ) ? $this->data['extra_attr'] : null;
				},
				'foundAvatar'  => function () {
					return ! empty( $this->data['found_avatar'] );
				},
				'url'          => function () {
					return ! empty( $this->data['url'] ) ? $this->data['url'] : null;
				},
			];
		}
	}
}


// File: wp-graphql\src\Model\Comment.php
<?php

namespace WPGraphQL\Model;

use GraphQLRelay\Relay;
use WP_Comment;

/**
 * Class Comment - Models data for Comments
 *
 * @property int    $comment_ID
 * @property int    $comment_parent_id
 * @property int    $commentId
 * @property int    $parentDatabaseId
 * @property int    $userId
 * @property string $agent
 * @property string $authorIp
 * @property string $comment_author
 * @property string $comment_author_url
 * @property string $commentAuthorEmail
 * @property string $contentRaw
 * @property string $contentRendered
 * @property string $date
 * @property string $dateGmt
 * @property string $id
 * @property string $karma
 * @property string $link
 * @property string $parentId
 * @property string $status
 * @property string $type
 * @property string $uri
 *
 * @package WPGraphQL\Model
 */
class Comment extends Model {

	/**
	 * Stores the incoming WP_Comment object to be modeled
	 *
	 * @var \WP_Comment $data
	 */
	protected $data;

	/**
	 * Comment constructor.
	 *
	 * @param \WP_Comment $comment The incoming WP_Comment to be modeled
	 */
	public function __construct( WP_Comment $comment ) {
		$allowed_restricted_fields = [
			'id',
			'ID',
			'commentId',
			'databaseId',
			'contentRendered',
			'date',
			'dateGmt',
			'karma',
			'link',
			'type',
			'commentedOnId',
			'comment_post_ID',
			'approved',
			'status',
			'comment_parent_id',
			'parentId',
			'parentDatabaseId',
			'isRestricted',
			'uri',
			'userId',
		];

		$this->data = $comment;
		$owner      = ! empty( $comment->user_id ) ? absint( $comment->user_id ) : null;
		parent::__construct( 'moderate_comments', $allowed_restricted_fields, $owner );
	}

	/**
	 * {@inheritDoc}
	 */
	protected function is_private() {
		if ( empty( $this->data->comment_post_ID ) ) {
			return true;
		}

		// if the current user is the author of the comment, the comment should not be private
		if ( 0 !== wp_get_current_user()->ID && absint( $this->data->user_id ) === absint( wp_get_current_user()->ID ) ) {
			return false;
		}

		$commented_on = get_post( (int) $this->data->comment_post_ID );

		if ( ! $commented_on instanceof \WP_Post ) {
			return true;
		}

		// A comment is considered private if it is attached to a private post.
		if ( true === ( new Post( $commented_on ) )->is_private() ) {
			return true;
		}

		if ( 0 === absint( $this->data->comment_approved ) && ! current_user_can( 'moderate_comments' ) ) {
			return true;
		}

		return false;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function init() {
		if ( empty( $this->fields ) ) {
			$this->fields = [
				'id'                 => function () {
					return ! empty( $this->data->comment_ID ) ? Relay::toGlobalId( 'comment', $this->data->comment_ID ) : null;
				},
				'commentId'          => function () {
					return ! empty( $this->data->comment_ID ) ? absint( $this->data->comment_ID ) : 0;
				},
				'databaseId'         => function () {
					return ! empty( $this->data->comment_ID ) ? $this->data->comment_ID : 0;
				},
				'commentAuthorEmail' => function () {
					return ! empty( $this->data->comment_author_email ) ? $this->data->comment_author_email : 0;
				},
				'comment_ID'         => function () {
					return ! empty( $this->data->comment_ID ) ? absint( $this->data->comment_ID ) : 0;
				},
				'comment_post_ID'    => function () {
					return ! empty( $this->data->comment_post_ID ) ? absint( $this->data->comment_post_ID ) : null;
				},
				'comment_parent_id'  => function () {
					return ! empty( $this->data->comment_parent ) ? absint( $this->data->comment_parent ) : 0;
				},
				'parentDatabaseId'   => function () {
					return ! empty( $this->data->comment_parent ) ? absint( $this->data->comment_parent ) : 0;
				},
				'parentId'           => function () {
					return ! empty( $this->comment_parent_id ) ? Relay::toGlobalId( 'comment', $this->data->comment_parent ) : null;
				},
				'comment_author'     => function () {
					return ! empty( $this->data->comment_author ) ? absint( $this->data->comment_author ) : null;
				},
				'comment_author_url' => function () {
					return ! empty( $this->data->comment_author_url ) ? absint( $this->data->comment_author_url ) : null;
				},
				'authorIp'           => function () {
					return ! empty( $this->data->comment_author_IP ) ? $this->data->comment_author_IP : null;
				},
				'date'               => function () {
					return ! empty( $this->data->comment_date ) ? $this->data->comment_date : null;
				},
				'dateGmt'            => function () {
					return ! empty( $this->data->comment_date_gmt ) ? $this->data->comment_date_gmt : null;
				},
				'contentRaw'         => function () {
					return ! empty( $this->data->comment_content ) ? $this->data->comment_content : null;
				},
				'contentRendered'    => function () {
					$content = ! empty( $this->data->comment_content ) ? $this->data->comment_content : null;

					return $this->html_entity_decode( apply_filters( 'comment_text', $content, $this->data ), 'contentRendered', false );
				},
				'karma'              => function () {
					return ! empty( $this->data->comment_karma ) ? $this->data->comment_karma : null;
				},
				'link'               => function () {
					$link = get_comment_link( $this->data );

					return ! empty( $link ) ? urldecode( $link ) : null;
				},
				'approved'           => function () {
					_doing_it_wrong( __METHOD__, 'The approved field is deprecated in favor of `status`', '1.13.0' );
					return ! empty( $this->data->comment_approved ) && 'hold' !== $this->data->comment_approved;
				},
				'status'             => function () {
					if ( ! is_numeric( $this->data->comment_approved ) ) {
						return $this->data->comment_approved;
					}

					return '1' === $this->data->comment_approved ? 'approve' : 'hold';
				},
				'agent'              => function () {
					return ! empty( $this->data->comment_agent ) ? $this->data->comment_agent : null;
				},
				'type'               => function () {
					return ! empty( $this->data->comment_type ) ? $this->data->comment_type : null;
				},
				'uri'                => function () {
					$uri = $this->link;

					return ! empty( $uri ) ? str_ireplace( home_url(), '', $uri ) : null;
				},
				'userId'             => function () {
					return ! empty( $this->data->user_id ) ? absint( $this->data->user_id ) : null;
				},
			];
		}
	}
}


// File: wp-graphql\src\Model\CommentAuthor.php
<?php

namespace WPGraphQL\Model;

use GraphQLRelay\Relay;
use WP_Comment;

/**
 * Class CommentAuthor - Models the CommentAuthor object
 *
 * @property string $id
 * @property int    $databaseId
 * @property string $name
 * @property string $email
 * @property string $url
 *
 * @package WPGraphQL\Model
 */
class CommentAuthor extends Model {

	/**
	 * Stores the comment author to be modeled
	 *
	 * @var \WP_Comment $data The raw data passed to he model
	 */
	protected $data;

	/**
	 * CommentAuthor constructor.
	 *
	 * @param \WP_Comment $comment_author The incoming comment author array to be modeled
	 */
	public function __construct( WP_Comment $comment_author ) {
		$this->data = $comment_author;
		parent::__construct();
	}

	/**
	 * {@inheritDoc}
	 */
	protected function init() {
		if ( empty( $this->fields ) ) {
			$this->fields = [
				'id'         => function () {
					return ! empty( $this->data->comment_ID ) ? Relay::toGlobalId( 'comment_author', $this->data->comment_ID ) : null;
				},
				'databaseId' => function () {
					return ! empty( $this->data->comment_ID ) ? absint( $this->data->comment_ID ) : null;
				},
				'name'       => function () {
					return ! empty( $this->data->comment_author ) ? $this->data->comment_author : null;
				},
				'email'      => function () {
					return current_user_can( 'moderate_comments' ) && ! empty( $this->data->comment_author_email ) ? $this->data->comment_author_email : null;
				},
				'url'        => function () {
					return ! empty( $this->data->comment_author_url ) ? $this->data->comment_author_url : '';
				},
			];
		}
	}
}


// File: wp-graphql\src\Model\Menu.php
<?php

namespace WPGraphQL\Model;

use GraphQLRelay\Relay;

/**
 * Class Menu - Models data for Menus
 *
 * @property string $id
 * @property int    $count
 * @property int    $menuId
 * @property int    $databaseId
 * @property string $name
 * @property string $slug
 *
 * @package WPGraphQL\Model
 */
class Menu extends Model {

	/**
	 * Stores the incoming WP_Term object
	 *
	 * @var \WP_Term $data
	 */
	protected $data;

	/**
	 * Menu constructor.
	 *
	 * @param \WP_Term $term The incoming WP_Term object that needs modeling
	 *
	 * @return void
	 */
	public function __construct( \WP_Term $term ) {
		$this->data = $term;
		parent::__construct();
	}

	/**
	 * {@inheritDoc}
	 *
	 * If a Menu is not connected to a menu that's assigned to a location
	 * it's not considered a public node.
	 */
	public function is_private() {

		// If the current user can edit theme options, consider the menu public
		if ( current_user_can( 'edit_theme_options' ) ) {
			return false;
		}

		$locations = get_theme_mod( 'nav_menu_locations' );
		if ( empty( $locations ) ) {
			return true;
		}
		$location_ids = array_values( $locations );
		if ( empty( $location_ids ) || ! in_array( $this->data->term_id, array_values( $location_ids ), true ) ) {
			return true;
		}

		return false;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function init() {
		if ( empty( $this->fields ) ) {
			$this->fields = [
				'id'         => function () {
					return ! empty( $this->data->term_id ) ? Relay::toGlobalId( 'term', (string) $this->data->term_id ) : null;
				},
				'count'      => function () {
					return ! empty( $this->data->count ) ? absint( $this->data->count ) : null;
				},
				'menuId'     => function () {
					return ! empty( $this->data->term_id ) ? absint( $this->data->term_id ) : null;
				},
				'databaseId' => function () {
					return ! empty( $this->data->term_id ) ? absint( $this->data->term_id ) : null;
				},
				'name'       => function () {
					return ! empty( $this->data->name ) ? $this->data->name : null;
				},
				'slug'       => function () {
					return ! empty( $this->data->slug ) ? urldecode( $this->data->slug ) : null;
				},
				'locations'  => function () {
					$menu_locations = get_theme_mod( 'nav_menu_locations' );

					if ( empty( $menu_locations ) || ! is_array( $menu_locations ) ) {
						return null;
					}

					$locations = null;
					foreach ( $menu_locations as $location => $id ) {
						if ( absint( $id ) === ( $this->data->term_id ) ) {
							$locations[] = $location;
						}
					}

					return $locations;
				},
			];
		}
	}
}


// File: wp-graphql\src\Model\MenuItem.php
<?php

namespace WPGraphQL\Model;

use Exception;
use GraphQL\Error\UserError;
use GraphQLRelay\Relay;
use WP_Post;

/**
 * Class MenuItem - Models the data for the MenuItem object type
 *
 * @property string $id
 * @property array  $cssClasses
 * @property string $description
 * @property string $label
 * @property string $linkRelationship
 * @property int    $menuItemId
 * @property int    $databaseId
 * @property int    $objectId
 * @property string $target
 * @property string $title
 * @property string $url
 * @property string $menuId
 * @property int    $menuDatabaseId
 * @property array  $locations
 *
 * @package WPGraphQL\Model
 */
class MenuItem extends Model {

	/**
	 * Stores the incoming post data
	 *
	 * @var mixed|object $data
	 */
	protected $data;

	/**
	 * MenuItem constructor.
	 *
	 * @param \WP_Post $post The incoming WP_Post object that needs modeling
	 *
	 * @return void
	 */
	public function __construct( WP_Post $post ) {
		$this->data = wp_setup_nav_menu_item( $post );
		parent::__construct();
	}

	/**
	 * {@inheritDoc}
	 *
	 * If a MenuItem is not connected to a menu that's assigned to a location
	 * it's not considered a public node.
	 *
	 * @throws \Exception
	 */
	public function is_private() {

		// If the current user can edit theme options, consider the menu item public
		if ( current_user_can( 'edit_theme_options' ) ) {
			return false;
		}

		// Get menu locations for the active theme
		$locations = get_theme_mod( 'nav_menu_locations' );

		// If there are no menu locations, consider the MenuItem private
		if ( empty( $locations ) ) {
			return true;
		}

		// Get the values of the locations
		$location_ids = array_values( $locations );
		$menus        = wp_get_object_terms( $this->data->ID, 'nav_menu', [ 'fields' => 'ids' ] );

		// If there are no menus
		if ( empty( $menus ) ) {
			return true;
		}

		if ( is_wp_error( $menus ) ) {
			// translators: %s is the menu item ID.
			throw new Exception( esc_html( sprintf( __( 'No menus could be found for menu item %s', 'wp-graphql' ), $this->data->ID ) ) );
		}

		$menu_id = $menus[0];
		if ( empty( $location_ids ) || ! in_array( $menu_id, $location_ids, true ) ) {
			return true;
		}

		return false;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function init() {
		if ( empty( $this->fields ) ) {
			$this->fields = [
				'id'               => function () {
					return ! empty( $this->data->ID ) ? Relay::toGlobalId( 'post', $this->data->ID ) : null;
				},
				'parentId'         => function () {
					return ! empty( $this->data->menu_item_parent ) ? Relay::toGlobalId( 'post', $this->data->menu_item_parent ) : null;
				},
				'parentDatabaseId' => function () {
					return $this->data->menu_item_parent;
				},
				'cssClasses'       => function () {
					// If all we have is a non-array or an array with one empty
					// string, return an empty array.
					if ( ! isset( $this->data->classes ) || ! is_array( $this->data->classes ) || empty( $this->data->classes ) || empty( $this->data->classes[0] ) ) {
						return [];
					}

					return $this->data->classes;
				},
				'description'      => function () {
					return ( ! empty( $this->data->description ) ) ? $this->data->description : null;
				},
				'label'            => function () {
					return ( ! empty( $this->data->title ) ) ? $this->html_entity_decode( $this->data->title, 'label', true ) : null;
				},
				'linkRelationship' => function () {
					return ! empty( $this->data->xfn ) ? $this->data->xfn : null;
				},
				'menuItemId'       => function () {
					return absint( $this->data->ID );
				},
				'databaseId'       => function () {
					return absint( $this->data->ID );
				},
				'objectId'         => function () {
					return ( absint( $this->data->object_id ) );
				},
				'target'           => function () {
					return ! empty( $this->data->target ) ? $this->data->target : null;
				},
				'title'            => function () {
					return ( ! empty( $this->data->attr_title ) ) ? $this->data->attr_title : null;
				},
				'uri'              => function () {
					$url = $this->data->url;

					return ! empty( $url ) ? str_ireplace( home_url(), '', $url ) : null;
				},
				'url'              => function () {
					return ! empty( $this->data->url ) ? $this->data->url : null;
				},
				'path'             => function () {
					$url = $this->url;

					if ( ! empty( $url ) ) {
						/** @var array<string,mixed> $parsed */
						$parsed = wp_parse_url( $url );
						if ( isset( $parsed['host'] ) && strpos( home_url(), $parsed['host'] ) ) {
							return $parsed['path'];
						}
					}

					return $url;
				},
				'order'            => function () {
					return $this->data->menu_order;
				},
				'menuId'           => function () {
					return ! empty( $this->menuDatabaseId ) ? Relay::toGlobalId( 'term', (string) $this->menuDatabaseId ) : null;
				},
				'menuDatabaseId'   => function () {
					$menus = wp_get_object_terms( $this->data->ID, 'nav_menu' );
					if ( is_wp_error( $menus ) ) {
						throw new UserError( esc_html( $menus->get_error_message() ) );
					}

					return ! empty( $menus[0]->term_id ) ? $menus[0]->term_id : null;
				},
				'locations'        => function () {
					if ( empty( $this->menuDatabaseId ) ) {
						return null;
					}

					$menu_locations = get_theme_mod( 'nav_menu_locations' );

					if ( empty( $menu_locations ) || ! is_array( $menu_locations ) ) {
						return null;
					}

					$locations = null;
					foreach ( $menu_locations as $location => $id ) {
						if ( absint( $id ) === ( $this->menuDatabaseId ) ) {
							$locations[] = $location;
						}
					}

					return $locations;
				},
			];
		}
	}
}


// File: wp-graphql\src\Model\Model.php
<?php

namespace WPGraphQL\Model;

use Exception;

/**
 * Class Model - Abstract class for modeling data for all core types
 *
 * @package WPGraphQL\Model
 */
abstract class Model {

	/**
	 * Stores the name of the type the child class extending this one represents
	 *
	 * @var string
	 */
	protected $model_name;

	/**
	 * Stores the raw data passed to the child class when it's instantiated before it's transformed
	 *
	 * @var mixed[]|object|mixed
	 */
	protected $data;

	/**
	 * Stores the capability name for what to check on the user if the data should be considered
	 * "Restricted"
	 *
	 * @var string
	 */
	protected $restricted_cap;

	/**
	 * Stores the array of allowed fields to show if the data is restricted
	 *
	 * @var string[]
	 */
	protected $allowed_restricted_fields;

	/**
	 * Stores the DB ID of the user that owns this piece of data, or null if there is no owner
	 *
	 * @var int|null
	 */
	protected $owner;

	/**
	 * Stores the WP_User object for the current user in the session
	 *
	 * @var \WP_User $current_user
	 */
	protected $current_user;

	/**
	 * Stores the visibility value for the current piece of data
	 *
	 * @var string
	 */
	protected $visibility;

	/**
	 * The fields for the modeled object. This will be populated in the child class
	 *
	 * @var array<string,mixed>
	 */
	public $fields;

	/**
	 * Model constructor.
	 *
	 * @param string   $restricted_cap            The capability to check against to determine if
	 *                                            the data should be restricted or not
	 * @param string[] $allowed_restricted_fields The allowed fields if the data is in fact restricted
	 * @param int|null $owner                     Database ID of the user that owns this piece of
	 *                                            data to compare with the current user ID
	 *
	 * @return void
	 * @throws \Exception Throws Exception.
	 */
	protected function __construct( $restricted_cap = '', $allowed_restricted_fields = [], $owner = null ) {
		if ( empty( $this->data ) ) {
			// translators: %s is the name of the model.
			throw new Exception( esc_html( sprintf( __( 'An empty data set was used to initialize the modeling of this %s object', 'wp-graphql' ), $this->get_model_name() ) ) );
		}

		$this->restricted_cap            = $restricted_cap;
		$this->allowed_restricted_fields = $allowed_restricted_fields;
		$this->owner                     = $owner;
		$this->current_user              = wp_get_current_user();

		if ( 'private' === $this->get_visibility() ) {
			return;
		}

		$this->init();
		$this->prepare_fields();
	}

	/**
	 * Magic method to re-map the isset check on the child class looking for properties when
	 * resolving the fields
	 *
	 * @param string $key The name of the field you are trying to retrieve
	 *
	 * @return bool
	 */
	public function __isset( $key ) {
		return isset( $this->fields[ $key ] );
	}

	/**
	 * Magic method to re-map setting new properties to the class inside of the $fields prop rather
	 * than on the class in unique properties
	 *
	 * @param string                    $key   Name of the key to set the data to
	 * @param callable|int|string|mixed $value The value to set to the key
	 *
	 * @return void
	 */
	public function __set( $key, $value ) {
		$this->fields[ $key ] = $value;
	}

	/**
	 * Magic method to re-map where external calls go to look for properties on the child objects.
	 * This is crucial to let objects modeled through this class work with the default field
	 * resolver.
	 *
	 * @param string $key Name of the property that is trying to be accessed
	 *
	 * @return mixed|null
	 */
	public function __get( $key ) {
		if ( isset( $this->fields[ $key ] ) ) {
			/**
			 * If the property has already been processed and cached to the model
			 * return the processed value.
			 *
			 * Otherwise, if it's a callable, process it and cache the value.
			 */
			if ( is_scalar( $this->fields[ $key ] ) || ( is_object( $this->fields[ $key ] ) && ! is_callable( $this->fields[ $key ] ) ) || is_array( $this->fields[ $key ] ) ) {
				return $this->fields[ $key ];
			} elseif ( is_callable( $this->fields[ $key ] ) ) {
				$data       = call_user_func( $this->fields[ $key ] );
				$this->$key = $data;

				return $data;
			} else {
				return $this->fields[ $key ];
			}
		} else {
			return null;
		}
	}

	/**
	 * Setup the global data for the model to have proper context when resolving.
	 *
	 * @return void
	 */
	public function setup() {
	}

	/**
	 * Generic model tear down after the fields are setup. This can be used
	 * to reset state to where it was before the model was setup.
	 *
	 * @return void
	 */
	public function tear_down() {
	}

	/**
	 * Returns the name of the model, built from the child className
	 *
	 * @return string
	 */
	protected function get_model_name() {
		$name = static::class;

		if ( empty( $this->model_name ) ) {
			if ( false !== strpos( static::class, '\\' ) ) {
				$starting_character = strrchr( static::class, '\\' );
				if ( ! empty( $starting_character ) ) {
					$name = substr( $starting_character, 1 );
				}
			}
			$this->model_name = $name . 'Object';
		}

		return ! empty( $this->model_name ) ? $this->model_name : $name;
	}

	/**
	 * Return the visibility state for the current piece of data
	 *
	 * @return string|null
	 */
	public function get_visibility() {
		if ( null === $this->visibility ) {

			/**
			 * Filter for the capability to check against for restricted data
			 *
			 * @param string      $restricted_cap The capability to check against
			 * @param string      $model_name     Name of the model the filter is currently being executed in
			 * @param mixed       $data           The un-modeled incoming data
			 * @param string|null $visibility     The visibility that has currently been set for the data at this point
			 * @param int|null    $owner          The user ID for the owner of this piece of data
			 * @param \WP_User $current_user The current user for the session
			 *
			 * @return string
			 */
			$protected_cap = apply_filters( 'graphql_restricted_data_cap', $this->restricted_cap, $this->get_model_name(), $this->data, $this->visibility, $this->owner, $this->current_user );

			/**
			 * Filter to short circuit default is_private check for the model. This is expensive in some cases so
			 * this filter lets you prevent this from running by returning a true or false value.
			 *
			 * @param ?bool       $is_private   Whether the model data is private. Defaults to null.
			 * @param string      $model_name   Name of the model the filter is currently being executed in
			 * @param mixed       $data         The un-modeled incoming data
			 * @param string|null $visibility   The visibility that has currently been set for the data at this point
			 * @param int|null    $owner        The user ID for the owner of this piece of data
			 * @param \WP_User $current_user The current user for the session
			 *
			 * @return bool|null
			 */
			$pre_is_private = apply_filters( 'graphql_pre_model_data_is_private', null, $this->get_model_name(), $this->data, $this->visibility, $this->owner, $this->current_user );

			// If 3rd party code has not filtered this, use the Models default logic to determine
			// whether the model should be considered private
			if ( null !== $pre_is_private ) {
				$is_private = $pre_is_private;
			} else {
				$is_private = $this->is_private();
			}

			/**
			 * Filter to determine if the data should be considered private or not
			 *
			 * @param bool     $is_private   Whether the model is private
			 * @param string      $model_name   Name of the model the filter is currently being executed in
			 * @param mixed       $data         The un-modeled incoming data
			 * @param string|null $visibility   The visibility that has currently been set for the data at this point
			 * @param int|null    $owner        The user ID for the owner of this piece of data
			 * @param \WP_User $current_user The current user for the session
			 *
			 * @return bool
			 */
			$is_private = apply_filters( 'graphql_data_is_private', (bool) $is_private, $this->get_model_name(), $this->data, $this->visibility, $this->owner, $this->current_user );

			if ( true === $is_private ) {
				$this->visibility = 'private';
			} elseif ( null !== $this->owner && true === $this->owner_matches_current_user() ) {
				$this->visibility = 'public';
			} elseif ( empty( $protected_cap ) || current_user_can( $protected_cap ) ) {
				$this->visibility = 'public';
			} else {
				$this->visibility = 'restricted';
			}
		}

		/**
		 * Filter the visibility name to be returned
		 *
		 * @param string|null $visibility   The visibility that has currently been set for the data at this point
		 * @param string      $model_name   Name of the model the filter is currently being executed in
		 * @param mixed       $data         The un-modeled incoming data
		 * @param int|null    $owner        The user ID for the owner of this piece of data
		 * @param \WP_User $current_user The current user for the session
		 *
		 * @return string
		 */
		return apply_filters( 'graphql_object_visibility', $this->visibility, $this->get_model_name(), $this->data, $this->owner, $this->current_user );
	}

	/**
	 * Method to return the private state of the object. Can be overwritten in classes extending
	 * this one.
	 *
	 * @return bool
	 */
	protected function is_private() {
		return false;
	}

	/**
	 * Whether or not the owner of the data matches the current user
	 *
	 * @return bool
	 */
	protected function owner_matches_current_user() {
		if ( empty( $this->current_user->ID ) || empty( $this->owner ) ) {
			return false;
		}

		return absint( $this->owner ) === absint( $this->current_user->ID );
	}

	/**
	 * Restricts fields for the data to only return the allowed fields if the data is restricted
	 *
	 * @return void
	 */
	protected function restrict_fields() {
		$this->fields = array_intersect_key(
			$this->fields,
			array_flip(
			/**
			 * Filter for the allowed restricted fields
			 *
			 * @param string[]    $allowed_restricted_fields The fields to allow when the data is designated as restricted to the current user
			 * @param string      $model_name                Name of the model the filter is currently being executed in
			 * @param mixed       $data                      The un-modeled incoming data
			 * @param string|null $visibility                The visibility that has currently been set for the data at this point
			 * @param int|null    $owner                     The user ID for the owner of this piece of data
			 * @param \WP_User $current_user The current user for the session
			 */
				apply_filters( 'graphql_allowed_fields_on_restricted_type', $this->allowed_restricted_fields, $this->get_model_name(), $this->data, $this->visibility, $this->owner, $this->current_user )
			)
		);
	}

	/**
	 * Wraps all fields with another callback layer so we can inject hooks & filters into them
	 *
	 * @return void
	 */
	protected function wrap_fields() {
		if ( ! is_array( $this->fields ) || empty( $this->fields ) ) {
			return;
		}

		$clean_array = [];
		foreach ( $this->fields as $key => $data ) {
			$clean_array[ $key ] = function () use ( $key, $data ) {
				if ( is_array( $data ) ) {
					$callback = ( ! empty( $data['callback'] ) ) ? $data['callback'] : null;

					/**
					 * Capability to check required for the field
					 *
					 * @param string   $capability   The capability to check against to return the field
					 * @param string   $key          The name of the field on the type
					 * @param string   $model_name   Name of the model the filter is currently being executed in
					 * @param mixed    $data         The un-modeled incoming data
					 * @param string   $visibility   The visibility setting for this piece of data
					 * @param int|null $owner        The user ID for the owner of this piece of data
					 * @param \WP_User $current_user The current user for the session
					 *
					 * @return string
					 */
					$cap_check = ( ! empty( $data['capability'] ) ) ? apply_filters( 'graphql_model_field_capability', $data['capability'], $key, $this->get_model_name(), $this->data, $this->visibility, $this->owner, $this->current_user ) : '';
					if ( ! empty( $cap_check ) ) {
						if ( ! current_user_can( $data['capability'] ) ) {
							$callback = null;
						}
					}
				} else {
					$callback = $data;
				}

				/**
				 * Filter to short circuit the callback for any field on a type. Returning anything
				 * other than null will stop the callback for the field from executing, and will
				 * return your data or execute your callback instead.
				 *
				 * @param ?string  $result       The data returned from the callback. Null by default.
				 * @param string   $key          The name of the field on the type
				 * @param string   $model_name   Name of the model the filter is currently being executed in
				 * @param mixed    $data         The un-modeled incoming data
				 * @param string   $visibility   The visibility setting for this piece of data
				 * @param int|null $owner        The user ID for the owner of this piece of data
				 * @param \WP_User $current_user The current user for the session
				 *
				 * @return callable|int|string|mixed[]|mixed|null
				 */
				$pre = apply_filters( 'graphql_pre_return_field_from_model', null, $key, $this->get_model_name(), $this->data, $this->visibility, $this->owner, $this->current_user );

				if ( ! is_null( $pre ) ) {
					$result = $pre;
				} else {
					if ( is_callable( $callback ) ) {
						$this->setup();
						$field = call_user_func( $callback );
						$this->tear_down();
					} else {
						$field = $callback;
					}

					/**
					 * Filter the data returned by the default callback for the field
					 *
					 * @param string   $field        The data returned from the callback
					 * @param string   $key          The name of the field on the type
					 * @param string   $model_name   Name of the model the filter is currently being executed in
					 * @param mixed    $data         The un-modeled incoming data
					 * @param string   $visibility   The visibility setting for this piece of data
					 * @param int|null $owner        The user ID for the owner of this piece of data
					 * @param \WP_User $current_user The current user for the session
					 *
					 * @return mixed
					 */
					$result = apply_filters( 'graphql_return_field_from_model', $field, $key, $this->get_model_name(), $this->data, $this->visibility, $this->owner, $this->current_user );
				}

				/**
				 * Hook that fires after the data is returned for the field
				 *
				 * @param string   $result       The returned data for the field
				 * @param string   $key          The name of the field on the type
				 * @param string   $model_name   Name of the model the filter is currently being executed in
				 * @param mixed    $data         The un-modeled incoming data
				 * @param string   $visibility   The visibility setting for this piece of data
				 * @param int|null $owner        The user ID for the owner of this piece of data
				 * @param \WP_User $current_user The current user for the session
				 */
				do_action( 'graphql_after_return_field_from_model', $result, $key, $this->get_model_name(), $this->data, $this->visibility, $this->owner, $this->current_user );

				return $result;
			};
		}

		$this->fields = $clean_array;
	}

	/**
	 * Adds the model visibility fields to the data
	 *
	 * @return void
	 */
	private function add_model_visibility() {

		/**
		 * @todo: potentially abstract this out into a more central spot
		 */
		$this->fields['isPublic']     = function () {
			return 'public' === $this->get_visibility();
		};
		$this->fields['isRestricted'] = function () {
			return 'restricted' === $this->get_visibility();
		};
		$this->fields['isPrivate']    = function () {
			return 'private' === $this->get_visibility();
		};
	}

	/**
	 * Returns instance of the data fully modeled
	 *
	 * @return void
	 */
	protected function prepare_fields() {
		if ( 'restricted' === $this->get_visibility() ) {
			$this->restrict_fields();
		}

		/**
		 * Add support for the deprecated "graphql_return_modeled_data" filter.
		 *
		 * @param array<string,mixed>    $fields       The array of fields for the model
		 * @param string                 $model_name   Name of the model the filter is currently being executed in
		 * @param string                 $visibility   The visibility setting for this piece of data
		 * @param ?int                   $owner        The user ID for the owner of this piece of data
		 * @param \WP_User               $current_user The current user for the session
		 *
		 * @deprecated 1.7.0 use "graphql_model_prepare_fields" filter instead, which passes additional context to the filter
		 */
		$this->fields = apply_filters_deprecated( 'graphql_return_modeled_data', [ $this->fields, $this->get_model_name(), $this->visibility, $this->owner, $this->current_user ], '1.7.0', 'graphql_model_prepare_fields' );

		/**
		 * Filter the array of fields for the Model before the object is hydrated with it
		 *
		 * @param array<string,mixed>    $fields       The array of fields for the model
		 * @param string                 $model_name   Name of the model the filter is currently being executed in
		 * @param mixed                  $data         The un-modeled incoming data
		 * @param string                 $visibility   The visibility setting for this piece of data
		 * @param ?int                   $owner        The user ID for the owner of this piece of data
		 * @param \WP_User               $current_user The current user for the session
		 */
		$this->fields = apply_filters( 'graphql_model_prepare_fields', $this->fields, $this->get_model_name(), $this->data, $this->visibility, $this->owner, $this->current_user );
		$this->wrap_fields();
		$this->add_model_visibility();
	}

	/**
	 * Given a string, and optional context, this decodes html entities if html_entity_decode is
	 * enabled.
	 *
	 * @param string $str        The string to decode
	 * @param string $field_name The name of the field being encoded
	 * @param bool   $enabled    Whether decoding is enabled by default for the string passed in
	 *
	 * @return string
	 */
	public function html_entity_decode( $str, $field_name, $enabled = false ) {

		/**
		 * Determine whether html_entity_decode should be applied to the string
		 *
		 * @param bool                   $enabled    Whether decoding is enabled by default for the string passed in
		 * @param string                 $str        The string to decode
		 * @param string                 $field_name The name of the field being encoded
		 * @param \WPGraphQL\Model\Model $model      The Model the field is being decoded on
		 */
		$decoding_enabled = apply_filters( 'graphql_html_entity_decoding_enabled', $enabled, $str, $field_name, $this );

		if ( false === $decoding_enabled ) {
			return $str;
		}

		return html_entity_decode( $str, ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML401, 'UTF-8' );
	}

	/**
	 * Filter the fields returned for the object
	 *
	 * @param string|mixed[]|null $fields The field or fields to build in the modeled object. You can
	 *                                  pass null to build all of the fields, a string to only
	 *                                  build an object with one field, or an array of field keys
	 *                                  to build an object with those keys and their respective values.
	 *
	 * @return void
	 */
	public function filter( $fields ) {
		if ( is_string( $fields ) ) {
			$fields = [ $fields ];
		}

		if ( is_array( $fields ) ) {
			$this->fields = array_intersect_key( $this->fields, array_flip( $fields ) );
		}
	}

	/**
	 * Initialized the object.
	 *
	 * @return void
	 */
	abstract protected function init();
}


// File: wp-graphql\src\Model\Plugin.php
<?php

namespace WPGraphQL\Model;

use GraphQLRelay\Relay;

/**
 * Class Plugin - Models the Plugin object
 *
 * @property string $id
 * @property string $name
 * @property string $pluginUri
 * @property string $description
 * @property string $author
 * @property string $authorUri
 * @property string $version
 * @property string $path
 *
 * @package WPGraphQL\Model
 */
class Plugin extends Model {

	/**
	 * Stores the incoming plugin data to be modeled
	 *
	 * @var array<string,mixed> $data
	 */
	protected $data;

	/**
	 * Plugin constructor.
	 *
	 * @param array<string,mixed> $plugin The incoming Plugin data to be modeled.
	 */
	public function __construct( $plugin ) {
		$this->data = $plugin;
		parent::__construct();
	}

	/**
	 * {@inheritDoc}
	 */
	protected function is_private() {
		if ( is_multisite() ) {
				// update_, install_, and delete_ are handled above with is_super_admin().
				$menu_perms = get_site_option( 'menu_items', [] );
			if ( empty( $menu_perms['plugins'] ) && ! current_user_can( 'manage_network_plugins' ) ) {
				return true;
			}
		} elseif ( ! current_user_can( 'activate_plugins' ) ) {
			return true;
		}

		return false;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function init() {
		if ( empty( $this->fields ) ) {
			$this->fields = [
				'id'          => function () {
					return ! empty( $this->data['Path'] ) ? Relay::toGlobalId( 'plugin', $this->data['Path'] ) : null;
				},
				'name'        => function () {
					return ! empty( $this->data['Name'] ) ? $this->data['Name'] : null;
				},
				'pluginUri'   => function () {
					return ! empty( $this->data['PluginURI'] ) ? $this->data['PluginURI'] : null;
				},
				'description' => function () {
					return ! empty( $this->data['Description'] ) ? $this->data['Description'] : null;
				},
				'author'      => function () {
					return ! empty( $this->data['Author'] ) ? $this->data['Author'] : null;
				},
				'authorUri'   => function () {
					return ! empty( $this->data['AuthorURI'] ) ? $this->data['AuthorURI'] : null;
				},
				'version'     => function () {
					return ! empty( $this->data['Version'] ) ? $this->data['Version'] : null;
				},
				'path'        => function () {
					return ! empty( $this->data['Path'] ) ? $this->data['Path'] : null;
				},
			];
		}
	}
}


// File: wp-graphql\src\Model\Post.php
<?php
/**
 * Model - PostObject
 *
 * @package WPGraphQL\Model
 */

namespace WPGraphQL\Model;

use GraphQLRelay\Relay;
use WPGraphQL\Utils\Utils;
use WP_Post;

/**
 * Class Post - Models data for the Post object type
 *
 * @property int     $ID
 * @property string  $post_author
 * @property string  $id
 * @property string  $post_type
 * @property string  $authorId
 * @property string  $authorDatabaseId
 * @property int     $databaseId
 * @property string  $date
 * @property string  $dateGmt
 * @property string  $contentRendered
 * @property string  $contentRaw
 * @property string  $titleRendered
 * @property string  $titleRaw
 * @property string  $excerptRendered
 * @property string  $excerptRaw
 * @property string  $post_status
 * @property string  $status
 * @property string  $commentStatus
 * @property string  $pingStatus
 * @property string  $slug
 * @property array   $template
 * @property bool $isFrontPage
 * @property bool $isPrivacyPage
 * @property bool $isPostsPage
 * @property bool $isPreview
 * @property bool $isRevision
 * @property bool $isSticky
 * @property string  $toPing
 * @property string  $pinged
 * @property string  $modified
 * @property string  $modifiedGmt
 * @property string  $parentId
 * @property int     $parentDatabaseId
 * @property int     $editLastId
 * @property array   $editLock
 * @property string  $enclosure
 * @property string  $guid
 * @property bool    $hasPassword
 * @property int     $menuOrder
 * @property string  $link
 * @property string  $uri
 * @property int     $commentCount
 * @property string  $featuredImageId
 * @property int     $featuredImageDatabaseId
 * @property string  $pageTemplate
 * @property string  $password
 * @property int     $previewRevisionDatabaseId
 *
 * @property string  $captionRaw
 * @property string  $captionRendered
 * @property string  $altText
 * @property string  $descriptionRaw
 * @property string  $descriptionRendered
 * @property string  $mediaType
 * @property string  $sourceUrl
 * @property string  $mimeType
 * @property array   $mediaDetails
 *
 * @package WPGraphQL\Model
 */
class Post extends Model {

	/**
	 * Stores the incoming post data
	 *
	 * @var \WP_Post $data
	 */
	protected $data;

	/**
	 * Store the global post to reset during model tear down
	 *
	 * @var \WP_Post
	 */
	protected $global_post;

	/**
	 * Stores the incoming post type object for the post being modeled
	 *
	 * @var \WP_Post_Type|null $post_type_object
	 */
	protected $post_type_object;

	/**
	 * Store the instance of the WP_Query
	 *
	 * @var \WP_Query
	 */
	protected $wp_query;

	/**
	 * Post constructor.
	 *
	 * @param \WP_Post $post The incoming WP_Post object that needs modeling.
	 *
	 * @return void
	 */
	public function __construct( WP_Post $post ) {

		/**
		 * Set the data as the Post object
		 */
		$this->data             = $post;
		$this->post_type_object = get_post_type_object( $post->post_type );

		/**
		 * If the post type is 'revision', we need to get the post_type_object
		 * of the parent post type to determine capabilities from
		 */
		if ( 'revision' === $post->post_type && ! empty( $post->post_parent ) ) {
			$parent = get_post( absint( $post->post_parent ) );
			if ( ! empty( $parent ) ) {
				$this->post_type_object = get_post_type_object( $parent->post_type );
			}
		}

		/**
		 * Mimic core functionality for templates, as seen here:
		 * https://github.com/WordPress/WordPress/blob/6fd8080e7ee7599b36d4528f72a8ced612130b8c/wp-includes/template-loader.php#L56
		 */
		if ( 'attachment' === $this->data->post_type ) {
			remove_filter( 'the_content', 'prepend_attachment' );
		}

		$allowed_restricted_fields = [
			'databaseId',
			'enqueuedScriptsQueue',
			'enqueuedStylesheetsQueue',
			'id',
			'isRestricted',
			'link',
			'post_status',
			'post_type',
			'slug',
			'status',
			'titleRendered',
			'uri',
			'isPostsPage',
			'isFrontPage',
			'isPrivacyPage',
			'hasPassword',
		];

		if ( isset( $this->post_type_object->graphql_single_name ) ) {
			$allowed_restricted_fields[] = $this->post_type_object->graphql_single_name . 'Id';
		}

		$restricted_cap = $this->get_restricted_cap();

		parent::__construct( $restricted_cap, $allowed_restricted_fields, (int) $post->post_author );
	}

	/**
	 * {@inheritDoc}
	 */
	public function setup() {
		global $wp_query, $post;

		/**
		 * Store the global post before overriding
		 */
		$this->global_post = $post;

		/**
		 * Set the resolving post to the global $post. That way any filters that
		 * might be applied when resolving fields can rely on global post and
		 * post data being set up.
		 */
		if ( $this->data instanceof WP_Post ) {
			$id        = $this->data->ID;
			$post_type = $this->data->post_type;
			$post_name = $this->data->post_name;
			$data      = $this->data;

			if ( 'revision' === $this->data->post_type ) {
				$id     = $this->data->post_parent;
				$parent = get_post( $this->data->post_parent );
				if ( empty( $parent ) ) {
					$this->fields = [];
					return;
				}
				$post_type = $parent->post_type;
				$post_name = $parent->post_name;
				$data      = $parent;
			}

			/**
			 * Clear out existing postdata
			 */
			$wp_query->reset_postdata();

			/**
			 * Parse the query to tell WordPress how to
			 * setup global state
			 */
			if ( 'post' === $post_type ) {
				$wp_query->parse_query(
					[
						'page' => '',
						'p'    => $id,
					]
				);
			} elseif ( 'page' === $post_type ) {
				$wp_query->parse_query(
					[
						'page'     => '',
						'pagename' => $post_name,
					]
				);
			} elseif ( 'attachment' === $post_type ) {
				$wp_query->parse_query(
					[
						'attachment' => $post_name,
					]
				);
			} else {
				$wp_query->parse_query(
					[
						$post_type  => $post_name,
						'post_type' => $post_type,
						'name'      => $post_name,
					]
				);
			}

			$wp_query->setup_postdata( $data );
			$GLOBALS['post']             = $data; // phpcs:ignore WordPress.WP.GlobalVariablesOverride
			$wp_query->queried_object    = get_post( $this->data->ID );
			$wp_query->queried_object_id = $this->data->ID;
		}
	}

	/**
	 * Retrieve the cap to check if the data should be restricted for the post
	 *
	 * @return string
	 */
	protected function get_restricted_cap() {
		if ( ! empty( $this->data->post_password ) ) {
			return isset( $this->post_type_object->cap->edit_others_posts ) ? $this->post_type_object->cap->edit_others_posts : 'edit_others_posts';
		}

		switch ( $this->data->post_status ) {
			case 'trash':
				$cap = isset( $this->post_type_object->cap->edit_posts ) ? $this->post_type_object->cap->edit_posts : 'edit_posts';
				break;
			case 'draft':
			case 'future':
			case 'pending':
				$cap = isset( $this->post_type_object->cap->edit_others_posts ) ? $this->post_type_object->cap->edit_others_posts : 'edit_others_posts';
				break;
			default:
				$cap = '';
				break;
		}

		return $cap;
	}

	/**
	 * {@inheritDoc}
	 */
	public function is_private() {

		/**
		 * If the post is of post_type "revision", we need to access the parent of the Post
		 * so that we can check access rights of the parent post. Revision access is inherit
		 * to the Parent it is a revision of.
		 */
		if ( 'revision' === $this->data->post_type ) {

			// Get the post
			$parent_post = get_post( $this->data->post_parent );

			// If the parent post doesn't exist, the revision should be considered private
			if ( ! $parent_post instanceof WP_Post ) {
				return true;
			}

			// Determine if the revision is private using capabilities relative to the parent
			return $this->is_post_private( $parent_post );
		}

		/**
		 * Media Items (attachments) are all public. Once uploaded to the media library
		 * they are exposed with a public URL on the site.
		 *
		 * The WP REST API sets media items to private if they don't have a `post_parent` set, but
		 * this has broken production apps, because media items can be uploaded directly to the
		 * media library and published as a featured image, published inline within content, or
		 * within a Gutenberg block, etc, but then a consumer tries to ask for data of a published
		 * image and REST returns nothing because the media item is treated as private.
		 *
		 * Currently, we're treating all media items as public because there's nothing explicit in
		 * how WP Core handles privacy of media library items. By default they're publicly exposed.
		 */
		if ( 'attachment' === $this->data->post_type ) {
			return false;
		}

		/**
		 * Published content is public, not private
		 */
		if ( 'publish' === $this->data->post_status && $this->post_type_object && ( true === $this->post_type_object->public || true === $this->post_type_object->publicly_queryable ) ) {
			return false;
		}

		return $this->is_post_private( $this->data );
	}

	/**
	 * Method for determining if the data should be considered private or not
	 *
	 * @param \WP_Post $post_object The object of the post we need to verify permissions for
	 *
	 * @return bool
	 */
	protected function is_post_private( $post_object = null ) {
		$post_type_object = $this->post_type_object;

		if ( ! $post_type_object ) {
			return true;
		}

		if ( ! $post_object ) {
			$post_object = $this->data;
		}

		/**
		 * If the status is NOT publish and the user does NOT have capabilities to edit posts,
		 * consider the post private.
		 */
		if ( ! isset( $post_type_object->cap->edit_posts ) || ! current_user_can( $post_type_object->cap->edit_posts ) ) {
			return true;
		}

		/**
		 * If the owner of the content is the current user
		 */
		if ( ( true === $this->owner_matches_current_user() ) && 'revision' !== $post_object->post_type ) {
			return false;
		}

		/**
		 * If the post_type isn't (not registered) or is not allowed in WPGraphQL,
		 * mark the post as private
		 */

		if ( empty( $post_type_object->name ) || ! in_array( $post_type_object->name, \WPGraphQL::get_allowed_post_types(), true ) ) {
			return true;
		}

		if ( 'private' === $this->data->post_status && ( ! isset( $post_type_object->cap->read_private_posts ) || ! current_user_can( $post_type_object->cap->read_private_posts ) ) ) {
			return true;
		}

		if ( 'revision' === $this->data->post_type || 'auto-draft' === $this->data->post_status ) {
			$parent = get_post( (int) $this->data->post_parent );

			if ( empty( $parent ) ) {
				return true;
			}

			$parent_post_type_obj = $post_type_object;

			if ( 'private' === $parent->post_status ) {
				$cap = isset( $parent_post_type_obj->cap->read_private_posts ) ? $parent_post_type_obj->cap->read_private_posts : 'read_private_posts';
			} else {
				$cap = isset( $parent_post_type_obj->cap->edit_post ) ? $parent_post_type_obj->cap->edit_post : 'edit_post';
			}

			if ( ! current_user_can( $cap, $parent->ID ) ) {
				return true;
			}
		}

		return false;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function init() {
		if ( empty( $this->fields ) ) {
			$this->fields = [
				'ID'                        => function () {
					return $this->data->ID;
				},
				'post_author'               => function () {
					if ( $this->isPreview ) {
						$parent_post = get_post( $this->parentDatabaseId );
						if ( empty( $parent_post ) ) {
							return null;
						}

						return (int) $parent_post->post_author;
					}

					return ! empty( $this->data->post_author ) ? $this->data->post_author : null;
				},
				'id'                        => function () {
					return ( ! empty( $this->data->post_type ) && ! empty( $this->databaseId ) ) ? Relay::toGlobalId( 'post', (string) $this->databaseId ) : null;
				},
				'databaseId'                => function () {
					return ! empty( $this->data->ID ) ? absint( $this->data->ID ) : null;
				},
				'post_type'                 => function () {
					return ! empty( $this->data->post_type ) ? $this->data->post_type : null;
				},
				'authorId'                  => function () {
					if ( true === $this->isPreview ) {
						$parent_post = get_post( $this->data->post_parent );
						if ( empty( $parent_post ) ) {
							return null;
						}
						$id = (int) $parent_post->post_author;
					} else {
						$id = ! empty( $this->data->post_author ) ? (int) $this->data->post_author : null;
					}

					return Relay::toGlobalId( 'user', (string) $id );
				},
				'authorDatabaseId'          => function () {
					if ( true === $this->isPreview ) {
						$parent_post = get_post( $this->data->post_parent );
						if ( empty( $parent_post ) ) {
							return null;
						}

						return $parent_post->post_author;
					}

					return ! empty( $this->data->post_author ) ? (int) $this->data->post_author : null;
				},
				'date'                      => function () {
					return ! empty( $this->data->post_date ) && '0000-00-00 00:00:00' !== $this->data->post_date ? Utils::prepare_date_response( $this->data->post_date_gmt, $this->data->post_date ) : null;
				},
				'dateGmt'                   => function () {
					return ! empty( $this->data->post_date_gmt ) ? Utils::prepare_date_response( $this->data->post_date_gmt ) : null;
				},
				'contentRendered'           => function () {
					$content = ! empty( $this->data->post_content ) ? $this->data->post_content : null;

					return ! empty( $content ) ? $this->html_entity_decode( apply_filters( 'the_content', $content ), 'contentRendered', false ) : null;
				},
				'pageTemplate'              => function () {
					$slug = get_page_template_slug( $this->data->ID );

					return ! empty( $slug ) ? $slug : null;
				},
				'contentRaw'                => [
					'callback'   => function () {
						return ! empty( $this->data->post_content ) ? $this->data->post_content : null;
					},
					'capability' => isset( $this->post_type_object->cap->edit_posts ) ? $this->post_type_object->cap->edit_posts : 'edit_posts',
				],
				'titleRendered'             => function () {
					$id    = ! empty( $this->data->ID ) ? $this->data->ID : null;
					$title = ! empty( $this->data->post_title ) ? $this->data->post_title : null;

					return $this->html_entity_decode( apply_filters( 'the_title', $title, $id ), 'titleRendered', true );
				},
				'titleRaw'                  => [
					'callback'   => function () {
						return ! empty( $this->data->post_title ) ? $this->data->post_title : null;
					},
					'capability' => isset( $this->post_type_object->cap->edit_posts ) ? $this->post_type_object->cap->edit_posts : 'edit_posts',
				],
				'excerptRendered'           => function () {
					$excerpt = ! empty( $this->data->post_excerpt ) ? $this->data->post_excerpt : '';
					$excerpt = apply_filters( 'get_the_excerpt', $excerpt, $this->data );

					return $this->html_entity_decode( apply_filters( 'the_excerpt', $excerpt ), 'excerptRendered' );
				},
				'excerptRaw'                => [
					'callback'   => function () {
						return ! empty( $this->data->post_excerpt ) ? $this->data->post_excerpt : null;
					},
					'capability' => isset( $this->post_type_object->cap->edit_posts ) ? $this->post_type_object->cap->edit_posts : 'edit_posts',
				],
				'post_status'               => function () {
					return ! empty( $this->data->post_status ) ? $this->data->post_status : null;
				},
				'status'                    => function () {
					return ! empty( $this->data->post_status ) ? $this->data->post_status : null;
				},
				'commentStatus'             => function () {
					return ! empty( $this->data->comment_status ) ? $this->data->comment_status : null;
				},
				'pingStatus'                => function () {
					return ! empty( $this->data->ping_status ) ? $this->data->ping_status : null;
				},
				'slug'                      => function () {
					return ! empty( $this->data->post_name ) ? urldecode( $this->data->post_name ) : null;
				},
				'template'                  => function () {
					$registered_templates = wp_get_theme()->get_page_templates( null, $this->data->post_type );

					$template = [
						'__typename'   => 'DefaultTemplate',
						'templateName' => 'Default',
					];

					if ( true === $this->isPreview ) {
						$parent_post = get_post( $this->parentDatabaseId );

						if ( empty( $parent_post ) ) {
							return $template;
						}

						$registered_templates = wp_get_theme()->get_page_templates( $parent_post );

						if ( empty( $registered_templates ) ) {
							return $template;
						}
						$set_template  = get_post_meta( $this->parentDatabaseId, '_wp_page_template', true );
						$template_name = get_page_template_slug( $this->parentDatabaseId );

						if ( empty( $set_template ) ) {
							$set_template = get_post_meta( $this->data->ID, '_wp_page_template', true );
						}

						if ( empty( $template_name ) ) {
							$template_name = get_page_template_slug( $this->data->ID );
						}

						$template_name = ! empty( $template_name ) ? $template_name : 'Default';
					} else {
						if ( empty( $registered_templates ) ) {
							return $template;
						}

						$set_template  = get_post_meta( $this->data->ID, '_wp_page_template', true );
						$template_name = get_page_template_slug( $this->data->ID );

						$template_name = ! empty( $template_name ) ? $template_name : 'Default';
					}

					if ( ! empty( $registered_templates[ $set_template ] ) ) {
						$name = Utils::format_type_name_for_wp_template( $registered_templates[ $set_template ], $set_template );

						// If the name is empty, fallback to DefaultTemplate
						if ( empty( $name ) ) {
							$name = 'DefaultTemplate';
						}

						$template = [
							'__typename'   => $name,
							'templateName' => ucwords( $registered_templates[ $set_template ] ),
						];
					}

					return $template;
				},
				'isFrontPage'               => function () {
					if ( 'page' !== $this->data->post_type || 'page' !== get_option( 'show_on_front' ) ) {
						return false;
					}
					if ( absint( get_option( 'page_on_front', 0 ) ) === $this->data->ID ) {
						return true;
					}

					return false;
				},
				'isPrivacyPage'             => function () {
					if ( 'page' !== $this->data->post_type ) {
						return false;
					}
					if ( absint( get_option( 'wp_page_for_privacy_policy', 0 ) ) === $this->data->ID ) {
						return true;
					}

					return false;
				},
				'isPostsPage'               => function () {
					if ( 'page' !== $this->data->post_type ) {
						return false;
					}
					if ( 'posts' !== get_option( 'show_on_front', 'posts' ) && absint( get_option( 'page_for_posts', 0 ) ) === $this->data->ID ) {
						return true;
					}

					return false;
				},
				'hasPassword'               => function () {
					return ! empty( $this->data->post_password );
				},
				'password'                  => function () {
					return ! empty( $this->data->post_password ) ? $this->data->post_password : null;
				},
				'toPing'                    => function () {
					$to_ping = get_to_ping( $this->databaseId );

					return ! empty( $to_ping ) ? implode( ',', (array) $to_ping ) : null;
				},
				'pinged'                    => function () {
					$punged = get_pung( $this->databaseId );

					return ! empty( implode( ',', (array) $punged ) ) ? $punged : null;
				},
				'modified'                  => function () {
					return ! empty( $this->data->post_modified ) && '0000-00-00 00:00:00' !== $this->data->post_modified ? Utils::prepare_date_response( $this->data->post_modified ) : null;
				},
				'modifiedGmt'               => function () {
					return ! empty( $this->data->post_modified_gmt ) ? Utils::prepare_date_response( $this->data->post_modified_gmt ) : null;
				},
				'parentId'                  => function () {
					return ( ! empty( $this->data->post_type ) && ! empty( $this->data->post_parent ) ) ? Relay::toGlobalId( 'post', (string) $this->data->post_parent ) : null;
				},
				'parentDatabaseId'          => function () {
					return ! empty( $this->data->post_parent ) ? absint( $this->data->post_parent ) : null;
				},
				'editLastId'                => function () {
					$edit_last = get_post_meta( $this->data->ID, '_edit_last', true );

					return ! empty( $edit_last ) ? absint( $edit_last ) : null;
				},
				'editLock'                  => function () {
					require_once ABSPATH . 'wp-admin/includes/post.php';
					if ( ! wp_check_post_lock( $this->data->ID ) ) {
						return null;
					}

					$edit_lock       = get_post_meta( $this->data->ID, '_edit_lock', true );
					$edit_lock_parts = ! empty( $edit_lock ) ? explode( ':', $edit_lock ) : null;

					return ! empty( $edit_lock_parts ) ? $edit_lock_parts : null;
				},
				'enclosure'                 => function () {
					$enclosure = get_post_meta( $this->data->ID, 'enclosure', true );

					return ! empty( $enclosure ) ? $enclosure : null;
				},
				'guid'                      => function () {
					return ! empty( $this->data->guid ) ? $this->data->guid : null;
				},
				'menuOrder'                 => function () {
					return ! empty( $this->data->menu_order ) ? absint( $this->data->menu_order ) : null;
				},
				'link'                      => function () {
					$link = get_permalink( $this->data->ID );

					if ( $this->isPreview ) {
						$link = get_preview_post_link( $this->parentDatabaseId );
					} elseif ( $this->isRevision ) {
						$link = get_permalink( $this->data->ID );
					}

					return ! empty( $link ) ? urldecode( $link ) : null;
				},
				'uri'                       => function () {
					$uri = $this->link;

					if ( true === $this->isFrontPage ) {
						return '/';
					}

					// if the page is set as the posts page
					// the page node itself is not identifiable
					// by URI. Instead, the uri would return the
					// Post content type as that uri
					// represents the blog archive instead of a page
					if ( true === $this->isPostsPage ) {
						return null;
					}

					return ! empty( $uri ) ? str_ireplace( home_url(), '', $uri ) : null;
				},
				'commentCount'              => function () {
					return ! empty( $this->data->comment_count ) ? absint( $this->data->comment_count ) : null;
				},
				'featuredImageId'           => function () {
					return ! empty( $this->featuredImageDatabaseId ) ? Relay::toGlobalId( 'post', (string) $this->featuredImageDatabaseId ) : null;
				},
				'featuredImageDatabaseId'   => function () {
					if ( $this->isRevision ) {
						$id = $this->parentDatabaseId;
					} else {
						$id = $this->data->ID;
					}

					$thumbnail_id = get_post_thumbnail_id( $id );

					return ! empty( $thumbnail_id ) ? absint( $thumbnail_id ) : null;
				},
				'enqueuedScriptsQueue'      => static function () {
					global $wp_scripts;
					do_action( 'wp_enqueue_scripts' );
					$queue = $wp_scripts->queue;
					$wp_scripts->reset();
					$wp_scripts->queue = [];

					return $queue;
				},
				'enqueuedStylesheetsQueue'  => static function () {
					global $wp_styles;
					do_action( 'wp_enqueue_scripts' );
					$queue = $wp_styles->queue;
					$wp_styles->reset();
					$wp_styles->queue = [];

					return $queue;
				},
				'isRevision'                => function () {
					return 'revision' === $this->data->post_type;
				},
				'previewRevisionDatabaseId' => [
					'callback'   => function () {
						$revisions = wp_get_post_revisions(
							$this->data->ID,
							[
								'posts_per_page' => 1,
								'fields'         => 'ids',
								'check_enabled'  => false,
							]
						);

						return is_array( $revisions ) && ! empty( $revisions ) ? array_values( $revisions )[0] : null;
					},
					'capability' => isset( $this->post_type_object->cap->edit_posts ) ? $this->post_type_object->cap->edit_posts : 'edit_posts',
				],
				'previewRevisionId'         => function () {
					return ! empty( $this->previewRevisionDatabaseId ) ? Relay::toGlobalId( 'post', (string) $this->previewRevisionDatabaseId ) : null;
				},
				'isPreview'                 => function () {
					if ( $this->isRevision ) {
						$revisions = wp_get_post_revisions(
							$this->parentDatabaseId,
							[
								'posts_per_page' => 1,
								'fields'         => 'ids',
								'check_enabled'  => false,
							]
						);

						if ( in_array( $this->data->ID, array_values( $revisions ), true ) ) {
							return true;
						}
					}

					if ( ! post_type_supports( $this->data->post_type, 'revisions' ) && 'draft' === $this->data->post_status ) {
						return true;
					}

					return false;
				},
				'isSticky'                  => function () {
					return is_sticky( $this->databaseId );
				},
			];

			if ( 'attachment' === $this->data->post_type ) {
				$attachment_fields = [
					'captionRendered'     => function () {
						$caption = apply_filters( 'the_excerpt', apply_filters( 'get_the_excerpt', $this->data->post_excerpt, $this->data ) );

						return ! empty( $caption ) ? $caption : null;
					},
					'captionRaw'          => [
						'callback'   => function () {
							return ! empty( $this->data->post_excerpt ) ? $this->data->post_excerpt : null;
						},
						'capability' => isset( $this->post_type_object->cap->edit_posts ) ? $this->post_type_object->cap->edit_posts : 'edit_posts',
					],
					'altText'             => function () {
						return get_post_meta( $this->data->ID, '_wp_attachment_image_alt', true );
					},
					'descriptionRendered' => function () {
						return ! empty( $this->data->post_content ) ? apply_filters( 'the_content', $this->data->post_content ) : null;
					},
					'descriptionRaw'      => [
						'callback'   => function () {
							return ! empty( $this->data->post_content ) ? $this->data->post_content : null;
						},
						'capability' => isset( $this->post_type_object->cap->edit_posts ) ? $this->post_type_object->cap->edit_posts : 'edit_posts',
					],
					'mediaType'           => function () {
						return wp_attachment_is_image( $this->data->ID ) ? 'image' : 'file';
					},
					'mediaItemUrl'        => function () {
						return wp_get_attachment_url( $this->data->ID );
					},
					'sourceUrl'           => function () {
						$source_url = wp_get_attachment_image_src( $this->data->ID, 'full' );

						return ! empty( $source_url ) ? $source_url[0] : null;
					},
					'sourceUrlsBySize'    => function () {
						/**
						 * This returns an empty array on the VIP Go platform.
						 */
						$sizes = get_intermediate_image_sizes(); // phpcs:ignore WordPressVIPMinimum.Functions.RestrictedFunctions.get_intermediate_image_sizes_get_intermediate_image_sizes
						$urls  = [];
						if ( ! empty( $sizes ) && is_array( $sizes ) ) {
							foreach ( $sizes as $size ) {
								$img_src       = wp_get_attachment_image_src( $this->data->ID, $size );
								$urls[ $size ] = ! empty( $img_src ) ? $img_src[0] : null;
							}
						}

						return $urls;
					},
					'mimeType'            => function () {
						return ! empty( $this->data->post_mime_type ) ? $this->data->post_mime_type : null;
					},
					'mediaDetails'        => function () {
						$media_details = wp_get_attachment_metadata( $this->data->ID );
						if ( ! empty( $media_details ) ) {
							$media_details['ID'] = $this->data->ID;

							return $media_details;
						}

						return null;
					},
				];

				$this->fields = array_merge( $this->fields, $attachment_fields );
			}

			/**
			 * Set the {post_type}Id field to the Model.
			 */
			if ( isset( $this->post_type_object ) && isset( $this->post_type_object->graphql_single_name ) ) {
				$type_id                  = $this->post_type_object->graphql_single_name . 'Id';
				$this->fields[ $type_id ] = function () {
					return absint( $this->data->ID );
				};
			}
		}
	}
}


// File: wp-graphql\src\Model\PostType.php
<?php

namespace WPGraphQL\Model;

use GraphQLRelay\Relay;

/**
 * Class PostType - Models data for PostTypes
 *
 * @property string $id
 * @property string $name
 * @property object $labels
 * @property string $description
 * @property bool   $public
 * @property bool   $hierarchical
 * @property bool   $excludeFromSearch
 * @property bool   $publiclyQueryable
 * @property bool   $showUi
 * @property bool   $showInMenu
 * @property bool   $showInNavMenus
 * @property bool   $showInAdminBar
 * @property int    $menuPosition
 * @property string $menuIcon
 * @property bool   $hasArchive
 * @property bool   $canExport
 * @property bool   $deleteWithUser
 * @property bool   $showInRest
 * @property string $restBase
 * @property string $restControllerClass
 * @property bool   $showInGraphql
 * @property string $graphqlSingleName
 * @property string $graphql_single_name
 * @property string $graphqlPluralName
 * @property string $graphql_plural_name
 * @property string $taxonomies
 *
 * @package WPGraphQL\Model
 */
class PostType extends Model {

	/**
	 * Stores the incoming WP_Post_Type to be modeled
	 *
	 * @var \WP_Post_Type $data
	 */
	protected $data;

	/**
	 * PostType constructor.
	 *
	 * @param \WP_Post_Type $post_type The incoming post type to model.
	 */
	public function __construct( \WP_Post_Type $post_type ) {
		$this->data = $post_type;

		$allowed_restricted_fields = [
			'id',
			'name',
			'description',
			'hierarchical',
			'slug',
			'taxonomies',
			'graphql_single_name',
			'graphqlSingleName',
			'graphql_plural_name',
			'graphqlPluralName',
			'showInGraphql',
			'isRestricted',
			'uri',
			'isPostsPage',
			'isFrontPage',
			'label',
		];

		$capability = isset( $post_type->cap->edit_posts ) ? $post_type->cap->edit_posts : 'edit_posts';

		parent::__construct( $capability, $allowed_restricted_fields );
	}

	/**
	 * {@inheritDoc}
	 */
	protected function is_private() {
		if ( false === $this->data->public && ( ! isset( $this->data->cap->edit_posts ) || ! current_user_can( $this->data->cap->edit_posts ) ) ) {
			return true;
		}

		return false;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function init() {
		if ( empty( $this->fields ) ) {
			$this->fields = [
				'id'                  => function () {
					return ! empty( $this->data->name ) ? Relay::toGlobalId( 'post_type', $this->data->name ) : null;
				},
				'name'                => function () {
					return ! empty( $this->data->name ) ? $this->data->name : null;
				},
				'label'               => function () {
					return ! empty( $this->data->label ) ? $this->data->label : null;
				},
				'labels'              => function () {
					return get_post_type_labels( $this->data );
				},
				'description'         => function () {
					return ! empty( $this->data->description ) ? $this->data->description : '';
				},
				'public'              => function () {
					return ! empty( $this->data->public ) ? (bool) $this->data->public : null;
				},
				'hierarchical'        => function () {
					return true === $this->data->hierarchical || ! empty( $this->data->hierarchical );
				},
				'excludeFromSearch'   => function () {
					return true === $this->data->exclude_from_search;
				},
				'publiclyQueryable'   => function () {
					return true === $this->data->publicly_queryable;
				},
				'showUi'              => function () {
					return true === $this->data->show_ui;
				},
				'showInMenu'          => function () {
					return true === $this->data->show_in_menu;
				},
				'showInNavMenus'      => function () {
					return true === $this->data->show_in_nav_menus;
				},
				'showInAdminBar'      => function () {
					return true === $this->data->show_in_admin_bar;
				},
				'menuPosition'        => function () {
					return ! empty( $this->data->menu_position ) ? $this->data->menu_position : null;
				},
				'menuIcon'            => function () {
					return ! empty( $this->data->menu_icon ) ? $this->data->menu_icon : null;
				},
				'hasArchive'          => function () {
					return ! empty( $this->uri );
				},
				'canExport'           => function () {
					return true === $this->data->can_export;
				},
				'deleteWithUser'      => function () {
					return true === $this->data->delete_with_user;
				},
				'taxonomies'          => function () {
					$object_taxonomies = get_object_taxonomies( $this->data->name );
					return ( ! empty( $object_taxonomies ) ) ? $object_taxonomies : null;
				},
				'showInRest'          => function () {
					return true === $this->data->show_in_rest;
				},
				'restBase'            => function () {
					return ! empty( $this->data->rest_base ) ? $this->data->rest_base : null;
				},
				'restControllerClass' => function () {
					return ! empty( $this->data->rest_controller_class ) ? $this->data->rest_controller_class : null;
				},
				'showInGraphql'       => function () {
					return true === $this->data->show_in_graphql;
				},
				'graphqlSingleName'   => function () {
					return ! empty( $this->data->graphql_single_name ) ? $this->data->graphql_single_name : null;
				},
				'graphql_single_name' => function () {
					return ! empty( $this->data->graphql_single_name ) ? $this->data->graphql_single_name : null;
				},
				'graphqlPluralName'   => function () {
					return ! empty( $this->data->graphql_plural_name ) ? $this->data->graphql_plural_name : null;
				},
				'graphql_plural_name' => function () {
					return ! empty( $this->data->graphql_plural_name ) ? $this->data->graphql_plural_name : null;
				},
				'uri'                 => function () {
					$link = get_post_type_archive_link( $this->name );
					return ! empty( $link ) ? trailingslashit( str_ireplace( home_url(), '', $link ) ) : null;
				},
				// If the homepage settings are to set to
				'isPostsPage'         => function () {
					// the "post" ContentType is always represented as isPostsPage
					return 'post' === $this->name;
				},
				'isFrontPage'         => function () {
					if (
						'post' === $this->name &&
						(
							'posts' === get_option( 'show_on_front', 'posts' ) ||
							empty( (int) get_option( 'page_on_front', 0 ) )
						)
					) {
						return true;
					}

					return false;
				},
			];
		}
	}
}


// File: wp-graphql\src\Model\Taxonomy.php
<?php

namespace WPGraphQL\Model;

use GraphQLRelay\Relay;

/**
 * Class Taxonomy - Models data for taxonomies
 *
 * @property string $id
 * @property array  $object_type
 * @property string $name
 * @property string $label
 * @property string $description
 * @property bool   $public
 * @property bool   $hierarchical
 * @property bool   $showUi
 * @property bool   $showInMenu
 * @property bool   $showInNavMenus
 * @property bool   $showCloud
 * @property bool   $showInQuickEdit
 * @property bool   $showInAdminColumn
 * @property bool   $showInRest
 * @property string $restBase
 * @property string $restControllerClass
 * @property bool   $showInGraphql
 * @property string $graphqlSingleName
 * @property string $graphql_single_name
 * @property string $graphqlPluralName
 * @property string $graphql_plural_name
 *
 * @package WPGraphQL\Model
 */
class Taxonomy extends Model {

	/**
	 * Stores the incoming WP_Taxonomy object to be modeled
	 *
	 * @var \WP_Taxonomy $data
	 */
	protected $data;

	/**
	 * Taxonomy constructor.
	 *
	 * @param \WP_Taxonomy $taxonomy The incoming Taxonomy to model.
	 */
	public function __construct( \WP_Taxonomy $taxonomy ) {
		$this->data = $taxonomy;

		$allowed_restricted_fields = [
			'id',
			'name',
			'description',
			'hierarchical',
			'object_type',
			'restBase',
			'graphql_single_name',
			'graphqlSingleName',
			'graphql_plural_name',
			'graphqlPluralName',
			'showInGraphql',
			'isRestricted',
		];

		$capability = isset( $this->data->cap->edit_terms ) ? $this->data->cap->edit_terms : 'edit_terms';

		parent::__construct( $capability, $allowed_restricted_fields );
	}

	/**
	 * {@inheritDoc}
	 */
	protected function is_private() {
		if ( false === $this->data->public && ( ! isset( $this->data->cap->edit_terms ) || ! current_user_can( $this->data->cap->edit_terms ) ) ) {
			return true;
		}

		return false;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function init() {
		if ( empty( $this->fields ) ) {
			$this->fields = [
				'id'                  => function () {
					return ! empty( $this->data->name ) ? Relay::toGlobalId( 'taxonomy', $this->data->name ) : null;
				},
				'object_type'         => function () {
					return ! empty( $this->data->object_type ) ? $this->data->object_type : null;
				},
				'name'                => function () {
					return ! empty( $this->data->name ) ? $this->data->name : null;
				},
				'label'               => function () {
					return ! empty( $this->data->label ) ? $this->data->label : null;
				},
				'description'         => function () {
					return ! empty( $this->data->description ) ? $this->data->description : '';
				},
				'public'              => function () {
					return ! empty( $this->data->public ) ? (bool) $this->data->public : true;
				},
				'hierarchical'        => function () {
					return true === $this->data->hierarchical;
				},
				'showUi'              => function () {
					return true === $this->data->show_ui;
				},
				'showInMenu'          => function () {
					return true === $this->data->show_in_menu;
				},
				'showInNavMenus'      => function () {
					return true === $this->data->show_in_nav_menus;
				},
				'showCloud'           => function () {
					return true === $this->data->show_tagcloud;
				},
				'showInQuickEdit'     => function () {
					return true === $this->data->show_in_quick_edit;
				},
				'showInAdminColumn'   => function () {
					return true === $this->data->show_admin_column;
				},
				'showInRest'          => function () {
					return true === $this->data->show_in_rest;
				},
				'restBase'            => function () {
					return ! empty( $this->data->rest_base ) ? $this->data->rest_base : null;
				},
				'restControllerClass' => function () {
					return ! empty( $this->data->rest_controller_class ) ? $this->data->rest_controller_class : null;
				},
				'showInGraphql'       => function () {
					return true === $this->data->show_in_graphql;
				},
				'graphqlSingleName'   => function () {
					return ! empty( $this->data->graphql_single_name ) ? $this->data->graphql_single_name : null;
				},
				'graphql_single_name' => function () {
					return ! empty( $this->data->graphql_single_name ) ? $this->data->graphql_single_name : null;
				},
				'graphqlPluralName'   => function () {
					return ! empty( $this->data->graphql_plural_name ) ? $this->data->graphql_plural_name : null;
				},
				'graphql_plural_name' => function () {
					return ! empty( $this->data->graphql_plural_name ) ? $this->data->graphql_plural_name : null;
				},
			];
		}
	}
}


// File: wp-graphql\src\Model\Term.php
<?php

namespace WPGraphQL\Model;

use GraphQLRelay\Relay;
use WP_Taxonomy;
use WP_Term;

/**
 * Class Term - Models data for Terms
 *
 * @property string $id
 * @property int    $term_id
 * @property int    $databaseId
 * @property int    $count
 * @property string $description
 * @property string $name
 * @property string $slug
 * @property int    $termGroupId
 * @property int    $termTaxonomyId
 * @property string $taxonomyName
 * @property string $link
 * @property string $parentId
 * @property int    $parentDatabaseId
 * @property array  $ancestors
 *
 * @package WPGraphQL\Model
 */
class Term extends Model {

	/**
	 * Stores the incoming WP_Term object
	 *
	 * @var \WP_Term $data
	 */
	protected $data;

	/**
	 * Stores the taxonomy object for the term being modeled
	 *
	 * @var \WP_Taxonomy|null $taxonomy_object
	 */
	protected $taxonomy_object;

	/**
	 * The global Post instance
	 *
	 * @var \WP_Post
	 */
	protected $global_post;

	/**
	 * Term constructor.
	 *
	 * @param \WP_Term $term The incoming WP_Term object that needs modeling
	 *
	 * @return void
	 */
	public function __construct( WP_Term $term ) {
		$this->data            = $term;
		$taxonomy              = get_taxonomy( $term->taxonomy );
		$this->taxonomy_object = $taxonomy instanceof WP_Taxonomy ? $taxonomy : null;
		parent::__construct();
	}

	/**
	 * {@inheritDoc}
	 */
	public function setup() {
		global $wp_query, $post;

		/**
		 * Store the global post before overriding
		 */
		$this->global_post = $post;

		if ( $this->data instanceof WP_Term ) {

			/**
			 * Reset global post
			 */
			$GLOBALS['post'] = get_post( 0 ); // phpcs:ignore WordPress.WP.GlobalVariablesOverride

			/**
			 * Parse the query to tell WordPress
			 * how to setup global state
			 */
			if ( 'category' === $this->data->taxonomy ) {
				$wp_query->parse_query(
					[
						'category_name' => $this->data->slug,
					]
				);
			} elseif ( 'post_tag' === $this->data->taxonomy ) {
				$wp_query->parse_query(
					[
						'tag' => $this->data->slug,
					]
				);
			}

			$wp_query->queried_object    = get_term( $this->data->term_id, $this->data->taxonomy );
			$wp_query->queried_object_id = $this->data->term_id;
		}
	}

	/**
	 * {@inheritDoc}
	 */
	public function tear_down() {
		$GLOBALS['post'] = $this->global_post; // phpcs:ignore WordPress.WP.GlobalVariablesOverride
		wp_reset_postdata();
	}

	/**
	 * {@inheritDoc}
	 */
	protected function init() {
		if ( empty( $this->fields ) ) {
			$this->fields = [
				'id'                       => function () {
					return ( ! empty( $this->data->taxonomy ) && ! empty( $this->data->term_id ) ) ? Relay::toGlobalId( 'term', (string) $this->data->term_id ) : null;
				},
				'term_id'                  => function () {
					return ( ! empty( $this->data->term_id ) ) ? absint( $this->data->term_id ) : null;
				},
				'databaseId'               => function () {
					return ( ! empty( $this->data->term_id ) ) ? absint( $this->data->term_id ) : null;
				},
				'count'                    => function () {
					return ! empty( $this->data->count ) ? absint( $this->data->count ) : null;
				},
				'description'              => function () {
					return ! empty( $this->data->description ) ? $this->html_entity_decode( $this->data->description, 'description' ) : null;
				},
				'name'                     => function () {
					return ! empty( $this->data->name ) ? $this->html_entity_decode( $this->data->name, 'name', true ) : null;
				},
				'slug'                     => function () {
					return ! empty( $this->data->slug ) ? urldecode( $this->data->slug ) : null;
				},
				'termGroupId'              => function () {
					return ! empty( $this->data->term_group ) ? absint( $this->data->term_group ) : null;
				},
				'termTaxonomyId'           => function () {
					return ! empty( $this->data->term_taxonomy_id ) ? absint( $this->data->term_taxonomy_id ) : null;
				},
				'taxonomyName'             => function () {
					return ! empty( $this->taxonomy_object->name ) ? $this->taxonomy_object->name : null;
				},
				'link'                     => function () {
					$link = get_term_link( $this->data->term_id );

					return ( ! is_wp_error( $link ) ) ? $link : null;
				},
				'parentId'                 => function () {
					return ! empty( $this->data->parent ) ? Relay::toGlobalId( 'term', (string) $this->data->parent ) : null;
				},
				'parentDatabaseId'         => function () {
					return ! empty( $this->data->parent ) ? $this->data->parent : null;
				},
				'enqueuedScriptsQueue'     => static function () {
					global $wp_scripts;
					$wp_scripts->reset();
					do_action( 'wp_enqueue_scripts' );
					$queue = $wp_scripts->queue;
					$wp_scripts->reset();
					$wp_scripts->queue = [];

					return $queue;
				},
				'enqueuedStylesheetsQueue' => static function () {
					global $wp_styles;
					do_action( 'wp_enqueue_scripts' );
					$queue = $wp_styles->queue;
					$wp_styles->reset();
					$wp_styles->queue = [];

					return $queue;
				},
				'uri'                      => function () {
					$link = $this->link;

					$maybe_url = wp_parse_url( $link );

					// If this isn't a URL, we can assume it's been filtered and just return the link value.
					if ( false === $maybe_url ) {
						return $link;
					}

					// Replace the home_url in the link in order to return a relative uri.
					// For subdirectory multisites, this replaces the home_url which includes the subdirectory.
					return ! empty( $link ) ? str_ireplace( home_url(), '', $link ) : null;
				},
			];

			if ( isset( $this->taxonomy_object, $this->taxonomy_object->graphql_single_name ) ) {
				$type_id                  = $this->taxonomy_object->graphql_single_name . 'Id';
				$this->fields[ $type_id ] = absint( $this->data->term_id );
			}
		}
	}
}


// File: wp-graphql\src\Model\Theme.php
<?php

namespace WPGraphQL\Model;

use GraphQLRelay\Relay;

/**
 * Class Theme - Models data for themes
 *
 * @property string     $id
 * @property string     $slug
 * @property string     $name
 * @property string     $screenshot
 * @property string     $themeUri
 * @property string     $description
 * @property string     $author
 * @property string     $authorUri
 * @property array      $tags
 * @property string|int $version
 *
 * @package WPGraphQL\Model
 */
class Theme extends Model {

	/**
	 * Stores the incoming WP_Theme to be modeled
	 *
	 * @var \WP_Theme $data
	 */
	protected $data;

	/**
	 * Theme constructor.
	 *
	 * @param \WP_Theme $theme The incoming WP_Theme to be modeled
	 *
	 * @return void
	 * @throws \Exception
	 */
	public function __construct( \WP_Theme $theme ) {
		$this->data = $theme;
		parent::__construct();
	}

	/**
	 * {@inheritDoc}
	 */
	protected function is_private() {
		// Don't assume a capabilities hierarchy, since it's likely headless sites might disable some capabilities site-wide.
		if ( current_user_can( 'edit_themes' ) || current_user_can( 'switch_themes' ) || current_user_can( 'update_themes' ) ) {
			return false;
		}

		if ( wp_get_theme()->get_stylesheet() !== $this->data->get_stylesheet() ) {
			return true;
		}

		return false;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function init() {
		if ( empty( $this->fields ) ) {
			$this->fields = [
				'id'          => function () {
					$stylesheet = $this->data->get_stylesheet();
					return ( ! empty( $stylesheet ) ) ? Relay::toGlobalId( 'theme', $stylesheet ) : null;
				},
				'slug'        => function () {
					$stylesheet = $this->data->get_stylesheet();
					return ! empty( $stylesheet ) ? $stylesheet : null;
				},
				'name'        => function () {
					$name = $this->data->get( 'Name' );
					return ! empty( $name ) ? $name : null;
				},
				'screenshot'  => function () {
					$screenshot = $this->data->get_screenshot();
					return ! empty( $screenshot ) ? $screenshot : null;
				},
				'themeUri'    => function () {
					$theme_uri = $this->data->get( 'ThemeURI' );
					return ! empty( $theme_uri ) ? $theme_uri : null;
				},
				'description' => function () {
					return ! empty( $this->data->description ) ? $this->data->description : null;
				},
				'author'      => function () {
					return ! empty( $this->data->author ) ? $this->data->author : null;
				},
				'authorUri'   => function () {
					$author_uri = $this->data->get( 'AuthorURI' );
					return ! empty( $author_uri ) ? $author_uri : null;
				},
				'tags'        => function () {
					return ! empty( $this->data->tags ) ? $this->data->tags : null;
				},
				'version'     => function () {
					return ! empty( $this->data->version ) ? $this->data->version : null;
				},
			];
		}
	}
}


// File: wp-graphql\src\Model\User.php
<?php

namespace WPGraphQL\Model;

use GraphQLRelay\Relay;
use WP_User;

/**
 * Class User - Models the data for the User object type
 *
 * @property string $id
 * @property int    $databaseId
 * @property array  $capabilities
 * @property string $capKey
 * @property array  $roles
 * @property string $email
 * @property string $firstName
 * @property string $lastName
 * @property array  $extraCapabilities
 * @property string $description
 * @property string $username
 * @property string $name
 * @property string $registeredDate
 * @property string $nickname
 * @property string $url
 * @property string $slug
 * @property string $nicename
 * @property string $locale
 * @property int    $userId
 * @property string $uri
 * @property string $enqueuedScriptsQueue
 * @property string $enqueuedStylesheetsQueue
 *
 * @package WPGraphQL\Model
 */
class User extends Model {

	/**
	 * Stores the WP_User object for the incoming data
	 *
	 * @var \WP_User $data
	 */
	protected $data;

	/**
	 * The Global Post at time of Model generation
	 *
	 * @var \WP_Post
	 */
	protected $global_post;

	/**
	 * The global authordata at time of Model generation
	 *
	 * @var \WP_User
	 */
	protected $global_authordata;

	/**
	 * User constructor.
	 *
	 * @param \WP_User $user The incoming WP_User object that needs modeling
	 *
	 * @return void
	 */
	public function __construct( WP_User $user ) {

		// Explicitly remove the user_pass early on so it doesn't show up in filters/hooks
		$user->user_pass = '';
		$this->data      = $user;

		$allowed_restricted_fields = [
			'isRestricted',
			'id',
			'userId',
			'databaseId',
			'name',
			'firstName',
			'lastName',
			'description',
			'slug',
			'uri',
			'url',
			'enqueuedScriptsQueue',
			'enqueuedStylesheetsQueue',
		];

		parent::__construct( 'list_users', $allowed_restricted_fields, $user->ID );
	}

	/**
	 * {@inheritDoc}
	 */
	public function setup() {
		global $wp_query, $post, $authordata;

		// Store variables for resetting at tear down
		$this->global_post       = $post;
		$this->global_authordata = $authordata;

		if ( $this->data instanceof WP_User ) {

			// Reset postdata
			$wp_query->reset_postdata();

			// Parse the query to setup global state
			$wp_query->parse_query(
				[
					'author_name' => $this->data->user_nicename,
				]
			);

			// Setup globals
			$wp_query->is_author         = true;
			$GLOBALS['authordata']       = $this->data; // phpcs:ignore WordPress.WP.GlobalVariablesOverride
			$wp_query->queried_object    = get_user_by( 'id', $this->data->ID );
			$wp_query->queried_object_id = $this->data->ID;
		}
	}

	/**
	 * {@inheritDoc}
	 */
	public function tear_down() {
		$GLOBALS['authordata'] = $this->global_authordata; // phpcs:ignore WordPress.WP.GlobalVariablesOverride
		$GLOBALS['post']       = $this->global_post; // phpcs:ignore WordPress.WP.GlobalVariablesOverride
		wp_reset_postdata();
	}

	/**
	 * {@inheritDoc}
	 */
	protected function is_private() {
		/**
		 * If the user has permissions to list users.
		 */
		if ( current_user_can( $this->restricted_cap ) ) {
			return false;
		}

		/**
		 * If the owner of the content is the current user
		 */
		if ( true === $this->owner_matches_current_user() ) {
			return false;
		}

		return $this->data->is_private ?? true;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function init() {
		if ( empty( $this->fields ) ) {
			$this->fields = [
				'id'                       => function () {
					return ( ! empty( $this->data->ID ) ) ? Relay::toGlobalId( 'user', (string) $this->data->ID ) : null;
				},
				'databaseId'               => function () {
					return $this->userId;
				},
				'capabilities'             => function () {
					if ( ! empty( $this->data->allcaps ) ) {

						/**
						 * Reformat the array of capabilities from the user object so that it is a true
						 * ListOf type
						 */
						$capabilities = array_keys(
							array_filter(
								$this->data->allcaps,
								static function ( $cap ) {
									return true === $cap;
								}
							)
						);
					}

					return ! empty( $capabilities ) ? $capabilities : null;
				},
				'capKey'                   => function () {
					return ! empty( $this->data->cap_key ) ? $this->data->cap_key : null;
				},
				'roles'                    => function () {
					return ! empty( $this->data->roles ) ? $this->data->roles : null;
				},
				'email'                    => function () {
					return ! empty( $this->data->user_email ) ? $this->data->user_email : null;
				},
				'firstName'                => function () {
					return ! empty( $this->data->first_name ) ? $this->data->first_name : null;
				},
				'lastName'                 => function () {
					return ! empty( $this->data->last_name ) ? $this->data->last_name : null;
				},
				'extraCapabilities'        => function () {
					return ! empty( $this->data->allcaps ) ? array_keys( $this->data->allcaps ) : null;
				},
				'description'              => function () {
					return ! empty( $this->data->description ) ? $this->data->description : null;
				},
				'username'                 => function () {
					return ! empty( $this->data->user_login ) ? $this->data->user_login : null;
				},
				'name'                     => function () {
					return ! empty( $this->data->display_name ) ? $this->data->display_name : null;
				},
				'registeredDate'           => function () {
					$timestamp = ! empty( $this->data->user_registered ) ? strtotime( $this->data->user_registered ) : null;
					return ! empty( $timestamp ) ? gmdate( 'c', $timestamp ) : null;
				},
				'nickname'                 => function () {
					return ! empty( $this->data->nickname ) ? $this->data->nickname : null;
				},
				'url'                      => function () {
					return ! empty( $this->data->user_url ) ? $this->data->user_url : null;
				},
				'slug'                     => function () {
					return ! empty( $this->data->user_nicename ) ? $this->data->user_nicename : null;
				},
				'nicename'                 => function () {
					return ! empty( $this->data->user_nicename ) ? $this->data->user_nicename : null;
				},
				'locale'                   => function () {
					$user_locale = get_user_locale( $this->data );

					return ! empty( $user_locale ) ? $user_locale : null;
				},
				'shouldShowAdminToolbar'   => function () {
					$toolbar_preference_meta = get_user_meta( $this->data->ID, 'show_admin_bar_front', true );

					return 'true' === $toolbar_preference_meta;
				},
				'userId'                   => ! empty( $this->data->ID ) ? absint( $this->data->ID ) : null,
				'uri'                      => function () {
					$user_profile_url = get_author_posts_url( $this->data->ID );

					return ! empty( $user_profile_url ) ? str_ireplace( home_url(), '', $user_profile_url ) : '';
				},
				'enqueuedScriptsQueue'     => static function () {
					global $wp_scripts;
					do_action( 'wp_enqueue_scripts' );
					$queue = $wp_scripts->queue;
					$wp_scripts->reset();
					$wp_scripts->queue = [];

					return $queue;
				},
				'enqueuedStylesheetsQueue' => static function () {
					global $wp_styles;
					do_action( 'wp_enqueue_scripts' );
					$queue = $wp_styles->queue;
					$wp_styles->reset();
					$wp_styles->queue = [];

					return $queue;
				},
			];
		}
	}
}


// File: wp-graphql\src\Model\UserRole.php
<?php

namespace WPGraphQL\Model;

use GraphQLRelay\Relay;

/**
 * Class UserRole - Models data for user roles
 *
 * @property string $displayName
 * @property string $id
 * @property string $name
 * @property array  $capabilities
 *
 * @package WPGraphQL\Model
 */
class UserRole extends Model {

	/**
	 * Stores the incoming user role to be modeled
	 *
	 * @var array<string,mixed> $data
	 */
	protected $data;

	/**
	 * UserRole constructor.
	 *
	 * @param array<string,mixed> $user_role The incoming user role to be modeled
	 *
	 * @return void
	 * @throws \Exception
	 */
	public function __construct( $user_role ) {
		$this->data = $user_role;
		parent::__construct();
	}

	/**
	 * {@inheritDoc}
	 */
	protected function is_private() {
		if ( current_user_can( 'list_users' ) ) {
			return false;
		}

		$current_user_roles = wp_get_current_user()->roles;

		if ( in_array( $this->data['slug'], $current_user_roles, true ) ) {
			return false;
		}

		return true;
	}

	/**
	 * {@inheritDoc}
	 */
	protected function init() {
		if ( empty( $this->fields ) ) {
			$this->fields = [
				'id'           => function () {
					return Relay::toGlobalId( 'user_role', $this->data['id'] );
				},
				'name'         => function () {
					return ! empty( $this->data['name'] ) ? esc_html( $this->data['name'] ) : null;
				},
				'displayName'  => function () {
					return ! empty( $this->data['displayName'] ) ? esc_html( $this->data['displayName'] ) : null;
				},
				'capabilities' => function () {
					if ( empty( $this->data['capabilities'] ) || ! is_array( $this->data['capabilities'] ) ) {
						return null;
					} else {
						return array_keys( $this->data['capabilities'] );
					}
				},
			];
		}
	}
}


// File: wp-graphql\src\Mutation\CommentCreate.php
<?php

namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Data\CommentMutation;

class CommentCreate {
	/**
	 * Registers the CommentCreate mutation.
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_mutation() {
		register_graphql_mutation(
			'createComment',
			[
				'inputFields'         => self::get_input_fields(),
				'outputFields'        => self::get_output_fields(),
				'mutateAndGetPayload' => self::mutate_and_get_payload(),
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields() {
		return [
			'approved'    => [
				'type'              => 'String',
				'description'       => __( 'The approval status of the comment.', 'wp-graphql' ),
				'deprecationReason' => __( 'Deprecated in favor of the status field', 'wp-graphql' ),
			],
			'author'      => [
				'type'        => 'String',
				'description' => __( 'The name of the comment\'s author.', 'wp-graphql' ),
			],
			'authorEmail' => [
				'type'        => 'String',
				'description' => __( 'The email of the comment\'s author.', 'wp-graphql' ),
			],
			'authorUrl'   => [
				'type'        => 'String',
				'description' => __( 'The url of the comment\'s author.', 'wp-graphql' ),
			],
			'commentOn'   => [
				'type'        => 'Int',
				'description' => __( 'The database ID of the post object the comment belongs to.', 'wp-graphql' ),
			],
			'content'     => [
				'type'        => 'String',
				'description' => __( 'Content of the comment.', 'wp-graphql' ),
			],
			'date'        => [
				'type'        => 'String',
				'description' => __( 'The date of the object. Preferable to enter as year/month/day ( e.g. 01/31/2017 ) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, "2017" as the input will use current date with timestamp 20:17 ', 'wp-graphql' ),
			],
			'parent'      => [
				'type'        => 'ID',
				'description' => __( 'Parent comment ID of current comment.', 'wp-graphql' ),
			],
			'status'      => [
				'type'        => 'CommentStatusEnum',
				'description' => __( 'The approval status of the comment', 'wp-graphql' ),
			],
			'type'        => [
				'type'        => 'String',
				'description' => __( 'Type of comment.', 'wp-graphql' ),
			],
		];
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields() {
		return [
			'comment' => [
				'type'        => 'Comment',
				'description' => __( 'The comment that was created', 'wp-graphql' ),
				'resolve'     => static function ( $payload, $args, AppContext $context ) {
					if ( ! isset( $payload['id'] ) || ! absint( $payload['id'] ) ) {
						return null;
					}

					return $context->get_loader( 'comment' )->load_deferred( absint( $payload['id'] ) );
				},
			],
			/**
			 * Comments can be created by non-authenticated users, but if the comment is not approved
			 * the user will not have access to the comment in response to the mutation.
			 *
			 * This field allows for the mutation to respond with a success message that the
			 * comment was indeed created, even if it cannot be returned in the response to respect
			 * server privacy.
			 *
			 * If the success comes back as true, the client can then use that response to
			 * dictate if they should use the input values as an optimistic response to the mutation
			 * and store in the cache, localStorage, cookie or whatever else so that the
			 * client can see their comment while it's still pending approval.
			 */
			'success' => [
				'type'        => 'Boolean',
				'description' => __( 'Whether the mutation succeeded. If the comment is not approved, the server will not return the comment to a non authenticated user, but a success message can be returned if the create succeeded, and the client can optimistically add the comment to the client cache', 'wp-graphql' ),
			],
		];
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @return callable(array<string,mixed>$input,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):array<string,mixed>
	 */
	public static function mutate_and_get_payload() {
		return static function ( $input, AppContext $context, ResolveInfo $info ) {

			/**
			 * Throw an exception if there's no input
			 */
			if ( ( empty( $input ) || ! is_array( $input ) ) ) {
				throw new UserError( esc_html__( 'Mutation not processed. There was no input for the mutation or the comment_object was invalid', 'wp-graphql' ) );
			}

			$commented_on = get_post( absint( $input['commentOn'] ) );

			if ( empty( $commented_on ) ) {
				throw new UserError( esc_html__( 'The ID of the node to comment on is invalid', 'wp-graphql' ) );
			}

			/**
			 * Stop if post not open to comments
			 */
			if ( empty( $input['commentOn'] ) || 'closed' === $commented_on->comment_status ) {
				throw new UserError( esc_html__( 'Sorry, this post is closed to comments at the moment', 'wp-graphql' ) );
			}

			if ( '1' === get_option( 'comment_registration' ) && ! is_user_logged_in() ) {
				throw new UserError( esc_html__( 'This site requires you to be logged in to leave a comment', 'wp-graphql' ) );
			}

			/**
			 * Map all of the args from GraphQL to WordPress friendly args array
			 */
			$comment_args = [
				'comment_author_url' => '',
				'comment_type'       => '',
				'comment_parent'     => 0,
				'user_id'            => 0,
				'comment_date'       => gmdate( 'Y-m-d H:i:s' ),
			];

			CommentMutation::prepare_comment_object( $input, $comment_args, 'createComment' );

			/**
			 * Insert the comment and retrieve the ID
			 */
			$comment_id = wp_new_comment( $comment_args, true );

			/**
			 * Throw an exception if the comment failed to be created
			 */
			if ( is_wp_error( $comment_id ) ) {
				$error_message = $comment_id->get_error_message();
				if ( ! empty( $error_message ) ) {
					throw new UserError( esc_html( $error_message ) );
				} else {
					throw new UserError( esc_html__( 'The object failed to create but no error was provided', 'wp-graphql' ) );
				}
			}

			/**
			 * If the $comment_id is empty, we should throw an exception
			 */
			if ( empty( $comment_id ) ) {
				throw new UserError( esc_html__( 'The object failed to create', 'wp-graphql' ) );
			}

			/**
			 * This updates additional data not part of the comments table ( commentmeta, other relations, etc )
			 *
			 * The input for the commentMutation will be passed, along with the $new_comment_id for the
			 * comment that was created so that relations can be set, meta can be updated, etc.
			 */
			CommentMutation::update_additional_comment_data( $comment_id, $input, 'createComment', $context, $info );

			/**
			 * Return the comment object
			 */
			return [
				'id'      => $comment_id,
				'success' => true,
			];
		};
	}
}


// File: wp-graphql\src\Mutation\CommentDelete.php
<?php

namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use GraphQLRelay\Relay;
use WPGraphQL\Model\Comment;
use WPGraphQL\Utils\Utils;

class CommentDelete {
	/**
	 * Registers the CommentDelete mutation.
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_mutation() {
		register_graphql_mutation(
			'deleteComment',
			[
				'inputFields'         => self::get_input_fields(),
				'outputFields'        => self::get_output_fields(),
				'mutateAndGetPayload' => self::mutate_and_get_payload(),
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields() {
		return [
			'id'          => [
				'type'        => [
					'non_null' => 'ID',
				],
				'description' => __( 'The deleted comment ID', 'wp-graphql' ),
			],
			'forceDelete' => [
				'type'        => 'Boolean',
				'description' => __( 'Whether the comment should be force deleted instead of being moved to the trash', 'wp-graphql' ),
			],
		];
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields() {
		return [
			'deletedId' => [
				'type'        => 'Id',
				'description' => __( 'The deleted comment ID', 'wp-graphql' ),
				'resolve'     => static function ( $payload ) {
					$deleted = (object) $payload['commentObject'];

					return ! empty( $deleted->comment_ID ) ? Relay::toGlobalId( 'comment', $deleted->comment_ID ) : null;
				},
			],
			'comment'   => [
				'type'        => 'Comment',
				'description' => __( 'The deleted comment object', 'wp-graphql' ),
				'resolve'     => static function ( $payload ) {
					return $payload['commentObject'] ? $payload['commentObject'] : null;
				},
			],
		];
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @return callable(array<string,mixed>$input,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):array<string,mixed>
	 */
	public static function mutate_and_get_payload() {
		return static function ( $input ) {
			// Get the database ID for the comment.
			$comment_id = Utils::get_database_id_from_id( $input['id'] );

			// Get the post object before deleting it.
			$comment_before_delete = ! empty( $comment_id ) ? get_comment( $comment_id ) : false;

			if ( empty( $comment_before_delete ) ) {
				throw new UserError( esc_html__( 'The Comment could not be deleted', 'wp-graphql' ) );
			}

			/**
			 * Stop now if a user isn't allowed to delete the comment
			 */
			$user_id = $comment_before_delete->user_id;

			// Prevent comment deletions by default
			$not_allowed = true;

			// If the current user can moderate comments proceed
			if ( current_user_can( 'moderate_comments' ) ) {
				$not_allowed = false;
			} else {
				// Get the current user id
				$current_user_id = absint( get_current_user_id() );
				// If the current user ID is the same as the comment author's ID, then the
				// current user is the comment author and can delete the comment
				if ( 0 !== $current_user_id && absint( $user_id ) === $current_user_id ) {
					$not_allowed = false;
				}
			}

			/**
			 * If the mutation has been prevented
			 */
			if ( true === $not_allowed ) {
				throw new UserError( esc_html__( 'Sorry, you are not allowed to delete this comment.', 'wp-graphql' ) );
			}

			/**
			 * Check if we should force delete or not
			 */
			$force_delete = ! empty( $input['forceDelete'] ) && true === $input['forceDelete'];

			$comment_before_delete = new Comment( $comment_before_delete );

			/**
			 * Delete the comment
			 */
			wp_delete_comment( (int) $comment_id, $force_delete );

			return [
				'commentObject' => $comment_before_delete,
			];
		};
	}
}


// File: wp-graphql\src\Mutation\CommentRestore.php
<?php

namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use GraphQLRelay\Relay;
use WPGraphQL\AppContext;
use WPGraphQL\Utils\Utils;

/**
 * Class CommentRestore
 *
 * @package WPGraphQL\Mutation
 */
class CommentRestore {
	/**
	 * Registers the CommentRestore mutation.
	 *
	 * @return void
	 */
	public static function register_mutation() {
		register_graphql_mutation(
			'restoreComment',
			[
				'inputFields'         => self::get_input_fields(),
				'outputFields'        => self::get_output_fields(),
				'mutateAndGetPayload' => self::mutate_and_get_payload(),
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields() {
		return [
			'id' => [
				'type'        => [
					'non_null' => 'ID',
				],
				'description' => __( 'The ID of the comment to be restored', 'wp-graphql' ),
			],
		];
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields() {
		return [
			'restoredId' => [
				'type'        => 'Id',
				'description' => __( 'The ID of the restored comment', 'wp-graphql' ),
				'resolve'     => static function ( $payload ) {
					$restore = (object) $payload['commentObject'];

					return ! empty( $restore->comment_ID ) ? Relay::toGlobalId( 'comment', $restore->comment_ID ) : null;
				},
			],
			'comment'    => [
				'type'        => 'Comment',
				'description' => __( 'The restored comment object', 'wp-graphql' ),
				'resolve'     => static function ( $payload, $args, AppContext $context ) {
					if ( ! isset( $payload['commentObject']->comment_ID ) || ! absint( $payload['commentObject']->comment_ID ) ) {
						return null;
					}
					return $context->get_loader( 'comment' )->load_deferred( absint( $payload['commentObject']->comment_ID ) );
				},
			],
		];
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @return callable(array<string,mixed>$input,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):array<string,mixed>
	 */
	public static function mutate_and_get_payload() {
		return static function ( $input ) {
			// Stop now if a user isn't allowed to delete the comment.
			if ( ! current_user_can( 'moderate_comments' ) ) {
				throw new UserError( esc_html__( 'Sorry, you are not allowed to restore this comment.', 'wp-graphql' ) );
			}

			// Get the database ID for the comment.
			$comment_id = Utils::get_database_id_from_id( $input['id'] );

			if ( false === $comment_id ) {
				throw new UserError( esc_html__( 'Sorry, you are not allowed to restore this comment.', 'wp-graphql' ) );
			}

			// Delete the comment.
			wp_untrash_comment( $comment_id );

			$comment = get_comment( $comment_id );

			return [
				'commentObject' => $comment,
			];
		};
	}
}


// File: wp-graphql\src\Mutation\CommentUpdate.php
<?php

namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Data\CommentMutation;
use WPGraphQL\Utils\Utils;

/**
 * Class CommentUpdate
 *
 * @package WPGraphQL\Mutation
 */
class CommentUpdate {
	/**
	 * Registers the CommentUpdate mutation.
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_mutation() {
		register_graphql_mutation(
			'updateComment',
			[
				'inputFields'         => self::get_input_fields(),
				'outputFields'        => self::get_output_fields(),
				'mutateAndGetPayload' => self::mutate_and_get_payload(),
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields() {
		return array_merge(
			CommentCreate::get_input_fields(),
			[
				'id' => [
					'type'        => [
						'non_null' => 'ID',
					],
					'description' => __( 'The ID of the comment being updated.', 'wp-graphql' ),
				],
			]
		);
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields() {
		return CommentCreate::get_output_fields();
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @return callable(array<string,mixed>$input,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):array<string,mixed>
	 */
	public static function mutate_and_get_payload() {
		return static function ( $input, AppContext $context, ResolveInfo $info ) {
			// Get the database ID for the comment.
			$comment_id = ! empty( $input['id'] ) ? Utils::get_database_id_from_id( $input['id'] ) : null;

			// Get the args from the existing comment.
			$comment_args = ! empty( $comment_id ) ? get_comment( $comment_id, ARRAY_A ) : null;

			if ( empty( $comment_id ) || empty( $comment_args ) ) {
				throw new UserError( esc_html__( 'The Comment could not be updated', 'wp-graphql' ) );
			}

			/**
			 * Map all of the args from GraphQL to WordPress friendly args array
			 */
			$user_id          = $comment_args['user_id'] ?? null;
			$raw_comment_args = $comment_args;
			CommentMutation::prepare_comment_object( $input, $comment_args, 'update', true );

			// Prevent comment deletions by default
			$not_allowed = true;

			// If the current user can moderate comments proceed
			if ( current_user_can( 'moderate_comments' ) ) {
				$not_allowed = false;
			} else {
				// Get the current user id
				$current_user_id = absint( get_current_user_id() );
				// If the current user ID is the same as the comment author's ID, then the
				// current user is the comment author and can delete the comment
				if ( 0 !== $current_user_id && absint( $user_id ) === $current_user_id ) {
					$not_allowed = false;
				}
			}

			/**
			 * If the mutation has been prevented
			 */
			if ( true === $not_allowed ) {
				throw new UserError( esc_html__( 'Sorry, you are not allowed to update this comment.', 'wp-graphql' ) );
			}

			// If there are no changes between the existing comment and the incoming comment
			if ( $comment_args === $raw_comment_args ) {
				throw new UserError( esc_html__( 'No changes have been provided to the comment.', 'wp-graphql' ) );
			}

			/**
			 * Update comment
			 * $success   int   1 on success and 0 on fail
			 */
			$success = wp_update_comment( $comment_args, true );

			/**
			 * Throw an exception if the comment failed to be created
			 */
			if ( is_wp_error( $success ) ) {
				throw new UserError( esc_html( $success->get_error_message() ) );
			}

			/**
			 * This updates additional data not part of the comments table ( commentmeta, other relations, etc )
			 *
			 * The input for the commentMutation will be passed, along with the $new_comment_id for the
			 * comment that was created so that relations can be set, meta can be updated, etc.
			 */
			CommentMutation::update_additional_comment_data( $comment_id, $input, 'create', $context, $info );

			/**
			 * Return the comment object
			 */
			return [
				'id'      => $comment_id,
				'success' => (bool) $success,
			];
		};
	}
}


// File: wp-graphql\src\Mutation\MediaItemCreate.php
<?php

namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Data\MediaItemMutation;
use WPGraphQL\Utils\Utils;

class MediaItemCreate {
	/**
	 * Registers the MediaItemCreate mutation.
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_mutation() {
		register_graphql_mutation(
			'createMediaItem',
			[
				'inputFields'         => self::get_input_fields(),
				'outputFields'        => self::get_output_fields(),
				'mutateAndGetPayload' => self::mutate_and_get_payload(),
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields() {
		return [
			'altText'       => [
				'type'        => 'String',
				'description' => __( 'Alternative text to display when mediaItem is not displayed', 'wp-graphql' ),
			],
			'authorId'      => [
				'type'        => 'ID',
				'description' => __( 'The userId to assign as the author of the mediaItem', 'wp-graphql' ),
			],
			'caption'       => [
				'type'        => 'String',
				'description' => __( 'The caption for the mediaItem', 'wp-graphql' ),
			],
			'commentStatus' => [
				'type'        => 'String',
				'description' => __( 'The comment status for the mediaItem', 'wp-graphql' ),
			],
			'date'          => [
				'type'        => 'String',
				'description' => __( 'The date of the mediaItem', 'wp-graphql' ),
			],
			'dateGmt'       => [
				'type'        => 'String',
				'description' => __( 'The date (in GMT zone) of the mediaItem', 'wp-graphql' ),
			],
			'description'   => [
				'type'        => 'String',
				'description' => __( 'Description of the mediaItem', 'wp-graphql' ),
			],
			'filePath'      => [
				'type'        => 'String',
				'description' => __( 'The file name of the mediaItem', 'wp-graphql' ),
			],
			'fileType'      => [
				'type'        => 'MimeTypeEnum',
				'description' => __( 'The file type of the mediaItem', 'wp-graphql' ),
			],
			'slug'          => [
				'type'        => 'String',
				'description' => __( 'The slug of the mediaItem', 'wp-graphql' ),
			],
			'status'        => [
				'type'        => 'MediaItemStatusEnum',
				'description' => __( 'The status of the mediaItem', 'wp-graphql' ),
			],
			'title'         => [
				'type'        => 'String',
				'description' => __( 'The title of the mediaItem', 'wp-graphql' ),
			],
			'pingStatus'    => [
				'type'        => 'String',
				'description' => __( 'The ping status for the mediaItem', 'wp-graphql' ),
			],
			'parentId'      => [
				'type'        => 'ID',
				'description' => __( 'The ID of the parent object', 'wp-graphql' ),
			],
		];
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields() {
		return [
			'mediaItem' => [
				'type'        => 'MediaItem',
				'description' => __( 'The MediaItem object mutation type.', 'wp-graphql' ),
				'resolve'     => static function ( $payload, $args, AppContext $context ) {
					if ( empty( $payload['postObjectId'] ) || ! absint( $payload['postObjectId'] ) ) {
						return null;
					}

					return $context->get_loader( 'post' )->load_deferred( $payload['postObjectId'] );
				},
			],
		];
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @return callable(array<string,mixed>$input,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):array<string,mixed>
	 */
	public static function mutate_and_get_payload() {
		return static function ( $input, AppContext $context, ResolveInfo $info ) {
			/**
			 * Stop now if a user isn't allowed to upload a mediaItem
			 */
			if ( ! current_user_can( 'upload_files' ) ) {
				throw new UserError( esc_html__( 'Sorry, you are not allowed to upload mediaItems', 'wp-graphql' ) );
			}

			$post_type_object = get_post_type_object( 'attachment' );
			if ( empty( $post_type_object ) ) {
				throw new UserError( esc_html__( 'The Media Item could not be created', 'wp-graphql' ) );
			}

			/**
			 * If the mediaItem being created is being assigned to another user that's not the current user, make sure
			 * the current user has permission to edit others mediaItems
			 */
			if ( ! empty( $input['authorId'] ) ) {
				// Ensure authorId is a valid databaseId.
				$input['authorId'] = Utils::get_database_id_from_id( $input['authorId'] );

				// Bail if can't edit other users' attachments.
				if ( get_current_user_id() !== $input['authorId'] && ( ! isset( $post_type_object->cap->edit_others_posts ) || ! current_user_can( $post_type_object->cap->edit_others_posts ) ) ) {
					throw new UserError( esc_html__( 'Sorry, you are not allowed to create mediaItems as this user', 'wp-graphql' ) );
				}
			}

			/**
			 * Set the file name, whether it's a local file or from a URL.
			 * Then set the url for the uploaded file
			 */
			$file_name           = basename( $input['filePath'] );
			$uploaded_file_url   = $input['filePath'];
			$sanitized_file_path = sanitize_file_name( $input['filePath'] );

			// Check that the filetype is allowed
			$check_file = wp_check_filetype( $sanitized_file_path );

			// if the file doesn't pass the check, throw an error
			if ( ! $check_file['ext'] || ! $check_file['type'] || ! wp_http_validate_url( $uploaded_file_url ) ) {
				// translators: %s is the file path.
				throw new UserError( esc_html( sprintf( __( 'Invalid filePath "%s"', 'wp-graphql' ), $input['filePath'] ) ) );
			}

			$protocol = wp_parse_url( $input['filePath'], PHP_URL_SCHEME );

			// prevent the filePath from being submitted with a non-allowed protocols
			$allowed_protocols = [ 'https', 'http', 'file' ];

			/**
			 * Filter the allowed protocols for the mutation
			 *
			 * @param string[]                             $allowed_protocols The allowed protocols for filePaths to be submitted
			 * @param mixed                                $protocol          The current protocol of the filePath
			 * @param array<string,mixed>                  $input             The input of the current mutation
			 * @param \WPGraphQL\AppContext                $context           The context of the current request
			 * @param \GraphQL\Type\Definition\ResolveInfo $info              The ResolveInfo of the current field
			 */
			$allowed_protocols = apply_filters( 'graphql_media_item_create_allowed_protocols', $allowed_protocols, $protocol, $input, $context, $info );

			if ( ! in_array( $protocol, $allowed_protocols, true ) ) {
				throw new UserError(
					esc_html(
						sprintf(
							// translators: %1$s is the protocol, %2$s is the list of allowed protocols.
							__( 'Invalid protocol. "%1$s". Only "%2$s" allowed.', 'wp-graphql' ),
							$protocol,
							implode( '", "', $allowed_protocols )
						)
					)
				);
			}

			/**
			 * Require the file.php file from wp-admin. This file includes the
			 * download_url and wp_handle_sideload methods
			 */
			require_once ABSPATH . 'wp-admin/includes/file.php';

			$file_contents = file_get_contents( $input['filePath'] );

			/**
			 * If the mediaItem file is from a local server, use wp_upload_bits before saving it to the uploads folder
			 */
			if ( 'file' === wp_parse_url( $input['filePath'], PHP_URL_SCHEME ) && ! empty( $file_contents ) ) {
				$uploaded_file     = wp_upload_bits( $file_name, null, $file_contents );
				$uploaded_file_url = ( empty( $uploaded_file['error'] ) ? $uploaded_file['url'] : null );
			}

			/**
			 * URL data for the mediaItem, timeout value is the default, see:
			 * https://developer.wordpress.org/reference/functions/download_url/
			 */
			$timeout_seconds = 300;
			$temp_file       = download_url( $uploaded_file_url, $timeout_seconds );

			/**
			 * Handle the error from download_url if it occurs
			 */
			if ( is_wp_error( $temp_file ) ) {
				throw new UserError( esc_html__( 'Sorry, the URL for this file is invalid, it must be a valid URL', 'wp-graphql' ) );
			}

			/**
			 * Build the file data for side loading
			 */
			$file_data = [
				'name'     => $file_name,
				'type'     => ! empty( $input['fileType'] ) ? $input['fileType'] : wp_check_filetype( $temp_file ),
				'tmp_name' => $temp_file,
				'error'    => 0,
				'size'     => filesize( $temp_file ),
			];

			/**
			 * Tells WordPress to not look for the POST form fields that would normally be present as
			 * we downloaded the file from a remote server, so there will be no form fields
			 * The default is true
			 */
			$overrides = [
				'test_form' => false,
			];

			/**
			 * Insert the mediaItem and retrieve it's data
			 */
			$file = wp_handle_sideload( $file_data, $overrides );

			/**
			 * Handle the error from wp_handle_sideload if it occurs
			 */
			if ( ! empty( $file['error'] ) ) {
				throw new UserError( esc_html__( 'Sorry, the URL for this file is invalid, it must be a path to the mediaItem file', 'wp-graphql' ) );
			}

			/**
			 * Insert the mediaItem object and get the ID
			 */
			$media_item_args = MediaItemMutation::prepare_media_item( $input, $post_type_object, 'createMediaItem', $file );

			/**
			 * Get the post parent and if it's not set, set it to 0
			 */
			$attachment_parent_id = ! empty( $media_item_args['post_parent'] ) ? $media_item_args['post_parent'] : 0;

			/**
			 * Stop now if a user isn't allowed to edit the parent post
			 */
			$parent = get_post( $attachment_parent_id );

			if ( null !== $parent ) {
				$post_parent_type = get_post_type_object( $parent->post_type );

				if ( empty( $post_parent_type ) ) {
					throw new UserError( esc_html__( 'The parent of the Media Item is of an invalid type', 'wp-graphql' ) );
				}

				if ( 'attachment' !== $post_parent_type->name && ( ! isset( $post_parent_type->cap->edit_post ) || ! current_user_can( $post_parent_type->cap->edit_post, $attachment_parent_id ) ) ) {
					throw new UserError( esc_html__( 'Sorry, you are not allowed to upload mediaItems assigned to this parent node', 'wp-graphql' ) );
				}
			}

			/**
			 * Insert the mediaItem
			 *
			 * Required Argument defaults are set in the main MediaItemMutation.php if they aren't set
			 * by the user during input, they are:
			 * post_title (pulled from file if not entered)
			 * post_content (empty string if not entered)
			 * post_status (inherit if not entered)
			 * post_mime_type (pulled from the file if not entered in the mutation)
			 */
			$attachment_id = wp_insert_attachment( $media_item_args, $file['file'], $attachment_parent_id, true );

			if ( is_wp_error( $attachment_id ) ) {
				$error_message = $attachment_id->get_error_message();
				if ( ! empty( $error_message ) ) {
					throw new UserError( esc_html( $error_message ) );
				}

				throw new UserError( esc_html__( 'The media item failed to create but no error was provided', 'wp-graphql' ) );
			}

			/**
			 * Check if the wp_generate_attachment_metadata method exists and include it if not
			 */
			require_once ABSPATH . 'wp-admin/includes/image.php';

			/**
			 * Generate and update the mediaItem's metadata.
			 * If we make it this far the file and attachment
			 * have been validated and we will not receive any errors
			 */
			$attachment_data = wp_generate_attachment_metadata( $attachment_id, $file['file'] );
			wp_update_attachment_metadata( $attachment_id, $attachment_data );

			/**
			 * Update alt text postmeta for mediaItem
			 */
			MediaItemMutation::update_additional_media_item_data( $attachment_id, $input, $post_type_object, 'createMediaItem', $context, $info );

			return [
				'postObjectId' => $attachment_id,
			];
		};
	}
}


// File: wp-graphql\src\Mutation\MediaItemDelete.php
<?php
namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use GraphQLRelay\Relay;
use WPGraphQL\Model\Post;
use WPGraphQL\Utils\Utils;

class MediaItemDelete {
	/**
	 * Registers the MediaItemDelete mutation.
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_mutation() {
		register_graphql_mutation(
			'deleteMediaItem',
			[
				'inputFields'         => self::get_input_fields(),
				'outputFields'        => self::get_output_fields(),
				'mutateAndGetPayload' => self::mutate_and_get_payload(),
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields() {
		return [
			'id'          => [
				'type'        => [
					'non_null' => 'ID',
				],
				'description' => __( 'The ID of the mediaItem to delete', 'wp-graphql' ),
			],
			'forceDelete' => [
				'type'        => 'Boolean',
				'description' => __( 'Whether the mediaItem should be force deleted instead of being moved to the trash', 'wp-graphql' ),
			],
		];
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields() {
		return [
			'deletedId' => [
				'type'        => 'ID',
				'description' => __( 'The ID of the deleted mediaItem', 'wp-graphql' ),
				'resolve'     => static function ( $payload ) {
					$deleted = (object) $payload['mediaItemObject'];

					return ! empty( $deleted->ID ) ? Relay::toGlobalId( 'post', $deleted->ID ) : null;
				},
			],
			'mediaItem' => [
				'type'        => 'MediaItem',
				'description' => __( 'The mediaItem before it was deleted', 'wp-graphql' ),
				'resolve'     => static function ( $payload ) {
					/** @var \WPGraphQL\Model\Post $deleted */
					$deleted = $payload['mediaItemObject'];

					return ! empty( $deleted->ID ) ? $deleted : null;
				},
			],
		];
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @return callable(array<string,mixed>$input,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):array<string,mixed>
	 */
	public static function mutate_and_get_payload() {
		return static function ( $input ) {
			// Get the database ID for the comment.
			$media_item_id = Utils::get_database_id_from_id( $input['id'] );

			/**
			 * Get the mediaItem object before deleting it
			 */
			$existing_media_item = ! empty( $media_item_id ) ? get_post( $media_item_id ) : null;

			// If there's no existing mediaItem, throw an exception.
			if ( null === $existing_media_item ) {
				throw new UserError( esc_html__( 'No mediaItem with that ID could be found to delete', 'wp-graphql' ) );
			}

			// Stop now if the post isn't a mediaItem.
			if ( 'attachment' !== $existing_media_item->post_type ) {
				// Translators: the placeholder is the post_type of the object being deleted
				throw new UserError( esc_html( sprintf( __( 'Sorry, the item you are trying to delete is a %1%s, not a mediaItem', 'wp-graphql' ), $existing_media_item->post_type ) ) );
			}

			/**
			 * Stop now if a user isn't allowed to delete a mediaItem
			 */
			$post_type_object = get_post_type_object( 'attachment' );

			if ( ! isset( $post_type_object->cap->delete_post ) || ! current_user_can( $post_type_object->cap->delete_post, $media_item_id ) ) {
				throw new UserError( esc_html__( 'Sorry, you are not allowed to delete mediaItems', 'wp-graphql' ) );
			}

			/**
			 * Check if we should force delete or not
			 */
			$force_delete = ! empty( $input['forceDelete'] ) && true === $input['forceDelete'];

			/**
			 * If the mediaItem is already in the trash, and the forceDelete input was not passed,
			 * don't remove from the trash
			 */
			if ( 'trash' === $existing_media_item->post_status && true !== $force_delete ) {
				// translators: the first placeholder is the post_type of the object being deleted and the second placeholder is the unique ID of that object
				throw new UserError( esc_html( sprintf( __( 'The mediaItem with id %1$s is already in the trash. To remove from the trash, use the forceDelete input', 'wp-graphql' ), $input['id'] ) ) );
			}

			/**
			 * Delete the mediaItem. This will not throw false thanks to
			 * all of the above validation
			 */
			$deleted = wp_delete_attachment( (int) $media_item_id, $force_delete );

			/**
			 * If the post was moved to the trash, spoof the object's status before returning it
			 */
			$existing_media_item->post_status = ( false !== $deleted && true !== $force_delete ) ? 'trash' : $existing_media_item->post_status;

			$media_item_before_delete = new Post( $existing_media_item );

			/**
			 * Return the deletedId and the mediaItem before it was deleted
			 */
			return [
				'mediaItemObject' => $media_item_before_delete,
			];
		};
	}
}


// File: wp-graphql\src\Mutation\MediaItemUpdate.php
<?php

namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Data\MediaItemMutation;
use WPGraphQL\Utils\Utils;

class MediaItemUpdate {
	/**
	 * Registers the MediaItemUpdate mutation.
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_mutation() {
		register_graphql_mutation(
			'updateMediaItem',
			[
				'inputFields'         => self::get_input_fields(),
				'outputFields'        => self::get_output_fields(),
				'mutateAndGetPayload' => self::mutate_and_get_payload(),
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields() {
		/** @var \WP_Post_Type $post_type_object */
		$post_type_object = get_post_type_object( 'attachment' );
		return array_merge(
			MediaItemCreate::get_input_fields(),
			[
				'id' => [
					'type'        => [
						'non_null' => 'ID',
					],
					// translators: the placeholder is the name of the type of post object being updated
					'description' => sprintf( __( 'The ID of the %1$s object', 'wp-graphql' ), $post_type_object->graphql_single_name ),
				],
			]
		);
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields() {
		return MediaItemCreate::get_output_fields();
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @return callable(array<string,mixed>$input,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):array<string,mixed>
	 */
	public static function mutate_and_get_payload() {
		return static function ( $input, AppContext $context, ResolveInfo $info ) {
			$post_type_object = get_post_type_object( 'attachment' );

			if ( empty( $post_type_object ) ) {
				return [];
			}

			// Get the database ID for the comment.
			$media_item_id = Utils::get_database_id_from_id( $input['id'] );

			/**
			 * Get the mediaItem object before deleting it
			 */
			$existing_media_item = ! empty( $media_item_id ) ? get_post( $media_item_id ) : null;

			$mutation_name = 'updateMediaItem';

			/**
			 * If there's no existing mediaItem, throw an exception
			 */
			if ( null === $existing_media_item ) {
				throw new UserError( esc_html__( 'No mediaItem with that ID could be found to update', 'wp-graphql' ) );
			}

			/**
			 * Stop now if the post isn't a mediaItem
			 */
			if ( $post_type_object->name !== $existing_media_item->post_type ) {
				// translators: The placeholder is the ID of the mediaItem being edited
				throw new UserError( esc_html( sprintf( __( 'The id %1$d is not of the type mediaItem', 'wp-graphql' ), $input['id'] ) ) );
			}

			/**
			 * Stop now if a user isn't allowed to edit mediaItems
			 */
			if ( ! isset( $post_type_object->cap->edit_posts ) || ! current_user_can( $post_type_object->cap->edit_posts ) ) {
				throw new UserError( esc_html__( 'Sorry, you are not allowed to update mediaItems', 'wp-graphql' ) );
			}

			$author_id = absint( $existing_media_item->post_author );

			/**
			 * If the mutation is setting the author to be someone other than the user making the request
			 * make sure they have permission to edit others posts
			 */
			if ( ! empty( $input['authorId'] ) ) {
				// Ensure authorId is a valid databaseId.
				$input['authorId'] = Utils::get_database_id_from_id( $input['authorId'] );
				// Use the new author for checks.
				$author_id = $input['authorId'];
			}

			/**
			 * Check to see if the existing_media_item author matches the current user,
			 * if not they need to be able to edit others posts to proceed
			 */
			if ( get_current_user_id() !== $author_id && ( ! isset( $post_type_object->cap->edit_others_posts ) || ! current_user_can( $post_type_object->cap->edit_others_posts ) ) ) {
				throw new UserError( esc_html__( 'Sorry, you are not allowed to update mediaItems as this user.', 'wp-graphql' ) );
			}

			/**
			 * Insert the post object and get the ID
			 */
			$post_args       = MediaItemMutation::prepare_media_item( $input, $post_type_object, $mutation_name, false );
			$post_args['ID'] = $media_item_id;

			$clean_args = wp_slash( (array) $post_args );

			if ( ! is_array( $clean_args ) || empty( $clean_args ) ) {
				throw new UserError( esc_html__( 'The media item failed to update', 'wp-graphql' ) );
			}

			/**
			 * Insert the post and retrieve the ID
			 *
			 * This will not fail as long as we have an ID in $post_args
			 * Thanks to the validation above we will always have the ID
			 */
			$post_id = wp_update_post( $clean_args, true );

			if ( is_wp_error( $post_id ) ) {
				$error_message = $post_id->get_error_message();
				if ( ! empty( $error_message ) ) {
					throw new UserError( esc_html( $error_message ) );
				}

				throw new UserError( esc_html__( 'The media item failed to update but no error was provided', 'wp-graphql' ) );
			}

			/**
			 * This updates additional data not part of the posts table (postmeta, terms, other relations, etc)
			 *
			 * The input for the postObjectMutation will be passed, along with the $new_post_id for the
			 * postObject that was updated so that relations can be set, meta can be updated, etc.
			 */
			MediaItemMutation::update_additional_media_item_data( $post_id, $input, $post_type_object, $mutation_name, $context, $info );

			/**
			 * Return the payload
			 */
			return [
				'postObjectId' => $post_id,
			];
		};
	}
}


// File: wp-graphql\src\Mutation\PostObjectCreate.php
<?php

namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Data\PostObjectMutation;
use WPGraphQL\Utils\Utils;
use WP_Post_Type;

/**
 * Class PostObjectCreate
 *
 * @package WPGraphQL\Mutation
 */
class PostObjectCreate {
	/**
	 * Registers the PostObjectCreate mutation.
	 *
	 * @param \WP_Post_Type $post_type_object The post type of the mutation.
	 *
	 * @return void
	 */
	public static function register_mutation( WP_Post_Type $post_type_object ) {
		$mutation_name = 'create' . ucwords( $post_type_object->graphql_single_name );

		register_graphql_mutation(
			$mutation_name,
			[
				'inputFields'         => self::get_input_fields( $post_type_object ),
				'outputFields'        => self::get_output_fields( $post_type_object ),
				'mutateAndGetPayload' => self::mutate_and_get_payload( $post_type_object, $mutation_name ),
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @param \WP_Post_Type $post_type_object The post type of the mutation.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields( $post_type_object ) {
		$fields = [
			'date'      => [
				'type'        => 'String',
				'description' => __( 'The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, "2017" as the input will use current date with timestamp 20:17 ', 'wp-graphql' ),
			],
			'menuOrder' => [
				'type'        => 'Int',
				'description' => __( 'A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types.', 'wp-graphql' ),
			],
			'password'  => [
				'type'        => 'String',
				'description' => __( 'The password used to protect the content of the object', 'wp-graphql' ),
			],
			'slug'      => [
				'type'        => 'String',
				'description' => __( 'The slug of the object', 'wp-graphql' ),
			],
			'status'    => [
				'type'        => 'PostStatusEnum',
				'description' => __( 'The status of the object', 'wp-graphql' ),
			],
		];

		if ( post_type_supports( $post_type_object->name, 'author' ) ) {
			$fields['authorId'] = [
				'type'        => 'ID',
				'description' => __( 'The userId to assign as the author of the object', 'wp-graphql' ),
			];
		}

		if ( post_type_supports( $post_type_object->name, 'comments' ) ) {
			$fields['commentStatus'] = [
				'type'        => 'String',
				'description' => __( 'The comment status for the object', 'wp-graphql' ),
			];
		}

		if ( post_type_supports( $post_type_object->name, 'editor' ) ) {
			$fields['content'] = [
				'type'        => 'String',
				'description' => __( 'The content of the object', 'wp-graphql' ),
			];
		}

		if ( post_type_supports( $post_type_object->name, 'excerpt' ) ) {
			$fields['excerpt'] = [
				'type'        => 'String',
				'description' => __( 'The excerpt of the object', 'wp-graphql' ),
			];
		}

		if ( post_type_supports( $post_type_object->name, 'title' ) ) {
			$fields['title'] = [
				'type'        => 'String',
				'description' => __( 'The title of the object', 'wp-graphql' ),
			];
		}

		if ( post_type_supports( $post_type_object->name, 'trackbacks' ) ) {
			$fields['pinged'] = [
				'type'        => [
					'list_of' => 'String',
				],
				'description' => __( 'URLs that have been pinged.', 'wp-graphql' ),
			];

			$fields['pingStatus'] = [
				'type'        => 'String',
				'description' => __( 'The ping status for the object', 'wp-graphql' ),
			];

			$fields['toPing'] = [
				'type'        => [
					'list_of' => 'String',
				],
				'description' => __( 'URLs queued to be pinged.', 'wp-graphql' ),
			];
		}

		if ( $post_type_object->hierarchical || in_array(
			$post_type_object->name,
			[
				'attachment',
				'revision',
			],
			true
		) ) {
			$fields['parentId'] = [
				'type'        => 'ID',
				'description' => __( 'The ID of the parent object', 'wp-graphql' ),
			];
		}

		if ( 'attachment' === $post_type_object->name ) {
			$fields['mimeType'] = [
				'type'        => 'MimeTypeEnum',
				'description' => __( 'If the post is an attachment or a media file, this field will carry the corresponding MIME type. This field is equivalent to the value of WP_Post->post_mime_type and the post_mime_type column in the "post_objects" database table.', 'wp-graphql' ),
			];
		}

		/** @var \WP_Taxonomy[] $allowed_taxonomies */
		$allowed_taxonomies = \WPGraphQL::get_allowed_taxonomies( 'objects' );

		foreach ( $allowed_taxonomies as $tax_object ) {
			// If the taxonomy is in the array of taxonomies registered to the post_type
			if ( in_array( $tax_object->name, get_object_taxonomies( $post_type_object->name ), true ) ) {
				$fields[ $tax_object->graphql_plural_name ] = [
					'description' => sprintf(
						// translators: %1$s is the post type GraphQL name, %2$s is the taxonomy GraphQL name.
						__( 'Set connections between the %1$s and %2$s', 'wp-graphql' ),
						$post_type_object->graphql_single_name,
						$tax_object->graphql_plural_name
					),
					'type'        => ucfirst( $post_type_object->graphql_single_name ) . ucfirst( $tax_object->graphql_plural_name ) . 'Input',
				];
			}
		}

		return $fields;
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @param \WP_Post_Type $post_type_object The post type of the mutation.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields( WP_Post_Type $post_type_object ) {
		return [
			$post_type_object->graphql_single_name => [
				'type'        => $post_type_object->graphql_single_name,
				'description' => __( 'The Post object mutation type.', 'wp-graphql' ),
				'resolve'     => static function ( $payload, $_args, AppContext $context ) {
					if ( empty( $payload['postObjectId'] ) || ! absint( $payload['postObjectId'] ) ) {
						return null;
					}

					return $context->get_loader( 'post' )->load_deferred( $payload['postObjectId'] );
				},
			],
		];
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @param \WP_Post_Type $post_type_object The post type of the mutation.
	 * @param string        $mutation_name    The mutation name.
	 *
	 * @return callable(array<string,mixed>$input,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):array<string,mixed>
	 */
	public static function mutate_and_get_payload( $post_type_object, $mutation_name ) {
		return static function ( $input, AppContext $context, ResolveInfo $info ) use ( $post_type_object, $mutation_name ) {

			/**
			 * Throw an exception if there's no input
			 */
			if ( ( empty( $post_type_object->name ) ) || ( empty( $input ) || ! is_array( $input ) ) ) {
				throw new UserError( esc_html__( 'Mutation not processed. There was no input for the mutation or the post_type_object was invalid', 'wp-graphql' ) );
			}

			/**
			 * Stop now if a user isn't allowed to create a post
			 */
			if ( ! isset( $post_type_object->cap->create_posts ) || ! current_user_can( $post_type_object->cap->create_posts ) ) {
				// translators: the $post_type_object->graphql_plural_name placeholder is the name of the object being mutated
				throw new UserError( esc_html( sprintf( __( 'Sorry, you are not allowed to create %1$s', 'wp-graphql' ), $post_type_object->graphql_plural_name ) ) );
			}

			/**
			 * If the post being created is being assigned to another user that's not the current user, make sure
			 * the current user has permission to edit others posts for this post_type
			 */
			if ( ! empty( $input['authorId'] ) ) {
				// Ensure authorId is a valid databaseId.
				$input['authorId'] = Utils::get_database_id_from_id( $input['authorId'] );

				$author = ! empty( $input['authorId'] ) ? get_user_by( 'ID', $input['authorId'] ) : false;

				if ( false === $author ) {
					throw new UserError( esc_html__( 'The provided `authorId` is not a valid user', 'wp-graphql' ) );
				}

				if ( get_current_user_id() !== $input['authorId'] && ( ! isset( $post_type_object->cap->edit_others_posts ) || ! current_user_can( $post_type_object->cap->edit_others_posts ) ) ) {
					// translators: the $post_type_object->graphql_plural_name placeholder is the name of the object being mutated
					throw new UserError( esc_html( sprintf( __( 'Sorry, you are not allowed to create %1$s as this user', 'wp-graphql' ), $post_type_object->graphql_plural_name ) ) );
				}
			}

			/**
			 * @todo: When we support assigning terms and setting posts as "sticky" we need to check permissions
			 * @see :https://github.com/WordPress/WordPress/blob/e357195ce303017d517aff944644a7a1232926f7/wp-includes/rest-api/endpoints/class-wp-rest-posts-controller.php#L504-L506
			 * @see : https://github.com/WordPress/WordPress/blob/e357195ce303017d517aff944644a7a1232926f7/wp-includes/rest-api/endpoints/class-wp-rest-posts-controller.php#L496-L498
			 */

			/**
			 * Insert the post object and get the ID
			 */
			$post_args = PostObjectMutation::prepare_post_object( $input, $post_type_object, $mutation_name );

			/**
			 * Filter the default post status to use when the post is initially created. Pass through a filter to
			 * allow other plugins to override the default (for example, Edit Flow, which provides control over
			 * customizing stati or various E-commerce plugins that make heavy use of custom stati)
			 *
			 * @param string       $default_status   The default status to be used when the post is initially inserted
			 * @param \WP_Post_Type $post_type_object The Post Type that is being inserted
			 * @param string       $mutation_name    The name of the mutation currently in progress
			 */
			$default_post_status = apply_filters( 'graphql_post_object_create_default_post_status', 'draft', $post_type_object, $mutation_name );

			/**
			 * We want to cache the "post_status" and set the status later. We will set the initial status
			 * of the inserted post as the default status for the site, allow side effects to process with the
			 * inserted post (set term object connections, set meta input, sideload images if necessary, etc)
			 * Then will follow up with setting the status as what it was declared to be later
			 */
			$intended_post_status = ! empty( $post_args['post_status'] ) ? $post_args['post_status'] : $default_post_status;

			/**
			 * If the current user cannot publish posts but their intent was to publish,
			 * default the status to pending.
			 */
			if ( ( ! isset( $post_type_object->cap->publish_posts ) || ! current_user_can( $post_type_object->cap->publish_posts ) ) && ! in_array(
				$intended_post_status,
				[
					'draft',
					'pending',
				],
				true
			) ) {
				$intended_post_status = 'pending';
			}

			/**
			 * Set the post_status as the default for the initial insert. The intended $post_status will be set after
			 * side effects are complete.
			 */
			$post_args['post_status'] = $default_post_status;

			$clean_args = wp_slash( (array) $post_args );

			if ( ! is_array( $clean_args ) || empty( $clean_args ) ) {
				throw new UserError( esc_html__( 'The object failed to create', 'wp-graphql' ) );
			}

			/**
			 * Insert the post and retrieve the ID
			 */
			$post_id = wp_insert_post( $clean_args, true );

			/**
			 * Throw an exception if the post failed to create
			 */
			if ( is_wp_error( $post_id ) ) {
				$error_message = $post_id->get_error_message();
				if ( ! empty( $error_message ) ) {
					throw new UserError( esc_html( $error_message ) );
				}

				throw new UserError( esc_html__( 'The object failed to create but no error was provided', 'wp-graphql' ) );
			}

			/**
			 * This updates additional data not part of the posts table (postmeta, terms, other relations, etc)
			 *
			 * The input for the postObjectMutation will be passed, along with the $new_post_id for the
			 * postObject that was created so that relations can be set, meta can be updated, etc.
			 */
			PostObjectMutation::update_additional_post_object_data( $post_id, $input, $post_type_object, $mutation_name, $context, $info, $default_post_status, $intended_post_status );

			/**
			 * Determine whether the intended status should be set or not.
			 *
			 * By filtering to false, the $intended_post_status will not be set at the completion of the mutation.
			 *
			 * This allows for side-effect actions to set the status later. For example, if a post
			 * was being created via a GraphQL Mutation, the post had additional required assets, such as images
			 * that needed to be sideloaded or some other semi-time-consuming side effect, those actions could
			 * be deferred (cron or whatever), and when those actions complete they could come back and set
			 * the $intended_status.
			 *
			 * @param bool      $should_set_intended_status Whether to set the intended post_status or not. Default true.
			 * @param \WP_Post_Type $post_type_object The Post Type Object for the post being mutated
			 * @param string       $mutation_name              The name of the mutation currently in progress
			 * @param \WPGraphQL\AppContext $context The AppContext passed down to all resolvers
			 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo passed down to all resolvers
			 * @param string       $intended_post_status       The intended post_status the post should have according to the mutation input
			 * @param string       $default_post_status        The default status posts should use if an intended status wasn't set
			 */
			$should_set_intended_status = apply_filters( 'graphql_post_object_create_should_set_intended_post_status', true, $post_type_object, $mutation_name, $context, $info, $intended_post_status, $default_post_status );

			/**
			 * If the intended post status and the default post status are not the same,
			 * update the post with the intended status now that side effects are complete.
			 */
			if ( $intended_post_status !== $default_post_status && true === $should_set_intended_status ) {

				/**
				 * If the post was deleted by a side effect action before getting here,
				 * don't proceed.
				 */
				$new_post = get_post( $post_id );
				if ( empty( $new_post ) ) {
					throw new UserError( esc_html__( 'The status of the post could not be set', 'wp-graphql' ) );
				}

				/**
				 * If the $intended_post_status is different than the current status of the post
				 * proceed and update the status.
				 */
				if ( $intended_post_status !== $new_post->post_status ) {
					$update_args = [
						'ID'          => $post_id,
						'post_status' => $intended_post_status,
						// Prevent the post_date from being reset if the date was included in the create post $args
						// see: https://core.trac.wordpress.org/browser/tags/4.9/src/wp-includes/post.php#L3637
						'edit_date'   => ! empty( $post_args['post_date'] ) ? $post_args['post_date'] : false,
					];

					wp_update_post( $update_args );
				}
			}

			/**
			 * Return the post object
			 */
			return [
				'postObjectId' => $post_id,
			];
		};
	}
}


// File: wp-graphql\src\Mutation\PostObjectDelete.php
<?php

namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use GraphQLRelay\Relay;
use WPGraphQL\Data\PostObjectMutation;
use WPGraphQL\Model\Post;
use WPGraphQL\Utils\Utils;
use WP_Post_Type;

class PostObjectDelete {
	/**
	 * Registers the PostObjectDelete mutation.
	 *
	 * @param \WP_Post_Type $post_type_object The post type of the mutation.
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_mutation( WP_Post_Type $post_type_object ) {
		$mutation_name = 'delete' . ucwords( $post_type_object->graphql_single_name );

		register_graphql_mutation(
			$mutation_name,
			[
				'inputFields'         => self::get_input_fields( $post_type_object ),
				'outputFields'        => self::get_output_fields( $post_type_object ),
				'mutateAndGetPayload' => self::mutate_and_get_payload( $post_type_object, $mutation_name ),
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @param \WP_Post_Type $post_type_object The post type of the mutation.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields( $post_type_object ) {
		return [
			'id'             => [
				'type'        => [
					'non_null' => 'ID',
				],
				// translators: The placeholder is the name of the post's post_type being deleted
				'description' => sprintf( __( 'The ID of the %1$s to delete', 'wp-graphql' ), $post_type_object->graphql_single_name ),
			],
			'forceDelete'    => [
				'type'        => 'Boolean',
				'description' => __( 'Whether the object should be force deleted instead of being moved to the trash', 'wp-graphql' ),
			],
			'ignoreEditLock' => [
				'type'        => 'Boolean',
				'description' => __( 'Override the edit lock when another user is editing the post', 'wp-graphql' ),
			],
		];
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @param \WP_Post_Type $post_type_object The post type of the mutation.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields( WP_Post_Type $post_type_object ) {
		return [
			'deletedId'                            => [
				'type'        => 'ID',
				'description' => __( 'The ID of the deleted object', 'wp-graphql' ),
				'resolve'     => static function ( $payload ) {
					/** @var \WPGraphQL\Model\Post $deleted */
					$deleted = $payload['postObject'];

					return ! empty( $deleted->ID ) ? Relay::toGlobalId( 'post', (string) $deleted->ID ) : null;
				},
			],
			$post_type_object->graphql_single_name => [
				'type'        => $post_type_object->graphql_single_name,
				'description' => __( 'The object before it was deleted', 'wp-graphql' ),
				'resolve'     => static function ( $payload ) {
					/** @var \WPGraphQL\Model\Post $deleted */
					$deleted = $payload['postObject'];

					return ! empty( $deleted->ID ) ? $deleted : null;
				},
			],
		];
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @param \WP_Post_Type $post_type_object The post type of the mutation.
	 * @param string        $mutation_name    The mutation name.
	 *
	 * @return callable(array<string,mixed>$input,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):array<string,mixed>
	 */
	public static function mutate_and_get_payload( WP_Post_Type $post_type_object, string $mutation_name ) {
		return static function ( $input ) use ( $post_type_object ) {
			// Get the database ID for the post.
			$post_id = Utils::get_database_id_from_id( $input['id'] );

			/**
			 * Stop now if a user isn't allowed to delete a post
			 */
			if ( ! isset( $post_type_object->cap->delete_post ) || ! current_user_can( $post_type_object->cap->delete_post, $post_id ) ) {
				// translators: the $post_type_object->graphql_plural_name placeholder is the name of the object being mutated
				throw new UserError( esc_html( sprintf( __( 'Sorry, you are not allowed to delete %1$s', 'wp-graphql' ), $post_type_object->graphql_plural_name ) ) );
			}

			/**
			 * Check if we should force delete or not
			 */
			$force_delete = ! empty( $input['forceDelete'] ) && true === $input['forceDelete'];

			/**
			 * Get the post object before deleting it
			 */
			$post_before_delete = ! empty( $post_id ) ? get_post( $post_id ) : null;

			if ( empty( $post_before_delete ) ) {
				throw new UserError( esc_html__( 'The post could not be deleted', 'wp-graphql' ) );
			}

			$post_before_delete = new Post( $post_before_delete );

			/**
			 * If the post is already in the trash, and the forceDelete input was not passed,
			 * don't remove from the trash
			 */
			if ( 'trash' === $post_before_delete->post_status && true !== $force_delete ) {
				// Translators: the first placeholder is the post_type of the object being deleted and the second placeholder is the unique ID of that object
				throw new UserError( esc_html( sprintf( __( 'The %1$s with id %2$s is already in the trash. To remove from the trash, use the forceDelete input', 'wp-graphql' ), $post_type_object->graphql_single_name, $post_id ) ) );
			}

			// If post is locked and the override is not specified, do not allow the edit
			$locked_user_id = PostObjectMutation::check_edit_lock( $post_id, $input );
			if ( false !== $locked_user_id ) {
				$user         = get_userdata( (int) $locked_user_id );
				$display_name = isset( $user->display_name ) ? $user->display_name : 'unknown';
				/* translators: %s: User's display name. */
				throw new UserError( esc_html( sprintf( __( 'You cannot delete this item. %s is currently editing.', 'wp-graphql' ), $display_name ) ) );
			}

			/**
			 * Delete the post
			 */
			$deleted = wp_delete_post( (int) $post_id, $force_delete );

			/**
			 * If the post was moved to the trash, spoof the object's status before returning it
			 */
			$post_before_delete->post_status = ( false !== $deleted && true !== $force_delete ) ? 'trash' : $post_before_delete->post_status;

			/**
			 * Return the deletedId and the object before it was deleted
			 */
			return [
				'postObject' => $post_before_delete,
			];
		};
	}
}


// File: wp-graphql\src\Mutation\PostObjectUpdate.php
<?php
namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Data\PostObjectMutation;
use WPGraphQL\Utils\Utils;
use WP_Post_Type;

class PostObjectUpdate {
	/**
	 * Registers the PostObjectUpdate mutation.
	 *
	 * @param \WP_Post_Type $post_type_object The post type of the mutation.
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_mutation( WP_Post_Type $post_type_object ) {
		$mutation_name = 'update' . ucwords( $post_type_object->graphql_single_name );

		register_graphql_mutation(
			$mutation_name,
			[
				'inputFields'         => self::get_input_fields( $post_type_object ),
				'outputFields'        => self::get_output_fields( $post_type_object ),
				'mutateAndGetPayload' => self::mutate_and_get_payload( $post_type_object, $mutation_name ),
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @param \WP_Post_Type $post_type_object The post type of the mutation.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields( $post_type_object ) {
		return array_merge(
			PostObjectCreate::get_input_fields( $post_type_object ),
			[
				'id'             => [
					'type'        => [
						'non_null' => 'ID',
					],
					// translators: the placeholder is the name of the type of post object being updated
					'description' => sprintf( __( 'The ID of the %1$s object', 'wp-graphql' ), $post_type_object->graphql_single_name ),
				],
				'ignoreEditLock' => [
					'type'        => 'Boolean',
					'description' => __( 'Override the edit lock when another user is editing the post', 'wp-graphql' ),
				],
			]
		);
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @param \WP_Post_Type $post_type_object The post type of the mutation.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields( $post_type_object ) {
		return PostObjectCreate::get_output_fields( $post_type_object );
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @param \WP_Post_Type $post_type_object The post type of the mutation.
	 * @param string        $mutation_name      The mutation name.
	 *
	 * @return callable(array<string,mixed>$input,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):array<string,mixed>
	 */
	public static function mutate_and_get_payload( $post_type_object, $mutation_name ) {
		return static function ( $input, AppContext $context, ResolveInfo $info ) use ( $post_type_object, $mutation_name ) {
			// Get the database ID for the comment.
			$post_id       = Utils::get_database_id_from_id( $input['id'] );
			$existing_post = ! empty( $post_id ) ? get_post( $post_id ) : null;

			/**
			 * If there's no existing post, throw an exception
			 */
			if ( null === $existing_post ) {
				// translators: the placeholder is the name of the type of post being updated
				throw new UserError( esc_html( sprintf( __( 'No %1$s could be found to update', 'wp-graphql' ), $post_type_object->graphql_single_name ) ) );
			}

			if ( $post_type_object->name !== $existing_post->post_type ) {
				// translators: The first placeholder is an ID and the second placeholder is the name of the post type being edited
				throw new UserError( esc_html( sprintf( __( 'The id %1$d is not of the type "%2$s"', 'wp-graphql' ), $post_id, $post_type_object->name ) ) );
			}

			/**
			 * Stop now if a user isn't allowed to edit posts
			 */
			if ( ! isset( $post_type_object->cap->edit_posts ) || ! current_user_can( $post_type_object->cap->edit_posts ) ) {
				// translators: the $post_type_object->graphql_single_name placeholder is the name of the object being mutated
				throw new UserError( esc_html( sprintf( __( 'Sorry, you are not allowed to update a %1$s', 'wp-graphql' ), $post_type_object->graphql_single_name ) ) );
			}

			/**
			 * If the existing post was authored by another author, ensure the requesting user has permission to edit it
			 */
			if ( get_current_user_id() !== (int) $existing_post->post_author && ( ! isset( $post_type_object->cap->edit_others_posts ) || true !== current_user_can( $post_type_object->cap->edit_others_posts ) ) ) {
				// translators: the $post_type_object->graphql_single_name placeholder is the name of the object being mutated
				throw new UserError( esc_html( sprintf( __( 'Sorry, you are not allowed to update another author\'s %1$s', 'wp-graphql' ), $post_type_object->graphql_single_name ) ) );
			}

			$author_id = absint( $existing_post->post_author );

			/**
			 * If the mutation is setting the author to be someone other than the user making the request
			 * make sure they have permission to edit others posts
			 */
			if ( ! empty( $input['authorId'] ) ) {
				// Ensure authorId is a valid databaseId.
				$input['authorId'] = Utils::get_database_id_from_id( $input['authorId'] );
				// Use the new author for checks.
				$author_id = $input['authorId'];
			}

			/**
			 * Check to see if the existing_media_item author matches the current user,
			 * if not they need to be able to edit others posts to proceed
			 */
			if ( get_current_user_id() !== $author_id && ( ! isset( $post_type_object->cap->edit_others_posts ) || ! current_user_can( $post_type_object->cap->edit_others_posts ) ) ) {
				// translators: the $post_type_object->graphql_single_name placeholder is the name of the object being mutated
				throw new UserError( esc_html( sprintf( __( 'Sorry, you are not allowed to update %1$s as this user.', 'wp-graphql' ), $post_type_object->graphql_plural_name ) ) );
			}

			// If post is locked and the override is not specified, do not allow the edit
			$locked_user_id = PostObjectMutation::check_edit_lock( $post_id, $input );
			if ( false !== $locked_user_id ) {
				$user         = get_userdata( (int) $locked_user_id );
				$display_name = isset( $user->display_name ) ? $user->display_name : 'unknown';
				/* translators: %s: User's display name. */
				throw new UserError( esc_html( sprintf( __( 'You cannot update this item. %s is currently editing.', 'wp-graphql' ), $display_name ) ) );
			}

			/**
			 * @todo: when we add support for making posts sticky, we should check permissions to make sure users can make posts sticky
			 * @see : https://github.com/WordPress/WordPress/blob/e357195ce303017d517aff944644a7a1232926f7/wp-includes/rest-api/endpoints/class-wp-rest-posts-controller.php#L640-L642
			 */

			/**
			 * @todo: when we add support for assigning terms to posts, we should check permissions to make sure they can assign terms
			 * @see : https://github.com/WordPress/WordPress/blob/e357195ce303017d517aff944644a7a1232926f7/wp-includes/rest-api/endpoints/class-wp-rest-posts-controller.php#L644-L646
			 */

			/**
			 * Insert the post object and get the ID
			 */
			$post_args       = PostObjectMutation::prepare_post_object( $input, $post_type_object, $mutation_name );
			$post_args['ID'] = $post_id;

			$clean_args = wp_slash( (array) $post_args );

			if ( ! is_array( $clean_args ) || empty( $clean_args ) ) {
				throw new UserError( esc_html__( 'The object failed to update.', 'wp-graphql' ) );
			}

			/**
			 * Insert the post and retrieve the ID
			 */
			$updated_post_id = wp_update_post( $clean_args, true );

			/**
			 * Throw an exception if the post failed to update
			 */
			if ( is_wp_error( $updated_post_id ) ) {
				$error_message = $updated_post_id->get_error_message();
				if ( ! empty( $error_message ) ) {
					throw new UserError( esc_html( $error_message ) );
				}

				throw new UserError( esc_html__( 'The object failed to update but no error was provided', 'wp-graphql' ) );
			}

			/**
			 * Fires after a single term is created or updated via a GraphQL mutation
			 *
			 * The dynamic portion of the hook name, `$taxonomy->name` refers to the taxonomy of the term being mutated
			 *
			 * @param int                 $post_id          Inserted post ID
			 * @param \WP_Post_Type       $post_type_object The Post Type object for the post being mutated
			 * @param array<string,mixed> $args             The args used to insert the term
			 * @param string              $mutation_name    The name of the mutation being performed
			 */
			do_action( 'graphql_insert_post_object', absint( $post_id ), $post_type_object, $post_args, $mutation_name );

			/**
			 * Fires after a single term is created or updated via a GraphQL mutation
			 *
			 * The dynamic portion of the hook name, `$taxonomy->name` refers to the taxonomy of the term being mutated
			 *
			 * @param int                 $post_id       Inserted post ID
			 * @param array<string,mixed> $args          The args used to insert the term
			 * @param string              $mutation_name The name of the mutation being performed
			 */
			do_action( "graphql_insert_{$post_type_object->name}", absint( $post_id ), $post_args, $mutation_name );

			/**
			 * This updates additional data not part of the posts table (postmeta, terms, other relations, etc)
			 *
			 * The input for the postObjectMutation will be passed, along with the $new_post_id for the
			 * postObject that was updated so that relations can be set, meta can be updated, etc.
			 */
			PostObjectMutation::update_additional_post_object_data( (int) $post_id, $input, $post_type_object, $mutation_name, $context, $info );

			/**
			 * Return the payload
			 */
			return [
				'postObjectId' => $post_id,
			];
		};
	}
}


// File: wp-graphql\src\Mutation\ResetUserPassword.php
<?php
namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use WPGraphQL\AppContext;

class ResetUserPassword {
	/**
	 * Registers the ResetUserPassword mutation.
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_mutation() {
		register_graphql_mutation(
			'resetUserPassword',
			[
				'inputFields'         => self::get_input_fields(),
				'outputFields'        => self::get_output_fields(),
				'mutateAndGetPayload' => self::mutate_and_get_payload(),
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields() {
		return [
			'key'      => [
				'type'        => 'String',
				'description' => __( 'Password reset key', 'wp-graphql' ),
			],
			'login'    => [
				'type'        => 'String',
				'description' => __( 'The user\'s login (username).', 'wp-graphql' ),
			],
			'password' => [
				'type'        => 'String',
				'description' => __( 'The new password.', 'wp-graphql' ),
			],
		];
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields() {
		return UserCreate::get_output_fields();
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @return callable(array<string,mixed>$input,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):array<string,mixed>
	 */
	public static function mutate_and_get_payload() {
		return static function ( $input, AppContext $context ) {
			if ( empty( $input['key'] ) ) {
				throw new UserError( esc_html__( 'A password reset key is required.', 'wp-graphql' ) );
			}

			if ( empty( $input['login'] ) ) {
				throw new UserError( esc_html__( 'A user login is required.', 'wp-graphql' ) );
			}

			if ( empty( $input['password'] ) ) {
				throw new UserError( esc_html__( 'A new password is required.', 'wp-graphql' ) );
			}

			$user = check_password_reset_key( $input['key'], $input['login'] );

			/**
			 * If the password reset key check returns an error
			 */
			if ( is_wp_error( $user ) ) {

				/**
				 * Determine the message to return
				 */
				if ( 'expired_key' === $user->get_error_code() ) {
					$message = __( 'Password reset link has expired.', 'wp-graphql' );
				} else {
					$message = __( 'Password reset link is invalid.', 'wp-graphql' );
				}

				/**
				 * Throw an error with the message
				 */
				throw new UserError( esc_html( $message ) );
			}

			/**
			 * Reset the password
			 */
			reset_password( $user, $input['password'] );

			// Log in the user, since they already authenticated with the reset key.
			wp_set_current_user( $user->ID );

			/**
			 * Return the user ID
			 */
			return [
				'id'   => $user->ID,
				'user' => $context->get_loader( 'user' )->load_deferred( $user->ID ),
			];
		};
	}
}


// File: wp-graphql\src\Mutation\SendPasswordResetEmail.php
<?php

namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use WPGraphQL\AppContext;

class SendPasswordResetEmail {

	/**
	 * Registers the sendPasswordResetEmail Mutation
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_mutation() {
		register_graphql_mutation(
			'sendPasswordResetEmail',
			[
				'description'         => __( 'Send password reset email to user', 'wp-graphql' ),
				'inputFields'         => self::get_input_fields(),
				'outputFields'        => self::get_output_fields(),
				'mutateAndGetPayload' => self::mutate_and_get_payload(),
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields(): array {
		return [
			'username' => [
				'type'        => [
					'non_null' => 'String',
				],
				'description' => __( 'A string that contains the user\'s username or email address.', 'wp-graphql' ),
			],
		];
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields(): array {
		return [
			'user'    => [
				'type'              => 'User',
				'description'       => __( 'The user that the password reset email was sent to', 'wp-graphql' ),
				'deprecationReason' => __( 'This field will be removed in a future version of WPGraphQL', 'wp-graphql' ),
				'resolve'           => static function ( $payload, $args, AppContext $context ) {
					return ! empty( $payload['id'] ) ? $context->get_loader( 'user' )->load_deferred( $payload['id'] ) : null;
				},
			],
			'success' => [
				'type'        => 'Boolean',
				'description' => __( 'Whether the mutation completed successfully. This does NOT necessarily mean that an email was sent.', 'wp-graphql' ),
			],
		];
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @return callable(array<string,mixed>$input,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):array<string,mixed>
	 */
	public static function mutate_and_get_payload(): callable {
		return static function ( $input ) {
			if ( ! self::was_username_provided( $input ) ) {
				throw new UserError( esc_html__( 'Enter a username or email address.', 'wp-graphql' ) );
			}

			// We obsfucate the actual success of this mutation to prevent user enumeration.
			$payload = [
				'success' => true,
				'id'      => null,
			];

			$user_data = self::get_user_data( $input['username'] );

			if ( ! $user_data ) {
				graphql_debug( self::get_user_not_found_error_message( $input['username'] ) );

				return $payload;
			}

			// Get the password reset key.
			$key = get_password_reset_key( $user_data );
			if ( is_wp_error( $key ) ) {
				graphql_debug( __( 'Unable to generate a password reset key.', 'wp-graphql' ) );

				return $payload;
			}

			// Mail the reset key.
			$subject = self::get_email_subject( $user_data );
			$message = self::get_email_message( $user_data, $key );

			$email_sent = wp_mail( // phpcs:ignore WordPressVIPMinimum.Functions.RestrictedFunctions.wp_mail_wp_mail
				$user_data->user_email,
				wp_specialchars_decode( $subject ),
				$message
			);

			// wp_mail can return a wp_error, but the docblock for it in WP Core is incorrect.
			// phpstan should ignore this check.
			// @phpstan-ignore-next-line
			if ( is_wp_error( $email_sent ) ) {
				graphql_debug( __( 'The email could not be sent.', 'wp-graphql' ) . "<br />\n" . __( 'Possible reason: your host may have disabled the mail() function.', 'wp-graphql' ) );

				return $payload;
			}

			/**
			 * Return the ID of the user
			 */
			return [
				'id'      => $user_data->ID,
				'success' => true,
			];
		};
	}

	/**
	 * Was a username or email address provided?
	 *
	 * @param array<string,mixed> $input The input args.
	 *
	 * @return bool
	 */
	private static function was_username_provided( $input ) {
		return ! empty( $input['username'] ) && is_string( $input['username'] );
	}

	/**
	 * Get WP_User object representing this user
	 *
	 * @param string $username The user's username or email address.
	 *
	 * @return \WP_User|false WP_User object on success, false on failure.
	 */
	private static function get_user_data( $username ) {
		if ( self::is_email_address( $username ) ) {
			$username = wp_unslash( $username );

			if ( ! is_string( $username ) ) {
				return false;
			}

			return get_user_by( 'email', trim( $username ) );
		}

		return get_user_by( 'login', trim( $username ) );
	}

	/**
	 * Get the error message indicating why the user wasn't found
	 *
	 * @param string $username The user's username or email address.
	 *
	 * @return string
	 */
	private static function get_user_not_found_error_message( string $username ) {
		if ( self::is_email_address( $username ) ) {
			return __( 'There is no user registered with that email address.', 'wp-graphql' );
		}

		return __( 'Invalid username.', 'wp-graphql' );
	}

	/**
	 * Is the provided username arg an email address?
	 *
	 * @param string $username The user's username or email address.
	 *
	 * @return bool
	 */
	private static function is_email_address( string $username ) {
		return (bool) strpos( $username, '@' );
	}

	/**
	 * Get the subject of the password reset email
	 *
	 * @param \WP_User $user_data User data
	 *
	 * @return string
	 */
	private static function get_email_subject( $user_data ) {
		/* translators: Password reset email subject. %s: Site name */
		$title = sprintf( __( '[%s] Password Reset', 'wp-graphql' ), self::get_site_name() );

		/**
		 * Filters the subject of the password reset email.
		 *
		 * @param string   $title      Default email title.
		 * @param string   $user_login The username for the user.
		 * @param \WP_User $user_data WP_User object.
		 */
		return apply_filters( 'retrieve_password_title', $title, $user_data->user_login, $user_data );
	}

	/**
	 * Get the site name.
	 *
	 * @return string
	 */
	private static function get_site_name() {
		if ( is_multisite() ) {
			$network = get_network();
			if ( isset( $network->site_name ) ) {
				return $network->site_name;
			}
		}

		/*
		* The blogname option is escaped with esc_html on the way into the database
		* in sanitize_option we want to reverse this for the plain text arena of emails.
		*/

		return wp_specialchars_decode( get_option( 'blogname' ), ENT_QUOTES );
	}

	/**
	 * Get the message body of the password reset email
	 *
	 * @param \WP_User $user_data User data
	 * @param string   $key       Password reset key
	 *
	 * @return string
	 */
	private static function get_email_message( $user_data, $key ) {
		$message = __( 'Someone has requested a password reset for the following account:', 'wp-graphql' ) . "\r\n\r\n";
		/* translators: %s: site name */
		$message .= sprintf( __( 'Site Name: %s', 'wp-graphql' ), self::get_site_name() ) . "\r\n\r\n";
		/* translators: %s: user login */
		$message .= sprintf( __( 'Username: %s', 'wp-graphql' ), $user_data->user_login ) . "\r\n\r\n";
		$message .= __( 'If this was a mistake, just ignore this email and nothing will happen.', 'wp-graphql' ) . "\r\n\r\n";
		$message .= __( 'To reset your password, visit the following address:', 'wp-graphql' ) . "\r\n\r\n";
		$message .= '<' . network_site_url( "wp-login.php?action=rp&key={$key}&login=" . rawurlencode( $user_data->user_login ), 'login' ) . ">\r\n";

		/**
		 * Filters the message body of the password reset mail.
		 *
		 * If the filtered message is empty, the password reset email will not be sent.
		 *
		 * @param string   $message    Default mail message.
		 * @param string   $key        The activation key.
		 * @param string   $user_login The username for the user.
		 * @param \WP_User $user_data WP_User object.
		 */
		return apply_filters( 'retrieve_password_message', $message, $key, $user_data->user_login, $user_data );
	}
}


// File: wp-graphql\src\Mutation\TermObjectCreate.php
<?php

namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Data\TermObjectMutation;
use WP_Taxonomy;

class TermObjectCreate {
	/**
	 * Registers the TermObjectCreate mutation.
	 *
	 * @param \WP_Taxonomy $taxonomy The taxonomy type of the mutation.
	 *
	 * @return void
	 */
	public static function register_mutation( WP_Taxonomy $taxonomy ) {
		$mutation_name = 'create' . ucwords( $taxonomy->graphql_single_name );

		register_graphql_mutation(
			$mutation_name,
			[
				'inputFields'         => array_merge(
					self::get_input_fields( $taxonomy ),
					[
						'name' => [
							'type'        => [
								'non_null' => 'String',
							],
							// translators: The placeholder is the name of the taxonomy for the object being mutated
							'description' => sprintf( __( 'The name of the %1$s object to mutate', 'wp-graphql' ), $taxonomy->name ),
						],
					]
				),
				'outputFields'        => self::get_output_fields( $taxonomy ),
				'mutateAndGetPayload' => self::mutate_and_get_payload( $taxonomy, $mutation_name ),
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @param \WP_Taxonomy $taxonomy The taxonomy type of the mutation.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields( WP_Taxonomy $taxonomy ) {
		$fields = [
			'aliasOf'     => [
				'type'        => 'String',
				// translators: The placeholder is the name of the taxonomy for the object being mutated
				'description' => sprintf( __( 'The slug that the %1$s will be an alias of', 'wp-graphql' ), $taxonomy->name ),
			],
			'description' => [
				'type'        => 'String',
				// translators: The placeholder is the name of the taxonomy for the object being mutated
				'description' => sprintf( __( 'The description of the %1$s object', 'wp-graphql' ), $taxonomy->name ),
			],
			'slug'        => [
				'type'        => 'String',
				'description' => __( 'If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name.', 'wp-graphql' ),
			],
		];

		/**
		 * Add a parentId field to hierarchical taxonomies to allow parents to be set
		 */
		if ( true === $taxonomy->hierarchical ) {
			$fields['parentId'] = [
				'type'        => 'ID',
				// translators: The placeholder is the name of the taxonomy for the object being mutated
				'description' => sprintf( __( 'The ID of the %1$s that should be set as the parent', 'wp-graphql' ), $taxonomy->name ),
			];
		}

		return $fields;
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @param \WP_Taxonomy $taxonomy The taxonomy type of the mutation.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields( WP_Taxonomy $taxonomy ) {
		return [
			$taxonomy->graphql_single_name => [
				'type'        => $taxonomy->graphql_single_name,
				// translators: Placeholder is the name of the taxonomy
				'description' => sprintf( __( 'The created %s', 'wp-graphql' ), $taxonomy->name ),
				'resolve'     => static function ( $payload, $_args, AppContext $context ) {
					$id = isset( $payload['termId'] ) ? absint( $payload['termId'] ) : null;

					return $context->get_loader( 'term' )->load_deferred( $id );
				},
			],
		];
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @param \WP_Taxonomy $taxonomy The taxonomy type of the mutation.
	 * @param string       $mutation_name The name of the mutation.
	 *
	 * @return callable(array<string,mixed>$input,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):array<string,mixed>
	 */
	public static function mutate_and_get_payload( WP_Taxonomy $taxonomy, string $mutation_name ) {
		return static function ( $input, AppContext $context, ResolveInfo $info ) use ( $taxonomy, $mutation_name ) {

			/**
			 * Ensure the user can edit_terms
			 */
			if ( ! isset( $taxonomy->cap->edit_terms ) || ! current_user_can( $taxonomy->cap->edit_terms ) ) {
				// translators: the $taxonomy->graphql_plural_name placeholder is the name of the object being mutated
				throw new UserError( esc_html( sprintf( __( 'Sorry, you are not allowed to create %1$s', 'wp-graphql' ), $taxonomy->graphql_plural_name ) ) );
			}

			/**
			 * Prepare the object for insertion
			 */
			$args = TermObjectMutation::prepare_object( $input, $taxonomy, $mutation_name );

			/**
			 * Ensure a name was provided
			 */
			if ( empty( $args['name'] ) ) {
				// translators: The placeholder is the name of the taxonomy of the term being mutated
				throw new UserError( esc_html( sprintf( __( 'A name is required to create a %1$s', 'wp-graphql' ), $taxonomy->name ) ) );
			}

			$term_name = wp_slash( $args['name'] );

			if ( ! is_string( $term_name ) ) {
				// translators: The placeholder is the name of the taxonomy of the term being mutated
				throw new UserError( esc_html( sprintf( __( 'A valid name is required to create a %1$s', 'wp-graphql' ), $taxonomy->name ) ) );
			}

			/**
			 * Insert the term
			 */
			$term = wp_insert_term( $term_name, $taxonomy->name, wp_slash( (array) $args ) );

			/**
			 * If it was an error, return the message as an exception
			 */
			if ( is_wp_error( $term ) ) {
				$error_message = $term->get_error_message();
				if ( ! empty( $error_message ) ) {
					throw new UserError( esc_html( $error_message ) );
				} else {
					throw new UserError( esc_html__( 'The object failed to update but no error was provided', 'wp-graphql' ) );
				}
			}

			/**
			 * If the response to creating the term didn't respond with a term_id, throw an exception
			 */
			if ( empty( $term['term_id'] ) ) {
				throw new UserError( esc_html__( 'The object failed to create', 'wp-graphql' ) );
			}

			/**
			 * Fires after a single term is created or updated via a GraphQL mutation
			 *
			 * @param int                                  $term_id       Inserted term object
			 * @param \WP_Taxonomy                         $taxonomy      The taxonomy of the term being updated
			 * @param array<string,mixed>                  $args          The args used to insert the term
			 * @param string                               $mutation_name The name of the mutation being performed
			 * @param \WPGraphQL\AppContext                $context       The AppContext passed down the resolve tree
			 * @param \GraphQL\Type\Definition\ResolveInfo $info          The ResolveInfo passed down the resolve tree
			 */
			do_action( 'graphql_insert_term', $term['term_id'], $taxonomy, $args, $mutation_name, $context, $info );

			/**
			 * Fires after a single term is created or updated via a GraphQL mutation
			 *
			 * The dynamic portion of the hook name, `$taxonomy->name` refers to the taxonomy of the term being mutated
			 *
			 * @param int                                  $term_id       Inserted term object
			 * @param array<string,mixed>                  $args          The args used to insert the term
			 * @param string                               $mutation_name The name of the mutation being performed
			 * @param \WPGraphQL\AppContext                $context       The AppContext passed down the resolve tree
			 * @param \GraphQL\Type\Definition\ResolveInfo $info          The ResolveInfo passed down the resolve tree
			 */
			do_action( "graphql_insert_{$taxonomy->name}", $term['term_id'], $args, $mutation_name, $context, $info );

			return [
				'termId' => $term['term_id'],
			];
		};
	}
}


// File: wp-graphql\src\Mutation\TermObjectDelete.php
<?php

namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use GraphQLRelay\Relay;
use WPGraphQL\Model\Term;
use WPGraphQL\Utils\Utils;
use WP_Taxonomy;

/**
 * Class TermObjectDelete
 *
 * @package WPGraphQL\Mutation
 */
class TermObjectDelete {
	/**
	 * Registers the TermObjectDelete mutation.
	 *
	 * @param \WP_Taxonomy $taxonomy The taxonomy type of the mutation.
	 *
	 * @return void
	 */
	public static function register_mutation( WP_Taxonomy $taxonomy ) {
		$mutation_name = 'delete' . ucfirst( $taxonomy->graphql_single_name );

		register_graphql_mutation(
			$mutation_name,
			[
				'inputFields'         => self::get_input_fields( $taxonomy ),
				'outputFields'        => self::get_output_fields( $taxonomy ),
				'mutateAndGetPayload' => self::mutate_and_get_payload( $taxonomy, $mutation_name ),
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @param \WP_Taxonomy $taxonomy The taxonomy type of the mutation.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields( WP_Taxonomy $taxonomy ) {
		return [
			'id' => [
				'type'        => [
					'non_null' => 'ID',
				],
				// translators: The placeholder is the name of the taxonomy for the term being deleted
				'description' => sprintf( __( 'The ID of the %1$s to delete', 'wp-graphql' ), $taxonomy->graphql_single_name ),
			],
		];
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @param \WP_Taxonomy $taxonomy The taxonomy type of the mutation.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields( WP_Taxonomy $taxonomy ) {
		return [
			'deletedId'                    => [
				'type'        => 'ID',
				'description' => __( 'The ID of the deleted object', 'wp-graphql' ),
				'resolve'     => static function ( $payload ) {
					$deleted = (object) $payload['termObject'];

					return ! empty( $deleted->term_id ) ? Relay::toGlobalId( 'term', $deleted->term_id ) : null;
				},
			],
			$taxonomy->graphql_single_name => [
				'type'        => $taxonomy->graphql_single_name,
				'description' => __( 'The deleted term object', 'wp-graphql' ),
				'resolve'     => static function ( $payload ) {
					return new Term( $payload['termObject'] );
				},
			],
		];
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @param \WP_Taxonomy $taxonomy The taxonomy type of the mutation.
	 * @param string       $mutation_name The name of the mutation.
	 *
	 * @return callable(array<string,mixed>$input,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):array<string,mixed>
	 */
	public static function mutate_and_get_payload( WP_Taxonomy $taxonomy, string $mutation_name ) {
		return static function ( $input ) use ( $taxonomy ) {
			// Get the database ID for the comment.
			$term_id = Utils::get_database_id_from_id( $input['id'] );

			if ( empty( $term_id ) ) {
				// Translators: The placeholder is the name of the taxonomy for the term being deleted
				throw new UserError( esc_html( sprintf( __( 'The ID for the %1$s was not valid', 'wp-graphql' ), $taxonomy->graphql_single_name ) ) );
			}

			/**
			 * Get the term before deleting it
			 */
			$term_object = get_term( $term_id, $taxonomy->name );

			if ( ! $term_object instanceof \WP_Term ) {
				throw new UserError( esc_html__( 'The ID passed is invalid', 'wp-graphql' ) );
			}

			/**
			 * Ensure the type for the Global ID matches the type being mutated
			 */
			if ( $taxonomy->name !== $term_object->taxonomy ) {
				// Translators: The placeholder is the name of the taxonomy for the term being edited
				throw new UserError( esc_html( sprintf( __( 'The ID passed is not for a %1$s object', 'wp-graphql' ), $taxonomy->graphql_single_name ) ) );
			}

			/**
			 * Ensure the user can delete terms of this taxonomy
			 */
			if ( ! current_user_can( 'delete_term', $term_object->term_id ) ) {
				// Translators: The placeholder is the name of the taxonomy for the term being deleted
				throw new UserError( esc_html( sprintf( __( 'You do not have permission to delete %1$s', 'wp-graphql' ), $taxonomy->graphql_plural_name ) ) );
			}

			/**
			 * Delete the term and get the response
			 */
			$deleted = wp_delete_term( $term_id, $taxonomy->name );

			/**
			 * If there was an error deleting the term, get the error message and return it
			 */
			if ( is_wp_error( $deleted ) ) {
				$error_message = $deleted->get_error_message();
				if ( ! empty( $error_message ) ) {
					throw new UserError( esc_html( $error_message ) );
				} else {
					// Translators: The placeholder is the name of the taxonomy for the term being deleted
					throw new UserError( esc_html( sprintf( __( 'The %1$s failed to delete but no error was provided', 'wp-graphql' ), $taxonomy->name ) ) );
				}
			}

			/**
			 * Return the term object that was retrieved prior to deletion
			 */
			return [
				'termObject' => $term_object,
			];
		};
	}
}


// File: wp-graphql\src\Mutation\TermObjectUpdate.php
<?php
namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Data\TermObjectMutation;
use WPGraphQL\Utils\Utils;
use WP_Taxonomy;

/**
 * Class TermObjectUpdate
 *
 * @package WPGraphQL\Mutation
 */
class TermObjectUpdate {
	/**
	 * Registers the TermObjectUpdate mutation.
	 *
	 * @param \WP_Taxonomy $taxonomy The Taxonomy the mutation is registered for.
	 *
	 * @return void
	 */
	public static function register_mutation( WP_Taxonomy $taxonomy ) {
		$mutation_name = 'update' . ucwords( $taxonomy->graphql_single_name );
		register_graphql_mutation(
			$mutation_name,
			[
				'inputFields'         => self::get_input_fields( $taxonomy ),
				'outputFields'        => self::get_output_fields( $taxonomy ),
				'mutateAndGetPayload' => self::mutate_and_get_payload( $taxonomy, $mutation_name ),
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @param \WP_Taxonomy $taxonomy The taxonomy type of the mutation.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields( WP_Taxonomy $taxonomy ) {
		return array_merge(
			TermObjectCreate::get_input_fields( $taxonomy ),
			[
				'name' => [
					'type'        => 'String',
					// Translators: The placeholder is the name of the taxonomy for the object being mutated
					'description' => sprintf( __( 'The name of the %1$s object to mutate', 'wp-graphql' ), $taxonomy->name ),
				],
				'id'   => [
					'type'        => [
						'non_null' => 'ID',
					],
					// Translators: The placeholder is the taxonomy of the term being updated
					'description' => sprintf( __( 'The ID of the %1$s object to update', 'wp-graphql' ), $taxonomy->graphql_single_name ),
				],
			]
		);
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @param \WP_Taxonomy $taxonomy The taxonomy type of the mutation.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields( WP_Taxonomy $taxonomy ) {
		return TermObjectCreate::get_output_fields( $taxonomy );
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @param \WP_Taxonomy $taxonomy The taxonomy type of the mutation.
	 * @param string       $mutation_name  The name of the mutation.
	 *
	 * @return callable(array<string,mixed>$input,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):array<string,mixed>
	 */
	public static function mutate_and_get_payload( WP_Taxonomy $taxonomy, $mutation_name ) {
		return static function ( $input, AppContext $context, ResolveInfo $info ) use ( $taxonomy, $mutation_name ) {
			$term_id = Utils::get_database_id_from_id( $input['id'] );

			/**
			 * Ensure the type for the Global ID matches the type being mutated
			 */
			if ( empty( $term_id ) ) {
				// Translators: The placeholder is the name of the taxonomy for the term being edited
				throw new UserError( esc_html( sprintf( __( 'The ID passed is not for a %1$s object', 'wp-graphql' ), $taxonomy->graphql_single_name ) ) );
			}

			/**
			 * Get the existing term
			 */
			$existing_term = get_term( $term_id, $taxonomy->name );

			/**
			 * If there was an error getting the existing term, return the error message
			 */
			if ( ! $existing_term instanceof \WP_Term ) {
				if ( is_wp_error( $existing_term ) ) {
					$error_message = $existing_term->get_error_message();
					if ( ! empty( $error_message ) ) {
						throw new UserError( esc_html( $error_message ) );
					} else {
						// Translators: The placeholder is the name of the taxonomy for the term being deleted
						throw new UserError( esc_html( sprintf( __( 'The %1$s node failed to update', 'wp-graphql' ), $taxonomy->name ) ) );
					}
				}

				// Translators: The placeholder is the name of the taxonomy for the term being deleted
				throw new UserError( esc_html( sprintf( __( 'The %1$s node failed to update', 'wp-graphql' ), $taxonomy->name ) ) );
			}

			if ( $taxonomy->name !== $existing_term->taxonomy ) {
				// translators: The first placeholder is an ID and the second placeholder is the name of the post type being edited
				throw new UserError( esc_html( sprintf( __( 'The id %1$d is not of the type "%2$s"', 'wp-graphql' ), $term_id, $taxonomy->name ) ) );
			}

			/**
			 * Ensure the user has permission to edit terms
			 */
			if ( ! current_user_can( 'edit_term', $existing_term->term_id ) ) {
				// Translators: The placeholder is the name of the taxonomy for the term being deleted
				throw new UserError( esc_html( sprintf( __( 'You do not have permission to update %1$s', 'wp-graphql' ), $taxonomy->graphql_plural_name ) ) );
			}

			/**
			 * Prepare the $args for mutation
			 */
			$args = TermObjectMutation::prepare_object( $input, $taxonomy, $mutation_name );

			if ( ! empty( $args ) ) {

				/**
				 * Update the term
				 */
				$update = wp_update_term( $existing_term->term_id, $taxonomy->name, wp_slash( (array) $args ) );

				/**
				 * Respond with any errors
				 */
				if ( is_wp_error( $update ) ) {
					// Translators: the placeholder is the name of the taxonomy
					throw new UserError( esc_html( sprintf( __( 'The %1$s failed to update', 'wp-graphql' ), $taxonomy->name ) ) );
				}
			}

			/**
			 * Fires an action when a term is updated via a GraphQL Mutation
			 *
			 * @param int                                  $term_id       The ID of the term object that was mutated
			 * @param \WP_Taxonomy                         $taxonomy      The taxonomy of the term being updated
			 * @param array<string,mixed>                  $args          The args used to update the term
			 * @param string                               $mutation_name The name of the mutation being performed (create, update, delete, etc)
			 * @param \WPGraphQL\AppContext                $context       The AppContext passed down the resolve tree
			 * @param \GraphQL\Type\Definition\ResolveInfo $info          The ResolveInfo passed down the resolve tree
			 */
			do_action( 'graphql_update_term', $existing_term->term_id, $taxonomy, $args, $mutation_name, $context, $info );

			/**
			 * Fires an action when a term is updated via a GraphQL Mutation
			 *
			 * @param int                                  $term_id       The ID of the term object that was mutated
			 * @param array<string,mixed>                  $args          The args used to update the term
			 * @param string                               $mutation_name The name of the mutation being performed (create, update, delete, etc)
			 * @param \WPGraphQL\AppContext                $context       The AppContext passed down the resolve tree
			 * @param \GraphQL\Type\Definition\ResolveInfo $info          The ResolveInfo passed down the resolve tree
			 */
			do_action( "graphql_update_{$taxonomy->name}", $existing_term->term_id, $args, $mutation_name, $context, $info );

			/**
			 * Return the payload
			 */
			return [
				'termId' => $existing_term->term_id,
			];
		};
	}
}


// File: wp-graphql\src\Mutation\UpdateSettings.php
<?php

namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use WPGraphQL\Data\DataSource;
use WPGraphQL\Registry\TypeRegistry;
use WPGraphQL\Utils\Utils;

/**
 * Class UpdateSettings
 *
 * @package WPGraphQL\Mutation
 */
class UpdateSettings {

	/**
	 * Registers the CommentCreate mutation.
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry The WPGraphQL TypeRegistry
	 *
	 * @return void
	 */
	public static function register_mutation( TypeRegistry $type_registry ) {
		$output_fields = self::get_output_fields( $type_registry );
		$input_fields  = self::get_input_fields( $type_registry );

		if ( empty( $output_fields ) || empty( $input_fields ) ) {
			return;
		}

		register_graphql_mutation(
			'updateSettings',
			[
				'inputFields'         => $input_fields,
				'outputFields'        => $output_fields,
				'mutateAndGetPayload' => static function ( $input ) use ( $type_registry ) {
					return self::mutate_and_get_payload( $input, $type_registry );
				},
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry The WPGraphQL TypeRegistry
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields( TypeRegistry $type_registry ) {
		$allowed_settings = DataSource::get_allowed_settings( $type_registry );

		$input_fields = [];

		if ( ! empty( $allowed_settings ) ) {

			/**
			 * Loop through the $allowed_settings and build fields
			 * for the individual settings
			 */
			foreach ( $allowed_settings as $key => $setting ) {
				if ( ! isset( $setting['type'] ) || ! $type_registry->get_type( $setting['type'] ) ) {
					continue;
				}

				/**
				 * Determine if the individual setting already has a
				 * REST API name, if not use the option name.
				 * Sanitize the field name to be camelcase
				 */
				if ( ! empty( $setting['show_in_rest']['name'] ) ) {
					$individual_setting_key = lcfirst( $setting['group'] . 'Settings' . str_replace( '_', '', ucwords( $setting['show_in_rest']['name'], '_' ) ) );
				} else {
					$individual_setting_key = lcfirst( $setting['group'] . 'Settings' . str_replace( '_', '', ucwords( $key, '_' ) ) );
				}

				$replaced_setting_key = graphql_format_name( $individual_setting_key, ' ', '/[^a-zA-Z0-9 -]/' );

				if ( ! empty( $replaced_setting_key ) ) {
					$individual_setting_key = $replaced_setting_key;
				}

				$individual_setting_key = lcfirst( $individual_setting_key );
				$individual_setting_key = lcfirst( str_replace( '_', ' ', ucwords( $individual_setting_key, '_' ) ) );
				$individual_setting_key = lcfirst( str_replace( '-', ' ', ucwords( $individual_setting_key, '_' ) ) );
				$individual_setting_key = lcfirst( str_replace( ' ', '', ucwords( $individual_setting_key, ' ' ) ) );

				/**
				 * Dynamically build the individual setting,
				 * then add it to the $input_fields
				 */
				$input_fields[ $individual_setting_key ] = [
					'type'        => $setting['type'],
					'description' => $setting['description'],
				];
			}
		}

		return $input_fields;
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry The WPGraphQL TypeRegistry
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields( TypeRegistry $type_registry ) {

		/**
		 * Get the allowed setting groups and their fields
		 */
		$allowed_setting_groups = DataSource::get_allowed_settings_by_group( $type_registry );

		$output_fields = [];

		/**
		 * Get all of the settings, regardless of group
		 */
		$output_fields['allSettings'] = [
			'type'        => 'Settings',
			'description' => __( 'Update all settings.', 'wp-graphql' ),
			'resolve'     => static function () {
				return true;
			},
		];

		if ( ! empty( $allowed_setting_groups ) && is_array( $allowed_setting_groups ) ) {
			foreach ( $allowed_setting_groups as $group => $setting_type ) {
				$setting_type      = DataSource::format_group_name( $group );
				$setting_type_name = Utils::format_type_name( $setting_type . 'Settings' );

				$output_fields[ Utils::format_field_name( $setting_type_name ) ] = [
					'type'        => $setting_type_name,
					// translators: %s is the setting type name
					'description' => sprintf( __( 'Update the %s setting.', 'wp-graphql' ), $setting_type_name ),
					'resolve'     => static function () use ( $setting_type_name ) {
						return $setting_type_name;
					},
				];
			}
		}
		return $output_fields;
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @param array<string,mixed>              $input The mutation input
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry The WPGraphQL TypeRegistry
	 *
	 * @return array<string,array<string,string>>
	 *
	 * @throws \GraphQL\Error\UserError
	 */
	public static function mutate_and_get_payload( array $input, TypeRegistry $type_registry ): array {
		/**
		 * Check that the user can manage setting options
		 */
		if ( ! current_user_can( 'manage_options' ) ) {
			throw new UserError( esc_html__( 'Sorry, you are not allowed to edit settings as this user.', 'wp-graphql' ) );
		}

		/**
		 * The $updatable_settings_options will store all of the allowed
		 * settings in a WP ready format
		 */
		$updatable_settings_options = [];

		$allowed_settings = DataSource::get_allowed_settings( $type_registry );

		/**
		 * Loop through the $allowed_settings and build the insert options array
		 */
		foreach ( $allowed_settings as $key => $setting ) {

			/**
			 * Determine if the individual setting already has a
			 * REST API name, if not use the option name.
			 * Sanitize the field name to be camelcase
			 */
			if ( isset( $setting['show_in_rest']['name'] ) && ! empty( $setting['show_in_rest']['name'] ) ) {
				$individual_setting_key = lcfirst( $setting['group'] . 'Settings' . str_replace( '_', '', ucwords( $setting['show_in_rest']['name'], '_' ) ) );
			} else {
				$individual_setting_key = lcfirst( $setting['group'] . 'Settings' . str_replace( '_', '', ucwords( $key, '_' ) ) );
			}

			/**
			 * Dynamically build the individual setting,
			 * then add it to $updatable_settings_options
			 */
			$updatable_settings_options[ Utils::format_field_name( $individual_setting_key ) ] = [
				'option' => $key,
				'group'  => $setting['group'],
			];
		}

		foreach ( $input as $key => $value ) {
			/**
			 * Throw an error if the input field is the site url,
			 * as we do not want users changing it and breaking all
			 * the things
			 */
			if ( 'generalSettingsUrl' === $key ) {
				throw new UserError( esc_html__( 'Sorry, that is not allowed, speak with your site administrator to change the site URL.', 'wp-graphql' ) );
			}

			/**
			 * Check to see that the input field exists in settings, if so grab the option
			 * name and update the option
			 */
			if ( array_key_exists( $key, $updatable_settings_options ) ) {
				update_option( $updatable_settings_options[ $key ]['option'], $value );
			}
		}

		return $updatable_settings_options;
	}
}


// File: wp-graphql\src\Mutation\UserCreate.php
<?php

namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Data\UserMutation;

/**
 * Class UserCreate
 *
 * @package WPGraphQL\Mutation
 */
class UserCreate {
	/**
	 * Registers the CommentCreate mutation.
	 *
	 * @return void
	 */
	public static function register_mutation() {
		register_graphql_mutation(
			'createUser',
			[
				'inputFields'         => array_merge(
					[
						'username' => [
							'type'        => [
								'non_null' => 'String',
							],
							// translators: the placeholder is the name of the type of post object being updated
							'description' => __( 'A string that contains the user\'s username for logging in.', 'wp-graphql' ),
						],
					],
					self::get_input_fields()
				),
				'outputFields'        => self::get_output_fields(),
				'mutateAndGetPayload' => self::mutate_and_get_payload(),
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields() {
		return [
			'password'    => [
				'type'        => 'String',
				'description' => __( 'A string that contains the plain text password for the user.', 'wp-graphql' ),
			],
			'nicename'    => [
				'type'        => 'String',
				'description' => __( 'A string that contains a URL-friendly name for the user. The default is the user\'s username.', 'wp-graphql' ),
			],
			'websiteUrl'  => [
				'type'        => 'String',
				'description' => __( 'A string containing the user\'s URL for the user\'s web site.', 'wp-graphql' ),
			],
			'email'       => [
				'type'        => 'String',
				'description' => __( 'A string containing the user\'s email address.', 'wp-graphql' ),
			],
			'displayName' => [
				'type'        => 'String',
				'description' => __( 'A string that will be shown on the site. Defaults to user\'s username. It is likely that you will want to change this, for both appearance and security through obscurity (that is if you dont use and delete the default admin user).', 'wp-graphql' ),
			],
			'nickname'    => [
				'type'        => 'String',
				'description' => __( 'The user\'s nickname, defaults to the user\'s username.', 'wp-graphql' ),
			],
			'firstName'   => [
				'type'        => 'String',
				'description' => __( '	The user\'s first name.', 'wp-graphql' ),
			],
			'lastName'    => [
				'type'        => 'String',
				'description' => __( 'The user\'s last name.', 'wp-graphql' ),
			],
			'description' => [
				'type'        => 'String',
				'description' => __( 'A string containing content about the user.', 'wp-graphql' ),
			],
			'richEditing' => [
				'type'        => 'String',
				'description' => __( 'A string for whether to enable the rich editor or not. False if not empty.', 'wp-graphql' ),
			],
			'registered'  => [
				'type'        => 'String',
				'description' => __( 'The date the user registered. Format is Y-m-d H:i:s.', 'wp-graphql' ),
			],
			'roles'       => [
				'type'        => [
					'list_of' => 'String',
				],
				'description' => __( 'An array of roles to be assigned to the user.', 'wp-graphql' ),
			],
			'jabber'      => [
				'type'        => 'String',
				'description' => __( 'User\'s Jabber account.', 'wp-graphql' ),
			],
			'aim'         => [
				'type'        => 'String',
				'description' => __( 'User\'s AOL IM account.', 'wp-graphql' ),
			],
			'yim'         => [
				'type'        => 'String',
				'description' => __( 'User\'s Yahoo IM account.', 'wp-graphql' ),
			],
			'locale'      => [
				'type'        => 'String',
				'description' => __( 'User\'s locale.', 'wp-graphql' ),
			],
		];
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields() {
		return [
			'user' => [
				'type'        => 'User',
				'description' => __( 'The User object mutation type.', 'wp-graphql' ),
			],
		];
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @return callable(array<string,mixed>$input,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):array<string,mixed>
	 */
	public static function mutate_and_get_payload() {
		return static function ( $input, AppContext $context, ResolveInfo $info ) {
			if ( ! current_user_can( 'create_users' ) ) {
				throw new UserError( esc_html__( 'Sorry, you are not allowed to create a new user.', 'wp-graphql' ) );
			}

			/**
			 * Map all of the args from GQL to WP friendly
			 */
			$user_args = UserMutation::prepare_user_object( $input, 'createUser' );

			/**
			 * Create the new user
			 */
			$user_id = wp_insert_user( $user_args );

			/**
			 * Throw an exception if the post failed to create
			 */
			if ( is_wp_error( $user_id ) ) {
				$error_message = $user_id->get_error_message();
				if ( ! empty( $error_message ) ) {
					throw new UserError( esc_html( $error_message ) );
				} else {
					throw new UserError( esc_html__( 'The object failed to create but no error was provided', 'wp-graphql' ) );
				}
			}

			/**
			 * If the $post_id is empty, we should throw an exception
			 */
			if ( empty( $user_id ) ) {
				throw new UserError( esc_html__( 'The object failed to create', 'wp-graphql' ) );
			}

			/**
			 * Update additional user data
			 */
			UserMutation::update_additional_user_object_data( $user_id, $input, 'createUser', $context, $info );

			/**
			 * Return the new user ID
			 */
			return [
				'id'   => $user_id,
				'user' => $context->get_loader( 'user' )->load_deferred( $user_id ),
			];
		};
	}
}


// File: wp-graphql\src\Mutation\UserDelete.php
<?php

namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use GraphQLRelay\Relay;
use WPGraphQL\Model\User;
use WPGraphQL\Utils\Utils;

/**
 * Class UserDelete
 *
 * @package WPGraphQL\Mutation
 */
class UserDelete {
	/**
	 * Registers the CommentCreate mutation.
	 *
	 * @return void
	 */
	public static function register_mutation() {
		register_graphql_mutation(
			'deleteUser',
			[
				'inputFields'         => self::get_input_fields(),
				'outputFields'        => self::get_output_fields(),
				'mutateAndGetPayload' => self::mutate_and_get_payload(),
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields() {
		return [
			'id'         => [
				'type'        => [
					'non_null' => 'ID',
				],
				'description' => __( 'The ID of the user you want to delete', 'wp-graphql' ),
			],
			'reassignId' => [
				'type'        => 'ID',
				'description' => __( 'Reassign posts and links to new User ID.', 'wp-graphql' ),
			],
		];
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields() {
		return [
			'deletedId' => [
				'type'        => 'ID',
				'description' => __( 'The ID of the user that you just deleted', 'wp-graphql' ),
				'resolve'     => static function ( $payload ) {
					$deleted = (object) $payload['user'];
					return ( ! empty( $deleted->ID ) ) ? Relay::toGlobalId( 'user', $deleted->ID ) : null;
				},
			],
			'user'      => [
				'type'        => 'User',
				'description' => __( 'The deleted user object', 'wp-graphql' ),
				'resolve'     => static function ( $payload ) {
					return new User( $payload['user'] );
				},
			],
		];
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @return callable(array<string,mixed>$input,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):array<string,mixed>
	 */
	public static function mutate_and_get_payload() {
		return static function ( $input ) {
			// Get the user ID.
			$user_id = Utils::get_database_id_from_id( $input['id'] );

			if ( empty( $user_id ) ) {
				throw new UserError( esc_html__( 'The user ID passed is invalid', 'wp-graphql' ) );
			}

			if ( ! current_user_can( 'delete_users', $user_id ) ) {
				throw new UserError( esc_html__( 'Sorry, you are not allowed to delete users.', 'wp-graphql' ) );
			}

			/**
			 * Retrieve the user object before it's deleted
			 */
			$user_before_delete = get_user_by( 'id', $user_id );

			/**
			 * Throw an error if the user we are trying to delete doesn't exist
			 */
			if ( false === $user_before_delete ) {
				throw new UserError( esc_html__( 'Could not find an existing user to delete', 'wp-graphql' ) );
			}

			/**
			 * Get the user to reassign posts to.
			 */
			$reassign_id = 0;
			if ( ! empty( $input['reassignId'] ) ) {
				$reassign_id = Utils::get_database_id_from_id( $input['reassignId'] );

				if ( empty( $reassign_id ) ) {
					throw new UserError( esc_html__( 'The user ID passed to `reassignId` is invalid', 'wp-graphql' ) );
				}
				/**
			 * Retrieve the user object before it's deleted
			 */
				$reassign_user = get_user_by( 'id', $reassign_id );

				if ( false === $reassign_user ) {
					throw new UserError( esc_html__( 'Could not find the existing user to reassign.', 'wp-graphql' ) );
				}
			}

			if ( ! function_exists( 'wp_delete_user' ) ) {
				require_once ABSPATH . 'wp-admin/includes/user.php';
			}

			if ( is_multisite() ) {

				/**
				 * If wpmu_delete_user() or remove_user_from_blog() doesn't exist yet,
				 * load the files in which each is defined. I think we need to
				 * load this manually here because WordPress only uses this
				 * function on the user edit screen normally.
				 */

				// only include these files for multisite requests
				if ( ! function_exists( 'wpmu_delete_user' ) ) {
					require_once ABSPATH . 'wp-admin/includes/ms.php';
				}
				if ( ! function_exists( 'remove_user_from_blog' ) ) {
					require_once ABSPATH . 'wp-admin/includes/ms-functions.php';
				}

				$blog_id = get_current_blog_id();

				// remove the user from the blog and reassign their posts
				remove_user_from_blog( $user_id, $blog_id, $reassign_id );

				// delete the user
				$deleted_user = wpmu_delete_user( $user_id );
			} else {
				$deleted_user = wp_delete_user( $user_id, $reassign_id );
			}

			if ( true !== $deleted_user ) {
				throw new UserError( esc_html__( 'Could not delete the user.', 'wp-graphql' ) );
			}

			return [
				'user' => $user_before_delete,
			];
		};
	}
}


// File: wp-graphql\src\Mutation\UserRegister.php
<?php

namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Data\UserMutation;

class UserRegister {
	/**
	 * Registers the CommentCreate mutation.
	 *
	 * @return void
	 */
	public static function register_mutation() {
		register_graphql_mutation(
			'registerUser',
			[
				'inputFields'         => self::get_input_fields(),
				'outputFields'        => self::get_output_fields(),
				'mutateAndGetPayload' => self::mutate_and_get_payload(),
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields() {
		$input_fields = array_merge(
			UserCreate::get_input_fields(),
			[
				'username' => [
					'type'        => [
						'non_null' => 'String',
					],
					// translators: the placeholder is the name of the type of object being updated
					'description' => __( 'A string that contains the user\'s username.', 'wp-graphql' ),
				],
				'email'    => [
					'type'        => 'String',
					'description' => __( 'A string containing the user\'s email address.', 'wp-graphql' ),
				],
			]
		);

		/**
		 * Make sure we don't allow input for role or roles
		 */
		unset( $input_fields['role'], $input_fields['roles'] );

		return $input_fields;
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields() {
		return UserCreate::get_output_fields();
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @return callable(array<string,mixed>$input,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):array<string,mixed>
	 */
	public static function mutate_and_get_payload() {
		return static function ( $input, AppContext $context, ResolveInfo $info ) {
			if ( ! get_option( 'users_can_register' ) ) {
				throw new UserError( esc_html__( 'User registration is currently not allowed.', 'wp-graphql' ) );
			}

			if ( empty( $input['username'] ) ) {
				throw new UserError( esc_html__( 'A username was not provided.', 'wp-graphql' ) );
			}

			if ( empty( $input['email'] ) ) {
				throw new UserError( esc_html__( 'An email address was not provided.', 'wp-graphql' ) );
			}

			/**
			 * Map all of the args from GQL to WP friendly
			 */
			$user_args = UserMutation::prepare_user_object( $input, 'registerUser' );

			/**
			 * Register the new user
			 */
			$user_id = register_new_user( $user_args['user_login'], $user_args['user_email'] );

			/**
			 * Throw an exception if the user failed to register
			 */
			if ( is_wp_error( $user_id ) ) {
				$error_message = $user_id->get_error_message();
				if ( ! empty( $error_message ) ) {
					throw new UserError( esc_html( $error_message ) );
				} else {
					throw new UserError( esc_html__( 'The user failed to register but no error was provided', 'wp-graphql' ) );
				}
			}

			/**
			 * If the $user_id is empty, we should throw an exception
			 */
			if ( empty( $user_id ) ) {
				throw new UserError( esc_html__( 'The user failed to create', 'wp-graphql' ) );
			}

			/**
			 * If the client isn't already authenticated, set the state in the current session to
			 * the user they just registered. This is mostly so that they can get a response from
			 * the mutation about the user they just registered after the user object passes
			 * through the user model.
			 */
			if ( ! is_user_logged_in() ) {
				wp_set_current_user( $user_id );
			}

			/**
			 * Set the ID of the user to be used in the update
			 */
			$user_args['ID'] = absint( $user_id );

			/**
			 * Make sure we don't accept any role input during registration
			 */
			unset( $user_args['role'] );

			/**
			 * Prevent "Password Changed" emails from being sent.
			 */
			add_filter( 'send_password_change_email', [ self::class, 'return_false' ] );

			/**
			 * Update the registered user with the additional input (firstName, lastName, etc) from the mutation
			 */
			wp_update_user( $user_args );

			/**
			 * Remove filter preventing "Password Changed" emails.
			 */
			remove_filter( 'send_password_change_email', [ self::class, 'return_false' ] );

			/**
			 * Update additional user data
			 */
			UserMutation::update_additional_user_object_data( $user_id, $input, 'registerUser', $context, $info );

			/**
			 * Return the new user ID
			 */
			return [
				'id'   => $user_id,
				'user' => $context->get_loader( 'user' )->load_deferred( $user_id ),
			];
		};
	}

	/**
	 * @return bool False.
	 */
	public static function return_false(): bool {
		return false;
	}
}


// File: wp-graphql\src\Mutation\UserUpdate.php
<?php
namespace WPGraphQL\Mutation;

use GraphQL\Error\UserError;
use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Data\UserMutation;
use WPGraphQL\Utils\Utils;

class UserUpdate {
	/**
	 * Registers the CommentCreate mutation.
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_mutation() {
		register_graphql_mutation(
			'updateUser',
			[
				'inputFields'         => self::get_input_fields(),
				'outputFields'        => self::get_output_fields(),
				'mutateAndGetPayload' => self::mutate_and_get_payload(),
			]
		);
	}

	/**
	 * Defines the mutation input field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_input_fields() {
		return array_merge(
			[
				'id' => [
					'type'        => [
						'non_null' => 'ID',
					],
					// translators: the placeholder is the name of the type of post object being updated
					'description' => __( 'The ID of the user', 'wp-graphql' ),
				],
			],
			UserCreate::get_input_fields()
		);
	}

	/**
	 * Defines the mutation output field configuration.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_output_fields() {
		return UserCreate::get_output_fields();
	}

	/**
	 * Defines the mutation data modification closure.
	 *
	 * @return callable(array<string,mixed>$input,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):array<string,mixed>
	 */
	public static function mutate_and_get_payload() {
		return static function ( $input, AppContext $context, ResolveInfo $info ) {
			// Get the user ID.
			$user_id = Utils::get_database_id_from_id( $input['id'] );

			if ( empty( $user_id ) ) {
				throw new UserError( esc_html__( 'The user ID passed is invalid', 'wp-graphql' ) );
			}
			$existing_user = get_user_by( 'ID', $user_id );

			/**
			 * If there's no existing user, throw an exception
			 */
			if ( false === $existing_user ) {
				throw new UserError( esc_html__( 'A user could not be updated with the provided ID', 'wp-graphql' ) );
			}

			if ( ! current_user_can( 'edit_user', $existing_user->ID ) ) {
				throw new UserError( esc_html__( 'You do not have the appropriate capabilities to perform this action', 'wp-graphql' ) );
			}

			if ( isset( $input['roles'] ) && ! current_user_can( 'edit_users' ) ) {
				unset( $input['roles'] );
				throw new UserError( esc_html__( 'You do not have the appropriate capabilities to perform this action', 'wp-graphql' ) );
			}

			$user_args       = UserMutation::prepare_user_object( $input, 'updateUser' );
			$user_args['ID'] = $user_id;

			/**
			 * Update the user
			 */
			$updated_user_id = wp_update_user( $user_args );

			/**
			 * Throw an exception if the post failed to create
			 */
			if ( is_wp_error( $updated_user_id ) ) {
				$error_message = $updated_user_id->get_error_message();
				if ( ! empty( $error_message ) ) {
					throw new UserError( esc_html( $error_message ) );
				} else {
					throw new UserError( esc_html__( 'The user failed to update but no error was provided', 'wp-graphql' ) );
				}
			}

			/**
			 * If the $updated_user_id is empty, we should throw an exception
			 */
			if ( empty( $updated_user_id ) ) {
				throw new UserError( esc_html__( 'The user failed to update', 'wp-graphql' ) );
			}

			/**
			 * Update additional user data
			 */
			UserMutation::update_additional_user_object_data( $updated_user_id, $input, 'updateUser', $context, $info );

			/**
			 * Return the new user ID
			 */
			return [
				'id'   => $updated_user_id,
				'user' => $context->get_loader( 'user' )->load_deferred( $updated_user_id ),
			];
		};
	}
}


// File: wp-graphql\src\Registry\SchemaRegistry.php
<?php

namespace WPGraphQL\Registry;

use GraphQL\Type\SchemaConfig;
use WPGraphQL\WPSchema;

/**
 * Class SchemaRegistry
 *
 * @package WPGraphQL\Registry
 */
class SchemaRegistry {

	/**
	 * @var \WPGraphQL\Registry\TypeRegistry
	 */
	protected $type_registry;

	/**
	 * SchemaRegistry constructor.
	 *
	 * @throws \Exception
	 */
	public function __construct() {
		$this->type_registry = \WPGraphQL::get_type_registry();
	}

	/**
	 * Returns the Schema to use for execution of the GraphQL Request
	 *
	 * @return \WPGraphQL\WPSchema
	 * @throws \Exception
	 */
	public function get_schema() {
		$this->type_registry->init();

		$schema_config             = new SchemaConfig();
		$schema_config->query      = $this->type_registry->get_type( 'RootQuery' );
		$schema_config->mutation   = $this->type_registry->get_type( 'RootMutation' );
		$schema_config->typeLoader = function ( $type ) {
			return $this->type_registry->get_type( $type );
		};
		$schema_config->types      = $this->type_registry->get_types();

		/**
		 * Create a new instance of the Schema
		 */
		$schema = new WPSchema( $schema_config, $this->type_registry );

		/**
		 * Filter the Schema
		 *
		 * @param \WPGraphQL\WPSchema $schema The generated Schema
		 * @param \WPGraphQL\Registry\SchemaRegistry $registry The Schema Registry Instance
		 */
		return apply_filters( 'graphql_schema', $schema, $this );
	}
}


// File: wp-graphql\src\Registry\TypeRegistry.php
<?php

namespace WPGraphQL\Registry;

use GraphQL\Error\Error;
use GraphQL\Type\Definition\Type;
use WPGraphQL\Data\DataSource;
use WPGraphQL\Mutation\CommentCreate;
use WPGraphQL\Mutation\CommentDelete;
use WPGraphQL\Mutation\CommentRestore;
use WPGraphQL\Mutation\CommentUpdate;
use WPGraphQL\Mutation\MediaItemCreate;
use WPGraphQL\Mutation\MediaItemDelete;
use WPGraphQL\Mutation\MediaItemUpdate;
use WPGraphQL\Mutation\PostObjectCreate;
use WPGraphQL\Mutation\PostObjectDelete;
use WPGraphQL\Mutation\PostObjectUpdate;
use WPGraphQL\Mutation\ResetUserPassword;
use WPGraphQL\Mutation\SendPasswordResetEmail;
use WPGraphQL\Mutation\TermObjectCreate;
use WPGraphQL\Mutation\TermObjectDelete;
use WPGraphQL\Mutation\TermObjectUpdate;
use WPGraphQL\Mutation\UpdateSettings;
use WPGraphQL\Mutation\UserCreate;
use WPGraphQL\Mutation\UserDelete;
use WPGraphQL\Mutation\UserRegister;
use WPGraphQL\Mutation\UserUpdate;
use WPGraphQL\Registry\Utils\PostObject;
use WPGraphQL\Registry\Utils\TermObject;
use WPGraphQL\Type\Connection\Comments;
use WPGraphQL\Type\Connection\MenuItems;
use WPGraphQL\Type\Connection\PostObjects;
use WPGraphQL\Type\Connection\Taxonomies;
use WPGraphQL\Type\Connection\TermObjects;
use WPGraphQL\Type\Connection\Users;
use WPGraphQL\Type\Enum\AvatarRatingEnum;
use WPGraphQL\Type\Enum\CommentNodeIdTypeEnum;
use WPGraphQL\Type\Enum\CommentStatusEnum;
use WPGraphQL\Type\Enum\CommentsConnectionOrderbyEnum;
use WPGraphQL\Type\Enum\ContentNodeIdTypeEnum;
use WPGraphQL\Type\Enum\ContentTypeEnum;
use WPGraphQL\Type\Enum\ContentTypeIdTypeEnum;
use WPGraphQL\Type\Enum\MediaItemSizeEnum;
use WPGraphQL\Type\Enum\MediaItemStatusEnum;
use WPGraphQL\Type\Enum\MenuItemNodeIdTypeEnum;
use WPGraphQL\Type\Enum\MenuLocationEnum;
use WPGraphQL\Type\Enum\MenuNodeIdTypeEnum;
use WPGraphQL\Type\Enum\MimeTypeEnum;
use WPGraphQL\Type\Enum\OrderEnum;
use WPGraphQL\Type\Enum\PluginStatusEnum;
use WPGraphQL\Type\Enum\PostObjectFieldFormatEnum;
use WPGraphQL\Type\Enum\PostObjectsConnectionDateColumnEnum;
use WPGraphQL\Type\Enum\PostObjectsConnectionOrderbyEnum;
use WPGraphQL\Type\Enum\PostStatusEnum;
use WPGraphQL\Type\Enum\RelationEnum;
use WPGraphQL\Type\Enum\ScriptLoadingStrategyEnum;
use WPGraphQL\Type\Enum\TaxonomyEnum;
use WPGraphQL\Type\Enum\TaxonomyIdTypeEnum;
use WPGraphQL\Type\Enum\TermNodeIdTypeEnum;
use WPGraphQL\Type\Enum\TermObjectsConnectionOrderbyEnum;
use WPGraphQL\Type\Enum\TimezoneEnum;
use WPGraphQL\Type\Enum\UserNodeIdTypeEnum;
use WPGraphQL\Type\Enum\UserRoleEnum;
use WPGraphQL\Type\Enum\UsersConnectionOrderbyEnum;
use WPGraphQL\Type\Enum\UsersConnectionSearchColumnEnum;
use WPGraphQL\Type\Input\DateInput;
use WPGraphQL\Type\Input\DateQueryInput;
use WPGraphQL\Type\Input\PostObjectsConnectionOrderbyInput;
use WPGraphQL\Type\Input\UsersConnectionOrderbyInput;
use WPGraphQL\Type\InterfaceType\Commenter;
use WPGraphQL\Type\InterfaceType\Connection;
use WPGraphQL\Type\InterfaceType\ContentNode;
use WPGraphQL\Type\InterfaceType\ContentTemplate;
use WPGraphQL\Type\InterfaceType\DatabaseIdentifier;
use WPGraphQL\Type\InterfaceType\Edge;
use WPGraphQL\Type\InterfaceType\EnqueuedAsset;
use WPGraphQL\Type\InterfaceType\HierarchicalContentNode;
use WPGraphQL\Type\InterfaceType\HierarchicalNode;
use WPGraphQL\Type\InterfaceType\HierarchicalTermNode;
use WPGraphQL\Type\InterfaceType\MenuItemLinkable;
use WPGraphQL\Type\InterfaceType\Node;
use WPGraphQL\Type\InterfaceType\NodeWithAuthor;
use WPGraphQL\Type\InterfaceType\NodeWithComments;
use WPGraphQL\Type\InterfaceType\NodeWithContentEditor;
use WPGraphQL\Type\InterfaceType\NodeWithExcerpt;
use WPGraphQL\Type\InterfaceType\NodeWithFeaturedImage;
use WPGraphQL\Type\InterfaceType\NodeWithPageAttributes;
use WPGraphQL\Type\InterfaceType\NodeWithRevisions;
use WPGraphQL\Type\InterfaceType\NodeWithTemplate;
use WPGraphQL\Type\InterfaceType\NodeWithTitle;
use WPGraphQL\Type\InterfaceType\NodeWithTrackbacks;
use WPGraphQL\Type\InterfaceType\OneToOneConnection;
use WPGraphQL\Type\InterfaceType\PageInfo;
use WPGraphQL\Type\InterfaceType\Previewable;
use WPGraphQL\Type\InterfaceType\TermNode;
use WPGraphQL\Type\InterfaceType\UniformResourceIdentifiable;
use WPGraphQL\Type\ObjectType\Avatar;
use WPGraphQL\Type\ObjectType\Comment;
use WPGraphQL\Type\ObjectType\CommentAuthor;
use WPGraphQL\Type\ObjectType\ContentType;
use WPGraphQL\Type\ObjectType\EnqueuedScript;
use WPGraphQL\Type\ObjectType\EnqueuedStylesheet;
use WPGraphQL\Type\ObjectType\MediaDetails;
use WPGraphQL\Type\ObjectType\MediaItemMeta;
use WPGraphQL\Type\ObjectType\MediaSize;
use WPGraphQL\Type\ObjectType\Menu;
use WPGraphQL\Type\ObjectType\MenuItem;
use WPGraphQL\Type\ObjectType\Plugin;
use WPGraphQL\Type\ObjectType\PostTypeLabelDetails;
use WPGraphQL\Type\ObjectType\RootMutation;
use WPGraphQL\Type\ObjectType\RootQuery;
use WPGraphQL\Type\ObjectType\SettingGroup;
use WPGraphQL\Type\ObjectType\Settings;
use WPGraphQL\Type\ObjectType\Taxonomy;
use WPGraphQL\Type\ObjectType\Theme;
use WPGraphQL\Type\ObjectType\User;
use WPGraphQL\Type\ObjectType\UserRole;
use WPGraphQL\Type\Union\MenuItemObjectUnion;
use WPGraphQL\Type\Union\PostObjectUnion;
use WPGraphQL\Type\Union\TermObjectUnion;
use WPGraphQL\Type\WPConnectionType;
use WPGraphQL\Type\WPEnumType;
use WPGraphQL\Type\WPInputObjectType;
use WPGraphQL\Type\WPInterfaceType;
use WPGraphQL\Type\WPMutationType;
use WPGraphQL\Type\WPObjectType;
use WPGraphQL\Type\WPScalar;
use WPGraphQL\Type\WPUnionType;
use WPGraphQL\Utils\Utils;

/**
 * Class TypeRegistry
 *
 * This class maintains the registry of Types used in the GraphQL Schema
 *
 * @package WPGraphQL\Registry
 */
class TypeRegistry {

	/**
	 * The registered Types
	 *
	 * @var array<string,mixed>
	 */
	protected $types;

	/**
	 * The loaders needed to register types
	 *
	 * @var array<string,callable():(mixed|array<string,mixed>|\GraphQL\Type\Definition\Type|null)>
	 */
	protected $type_loaders;

	/**
	 * Stores a list of Types that need to be eagerly loaded instead of lazy loaded.
	 *
	 * Types that exist in the Schema but are only part of a Union/Interface ResolveType but not
	 * referenced directly need to be eagerly loaded.
	 *
	 * @var array<string,string>
	 */
	protected $eager_type_map;

	/**
	 * Stores a list of Types that should be excluded from the schema.
	 *
	 * Type names are filtered by `graphql_excluded_types` and normalized using strtolower(), to avoid case sensitivity issues.
	 *
	 * @var string[]
	 */
	protected $excluded_types = null;

	/**
	 * Stores a list of mutation names that should be excluded from the schema, along with their generated input and payload types.
	 *
	 * Type names are filtered by `graphql_excluded_mutations` and normalized using strtolower(), to avoid case sensitivity issues.
	 *
	 * @var string[]
	 */
	protected $excluded_mutations = null;

	/**
	 * Stores a list of connection Type names that should be excluded from the schema, along with their generated types.
	 *
	 * Type names are filtered by `graphql_excluded_connections` and normalized using strtolower(), to avoid case sensitivity issues.
	 *
	 * Type name
	 *
	 * @var string[]
	 */
	protected $excluded_connections = null;

	/**
	 * TypeRegistry constructor.
	 */
	public function __construct() {
		$this->types          = [];
		$this->type_loaders   = [];
		$this->eager_type_map = [];
	}

	/**
	 * Formats the array key to a more friendly format
	 *
	 * @param string $key Name of the array key to format
	 *
	 * @return string
	 */
	protected function format_key( string $key ) {
		return strtolower( $key );
	}

	/**
	 * Returns the eager type map, an array of Type definitions for Types that
	 * are not directly referenced in the schema.
	 *
	 * Types can add "eagerlyLoadType => true" when being registered to be included
	 * in the eager_type_map.
	 *
	 * @return array<string,mixed>
	 */
	protected function get_eager_type_map() {
		if ( ! empty( $this->eager_type_map ) ) {
			return array_map(
				function ( $type_name ) {
					return $this->get_type( $type_name );
				},
				$this->eager_type_map
			);
		}

		return [];
	}

	/**
	 * Initialize the TypeRegistry
	 *
	 * @throws \Exception
	 *
	 * @return void
	 */
	public function init() {
		$this->register_type( 'Bool', Type::boolean() );
		$this->register_type( 'Boolean', Type::boolean() );
		$this->register_type( 'Float', Type::float() );
		$this->register_type( 'Number', Type::float() );
		$this->register_type( 'Id', Type::id() );
		$this->register_type( 'Int', Type::int() );
		$this->register_type( 'Integer', Type::int() );
		$this->register_type( 'String', Type::string() );

		/**
		 * When the Type Registry is initialized execute these files
		 */
		add_action( 'init_graphql_type_registry', [ $this, 'init_type_registry' ], 5, 1 );

		/**
		 * Fire an action as the Type registry is being initiated
		 *
		 * @param \WPGraphQL\Registry\TypeRegistry $registry Instance of the TypeRegistry
		 */
		do_action( 'init_graphql_type_registry', $this );
	}

	/**
	 * Initialize the Type Registry
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @return void
	 * @throws \Exception
	 */
	public function init_type_registry( self $type_registry ) {

		/**
		 * Fire an action as the type registry is initialized. This executes
		 * before the `graphql_register_types` action to allow for earlier hooking
		 *
		 * @param \WPGraphQL\Registry\TypeRegistry $registry Instance of the TypeRegistry
		 */
		do_action( 'graphql_register_initial_types', $type_registry );

		// Register Interfaces.
		Node::register_type();
		Commenter::register_type( $type_registry );
		Connection::register_type( $type_registry );
		ContentNode::register_type( $type_registry );
		ContentTemplate::register_type();
		DatabaseIdentifier::register_type();
		Edge::register_type( $type_registry );
		EnqueuedAsset::register_type( $type_registry );
		HierarchicalContentNode::register_type( $type_registry );
		HierarchicalNode::register_type( $type_registry );
		HierarchicalTermNode::register_type( $type_registry );
		MenuItemLinkable::register_type( $type_registry );
		NodeWithAuthor::register_type( $type_registry );
		NodeWithComments::register_type( $type_registry );
		NodeWithContentEditor::register_type( $type_registry );
		NodeWithExcerpt::register_type( $type_registry );
		NodeWithFeaturedImage::register_type( $type_registry );
		NodeWithRevisions::register_type( $type_registry );
		NodeWithTitle::register_type( $type_registry );
		NodeWithTemplate::register_type( $type_registry );
		NodeWithTrackbacks::register_type( $type_registry );
		NodeWithPageAttributes::register_type( $type_registry );
		PageInfo::register_type( $type_registry );
		Previewable::register_type( $type_registry );
		OneToOneConnection::register_type( $type_registry );
		TermNode::register_type( $type_registry );
		UniformResourceIdentifiable::register_type( $type_registry );

		// register types
		RootQuery::register_type();
		RootQuery::register_post_object_fields();
		RootQuery::register_term_object_fields();
		RootMutation::register_type();
		Avatar::register_type();
		Comment::register_type();
		CommentAuthor::register_type();
		ContentTemplate::register_content_template_types();
		EnqueuedStylesheet::register_type();
		EnqueuedScript::register_type();
		MediaDetails::register_type();
		MediaItemMeta::register_type();
		MediaSize::register_type();
		Menu::register_type();
		MenuItem::register_type();
		Plugin::register_type();
		ContentType::register_type();
		PostTypeLabelDetails::register_type();
		Settings::register_type( $this );
		Taxonomy::register_type();
		Theme::register_type();
		User::register_type();
		UserRole::register_type();

		AvatarRatingEnum::register_type();
		CommentNodeIdTypeEnum::register_type();
		CommentsConnectionOrderbyEnum::register_type();
		CommentStatusEnum::register_type();
		ContentNodeIdTypeEnum::register_type();
		ContentTypeEnum::register_type();
		ContentTypeIdTypeEnum::register_type();
		MediaItemSizeEnum::register_type();
		MediaItemStatusEnum::register_type();
		MenuLocationEnum::register_type();
		MenuItemNodeIdTypeEnum::register_type();
		MenuNodeIdTypeEnum::register_type();
		MimeTypeEnum::register_type();
		OrderEnum::register_type();
		PluginStatusEnum::register_type();
		PostObjectFieldFormatEnum::register_type();
		PostObjectsConnectionDateColumnEnum::register_type();
		PostObjectsConnectionOrderbyEnum::register_type();
		PostStatusEnum::register_type();
		RelationEnum::register_type();
		ScriptLoadingStrategyEnum::register_type();
		TaxonomyEnum::register_type();
		TaxonomyIdTypeEnum::register_type();
		TermNodeIdTypeEnum::register_type();
		TermObjectsConnectionOrderbyEnum::register_type();
		TimezoneEnum::register_type();
		UserNodeIdTypeEnum::register_type();
		UserRoleEnum::register_type();
		UsersConnectionOrderbyEnum::register_type();
		UsersConnectionSearchColumnEnum::register_type();

		DateInput::register_type();
		DateQueryInput::register_type();
		PostObjectsConnectionOrderbyInput::register_type();
		UsersConnectionOrderbyInput::register_type();

		MenuItemObjectUnion::register_type( $this );
		PostObjectUnion::register_type( $this );
		TermObjectUnion::register_type( $this );

		/**
		 * Register core connections
		 */
		Comments::register_connections();
		MenuItems::register_connections();
		PostObjects::register_connections();
		Taxonomies::register_connections();
		TermObjects::register_connections();
		Users::register_connections();

		/**
		 * Register core mutations
		 */
		CommentCreate::register_mutation();
		CommentDelete::register_mutation();
		CommentRestore::register_mutation();
		CommentUpdate::register_mutation();
		MediaItemCreate::register_mutation();
		MediaItemDelete::register_mutation();
		MediaItemUpdate::register_mutation();
		ResetUserPassword::register_mutation();
		SendPasswordResetEmail::register_mutation();
		UserCreate::register_mutation();
		UserDelete::register_mutation();
		UserUpdate::register_mutation();
		UserRegister::register_mutation();
		UpdateSettings::register_mutation( $this );

		/**
		 * Register PostObject types based on post_types configured to show_in_graphql
		 *
		 * @var \WP_Post_Type[] $allowed_post_types
		 */
		$allowed_post_types = \WPGraphQL::get_allowed_post_types( 'objects' );

		/** @var \WP_Taxonomy[] $allowed_taxonomies */
		$allowed_taxonomies = \WPGraphQL::get_allowed_taxonomies( 'objects' );

		foreach ( $allowed_post_types as $post_type_object ) {
			PostObject::register_types( $post_type_object );

			/**
			 * Mutations for attachments are handled differently
			 * because they require different inputs
			 */
			if ( 'attachment' !== $post_type_object->name ) {

				/**
				 * Revisions are created behind the scenes as a side effect of post updates,
				 * they aren't created manually.
				 */
				if ( 'revision' !== $post_type_object->name ) {
					if ( empty( $post_type_object->graphql_exclude_mutations ) || ! in_array( 'create', $post_type_object->graphql_exclude_mutations, true ) ) {
						PostObjectCreate::register_mutation( $post_type_object );
					}

					if ( empty( $post_type_object->graphql_exclude_mutations ) || ! in_array( 'update', $post_type_object->graphql_exclude_mutations, true ) ) {
						PostObjectUpdate::register_mutation( $post_type_object );
					}
				}

				if ( empty( $post_type_object->graphql_exclude_mutations ) || ! in_array( 'delete', $post_type_object->graphql_exclude_mutations, true ) ) {
					PostObjectDelete::register_mutation( $post_type_object );
				}
			}

			foreach ( $allowed_taxonomies as $tax_object ) {
				// If the taxonomy is in the array of taxonomies registered to the post_type
				if ( in_array( $tax_object->name, get_object_taxonomies( $post_type_object->name ), true ) ) {
					register_graphql_input_type(
						$post_type_object->graphql_single_name . ucfirst( $tax_object->graphql_plural_name ) . 'NodeInput',
						[
							'description' => sprintf(
								// translators: %1$s is the GraphQL plural name of the taxonomy, %2$s is the GraphQL singular name of the post type.
								__( 'List of %1$s to connect the %2$s to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists.', 'wp-graphql' ),
								$tax_object->graphql_plural_name,
								$post_type_object->graphql_single_name
							),
							'fields'      => [
								'id'          => [
									'type'        => 'Id',
									'description' => sprintf(
										// translators: %1$s is the GraphQL name of the taxonomy, %2$s is the GraphQL name of the post type.
										__( 'The ID of the %1$s. If present, this will be used to connect to the %2$s. If no existing %1$s exists with this ID, no connection will be made.', 'wp-graphql' ),
										$tax_object->graphql_single_name,
										$post_type_object->graphql_single_name
									),
								],
								'slug'        => [
									'type'        => 'String',
									'description' => sprintf(
										// translators: %1$s is the GraphQL name of the taxonomy.
										__( 'The slug of the %1$s. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation.', 'wp-graphql' ),
										$tax_object->graphql_single_name
									),
								],
								'description' => [
									'type'        => 'String',
									'description' => sprintf(
										// translators: %1$s is the GraphQL name of the taxonomy.
										__( 'The description of the %1$s. This field is used to set a description of the %1$s if a new one is created during the mutation.', 'wp-graphql' ),
										$tax_object->graphql_single_name
									),
								],
								'name'        => [
									'type'        => 'String',
									'description' => sprintf(
											// translators: %1$s is the GraphQL name of the taxonomy.
										__( 'The name of the %1$s. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field.', 'wp-graphql' ),
										$tax_object->graphql_single_name
									),
								],
							],
						]
					);

					register_graphql_input_type(
						ucfirst( $post_type_object->graphql_single_name ) . ucfirst( $tax_object->graphql_plural_name ) . 'Input',
						[
							'description' => sprintf(
								// translators: %1$s is the GraphQL name of the post type, %2$s is the plural GraphQL name of the taxonomy.
								__( 'Set relationships between the %1$s to %2$s', 'wp-graphql' ),
								$post_type_object->graphql_single_name,
								$tax_object->graphql_plural_name
							),
							'fields'      => [
								'append' => [
									'type'        => 'Boolean',
									'description' => sprintf(
										// translators: %1$s is the GraphQL name of the taxonomy, %2$s is the plural GraphQL name of the taxonomy.
										__( 'If true, this will append the %1$s to existing related %2$s. If false, this will replace existing relationships. Default true.', 'wp-graphql' ),
										$tax_object->graphql_single_name,
										$tax_object->graphql_plural_name
									),
								],
								'nodes'  => [
									'type'        => [
										'list_of' => $post_type_object->graphql_single_name . ucfirst( $tax_object->graphql_plural_name ) . 'NodeInput',
									],
									'description' => __( 'The input list of items to set.', 'wp-graphql' ),
								],
							],
						]
					);
				}
			}
		}

		/**
		 * Register TermObject types based on taxonomies configured to show_in_graphql
		 */
		foreach ( $allowed_taxonomies as $tax_object ) {
			TermObject::register_types( $tax_object );

			if ( empty( $tax_object->graphql_exclude_mutations ) || ! in_array( 'create', $tax_object->graphql_exclude_mutations, true ) ) {
				TermObjectCreate::register_mutation( $tax_object );
			}

			if ( empty( $tax_object->graphql_exclude_mutations ) || ! in_array( 'update', $tax_object->graphql_exclude_mutations, true ) ) {
				TermObjectUpdate::register_mutation( $tax_object );
			}

			if ( empty( $tax_object->graphql_exclude_mutations ) || ! in_array( 'delete', $tax_object->graphql_exclude_mutations, true ) ) {
				TermObjectDelete::register_mutation( $tax_object );
			}
		}

		/**
		 * Create the root query fields for any setting type in
		 * the $allowed_setting_types array.
		 */
		$allowed_setting_types = DataSource::get_allowed_settings_by_group( $this );

		/**
		 * The url is not a registered setting for multisite, so this is a polyfill
		 * to expose the URL to the Schema for multisite sites
		 */
		if ( is_multisite() ) {
			$this->register_field(
				'GeneralSettings',
				'url',
				[
					'type'        => 'String',
					'description' => __( 'Site URL.', 'wp-graphql' ),
					'resolve'     => static function () {
						return get_site_url();
					},
				]
			);
		}

		if ( ! empty( $allowed_setting_types ) && is_array( $allowed_setting_types ) ) {
			foreach ( $allowed_setting_types as $group_name => $setting_type ) {
				$group_name = DataSource::format_group_name( $group_name );
				$type_name  = SettingGroup::register_settings_group( $group_name, $group_name, $this );

				if ( ! $type_name ) {
					continue;
				}

				register_graphql_field(
					'RootQuery',
					Utils::format_field_name( $type_name ),
					[
						'type'        => $type_name,
						'description' => sprintf(
							// translators: %s is the GraphQL name of the settings group.
							__( "Fields of the '%s' settings group", 'wp-graphql' ),
							ucfirst( $group_name ) . 'Settings'
						),
						'resolve'     => static function () use ( $setting_type ) {
							return $setting_type;
						},
					]
				);
			}
		}

		/**
		 * Fire an action as the type registry is initialized. This executes
		 * before the `graphql_register_types` action to allow for earlier hooking
		 *
		 * @param \WPGraphQL\Registry\TypeRegistry $registry Instance of the TypeRegistry
		 */
		do_action( 'graphql_register_types', $type_registry );

		/**
		 * Fire an action as the type registry is initialized. This executes
		 * during the `graphql_register_types` action to allow for earlier hooking
		 *
		 * @param \WPGraphQL\Registry\TypeRegistry $registry Instance of the TypeRegistry
		 */
		do_action( 'graphql_register_types_late', $type_registry );
	}

	/**
	 * Given a config for a custom Scalar, this adds the Scalar for use in the Schema.
	 *
	 * @param string              $type_name The name of the Type to register
	 * @param array<string,mixed> $config    The config for the scalar type to register
	 *
	 * @throws \Exception
	 *
	 * @return void
	 */
	public function register_scalar( string $type_name, array $config ) {
		$config['kind'] = 'scalar';
		$this->register_type( $type_name, $config );
	}

	/**
	 * Registers connections that were passed through the Type registration config
	 *
	 * @param array<string,mixed> $config Type config
	 *
	 * @return void
	 *
	 * @throws \Exception
	 */
	protected function register_connections_from_config( array $config ) {
		$connections = $config['connections'] ?? null;

		if ( ! is_array( $connections ) ) {
			return;
		}

		foreach ( $connections as $field_name => $connection_config ) {
			if ( ! is_array( $connection_config ) ) {
				continue;
			}

			$connection_config['fromType']      = $config['name'];
			$connection_config['fromFieldName'] = $field_name;
			register_graphql_connection( $connection_config );
		}
	}

	/**
	 * Add a Type to the Registry
	 *
	 * @param string                                                  $type_name The name of the type to register
	 * @param mixed|array<string,mixed>|\GraphQL\Type\Definition\Type $config The config for the type
	 *
	 * @throws \Exception
	 */
	public function register_type( string $type_name, $config ): void {
		/**
		 * If the type should be excluded from the schema, skip it.
		 */
		if ( in_array( strtolower( $type_name ), $this->get_excluded_types(), true ) ) {
			return;
		}
		/**
		 * If the Type Name starts with a number, skip it.
		 */
		if ( ! is_valid_graphql_name( $type_name ) ) {
			graphql_debug(
				sprintf(
					// translators: %s is the name of the type.
					__( 'The Type name \'%1$s\' is invalid and has not been added to the GraphQL Schema.', 'wp-graphql' ),
					$type_name
				),
				[
					'type'      => 'INVALID_TYPE_NAME',
					'type_name' => $type_name,
				]
			);
			return;
		}

		/**
		 * If the Type Name is already registered, skip it.
		 */
		if ( isset( $this->types[ $this->format_key( $type_name ) ] ) || isset( $this->type_loaders[ $this->format_key( $type_name ) ] ) ) {
			graphql_debug(
				sprintf(
					// translators: %s is the name of the type.
					__( 'You cannot register duplicate Types to the Schema. The Type \'%1$s\' already exists in the Schema. Make sure to give new Types a unique name.', 'wp-graphql' ),
					$type_name
				),
				[
					'type'      => 'DUPLICATE_TYPE',
					'type_name' => $type_name,
				]
			);
			return;
		}

		/**
		 * Register any connections that were passed through the Type config
		 */
		if ( is_array( $config ) && isset( $config['connections'] ) ) {
			$config['name'] = ucfirst( $type_name );
			$this->register_connections_from_config( $config );
		}

		$this->type_loaders[ $this->format_key( $type_name ) ] = function () use ( $type_name, $config ) {
			return $this->prepare_type( $type_name, $config );
		};

		if ( is_array( $config ) && isset( $config['eagerlyLoadType'] ) && true === $config['eagerlyLoadType'] && ! isset( $this->eager_type_map[ $this->format_key( $type_name ) ] ) ) {
			$this->eager_type_map[ $this->format_key( $type_name ) ] = $this->format_key( $type_name );
		}
	}

	/**
	 * Add an Object Type to the Registry
	 *
	 * @param string              $type_name The name of the type to register
	 * @param array<string,mixed> $config The configuration of the type
	 *
	 * @throws \Exception
	 */
	public function register_object_type( string $type_name, array $config ): void {
		$config['kind'] = 'object';
		$this->register_type( $type_name, $config );
	}

	/**
	 * Add an Interface Type to the registry
	 *
	 * @param string                                                  $type_name The name of the type to register
	 * @param mixed|array<string,mixed>|\GraphQL\Type\Definition\Type $config The configuration of the type
	 *
	 * @throws \Exception
	 */
	public function register_interface_type( string $type_name, $config ): void {
		$config['kind'] = 'interface';
		$this->register_type( $type_name, $config );
	}

	/**
	 * Add an Enum Type to the registry
	 *
	 * @param string              $type_name The name of the type to register
	 * @param array<string,mixed> $config he configuration of the type
	 *
	 * @throws \Exception
	 */
	public function register_enum_type( string $type_name, array $config ): void {
		$config['kind'] = 'enum';
		$this->register_type( $type_name, $config );
	}

	/**
	 * Add an Input Type to the Registry
	 *
	 * @param string              $type_name The name of the type to register
	 * @param array<string,mixed> $config he configuration of the type
	 *
	 * @throws \Exception
	 */
	public function register_input_type( string $type_name, array $config ): void {
		$config['kind'] = 'input';
		$this->register_type( $type_name, $config );
	}

	/**
	 * Add a Union Type to the Registry
	 *
	 * @param string              $type_name The name of the type to register
	 * @param array<string,mixed> $config he configuration of the type
	 *
	 * @throws \Exception
	 */
	public function register_union_type( string $type_name, array $config ): void {
		$config['kind'] = 'union';
		$this->register_type( $type_name, $config );
	}

	/**
	 * @param string                                                  $type_name The name of the type to register
	 * @param mixed|array<string,mixed>|\GraphQL\Type\Definition\Type $config he configuration of the type
	 *
	 * @return mixed|array<string,mixed>|\GraphQL\Type\Definition\Type|null
	 * @throws \Exception
	 */
	public function prepare_type( string $type_name, $config ) {
		/**
		 * Uncomment to help trace eagerly (not lazy) loaded types.
		 *
		 * Use: graphql_debug( "prepare_type: {$type_name}", [ 'type' => $type_name ] );.
		 */

		if ( ! is_array( $config ) ) {
			return $config;
		}

		$prepared_type = null;

		if ( ! empty( $config ) ) {
			$kind           = isset( $config['kind'] ) ? $config['kind'] : null;
			$config['name'] = ucfirst( $type_name );

			switch ( $kind ) {
				case 'enum':
					$prepared_type = new WPEnumType( $config );
					break;
				case 'input':
					$prepared_type = new WPInputObjectType( $config, $this );
					break;
				case 'scalar':
					$prepared_type = new WPScalar( $config, $this );
					break;
				case 'union':
					$prepared_type = new WPUnionType( $config, $this );
					break;
				case 'interface':
					$prepared_type = new WPInterfaceType( $config, $this );
					break;
				case 'object':
				default:
					$prepared_type = new WPObjectType( $config, $this );
			}
		}

		return $prepared_type;
	}

	/**
	 * Given a type name, returns the type or null if not found
	 *
	 * @param string $type_name The name of the Type to get from the registry
	 *
	 * @return mixed|array<string,mixed>|\GraphQL\Type\Definition\Type|null
	 */
	public function get_type( string $type_name ) {
		$key = $this->format_key( $type_name );

		if ( isset( $this->type_loaders[ $key ] ) ) {
			$type                = $this->type_loaders[ $key ]();
			$this->types[ $key ] = apply_filters( 'graphql_get_type', $type, $type_name );
			unset( $this->type_loaders[ $key ] );
		}

		return $this->types[ $key ] ?? null;
	}

	/**
	 * Given a type name, determines if the type is already present in the Type Loader
	 *
	 * @param string $type_name The name of the type to check the registry for
	 */
	public function has_type( string $type_name ): bool {
		return isset( $this->type_loaders[ $this->format_key( $type_name ) ] );
	}

	/**
	 * Return the Types in the registry
	 *
	 * @return array<string,mixed>
	 */
	public function get_types(): array {

		// The full map of types is merged with eager types to support the
		// rename_graphql_type API.
		//
		// All of the types are closures, but eager Types are the full
		// Type definitions up front
		return array_merge( $this->types, $this->get_eager_type_map() );
	}

	/**
	 * Wrapper for prepare_field to prepare multiple fields for registration at once
	 *
	 * @param array<string,mixed> $fields    Array of fields and their settings to register on a Type
	 * @param string              $type_name Name of the Type to register the fields to
	 *
	 * @return array<string,array<string,mixed>>
	 * @throws \Exception
	 */
	public function prepare_fields( array $fields, string $type_name ): array {
		$prepared_fields = [];
		foreach ( $fields as $field_name => $field_config ) {
			if ( is_array( $field_config ) && isset( $field_config['type'] ) ) {
				$prepared_field = $this->prepare_field( $field_name, $field_config, $type_name );
				if ( ! empty( $prepared_field ) ) {
					$prepared_fields[ $this->format_key( $field_name ) ] = $prepared_field;
				}
			}
		}

		return $prepared_fields;
	}

	/**
	 * Prepare the field to be registered on the type
	 *
	 * @param string              $field_name   Friendly name of the field
	 * @param array<string,mixed> $field_config Config data about the field to prepare
	 * @param string              $type_name    Name of the type to prepare the field for
	 *
	 * @return ?array<string,mixed>
	 * @throws \Exception
	 */
	protected function prepare_field( string $field_name, array $field_config, string $type_name ): ?array {
		if ( ! isset( $field_config['name'] ) ) {
			$field_config['name'] = lcfirst( $field_name );
		}

		if ( ! isset( $field_config['type'] ) ) {
			graphql_debug(
				sprintf(
					/* translators: %s is the Field name. */
					__( 'The registered field \'%s\' does not have a Type defined. Make sure to define a type for all fields.', 'wp-graphql' ),
					$field_name
				),
				[
					'type'       => 'INVALID_FIELD_TYPE',
					'type_name'  => $type_name,
					'field_name' => $field_name,
				]
			);
			return null;
		}

		/**
		 * If the type is a string, create a callable wrapper to get the type from
		 * type registry. This preserves lazy-loading and prevents a bug where a type
		 * has the same name as a function in the global scope (e.g., `header()`) and
		 * is called since it passes `is_callable`.
		 */
		if ( is_string( $field_config['type'] ) ) {
			// Bail if the type is excluded from the Schema.
			if ( in_array( strtolower( $field_config['type'] ), $this->get_excluded_types(), true ) ) {
				return null;
			}

			$field_config['type'] = function () use ( $field_config, $type_name ) {
				$type = $this->get_type( $field_config['type'] );
				if ( ! $type ) {
					$message = sprintf(
					/* translators: %1$s is the Field name, %2$s is the type name the field belongs to. %3$s is the non-existent type name being referenced. */
						__( 'The field \'%1$s\' on Type \'%2$s\' is configured to return \'%3$s\' which is a non-existent Type in the Schema. Make sure to define a valid type for all fields. This might occur if there was a typo with \'%3$s\', or it needs to be registered to the Schema.', 'wp-graphql' ),
						$field_config['name'],
						$type_name,
						$field_config['type']
					);
					// We throw an error here instead of graphql_debug message, as an error would already be thrown if a type didn't exist at this point,
					// but now it will have a more helpful error message.
					throw new Error( esc_html( $message ) );
				}
				return $type;
			};
		}

		/**
		 * If the type is an array, it contains type modifiers (e.g., "non_null").
		 * Create a callable wrapper to preserve lazy-loading.
		 */
		if ( is_array( $field_config['type'] ) ) {
			// Bail if the type is excluded from the Schema.
			$unmodified_type_name = $this->get_unmodified_type_name( $field_config['type'] );

			if ( empty( $unmodified_type_name ) || in_array( strtolower( $unmodified_type_name ), $this->get_excluded_types(), true ) ) {
				return null;
			}

			$field_config['type'] = function () use ( $field_config ) {
				return $this->setup_type_modifiers( $field_config['type'] );
			};
		}

		/**
		 * If the field has arguments, each one must be prepared.
		 */
		if ( isset( $field_config['args'] ) && is_array( $field_config['args'] ) ) {
			foreach ( $field_config['args'] as $arg_name => $arg_config ) {
				$arg = $this->prepare_field( $arg_name, $arg_config, $type_name );

				// Remove the arg if the field could not be prepared.
				if ( empty( $arg ) ) {
					unset( $field_config['args'][ $arg_name ] );
					continue;
				}

				$field_config['args'][ $arg_name ] = $arg;
			}
		}

		/**
		 * If the field has no (remaining) valid arguments, unset the key.
		 */
		if ( empty( $field_config['args'] ) ) {
			unset( $field_config['args'] );
		}

		return $field_config;
	}

	/**
	 * Processes type modifiers (e.g., "non-null"). Loads types immediately, so do
	 * not call before types are ready to be loaded.
	 *
	 * @param mixed|string|array<string,mixed> $type The type definition to process.
	 *
	 * @return \GraphQL\Type\Definition\Type|string|array<string,mixed>|mixed
	 * @throws \Exception
	 */
	public function setup_type_modifiers( $type ) {
		if ( ! is_array( $type ) ) {
			return $type;
		}

		if ( isset( $type['non_null'] ) ) {
			return $this->non_null(
				$this->setup_type_modifiers( $type['non_null'] )
			);
		}

		if ( isset( $type['list_of'] ) ) {
			return $this->list_of(
				$this->setup_type_modifiers( $type['list_of'] )
			);
		}

		return $type;
	}

	/**
	 * Wrapper for the register_field method to register multiple fields at once
	 *
	 * @param string                            $type_name Name of the type in the Type Registry to add the fields to
	 * @param array<string,array<string,mixed>> $fields    Fields to register
	 *
	 * @throws \Exception
	 */
	public function register_fields( string $type_name, array $fields = [] ): void {
		if ( ! empty( $fields ) ) {
			foreach ( $fields as $field_name => $config ) {
				if ( is_string( $field_name ) && ! empty( $config ) && is_array( $config ) ) {
					$this->register_field( $type_name, $field_name, $config );
				}
			}
		}
	}

	/**
	 * Add a field to a Type in the Type Registry
	 *
	 * @param string              $type_name  Name of the type in the Type Registry to add the fields to
	 * @param string              $field_name Name of the field to add to the type
	 * @param array<string,mixed> $config     Info about the field to register to the type
	 *
	 * @throws \Exception
	 */
	public function register_field( string $type_name, string $field_name, array $config ): void {
		add_filter(
			'graphql_' . $type_name . '_fields',
			function ( $fields ) use ( $type_name, $field_name, $config ) {

				// Whether the field should be allowed to have underscores in the field name
				$allow_field_underscores = isset( $config['allowFieldUnderscores'] ) && true === $config['allowFieldUnderscores'];

				$field_name = Utils::format_field_name( $field_name, $allow_field_underscores );

				if ( preg_match( '/^\d/', $field_name ) ) {
					graphql_debug(
						sprintf(
							// translators: %1$s is the field name, %2$s is the type name.
							__( 'The field \'%1$s\' on Type \'%2$s\' is invalid. Field names cannot start with a number.', 'wp-graphql' ),
							$field_name,
							$type_name
						),
						[
							'type'       => 'INVALID_FIELD_NAME',
							'field_name' => $field_name,
							'type_name'  => $type_name,
						]
					);
					return $fields;
				}

				// if a field has already been registered with the same name output a debug message
				if ( isset( $fields[ $field_name ] ) ) {

					// if the existing field is a connection type
					// and the new field is also a connection type
					// and the toType is the same for both
					// then we can allow the duplicate field
					if (
						isset(
							$fields[ $field_name ]['isConnectionField'],
							$config['isConnectionField'],
							$fields[ $field_name ]['toType'],
							$config['toType'],
							$fields[ $field_name ]['connectionTypeName'],
							$config['connectionTypeName']
						) &&
						$fields[ $field_name ]['toType'] === $config['toType'] &&
						$fields[ $field_name ]['connectionTypeName'] === $config['connectionTypeName']
					) {
						return $fields;
					}

					graphql_debug(
						sprintf(
							// translators: %1$s is the field name, %2$s is the type name.
							__( 'You cannot register duplicate fields on the same Type. The field \'%1$s\' already exists on the type \'%2$s\'. Make sure to give the field a unique name.', 'wp-graphql' ),
							$field_name,
							$type_name
						),
						[
							'type'            => 'DUPLICATE_FIELD',
							'field_name'      => $field_name,
							'type_name'       => $type_name,
							'existing_field'  => $fields[ $field_name ],
							'duplicate_field' => $config,
						]
					);
					return $fields;
				}

				/**
				 * If the field returns a properly prepared field, add it the the field registry
				 */
				$field = $this->prepare_field( $field_name, $config, $type_name );

				if ( ! empty( $field ) ) {
					$fields[ $field_name ] = $field;
				}

				return $fields;
			},
			10,
			1
		);
	}

	/**
	 * Remove a field from a type
	 *
	 * @param string $type_name  Name of the Type the field is registered to
	 * @param string $field_name Name of the field you would like to remove from the type
	 *
	 * @return void
	 */
	public function deregister_field( string $type_name, string $field_name ) {
		add_filter(
			'graphql_' . $type_name . '_fields',
			static function ( $fields ) use ( $field_name ) {
				if ( isset( $fields[ $field_name ] ) ) {
					unset( $fields[ $field_name ] );
				}

				return $fields;
			}
		);
	}

	/**
	 * Method to register a new connection in the Type registry
	 *
	 * @param array<string,mixed> $config The info about the connection being registered
	 *
	 * @throws \InvalidArgumentException
	 * @throws \Exception
	 */
	public function register_connection( array $config ): void {
		new WPConnectionType( $config, $this );
	}

	/**
	 * Handles registration of a mutation to the Type registry
	 *
	 * @param string              $mutation_name Name of the mutation being registered
	 * @param array<string,mixed> $config        Info about the mutation being registered
	 *
	 * @throws \Exception
	 */
	public function register_mutation( string $mutation_name, array $config ): void {
		// Bail if the mutation has been excluded from the schema.
		if ( in_array( strtolower( $mutation_name ), $this->get_excluded_mutations(), true ) ) {
			return;
		}

		$config['name'] = $mutation_name;
		new WPMutationType( $config, $this );
	}

	/**
	 * Removes a GraphQL mutation from the schema.
	 *
	 * This works by preventing the mutation from being registered in the first place.
	 *
	 * @uses 'graphql_excluded_mutations' filter.
	 *
	 * @param string $mutation_name Name of the mutation to remove from the schema.
	 *
	 * @since 1.14.0
	 */
	public function deregister_mutation( string $mutation_name ): void {
		// Prevent the mutation from being registered to the scheme directly.
		add_filter(
			'graphql_excluded_mutations',
			static function ( $excluded_mutations ) use ( $mutation_name ): array {
				// Normalize the types to prevent case sensitivity issues.
				$mutation_name = strtolower( $mutation_name );
				// If the type isn't already excluded, add it to the array.
				if ( ! in_array( $mutation_name, $excluded_mutations, true ) ) {
					$excluded_mutations[] = $mutation_name;
				}

				return $excluded_mutations;
			},
			10
		);
	}

	/**
	 * Removes a GraphQL connection from the schema.
	 *
	 * This works by preventing the connection from being registered in the first place.
	 *
	 * @uses 'graphql_excluded_connections' filter.
	 *
	 * @param string $connection_name The GraphQL connection name.
	 */
	public function deregister_connection( string $connection_name ): void {
		add_filter(
			'graphql_excluded_connections',
			static function ( $excluded_connections ) use ( $connection_name ) {
				$connection_name = strtolower( $connection_name );

				if ( ! in_array( $connection_name, $excluded_connections, true ) ) {
					$excluded_connections[] = $connection_name;
				}

				return $excluded_connections;
			}
		);
	}

	/**
	 * Given a Type, this returns an instance of a NonNull of that type
	 *
	 * @param string|callable|\GraphQL\Type\Definition\NullableType $type The Type being wrapped
	 *
	 * @return \GraphQL\Type\Definition\NonNull
	 */
	public function non_null( $type ) {
		if ( is_string( $type ) ) {
			$type_def = $this->get_type( $type );

			return Type::nonNull( $type_def );
		}

		return Type::nonNull( $type );
	}

	/**
	 * Given a Type, this returns an instance of a listOf of that type
	 *
	 * @param string|\GraphQL\Type\Definition\Type $type The Type being wrapped
	 *
	 * @return \GraphQL\Type\Definition\ListOfType
	 */
	public function list_of( $type ) {
		if ( is_string( $type ) ) {
			$type_def = $this->get_type( $type );

			if ( is_null( $type_def ) ) {
				return Type::listOf( Type::string() );
			}

			return Type::listOf( $type_def );
		}

		return Type::listOf( $type );
	}

	/**
	 * Get the list of GraphQL type names to exclude from the schema.
	 *
	 * Type names are normalized using `strtolower()`, to avoid case sensitivity issues.
	 *
	 * @since 1.13.0
	 *
	 * @return string[]
	 */
	public function get_excluded_types(): array {
		if ( null === $this->excluded_types ) {
			/**
			 * Filter the list of GraphQL types to exclude from the schema.
			 *
			 * Note: using this filter directly will NOT remove the type from being referenced as a possible interface or a union type.
			 * To remove a GraphQL from the schema **entirely**, please use deregister_graphql_type();
			 *
			 * @param string[] $excluded_types The names of the GraphQL Types to exclude.
			 *
			 * @since 1.13.0
			 */
			$excluded_types = apply_filters( 'graphql_excluded_types', [] );

			// Normalize the types to be lowercase, to avoid case-sensitivity issue when comparing.
			$this->excluded_types = ! empty( $excluded_types ) ? array_map( 'strtolower', $excluded_types ) : [];
		}

		return $this->excluded_types;
	}

	/**
	 * Get the list of GraphQL connections to exclude from the schema.
	 *
	 * Type names are normalized using `strtolower()`, to avoid case sensitivity issues.
	 *
	 * @return string[]
	 *
	 * @since 1.14.0
	 */
	public function get_excluded_connections(): array {
		if ( null === $this->excluded_connections ) {
			/**
			 * Filter the list of GraphQL connections to excluded from the registry.
			 *
			 * @param string[] $excluded_connections The names of the GraphQL connections to exclude.
			 *
			 * @since 1.14.0
			 */
			$excluded_connections = apply_filters( 'graphql_excluded_connections', [] );

			// Normalize the types to be lowercase, to avoid case-sensitivity issue when comparing.
			$this->excluded_connections = ! empty( $excluded_connections ) ? array_map( 'strtolower', $excluded_connections ) : [];
		}

		return $this->excluded_connections;
	}

	/**
	 * Get the list of GraphQL mutation names to exclude from the schema.
	 *
	 * Mutation names are normalized using `strtolower()`, to avoid case sensitivity issues.
	 *
	 * @return string[]
	 * @since 1.14.0
	 */
	public function get_excluded_mutations(): array {
		if ( null === $this->excluded_mutations ) {
			/**
			 * Filter the list of GraphQL mutations to excluded from the registry.
			 *
			 * @param string[] $excluded_mutations The names of the GraphQL mutations to exclude.
			 *
			 * @since 1.14.0
			 */
			$excluded_mutations = apply_filters( 'graphql_excluded_mutations', [] );

			// Normalize the types to be lowercase, to avoid case-sensitivity issue when comparing.
			$this->excluded_mutations = ! empty( $excluded_mutations ) ? array_map( 'strtolower', $excluded_mutations ) : [];
		}

		return $this->excluded_mutations;
	}

	/**
	 * Gets the actual type name, stripped of possible NonNull and ListOf wrappers.
	 *
	 * Returns an empty string if the type modifiers are malformed.
	 *
	 * @param string|array<string|int,mixed> $type The (possibly-wrapped) type name.
	 */
	protected function get_unmodified_type_name( $type ): string {
		if ( ! is_array( $type ) ) {
			return $type;
		}

		$type = array_values( $type )[0] ?? '';

		return $this->get_unmodified_type_name( $type );
	}
}


// File: wp-graphql\src\Registry\Utils\PostObject.php
<?php

namespace WPGraphQL\Registry\Utils;

use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL;
use WPGraphQL\AppContext;
use WPGraphQL\Data\Connection\CommentConnectionResolver;
use WPGraphQL\Data\Connection\PostObjectConnectionResolver;
use WPGraphQL\Data\Connection\TermObjectConnectionResolver;
use WPGraphQL\Model\Post;
use WPGraphQL\Type\Connection\Comments;
use WPGraphQL\Type\Connection\PostObjects;
use WPGraphQL\Type\Connection\TermObjects;
use WP_Post_Type;

/**
 * Class PostObject
 *
 * @package WPGraphQL\Data
 * @since   1.12.0
 */
class PostObject {

	/**
	 * Registers a post_type type to the schema as either a GraphQL object, interface, or union.
	 *
	 * @param \WP_Post_Type $post_type_object Post type.
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_types( WP_Post_Type $post_type_object ) {
		$single_name = $post_type_object->graphql_single_name;

		$config = [
			/* translators: post object singular name w/ description */
			'description' => sprintf( __( 'The %s type', 'wp-graphql' ), $single_name ),
			'connections' => static::get_connections( $post_type_object ),
			'interfaces'  => static::get_interfaces( $post_type_object ),
			'fields'      => static::get_fields( $post_type_object ),
			'model'       => Post::class,
		];

		// Register as GraphQL objects.
		if ( 'object' === $post_type_object->graphql_kind ) {
			register_graphql_object_type( $single_name, $config );

			// Register fields to the Type used for attachments (MediaItem)
			if ( 'attachment' === $post_type_object->name && true === $post_type_object->show_in_graphql && isset( $post_type_object->graphql_single_name ) ) {
				self::register_attachment_fields( $post_type_object );
			}

			return;
		}

		/**
		 * Register as GraphQL interfaces or unions.
		 *
		 * It's assumed that the types used in `resolveType` have already been registered to the schema.
		 */

		// Bail early if graphql_resolve_type isnt a vallable callback.
		if ( empty( $post_type_object->graphql_resolve_type ) || ! is_callable( $post_type_object->graphql_resolve_type ) ) {
			graphql_debug(
				sprintf(
					// translators: %1$s is the post type name, %2$s is the graphql kind.
					__( '%1$s is registered as a GraphQL %2$s, but has no way to resolve the type. Ensure "graphql_resolve_type" is a valid callback function', 'wp-graphql' ),
					$single_name,
					$post_type_object->graphql_kind
				),
				[ 'registered_post_type_object' => $post_type_object ]
			);

			return;
		}

		$config['resolveType'] = $post_type_object->graphql_resolve_type;

		if ( 'interface' === $post_type_object->graphql_kind ) {
			register_graphql_interface_type( $single_name, $config );

			return;
		} elseif ( 'union' === $post_type_object->graphql_kind ) {

			// Bail early if graphql_union_types is not defined.
			if ( empty( $post_type_object->graphql_union_types ) || ! is_array( $post_type_object->graphql_union_types ) ) {
				graphql_debug(
					__( 'Registering a post type with "graphql_kind" => "union" requires "graphql_union_types" to be a valid array of possible GraphQL type names.', 'wp-graphql' ),
					[ 'registered_post_type_object' => $post_type_object ]
				);

				return;
			}

			// Set the possible types for the union.
			$config['typeNames'] = $post_type_object->graphql_union_types;

			register_graphql_union_type( $single_name, $config );
		}
	}

	/**
	 * Gets all the connections for the given post type.
	 *
	 * @param \WP_Post_Type $post_type_object
	 *
	 * @return array<string,array<string,mixed>>
	 */
	protected static function get_connections( WP_Post_Type $post_type_object ) {
		$connections = [];

		// Comments.
		if ( post_type_supports( $post_type_object->name, 'comments' ) ) {
			$connections['comments'] = [
				'toType'         => 'Comment',
				'connectionArgs' => Comments::get_connection_args(),
				'resolve'        => static function ( Post $post, $args, $context, $info ) {
					if ( $post->isRevision ) {
						$id = $post->parentDatabaseId;
					} else {
						$id = $post->ID;
					}

					$resolver = new CommentConnectionResolver( $post, $args, $context, $info );

					return $resolver->set_query_arg( 'post_id', absint( $id ) )->get_connection();
				},
			];
		}

		// Previews.
		if ( ! in_array( $post_type_object->name, [ 'attachment', 'revision' ], true ) ) {
			$connections['preview'] = [
				'toType'             => $post_type_object->graphql_single_name,
				'connectionTypeName' => ucfirst( $post_type_object->graphql_single_name ) . 'ToPreviewConnection',
				'oneToOne'           => true,
				'deprecationReason'  => ( true === $post_type_object->publicly_queryable || true === $post_type_object->public ) ? null
					: sprintf(
						// translators: %s is the post type's GraphQL name.
						__( 'The "%s" Type is not publicly queryable and does not support previews. This field will be removed in the future.', 'wp-graphql' ),
						WPGraphQL\Utils\Utils::format_type_name( $post_type_object->graphql_single_name )
					),
				'resolve'            => static function ( Post $post, $args, AppContext $context, ResolveInfo $info ) {
					if ( $post->isRevision ) {
						return null;
					}

					if ( empty( $post->previewRevisionDatabaseId ) ) {
						return null;
					}

					$resolver = new PostObjectConnectionResolver( $post, $args, $context, $info, 'revision' );
					$resolver->set_query_arg( 'p', $post->previewRevisionDatabaseId );

					return $resolver->one_to_one()->get_connection();
				},
			];
		}

		// Revisions.
		if ( true === post_type_supports( $post_type_object->name, 'revisions' ) ) {
			$connections['revisions'] = [
				'connectionTypeName' => ucfirst( $post_type_object->graphql_single_name ) . 'ToRevisionConnection',
				'toType'             => $post_type_object->graphql_single_name,
				'queryClass'         => 'WP_Query',
				'connectionArgs'     => PostObjects::get_connection_args( [], $post_type_object ),
				'resolve'            => static function ( Post $post, $args, $context, $info ) {
					$resolver = new PostObjectConnectionResolver( $post, $args, $context, $info, 'revision' );
					$resolver->set_query_arg( 'post_parent', $post->ID );

					return $resolver->get_connection();
				},
			];
		}

		// Used to ensure TermNode connection doesn't get registered multiple times.
		$already_registered = false;
		$allowed_taxonomies = WPGraphQL::get_allowed_taxonomies( 'objects' );

		foreach ( $allowed_taxonomies as $tax_object ) {
			if ( ! in_array( $post_type_object->name, $tax_object->object_type, true ) ) {
				continue;
			}

			// TermNode.
			if ( ! $already_registered ) {
				$connections['terms'] = [
					'toType'         => 'TermNode',
					'queryClass'     => 'WP_Term_Query',
					'connectionArgs' => TermObjects::get_connection_args(
						[
							'taxonomies' => [
								'type'        => [ 'list_of' => 'TaxonomyEnum' ],
								'description' => __( 'The Taxonomy to filter terms by', 'wp-graphql' ),
							],
						]
					),
					'resolve'        => static function ( Post $post, $args, AppContext $context, ResolveInfo $info ) {
						$taxonomies = \WPGraphQL::get_allowed_taxonomies();
						$terms      = wp_get_post_terms( $post->ID, $taxonomies, [ 'fields' => 'ids' ] );

						if ( empty( $terms ) || is_wp_error( $terms ) ) {
							return null;
						}
						$resolver = new TermObjectConnectionResolver( $post, $args, $context, $info, $taxonomies );
						$resolver->set_query_arg( 'include', $terms );

						return $resolver->get_connection();
					},
				];

				// We won't need to register this connection again.
				$already_registered = true;
			}

			// TermObjects.
			$connections[ $tax_object->graphql_plural_name ] = [
				'toType'         => $tax_object->graphql_single_name,
				'queryClass'     => 'WP_Term_Query',
				'connectionArgs' => TermObjects::get_connection_args(),
				'resolve'        => static function ( Post $post, $args, AppContext $context, $info ) use ( $tax_object ) {
					$object_id = true === $post->isPreview && ! empty( $post->parentDatabaseId ) ? $post->parentDatabaseId : $post->ID;

					if ( empty( $object_id ) || ! absint( $object_id ) ) {
						return null;
					}

					$resolver = new TermObjectConnectionResolver( $post, $args, $context, $info, $tax_object->name );
					$resolver->set_query_arg( 'object_ids', absint( $object_id ) );

					return $resolver->get_connection();
				},
			];
		}

		// Merge with connections set in register_post_type.
		if ( ! empty( $post_type_object->graphql_connections ) ) {
			$connections = array_merge( $connections, $post_type_object->graphql_connections );
		}

		// Remove excluded connections.
		if ( ! empty( $post_type_object->graphql_exclude_connections ) ) {
			foreach ( $post_type_object->graphql_exclude_connections as $connection_name ) {
				unset( $connections[ lcfirst( $connection_name ) ] );
			}
		}

		return $connections;
	}

	/**
	 * Gets all the interfaces for the given post type.
	 *
	 * @param \WP_Post_Type $post_type_object Post type.
	 *
	 * @return string[]
	 */
	protected static function get_interfaces( WP_Post_Type $post_type_object ) {
		$interfaces = [ 'Node', 'ContentNode', 'DatabaseIdentifier', 'NodeWithTemplate' ];

		if ( true === $post_type_object->public ) {
			$interfaces[] = 'UniformResourceIdentifiable';
		}

		// Only post types that are publicly_queryable are previewable
		if ( 'attachment' !== $post_type_object->name && ( true === $post_type_object->publicly_queryable || true === $post_type_object->public ) ) {
			$interfaces[] = 'Previewable';
		}

		if ( post_type_supports( $post_type_object->name, 'title' ) ) {
			$interfaces[] = 'NodeWithTitle';
		}

		if ( post_type_supports( $post_type_object->name, 'editor' ) ) {
			$interfaces[] = 'NodeWithContentEditor';
		}

		if ( post_type_supports( $post_type_object->name, 'author' ) ) {
			$interfaces[] = 'NodeWithAuthor';
		}

		if ( post_type_supports( $post_type_object->name, 'thumbnail' ) ) {
			$interfaces[] = 'NodeWithFeaturedImage';
		}

		if ( post_type_supports( $post_type_object->name, 'excerpt' ) ) {
			$interfaces[] = 'NodeWithExcerpt';
		}

		if ( post_type_supports( $post_type_object->name, 'comments' ) ) {
			$interfaces[] = 'NodeWithComments';
		}

		if ( post_type_supports( $post_type_object->name, 'trackbacks' ) ) {
			$interfaces[] = 'NodeWithTrackbacks';
		}

		if ( post_type_supports( $post_type_object->name, 'revisions' ) ) {
			$interfaces[] = 'NodeWithRevisions';
		}

		if ( post_type_supports( $post_type_object->name, 'page-attributes' ) ) {
			$interfaces[] = 'NodeWithPageAttributes';
		}

		if ( $post_type_object->hierarchical || in_array(
			$post_type_object->name,
			[
				'attachment',
				'revision',
			],
			true
		) ) {
			$interfaces[] = 'HierarchicalContentNode';
		}

		if ( true === $post_type_object->show_in_nav_menus ) {
			$interfaces[] = 'MenuItemLinkable';
		}

		// Merge with interfaces set in register_post_type.
		if ( ! empty( $post_type_object->graphql_interfaces ) ) {
			$interfaces = array_merge( $interfaces, $post_type_object->graphql_interfaces );
		}

		// Remove excluded interfaces.
		if ( ! empty( $post_type_object->graphql_exclude_interfaces ) ) {
			$interfaces = array_diff( $interfaces, $post_type_object->graphql_exclude_interfaces );
		}

		return $interfaces;
	}

	/**
	 * Registers common post type fields on schema type corresponding to provided post type object.
	 *
	 * @param \WP_Post_Type $post_type_object Post type.
	 *
	 * @return array<string,array<string,mixed>>
	 * @todo make protected after \Type\ObjectType\PostObject::get_fields() is removed.
	 */
	public static function get_fields( WP_Post_Type $post_type_object ) {
		$single_name = $post_type_object->graphql_single_name;
		$fields      = [
			'id'                => [
				'description' => sprintf(
				/* translators: %s: custom post-type name */
					__( 'The globally unique identifier of the %s object.', 'wp-graphql' ),
					$post_type_object->name
				),
			],
			$single_name . 'Id' => [
				'type'              => [
					'non_null' => 'Int',
				],
				'deprecationReason' => __( 'Deprecated in favor of the databaseId field', 'wp-graphql' ),
				'description'       => __( 'The id field matches the WP_Post->ID field.', 'wp-graphql' ),
				'resolve'           => static function ( Post $post ) {
					return absint( $post->ID );
				},
			],
			'hasPassword'       => [
				'type'        => 'Boolean',
				'description' => sprintf(
					// translators: %s: custom post-type name.
					__( 'Whether the %s object is password protected.', 'wp-graphql' ),
					$post_type_object->name
				),
			],
			'password'          => [
				'type'        => 'String',
				'description' => sprintf(
					// translators: %s: custom post-type name.
					__( 'The password for the %s object.', 'wp-graphql' ),
					$post_type_object->name
				),
			],
		];

		if ( 'page' === $post_type_object->name ) {
			$fields['isFrontPage'] = [
				'type'        => [ 'non_null' => 'Bool' ],
				'description' => __( 'Whether this page is set to the static front page.', 'wp-graphql' ),
			];

			$fields['isPostsPage'] = [
				'type'        => [ 'non_null' => 'Bool' ],
				'description' => __( 'Whether this page is set to the blog posts page.', 'wp-graphql' ),
			];

			$fields['isPrivacyPage'] = [
				'type'        => [ 'non_null' => 'Bool' ],
				'description' => __( 'Whether this page is set to the privacy page.', 'wp-graphql' ),
			];
		}

		if ( 'post' === $post_type_object->name ) {
			$fields['isSticky'] = [
				'type'        => [ 'non_null' => 'Bool' ],
				'description' => __( 'Whether this page is sticky', 'wp-graphql' ),
			];
		}

		if ( ! $post_type_object->hierarchical &&
			! in_array(
				$post_type_object->name,
				[
					'attachment',
					'revision',
				],
				true
			) ) {
			$fields['ancestors']['deprecationReason'] = __( 'This content type is not hierarchical and typically will not have ancestors', 'wp-graphql' );
			$fields['parent']['deprecationReason']    = __( 'This content type is not hierarchical and typically will not have a parent', 'wp-graphql' );
		}

		// Merge with fields set in register_post_type.
		if ( ! empty( $post_type_object->graphql_fields ) ) {
			$fields = array_merge( $fields, $post_type_object->graphql_fields );
		}

		// Remove excluded fields.
		if ( ! empty( $post_type_object->graphql_exclude_fields ) ) {
			foreach ( $post_type_object->graphql_exclude_fields as $field_name ) {
				unset( $fields[ $field_name ] );
			}
		}

		return $fields;
	}

	/**
	 * Register fields to the Type used for attachments (MediaItem).
	 *
	 * @param \WP_Post_Type $post_type_object Post type.
	 *
	 * @return void
	 */
	private static function register_attachment_fields( WP_Post_Type $post_type_object ) {
		/**
		 * Register fields custom to the MediaItem Type
		 */
		register_graphql_fields(
			$post_type_object->graphql_single_name,
			[
				'caption'      => [
					'type'        => 'String',
					'description' => __( 'The caption for the resource', 'wp-graphql' ),
					'args'        => [
						'format' => [
							'type'        => 'PostObjectFieldFormatEnum',
							'description' => __( 'Format of the field output', 'wp-graphql' ),
						],
					],
					'resolve'     => static function ( $source, $args ) {
						if ( isset( $args['format'] ) && 'raw' === $args['format'] ) {
							// @codingStandardsIgnoreLine.
							return $source->captionRaw;
						}

						// @codingStandardsIgnoreLine.
						return $source->captionRendered;
					},
				],
				'altText'      => [
					'type'        => 'String',
					'description' => __( 'Alternative text to display when resource is not displayed', 'wp-graphql' ),
				],
				'srcSet'       => [
					'type'        => 'string',
					'args'        => [
						'size' => [
							'type'        => 'MediaItemSizeEnum',
							'description' => __( 'Size of the MediaItem to calculate srcSet with', 'wp-graphql' ),
						],
					],
					'description' => __( 'The srcset attribute specifies the URL of the image to use in different situations. It is a comma separated string of urls and their widths.', 'wp-graphql' ),
					'resolve'     => static function ( $source, $args ) {
						$size = 'medium';
						if ( ! empty( $args['size'] ) ) {
							$size = $args['size'];
						}

						$src_set = wp_get_attachment_image_srcset( $source->ID, $size );

						return ! empty( $src_set ) ? $src_set : null;
					},
				],
				'sizes'        => [
					'type'        => 'string',
					'args'        => [
						'size' => [
							'type'        => 'MediaItemSizeEnum',
							'description' => __( 'Size of the MediaItem to calculate sizes with', 'wp-graphql' ),
						],
					],
					'description' => __( 'The sizes attribute value for an image.', 'wp-graphql' ),
					'resolve'     => static function ( $source, $args ) {
						$size = 'medium';
						if ( ! empty( $args['size'] ) ) {
							$size = $args['size'];
						}

						$image = wp_get_attachment_image_src( $source->ID, $size );
						if ( $image ) {
							list( $src, $width, $height ) = $image;
							$sizes                        = wp_calculate_image_sizes(
								[
									absint( $width ),
									absint( $height ),
								],
								$src,
								null,
								$source->ID
							);

							return ! empty( $sizes ) ? $sizes : null;
						}

						return null;
					},
				],
				'description'  => [
					'type'        => 'String',
					'description' => __( 'Description of the image (stored as post_content)', 'wp-graphql' ),
					'args'        => [
						'format' => [
							'type'        => 'PostObjectFieldFormatEnum',
							'description' => __( 'Format of the field output', 'wp-graphql' ),
						],
					],
					'resolve'     => static function ( $source, $args ) {
						if ( isset( $args['format'] ) && 'raw' === $args['format'] ) {
							// @codingStandardsIgnoreLine.
							return $source->descriptionRaw;
						}

						// @codingStandardsIgnoreLine.
						return $source->descriptionRendered;
					},
				],
				'mediaItemUrl' => [
					'type'        => 'String',
					'description' => __( 'Url of the mediaItem', 'wp-graphql' ),
				],
				'mediaType'    => [
					'type'        => 'String',
					'description' => __( 'Type of resource', 'wp-graphql' ),
				],
				'sourceUrl'    => [
					'type'        => 'String',
					'description' => __( 'Url of the mediaItem', 'wp-graphql' ),
					'args'        => [
						'size' => [
							'type'        => 'MediaItemSizeEnum',
							'description' => __( 'Size of the MediaItem to return', 'wp-graphql' ),
						],
					],
					'resolve'     => static function ( $image, $args ) {
						// @codingStandardsIgnoreLine.
						$size = null;
						if ( isset( $args['size'] ) ) {
							$size = ( 'full' === $args['size'] ) ? 'large' : $args['size'];
						}

						return ! empty( $size ) ? $image->sourceUrlsBySize[ $size ] : $image->sourceUrl;
					},
				],
				'fileSize'     => [
					'type'        => 'Int',
					'description' => __( 'The filesize in bytes of the resource', 'wp-graphql' ),
					'args'        => [
						'size' => [
							'type'        => 'MediaItemSizeEnum',
							'description' => __( 'Size of the MediaItem to return', 'wp-graphql' ),
						],
					],
					'resolve'     => static function ( $image, $args ) {

						// @codingStandardsIgnoreLine.
						$size = null;
						if ( isset( $args['size'] ) ) {
							$size = ( 'full' === $args['size'] ) ? 'large' : $args['size'];
						}

						$sourceUrl     = ! empty( $size ) ? $image->sourceUrlsBySize[ $size ] : $image->mediaItemUrl;
						$path_parts    = pathinfo( $sourceUrl );
						$original_file = get_attached_file( absint( $image->databaseId ) );
						$filesize_path = ! empty( $original_file ) ? path_join( dirname( $original_file ), $path_parts['basename'] ) : null;

						return ! empty( $filesize_path ) ? filesize( $filesize_path ) : null;
					},
				],
				'mimeType'     => [
					'type'        => 'String',
					'description' => __( 'The mime type of the mediaItem', 'wp-graphql' ),
				],
				'mediaDetails' => [
					'type'        => 'MediaDetails',
					'description' => __( 'Details about the mediaItem', 'wp-graphql' ),
				],
			]
		);
	}
}


// File: wp-graphql\src\Registry\Utils\TermObject.php
<?php

namespace WPGraphQL\Registry\Utils;

use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL;
use WPGraphQL\AppContext;
use WPGraphQL\Data\Connection\PostObjectConnectionResolver;
use WPGraphQL\Data\Connection\TaxonomyConnectionResolver;
use WPGraphQL\Data\Connection\TermObjectConnectionResolver;
use WPGraphQL\Model\Term;
use WPGraphQL\Type\Connection\PostObjects;
use WPGraphQL\Type\Connection\TermObjects;
use WP_Taxonomy;

/**
 * Class TermObjectType
 *
 * @package WPGraphQL\Data
 * @since   1.12.0
 */
class TermObject {

	/**
	 * Registers a taxonomy type to the schema as either a GraphQL object, interface, or union.
	 *
	 * @param \WP_Taxonomy $tax_object Taxonomy.
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_types( WP_Taxonomy $tax_object ) {
		$single_name = $tax_object->graphql_single_name;

		$config = [
			'description' => sprintf(
				// translators: %s is the term object singular name.
				__( 'The %s type', 'wp-graphql' ),
				$single_name
			),
			'connections' => static::get_connections( $tax_object ),
			'interfaces'  => static::get_interfaces( $tax_object ),
			'fields'      => static::get_fields( $tax_object ),
			'model'       => Term::class,
		];

		// Register as GraphQL objects.
		if ( 'object' === $tax_object->graphql_kind ) {
			register_graphql_object_type( $single_name, $config );
			return;
		}

		/**
		 * Register as GraphQL interfaces or unions.
		 *
		 * It's assumed that the types used in `resolveType` have already been registered to the schema.
		 */

		// Bail early if graphql_resolve_type isnt a vallable callback.
		if ( empty( $tax_object->graphql_resolve_type ) || ! is_callable( $tax_object->graphql_resolve_type ) ) {
			graphql_debug(
				sprintf(
					// translators: %1$s is the term object singular name, %2$s is the graphql kind.
					__( '%1$s is registered as a GraphQL %2$s, but has no way to resolve the type. Ensure "graphql_resolve_type" is a valid callback function', 'wp-graphql' ),
					$single_name,
					$tax_object->graphql_kind
				),
				[ 'registered_taxonomy_object' => $tax_object ]
			);

			return;
		}

		$config['resolveType'] = $tax_object->graphql_resolve_type;

		if ( 'interface' === $tax_object->graphql_kind ) {
			register_graphql_interface_type( $single_name, $config );

			return;
		} elseif ( 'union' === $tax_object->graphql_kind ) {

			// Bail early if graphql_union_types is not defined.
			if ( empty( $tax_object->graphql_union_types ) || ! is_array( $tax_object->graphql_union_types ) ) {
				graphql_debug(
					__( 'Registering a taxonomy with "graphql_kind" => "union" requires "graphql_union_types" to be a valid array of possible GraphQL type names.', 'wp-graphql' ),
					[ 'registered_taxonomy_object' => $tax_object ]
				);

				return;
			}

			// Set the possible types for the union.
			$config['typeNames'] = $tax_object->graphql_union_types;

			register_graphql_union_type( $single_name, $config );
		}
	}

	/**
	 * Gets all the connections for the given post type.
	 *
	 * @param \WP_Taxonomy $tax_object
	 *
	 * @return array<string,array<string,mixed>>
	 */
	protected static function get_connections( WP_Taxonomy $tax_object ) {
		$connections = [];

		// Taxonomy.
		// @todo connection move to TermNode (breaking).
		$connections['taxonomy'] = [
			'toType'   => 'Taxonomy',
			'oneToOne' => true,
			'resolve'  => static function ( Term $source, $args, $context, $info ) {
				if ( empty( $source->taxonomyName ) ) {
					return null;
				}
				$resolver = new TaxonomyConnectionResolver( $source, $args, $context, $info );
				$resolver->set_query_arg( 'name', $source->taxonomyName );
				return $resolver->one_to_one()->get_connection();
			},
		];

		if ( true === $tax_object->hierarchical ) {
			// Children.
			$connections['children'] = [
				'toType'         => $tax_object->graphql_single_name,
				'description'    => sprintf(
					// translators: %1$s is the term object singular name, %2$s is the term object plural name.
					__( 'Connection between the %1$s type and its children %2$s.', 'wp-graphql' ),
					$tax_object->graphql_single_name,
					$tax_object->graphql_plural_name
				),
				'connectionArgs' => TermObjects::get_connection_args(),
				'queryClass'     => 'WP_Term_Query',
				'resolve'        => static function ( Term $term, $args, AppContext $context, $info ) {
					$resolver = new TermObjectConnectionResolver( $term, $args, $context, $info );
					$resolver->set_query_arg( 'parent', $term->term_id );

					return $resolver->get_connection();
				},
			];

			// Parent.
			$connections['parent'] = [
				'toType'             => $tax_object->graphql_single_name,
				'description'        => sprintf(
					// translators: %s is the term object singular name.
					__( 'Connection between the %1$s type and its parent %1$s.', 'wp-graphql' ),
					$tax_object->graphql_single_name
				),
				'connectionTypeName' => ucfirst( $tax_object->graphql_single_name ) . 'ToParent' . ucfirst( $tax_object->graphql_single_name ) . 'Connection',
				'oneToOne'           => true,
				'resolve'            => static function ( Term $term, $args, AppContext $context, $info ) use ( $tax_object ) {
					if ( ! isset( $term->parentDatabaseId ) || empty( $term->parentDatabaseId ) ) {
						return null;
					}

					$resolver = new TermObjectConnectionResolver( $term, $args, $context, $info, $tax_object->name );
					$resolver->set_query_arg( 'include', $term->parentDatabaseId );

					return $resolver->one_to_one()->get_connection();
				},
			];

			// Ancestors.
			$connections['ancestors'] = [
				'toType'             => $tax_object->graphql_single_name,
				'description'        => __( 'The ancestors of the node. Default ordered as lowest (closest to the child) to highest (closest to the root).', 'wp-graphql' ),
				'connectionTypeName' => ucfirst( $tax_object->graphql_single_name ) . 'ToAncestors' . ucfirst( $tax_object->graphql_single_name ) . 'Connection',
				'resolve'            => static function ( Term $term, $args, AppContext $context, $info ) use ( $tax_object ) {
					$ancestor_ids = get_ancestors( absint( $term->term_id ), $term->taxonomyName, 'taxonomy' );

					if ( empty( $ancestor_ids ) ) {
						return null;
					}

					$resolver = new TermObjectConnectionResolver( $term, $args, $context, $info, $tax_object->name );
					$resolver->set_query_arg( 'include', $ancestor_ids );
					$resolver->set_query_arg( 'orderby', 'include' );

					return $resolver->get_connection();
				},
			];
		}

		// Used to ensure contentNodes connection doesn't get registered multiple times.
		$already_registered = false;
		$allowed_post_types = WPGraphQL::get_allowed_post_types( 'objects' );

		foreach ( $allowed_post_types as $post_type_object ) {
			if ( ! in_array( $tax_object->name, get_object_taxonomies( $post_type_object->name ), true ) ) {
				continue;
			}

			// ContentNodes.
			if ( ! $already_registered ) {
				$connections['contentNodes'] = PostObjects::get_connection_config(
					$tax_object,
					[
						'toType'  => 'ContentNode',
						'resolve' => static function ( Term $term, $args, $context, $info ) {
							$resolver = new PostObjectConnectionResolver( $term, $args, $context, $info, 'any' );
							$resolver->set_query_arg(
								'tax_query',
								[
									[
										'taxonomy'         => $term->taxonomyName,
										'terms'            => [ $term->term_id ],
										'field'            => 'term_id',
										'include_children' => false,
									],
								]
							);

							return $resolver->get_connection();
						},
					]
				);

				// We won't need to register this connection again.
				$already_registered = true;
			}

			// PostObjects.
			$connections[ $post_type_object->graphql_plural_name ] = PostObjects::get_connection_config(
				$post_type_object,
				[
					'toType'     => $post_type_object->graphql_single_name,
					'queryClass' => 'WP_Query',
					'resolve'    => static function ( Term $term, $args, AppContext $context, ResolveInfo $info ) use ( $post_type_object ) {
						$resolver = new PostObjectConnectionResolver( $term, $args, $context, $info, $post_type_object->name );
						$resolver->set_query_arg(
							'tax_query',
							[
								[
									'taxonomy'         => $term->taxonomyName,
									'terms'            => [ $term->term_id ],
									'field'            => 'term_id',
									'include_children' => false,
								],
							]
						);

						return $resolver->get_connection();
					},
				]
			);
		}

		// Merge with connections set in register_taxonomy.
		if ( ! empty( $tax_object->graphql_connections ) ) {
			$connections = array_merge( $connections, $tax_object->graphql_connections );
		}

		// Remove excluded connections.
		if ( ! empty( $tax_object->graphql_exclude_connections ) ) {
			foreach ( $tax_object->graphql_exclude_connections as $connection_name ) {
				unset( $connections[ lcfirst( $connection_name ) ] );
			}
		}

		return $connections;
	}
	/**
	 * Gets all the interfaces for the given Taxonomy.
	 *
	 * @param \WP_Taxonomy $tax_object Taxonomy.
	 *
	 * @return string[]
	 */
	protected static function get_interfaces( WP_Taxonomy $tax_object ) {
		$interfaces = [ 'Node', 'TermNode', 'DatabaseIdentifier' ];

		if ( true === $tax_object->public ) {
			$interfaces[] = 'UniformResourceIdentifiable';
		}

		if ( $tax_object->hierarchical ) {
			$interfaces[] = 'HierarchicalTermNode';
		}

		if ( true === $tax_object->show_in_nav_menus ) {
			$interfaces[] = 'MenuItemLinkable';
		}

		// Merge with interfaces set in register_taxonomy.
		if ( ! empty( $tax_object->graphql_interfaces ) ) {
			$interfaces = array_merge( $interfaces, $tax_object->graphql_interfaces );
		}

		// Remove excluded interfaces.
		if ( ! empty( $tax_object->graphql_exclude_interfaces ) ) {
			$interfaces = array_diff( $interfaces, $tax_object->graphql_exclude_interfaces );
		}

		return $interfaces;
	}

	/**
	 * Registers common Taxonomy fields on schema type corresponding to provided Taxonomy object.
	 *
	 * @param \WP_Taxonomy $tax_object Taxonomy.
	 *
	 * @return array<string,array<string,mixed>>[]
	 */
	protected static function get_fields( WP_Taxonomy $tax_object ) {
		$single_name = $tax_object->graphql_single_name;
		$fields      = [
			$single_name . 'Id' => [
				'type'              => 'Int',
				'deprecationReason' => __( 'Deprecated in favor of databaseId', 'wp-graphql' ),
				'description'       => __( 'The id field matches the WP_Post->ID field.', 'wp-graphql' ),
				'resolve'           => static function ( Term $term ) {
					return absint( $term->term_id );
				},
			],
		];

		// Merge with fields set in register_taxonomy.
		if ( ! empty( $tax_object->graphql_fields ) ) {
			$fields = array_merge( $fields, $tax_object->graphql_fields );
		}

		// Remove excluded fields.
		if ( ! empty( $tax_object->graphql_exclude_fields ) ) {
			foreach ( $tax_object->graphql_exclude_fields as $field_name ) {
				unset( $fields[ $field_name ] );
			}
		}

		return $fields;
	}
}


// File: wp-graphql\src\Server\WPHelper.php
<?php

namespace WPGraphQL\Server;

use GraphQL\Server\Helper;

/**
 * Extends GraphQL\Server\Helper to apply filters and parse query extensions.
 *
 * @package WPGraphQL\Server
 */
class WPHelper extends Helper {

	/**
	 * Parses normalized request params and returns instance of OperationParams
	 * or array of OperationParams in case of batch operation.
	 *
	 * @param string  $method The method of the request (GET, POST, etc).
	 * @param mixed[] $bodyParams The params passed to the body of the request.
	 * @param mixed[] $queryParams The query params passed to the request.
	 *
	 * @return \GraphQL\Server\OperationParams|\GraphQL\Server\OperationParams[]
	 * @throws \GraphQL\Server\RequestError Throws RequestError.
	 */
	public function parseRequestParams( $method, array $bodyParams, array $queryParams ) {
		// Apply wp_unslash to query (GET) variables to undo wp_magic_quotes. We
		// don't need to do this for POST variables because graphql-php reads the
		// HTTP body directly.
		$parsed_body_params = $this->parse_params( $bodyParams );

		$parsed_query_params = $this->parse_extensions( wp_unslash( $queryParams ) );

		$request_context = [
			'method'       => $method,
			'query_params' => ! empty( $parsed_query_params ) ? $parsed_query_params : null,
			'body_params'  => ! empty( $parsed_body_params ) ? $parsed_body_params : null,
		];

		/**
		 * Allow the request data to be filtered. Previously this filter was only
		 * applied to non-HTTP requests. Since 0.2.0, we will apply it to all
		 * requests.
		 *
		 * This is a great place to hook if you are interested in implementing
		 * persisted queries (and ends up being a bit more flexible than
		 * graphql-php's built-in persistentQueryLoader).
		 *
		 * @param mixed[] $data            An array containing the pieces of the data of the GraphQL request
		 * @param mixed[] $request_context An array containing the both body and query params
		 */
		if ( 'GET' === $method ) {
			$parsed_query_params = apply_filters( 'graphql_request_data', $parsed_query_params, $request_context );
			// In GET requests there cannot be any body params so it's empty.
			return parent::parseRequestParams( $method, [], $parsed_query_params );
		}

		// In POST requests the query params are ignored by default but users can
		// merge them into the body params manually using the $request_context if
		// needed.
		$parsed_body_params = apply_filters( 'graphql_request_data', $parsed_body_params, $request_context );
		return parent::parseRequestParams( $method, $parsed_body_params, [] );
	}

	/**
	 * Parse parameters and proxy to parse_extensions.
	 *
	 * @param array<string,mixed>|array<string,mixed>[] $params Request parameters.
	 * @return array<string,mixed>|array<string,mixed>[]
	 */
	private function parse_params( $params ) {
		if ( isset( $params[0] ) ) {
			return array_map( [ $this, 'parse_extensions' ], $params );
		}

		return $this->parse_extensions( $params );
	}

	/**
	 * Parse query extensions.
	 *
	 * @param  array<string,mixed> $params Request parameters.
	 * @return array<string,mixed>
	 */
	private function parse_extensions( $params ) {
		if ( isset( $params['extensions'] ) && is_string( $params['extensions'] ) ) {
			$tmp = json_decode( $params['extensions'], true );
			if ( ! json_last_error() ) {
				$params['extensions'] = $tmp;
			}
		}

		// Apollo server/client compatibility: look for the query id in extensions
		if ( isset( $params['extensions']['persistedQuery']['sha256Hash'] ) && ! isset( $params['queryId'] ) ) {
			$params['queryId'] = $params['extensions']['persistedQuery']['sha256Hash'];
			unset( $params['extensions']['persistedQuery'] );
		}

		return $params;
	}
}


// File: wp-graphql\src\Server\ValidationRules\DisableIntrospection.php
<?php

namespace WPGraphQL\Server\ValidationRules;

/**
 * Class DisableIntrospection
 *
 * @package WPGraphQL\Server\ValidationRules
 */
class DisableIntrospection extends \GraphQL\Validator\Rules\DisableIntrospection {

	/**
	 * Whether the rule is enabled or not.
	 *
	 * @return bool
	 */
	public function isEnabled() {
		$enabled = false;

		if ( ! get_current_user_id() && ! \WPGraphQL::debug() && 'off' === get_graphql_setting( 'public_introspection_enabled', 'off' ) ) {
			$enabled = true;
		}

		return $enabled;
	}
}


// File: wp-graphql\src\Server\ValidationRules\QueryDepth.php
<?php

namespace WPGraphQL\Server\ValidationRules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\FragmentSpreadNode;
use GraphQL\Language\AST\InlineFragmentNode;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Language\AST\SelectionSetNode;
use GraphQL\Validator\Rules\QuerySecurityRule;
use GraphQL\Validator\ValidationContext;
use function sprintf;

/**
 * Class QueryDepth
 *
 * @package WPGraphQL\Server\ValidationRules
 */
class QueryDepth extends QuerySecurityRule {

	/**
	 * The max query depth allowed.
	 *
	 * @var int
	 */
	private $maxQueryDepth;

	/**
	 * QueryDepth constructor.
	 */
	public function __construct() {
		$max_query_depth = get_graphql_setting( 'query_depth_max', 10 );
		$max_query_depth = absint( $max_query_depth ) ?? 10;
		$this->setMaxQueryDepth( $max_query_depth );
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param \GraphQL\Validator\ValidationContext $context
	 *
	 * @return callable[]
	 */
	public function getVisitor( ValidationContext $context ) {
		return $this->invokeIfNeeded(
			$context,
			// @phpstan-ignore-next-line
			[
				NodeKind::OPERATION_DEFINITION => [
					'leave' => function ( OperationDefinitionNode $operationDefinition ) use ( $context ): void {
						$maxDepth = $this->fieldDepth( $operationDefinition );

						if ( $maxDepth <= $this->getMaxQueryDepth() ) {
							return;
						}

						$context->reportError(
							new Error( $this->errorMessage( $this->getMaxQueryDepth(), $maxDepth ) )
						);
					},
				],
			]
		);
	}

	/**
	 * Determine field depth
	 *
	 * @param mixed $node The node being analyzed
	 * @param int   $depth The depth of the field
	 * @param int   $maxDepth The max depth allowed
	 *
	 * @return int|mixed
	 */
	private function fieldDepth( $node, $depth = 0, $maxDepth = 0 ) {
		if ( isset( $node->selectionSet ) && $node->selectionSet instanceof SelectionSetNode ) {
			foreach ( $node->selectionSet->selections as $childNode ) {
				$maxDepth = $this->nodeDepth( $childNode, $depth, $maxDepth );
			}
		}

		return $maxDepth;
	}

	/**
	 * Determine node depth
	 *
	 * @param \GraphQL\Language\AST\Node $node The node being analyzed in the operation
	 * @param int                        $depth The depth of the operation
	 * @param int                        $maxDepth The Max Depth of the operation
	 *
	 * @return int|mixed
	 */
	private function nodeDepth( Node $node, $depth = 0, $maxDepth = 0 ) {
		switch ( true ) {
			case $node instanceof FieldNode:
				// node has children?
				if ( isset( $node->selectionSet ) ) {
					// update maxDepth if needed
					if ( $depth > $maxDepth ) {
						$maxDepth = $depth;
					}
					$maxDepth = $this->fieldDepth( $node, $depth + 1, $maxDepth );
				}
				break;

			case $node instanceof InlineFragmentNode:
				// node has children?
				$maxDepth = $this->fieldDepth( $node, $depth, $maxDepth );
				break;

			case $node instanceof FragmentSpreadNode:
				$fragment = $this->getFragment( $node );

				if ( null !== $fragment ) {
					$maxDepth = $this->fieldDepth( $fragment, $depth, $maxDepth );
				}
				break;
		}

		return $maxDepth;
	}

	/**
	 * Return the maxQueryDepth allowed
	 *
	 * @return int
	 */
	public function getMaxQueryDepth() {
		return $this->maxQueryDepth;
	}

	/**
	 * Set max query depth. If equal to 0 no check is done. Must be greater or equal to 0.
	 *
	 * @param int $maxQueryDepth The max query depth to allow for GraphQL operations
	 *
	 * @return void
	 */
	public function setMaxQueryDepth( int $maxQueryDepth ) {
		$this->checkIfGreaterOrEqualToZero( 'maxQueryDepth', $maxQueryDepth );

		$this->maxQueryDepth = $maxQueryDepth;
	}

	/**
	 * Return the max query depth error message
	 *
	 * @param int $max The max number of levels to allow in GraphQL operation
	 * @param int $count The number of levels in the current operation
	 *
	 * @return string
	 */
	public function errorMessage( $max, $count ) {
		return sprintf( 'The server administrator has limited the max query depth to %d, but the requested query has %d levels.', $max, $count );
	}

	/**
	 * Determine whether the rule should be enabled
	 *
	 * @return bool
	 */
	protected function isEnabled() {
		$is_enabled = false;

		$enabled = get_graphql_setting( 'query_depth_enabled', 'off' );

		if ( 'on' === $enabled && absint( $this->getMaxQueryDepth() ) && 1 <= $this->getMaxQueryDepth() ) {
			$is_enabled = true;
		}

		return $is_enabled;
	}
}


// File: wp-graphql\src\Server\ValidationRules\RequireAuthentication.php
<?php

namespace WPGraphQL\Server\ValidationRules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Type\Definition\Type;
use GraphQL\Validator\Rules\QuerySecurityRule;
use GraphQL\Validator\ValidationContext;

/**
 * Class RequireAuthentication
 *
 * @package WPGraphQL\Server\ValidationRules
 */
class RequireAuthentication extends QuerySecurityRule {

	/**
	 * Whether the rule is enabled or not.
	 *
	 * @return bool
	 */
	protected function isEnabled() {
		$restrict_endpoint = null;

		/**
		 * Allows overriding the default graphql_restrict_endpoint behavior. Returning anything other
		 * than null will skip the default restrict checks.
		 *
		 * @param bool|null $restrict_endpoint Whether to restrict the endpoint. Defaults to null
		*/
		$restrict_endpoint = apply_filters( 'graphql_pre_restrict_endpoint', $restrict_endpoint );

		if ( null !== $restrict_endpoint ) {
			return (bool) $restrict_endpoint;
		}

		// Check to see if the endpoint should be restricted to logged in users
		$restrict_endpoint = get_graphql_setting( 'restrict_endpoint_to_logged_in_users' );

		if ( false === is_graphql_http_request() ) {
			return false;
		}

		if ( empty( $restrict_endpoint ) ) {
			return false;
		}

		if ( 'on' !== $restrict_endpoint ) {
			return false;
		}

		if ( null !== wp_get_current_user() && 0 !== wp_get_current_user()->ID ) {
			return false;
		}

		return true;
	}

	/**
	 * {@inheritDoc}
	 *
	 * @param \GraphQL\Validator\ValidationContext $context
	 *
	 * @return callable[]
	 */
	public function getVisitor( ValidationContext $context ) {
		$allowed_root_fields = [];

		/**
		 * Filters the allowed
		 *
		 * @param string[]                             $allowed_root_fields The Root fields allowed to be requested without authentication
		 * @param \GraphQL\Validator\ValidationContext $context The Validation context of the field being executed.
		 */
		$allowed_root_fields = apply_filters( 'graphql_require_authentication_allowed_fields', $allowed_root_fields, $context );

		return $this->invokeIfNeeded(
			$context,
			[
				NodeKind::FIELD => static function ( FieldNode $node ) use ( $context, $allowed_root_fields ) {
					$parent_type = $context->getParentType();

					if ( ! $parent_type instanceof Type || empty( $parent_type->name ) ) {
						return;
					}

					if ( ! in_array( $parent_type->name, [ 'RootQuery', 'RootSubscription', 'RootMutation' ], true ) ) {
						return;
					}

					if ( empty( $allowed_root_fields ) || ! is_array( $allowed_root_fields ) || ! in_array( $node->name->value, $allowed_root_fields, true ) ) {
						$context->reportError(
							new Error(
								sprintf(
									// translators: %s is the field name
									__( 'The field "%s" cannot be accessed without authentication.', 'wp-graphql' ),
									$context->getParentType() . '.' . $node->name->value
								),
								// @phpstan-ignore-next-line
								[ $node ]
							)
						);
					}
				},
			]
		);
	}
}


// File: wp-graphql\src\Type\WPConnectionType.php
<?php
namespace WPGraphQL\Type;

use GraphQL\Exception\InvalidArgument;
use WPGraphQL\Registry\TypeRegistry;
use WPGraphQL\Type\InterfaceType\PageInfo;
use WPGraphQL\Utils\Utils;

/**
 * Class WPConnectionType
 *
 * @package WPGraphQL\Type
 */
class WPConnectionType {

	/**
	 * Configuration for how auth should be handled on the connection field
	 *
	 * @var array<string,mixed>
	 */
	protected $auth;

	/**
	 * The config for the connection
	 *
	 * @var array<string,mixed>
	 */
	protected $config;

	/**
	 * The args configured for the connection
	 *
	 * @var array<string,array<string,mixed>>
	 */
	protected $connection_args;

	/**
	 * The fields to show on the connection
	 *
	 * @var array<string,mixed>
	 */
	protected $connection_fields;

	/**
	 * @var string[]|null
	 */
	protected $connection_interfaces;

	/**
	 * The name of the connection
	 *
	 * @var mixed|string
	 */
	protected $connection_name;

	/**
	 * The fields to expose on the edge of the connection
	 *
	 * @var array<string,array<string,mixed>>
	 */
	protected $edge_fields;

	/**
	 * The name of the field the connection will be exposed as
	 *
	 * @var string
	 */
	protected $from_field_name;

	/**
	 * The name of the GraphQL Type the connection stems from
	 *
	 * @var string
	 */
	protected $from_type;

	/**
	 * Whether the connection is a one-to-one connection (default is false)
	 *
	 * @var bool
	 */
	protected $one_to_one;

	/**
	 * The Query Class that is used to resolve the connection.
	 *
	 * @var string
	 */
	protected $query_class;

	/**
	 * The resolver function to resolve the connection
	 *
	 * @var callable(mixed $root,array<string,mixed> $args,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info):mixed
	 */
	protected $resolve_connection;

	/**
	 * @var mixed|null
	 */
	protected $resolve_cursor;

	/**
	 * Whether to  include and generate the default GraphQL interfaces on the connection Object types.
	 *
	 * @var bool
	 */
	protected $include_default_interfaces;

	/**
	 * The name of the GraphQL Type the connection connects to
	 *
	 * @var string
	 */
	protected $to_type;

	/**
	 * The WPGraphQL TypeRegistry
	 *
	 * @var \WPGraphQL\Registry\TypeRegistry
	 */
	protected $type_registry;

	/**
	 * The where args for the connection
	 *
	 * @var array<string,array<string,mixed>>
	 */
	protected $where_args;

	/**
	 * WPConnectionType constructor.
	 *
	 * @param array<string,mixed>              $config        The config array for the connection
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry Instance of the WPGraphQL Type Registry
	 *
	 * @throws \Exception
	 */
	public function __construct( array $config, TypeRegistry $type_registry ) {
		$this->type_registry = $type_registry;

		/**
		 * Filter the config of WPConnectionType
		 *
		 * @param array<string,mixed>              $config             Array of configuration options passed to the WPConnectionType when instantiating a new type
		 * @param \WPGraphQL\Type\WPConnectionType $wp_connection_type The instance of the WPConnectionType class
		 */
		$config = apply_filters( 'graphql_wp_connection_type_config', $config, $this );

		$this->validate_config( $config );

		$this->config    = $config;
		$this->from_type = $config['fromType'];
		$this->to_type   = $config['toType'];

		/**
		 * Filter the connection field name.
		 *
		 * @internal This filter is internal and used by rename_graphql_field(). It is not intended for use by external code.
		 *
		 * @param string $from_field_name The name of the field the connection will be exposed as.
		 */
		$this->from_field_name = apply_filters( "graphql_wp_connection_{$this->from_type}_from_field_name", $config['fromFieldName'] );

		$this->connection_name = ! empty( $config['connectionTypeName'] ) ? $config['connectionTypeName'] : $this->get_connection_name( $this->from_type, $this->to_type, $this->from_field_name );

		/**
		 * Bail if the connection has been de-registered or excluded.
		 */
		if ( ! $this->should_register() ) {
			return;
		}

		$this->auth                       = array_key_exists( 'auth', $config ) && is_array( $config['auth'] ) ? $config['auth'] : [];
		$this->connection_fields          = array_key_exists( 'connectionFields', $config ) && is_array( $config['connectionFields'] ) ? $config['connectionFields'] : [];
		$this->connection_args            = array_key_exists( 'connectionArgs', $config ) && is_array( $config['connectionArgs'] ) ? $config['connectionArgs'] : [];
		$this->edge_fields                = array_key_exists( 'edgeFields', $config ) && is_array( $config['edgeFields'] ) ? $config['edgeFields'] : [];
		$this->resolve_cursor             = array_key_exists( 'resolveCursor', $config ) && is_callable( $config['resolve'] ) ? $config['resolveCursor'] : null;
		$this->resolve_connection         = array_key_exists( 'resolve', $config ) && is_callable( $config['resolve'] ) ? $config['resolve'] : static function () {
			return null;
		};
		$this->where_args                 = [];
		$this->one_to_one                 = isset( $config['oneToOne'] ) && true === $config['oneToOne'];
		$this->connection_interfaces      = isset( $config['connectionInterfaces'] ) && is_array( $config['connectionInterfaces'] ) ? $config['connectionInterfaces'] : [];
		$this->include_default_interfaces = isset( $config['includeDefaultInterfaces'] ) ? (bool) $config['includeDefaultInterfaces'] : true;
		$this->query_class                = array_key_exists( 'queryClass', $config ) && ! empty( $config['queryClass'] ) ? $config['queryClass'] : null;

		/**
		 * Run an action when the WPConnectionType is instantiating.
		 *
		 * @param array<string,mixed>              $config             Array of configuration options passed to the WPObjectType when instantiating a new type
		 * @param \WPGraphQL\Type\WPConnectionType $wp_connection_type The instance of the WPConnectionType class
		 *
		 * @since 1.13.0
		 */
		do_action( 'graphql_wp_connection_type', $config, $this );

		$this->register_connection();
	}

	/**
	 * Validates that essential key/value pairs are passed to the connection config.
	 *
	 * @param array<string,mixed> $config The config array for the connection.
	 *
	 * @throws \GraphQL\Exception\InvalidArgument If the config is invalid.
	 */
	protected function validate_config( array $config ): void {
		if ( ! array_key_exists( 'fromType', $config ) ) {
			throw new InvalidArgument( esc_html__( 'Connection config needs to have at least a fromType defined', 'wp-graphql' ) );
		}

		if ( ! array_key_exists( 'toType', $config ) ) {
			throw new InvalidArgument( esc_html__( 'Connection config needs to have a "toType" defined', 'wp-graphql' ) );
		}

		if ( ! array_key_exists( 'fromFieldName', $config ) || ! is_string( $config['fromFieldName'] ) ) {
			throw new InvalidArgument( esc_html__( 'Connection config needs to have "fromFieldName" defined as a string value', 'wp-graphql' ) );
		}
	}

	/**
	 * Get edge interfaces
	 *
	 * @param string[] $interfaces Array of interfaces to add to the edge.
	 *
	 * @return string[]
	 */
	protected function get_edge_interfaces( array $interfaces = [] ): array {

		// Only include the default interfaces if the user hasnt explicitly opted out.
		if ( false !== $this->include_default_interfaces ) {
			$interfaces[] = Utils::format_type_name( $this->to_type . 'ConnectionEdge' );
		}

		if ( ! empty( $this->connection_interfaces ) ) {
			foreach ( $this->connection_interfaces as $connection_interface ) {
				$interfaces[] = str_ends_with( $connection_interface, 'Edge' ) ? $connection_interface : $connection_interface . 'Edge';
			}
		}
		return $interfaces;
	}

	/**
	 * Utility method that formats the connection name given the name of the from Type and the to
	 * Type
	 *
	 * @param string $from_type        Name of the Type the connection is coming from
	 * @param string $to_type          Name of the Type the connection is going to
	 * @param string $from_field_name  Acts as an alternative "toType" if connection type already defined using $to_type.
	 */
	public function get_connection_name( string $from_type, string $to_type, string $from_field_name ): string {

		// Create connection name using $from_type + To + $to_type + Connection.
		$connection_name = ucfirst( $from_type ) . 'To' . ucfirst( $to_type ) . 'Connection';

		// If connection type already exists with that connection name. Set connection name using
		// $from_field_name + To + $to_type + Connection.
		if ( $this->type_registry->has_type( $connection_name ) ) {
			$connection_name = ucfirst( $from_type ) . 'To' . ucfirst( $from_field_name ) . 'Connection';
		}

		return $connection_name;
	}

	/**
	 * If the connection includes connection args in the config, this registers the input args
	 * for the connection
	 *
	 * @return void
	 *
	 * @throws \Exception
	 */
	protected function register_connection_input() {
		if ( empty( $this->connection_args ) ) {
			return;
		}

		$input_name = $this->connection_name . 'WhereArgs';

		if ( $this->type_registry->has_type( $input_name ) ) {
			return;
		}

		$this->type_registry->register_input_type(
			$input_name,
			[
				'description' => sprintf(
					// translators: %s is the name of the connection
					__( 'Arguments for filtering the %s connection', 'wp-graphql' ),
					$this->connection_name
				),
				'fields'      => $this->connection_args,
				'queryClass'  => $this->query_class,
			]
		);

		$this->where_args = [
			'where' => [
				'description' => __( 'Arguments for filtering the connection', 'wp-graphql' ),
				'type'        => $this->connection_name . 'WhereArgs',
			],
		];
	}

	/**
	 * Registers the One to One Connection Edge type to the Schema
	 *
	 * @throws \Exception
	 */
	protected function register_one_to_one_connection_edge_type(): void {
		if ( $this->type_registry->has_type( $this->connection_name . 'Edge' ) ) {
			return;
		}

		// Only include the default interfaces if the user hasnt explicitly opted out.
		$default_interfaces = false !== $this->include_default_interfaces ? [
			'OneToOneConnection',
			'Edge',
		] : [];
		$interfaces         = $this->get_edge_interfaces( $default_interfaces );

		$this->type_registry->register_object_type(
			$this->connection_name . 'Edge',
			[
				'interfaces'  => $interfaces,
				'description' => sprintf(
					// translators: Placeholders are for the name of the Type the connection is coming from and the name of the Type the connection is going to
					__( 'Connection between the %1$s type and the %2$s type', 'wp-graphql' ),
					$this->from_type,
					$this->to_type
				),
				'fields'      => array_merge(
					[
						'node' => [
							'type'              => [ 'non_null' => $this->to_type ],
							'description'       => __( 'The node of the connection, without the edges', 'wp-graphql' ),
							'deprecationReason' => ! empty( $this->config['deprecationReason'] ) ? $this->config['deprecationReason'] : null,
						],
					],
					$this->edge_fields
				),
			]
		);
	}

	/**
	 * Registers the PageInfo type for the connection
	 *
	 * @throws \Exception
	 */
	public function register_connection_page_info_type(): void {
		if ( $this->type_registry->has_type( $this->connection_name . 'PageInfo' ) ) {
			return;
		}

		$this->type_registry->register_object_type(
			$this->connection_name . 'PageInfo',
			[
				'interfaces'  => [ $this->to_type . 'ConnectionPageInfo' ],
				'description' => sprintf(
					// translators: %s is the name of the connection.
					__( 'Page Info on the "%s"', 'wp-graphql' ),
					$this->connection_name
				),
				'fields'      => PageInfo::get_fields(),
			]
		);
	}

	/**
	 * Registers the Connection Edge type to the Schema
	 *
	 * @throws \Exception
	 */
	protected function register_connection_edge_type(): void {
		if ( $this->type_registry->has_type( $this->connection_name . 'Edge' ) ) {
			return;
		}
		// Only include the default interfaces if the user hasnt explicitly opted out.
		$default_interfaces = false === $this->include_default_interfaces ? [
			'Edge',
		] : [];
		$interfaces         = $this->get_edge_interfaces( $default_interfaces );

		$this->type_registry->register_object_type(
			$this->connection_name . 'Edge',
			[
				'description' => __( 'An edge in a connection', 'wp-graphql' ),
				'interfaces'  => $interfaces,
				'fields'      => array_merge(
					[
						'cursor' => [
							'type'              => 'String',
							'description'       => __( 'A cursor for use in pagination', 'wp-graphql' ),
							'resolve'           => $this->resolve_cursor,
							'deprecationReason' => ! empty( $this->config['deprecationReason'] ) ? $this->config['deprecationReason'] : null,
						],
						'node'   => [
							'type'              => [ 'non_null' => $this->to_type ],
							'description'       => __( 'The item at the end of the edge', 'wp-graphql' ),
							'deprecationReason' => ! empty( $this->config['deprecationReason'] ) ? $this->config['deprecationReason'] : null,
						],
					],
					$this->edge_fields
				),
			]
		);
	}

	/**
	 * Registers the Connection Type to the Schema
	 *
	 * @throws \Exception
	 */
	protected function register_connection_type(): void {
		if ( $this->type_registry->has_type( $this->connection_name ) ) {
			return;
		}

		$interfaces   = ! empty( $this->connection_interfaces ) ? $this->connection_interfaces : [];
		$interfaces[] = Utils::format_type_name( $this->to_type . 'Connection' );

		// Only include the default interfaces if the user hasnt explicitly opted out.
		if ( false !== $this->include_default_interfaces ) {
			$interfaces[] = 'Connection';
		}

		$this->type_registry->register_object_type(
			$this->connection_name,
			[
				'description'       => sprintf(
					// translators: the placeholders are the name of the Types the connection is between.
					__( 'Connection between the %1$s type and the %2$s type', 'wp-graphql' ),
					$this->from_type,
					$this->to_type
				),
				'interfaces'        => $interfaces,
				'connection_config' => $this->config,
				'fields'            => $this->get_connection_fields(),
			]
		);
	}

	/**
	 * Returns fields to be used on the connection
	 *
	 * @return array<string,array<string,mixed>>
	 */
	protected function get_connection_fields(): array {
		return array_merge(
			[
				'pageInfo' => [
					'type'        => [ 'non_null' => $this->connection_name . 'PageInfo' ],
					'description' => __( 'Information about pagination in a connection.', 'wp-graphql' ),
				],
				'edges'    => [
					'type'        => [ 'non_null' => [ 'list_of' => [ 'non_null' => $this->connection_name . 'Edge' ] ] ],
					// translators: %s is the name of the connection.
					'description' => sprintf( __( 'Edges for the %s connection', 'wp-graphql' ), $this->connection_name ),
				],
				'nodes'    => [
					'type'        => [ 'non_null' => [ 'list_of' => [ 'non_null' => $this->to_type ] ] ],
					'description' => __( 'The nodes of the connection, without the edges', 'wp-graphql' ),
				],
			],
			$this->connection_fields
		);
	}

	/**
	 * Get the args used for pagination on connections
	 *
	 * @return array<string,array<string,mixed>>
	 */
	protected function get_pagination_args(): array {
		if ( true === $this->one_to_one ) {
			$pagination_args = [];
		} else {
			$pagination_args = [
				'first'  => [
					'type'        => 'Int',
					'description' => __( 'The number of items to return after the referenced "after" cursor', 'wp-graphql' ),
				],
				'last'   => [
					'type'        => 'Int',
					'description' => __( 'The number of items to return before the referenced "before" cursor', 'wp-graphql' ),
				],
				'after'  => [
					'type'        => 'String',
					'description' => __( 'Cursor used along with the "first" argument to reference where in the dataset to get data', 'wp-graphql' ),
				],
				'before' => [
					'type'        => 'String',
					'description' => __( 'Cursor used along with the "last" argument to reference where in the dataset to get data', 'wp-graphql' ),
				],
			];
		}

		return $pagination_args;
	}

	/**
	 * Registers the connection in the Graph
	 *
	 * @throws \Exception
	 */
	public function register_connection_field(): void {

		// merge the config so the raw data passed to the connection
		// is passed to the field and can be accessed via $info in resolvers
		$field_config = array_merge(
			$this->config,
			[
				'type'                  => true === $this->one_to_one ? $this->connection_name . 'Edge' : $this->connection_name,
				'args'                  => array_merge( $this->get_pagination_args(), $this->where_args ),
				'auth'                  => $this->auth,
				'isConnectionField'     => true,
				'deprecationReason'     => ! empty( $this->config['deprecationReason'] ) ? $this->config['deprecationReason'] : null,
				'description'           => ! empty( $this->config['description'] )
					? $this->config['description']
					: sprintf(
						// translators: the placeholders are the name of the Types the connection is between.
						__( 'Connection between the %1$s type and the %2$s type', 'wp-graphql' ),
						$this->from_type,
						$this->to_type
					),
				'resolve'               => function ( $root, $args, $context, $info ) {
					$context->connection_query_class = $this->query_class;
					$resolve_connection              = $this->resolve_connection;

					/**
					 * Return the results of the connection resolver
					 */
					return $resolve_connection( $root, $args, $context, $info );
				},
				'allowFieldUnderscores' => isset( $this->config['allowFieldUnderscores'] ) && true === $this->config['allowFieldUnderscores'],
			]
		);

		$this->type_registry->register_field(
			$this->from_type,
			$this->from_field_name,
			$field_config
		);
	}

	/**
	 * @throws \Exception
	 */
	public function register_connection_interfaces(): void {
		$connection_edge_type = Utils::format_type_name( $this->to_type . 'ConnectionEdge' );

		if ( ! $this->type_registry->has_type( $this->to_type . 'ConnectionPageInfo' ) ) {
			$this->type_registry->register_interface_type(
				$this->to_type . 'ConnectionPageInfo',
				[
					'interfaces'  => [ 'WPPageInfo' ],
					// translators: %s is the name of the connection edge.
					'description' => sprintf( __( 'Page Info on the connected %s', 'wp-graphql' ), $connection_edge_type ),
					'fields'      => PageInfo::get_fields(),
				]
			);
		}

		if ( ! $this->type_registry->has_type( $connection_edge_type ) ) {
			$this->type_registry->register_interface_type(
				$connection_edge_type,
				[
					'interfaces'  => [ 'Edge' ],
					// translators: %s is the name of the type the connection edge is to.
					'description' => sprintf( __( 'Edge between a Node and a connected %s', 'wp-graphql' ), $this->to_type ),
					'fields'      => [
						'node' => [
							'type'        => [ 'non_null' => $this->to_type ],
							// translators: %s is the name of the type the connection edge is to.
							'description' => sprintf( __( 'The connected %s Node', 'wp-graphql' ), $this->to_type ),
						],
					],
				]
			);
		}

		if ( ! $this->one_to_one && ! $this->type_registry->has_type( $this->to_type . 'Connection' ) ) {
			$this->type_registry->register_interface_type(
				$this->to_type . 'Connection',
				[
					'interfaces'  => [ 'Connection' ],
					// translators: %s is the name of the type the connection is to.
					'description' => sprintf( __( 'Connection to %s Nodes', 'wp-graphql' ), $this->to_type ),
					'fields'      => [
						'edges'    => [
							'type'        => [ 'non_null' => [ 'list_of' => [ 'non_null' => $connection_edge_type ] ] ],
							'description' => sprintf(
								// translators: %1$s is the name of the type the connection is from, %2$s is the name of the type the connection is to.
								__( 'A list of edges (relational context) between %1$s and connected %2$s Nodes', 'wp-graphql' ),
								$this->from_type,
								$this->to_type
							),
						],
						'pageInfo' => [
							'type' => [ 'non_null' => $this->to_type . 'ConnectionPageInfo' ],
						],
						'nodes'    => [
							'type'        => [ 'non_null' => [ 'list_of' => [ 'non_null' => $this->to_type ] ] ],
							// translators: %s is the name of the type the connection is to.
							'description' => sprintf( __( 'A list of connected %s Nodes', 'wp-graphql' ), $this->to_type ),
						],
					],
				]
			);
		}
	}

	/**
	 * Registers the connection Types and field to the Schema.
	 *
	 * @todo change to 'Protected'. This is public for now to allow for backwards compatibility.
	 *
	 * @throws \Exception
	 */
	public function register_connection(): void {
		$this->register_connection_input();

		if ( false !== $this->include_default_interfaces ) {
			$this->register_connection_interfaces();
		}

		if ( true === $this->one_to_one ) {
			$this->register_one_to_one_connection_edge_type();
		} else {
			$this->register_connection_page_info_type();
			$this->register_connection_edge_type();
			$this->register_connection_type();
		}

		$this->register_connection_field();
	}

	/**
	 * Checks whether the connection should be registered to the Schema.
	 */
	protected function should_register(): bool {

		// Don't register if the connection has been excluded from the schema.
		$excluded_connections = $this->type_registry->get_excluded_connections();
		if ( in_array( strtolower( $this->connection_name ), $excluded_connections, true ) ) {
			return false;
		}

		// Don't register if one of the connection types has been excluded from the schema.
		$excluded_types = $this->type_registry->get_excluded_types();
		if ( ( in_array( strtolower( $this->from_type ), $excluded_types, true ) || in_array( strtolower( $this->to_type ), $excluded_types, true ) ) ) {
			return false;
		}

		return true;
	}
}


// File: wp-graphql\src\Type\WPEnumType.php
<?php
namespace WPGraphQL\Type;

use GraphQL\Type\Definition\EnumType;

/**
 * Class WPEnumType
 *
 * EnumTypes should extend this class to have filters and sorting applied, etc.
 *
 * @package WPGraphQL\Type
 */
class WPEnumType extends EnumType {

	/**
	 * WPEnumType constructor.
	 *
	 * @param array<string,mixed> $config
	 */
	public function __construct( $config ) {
		$name             = ucfirst( $config['name'] );
		$config['name']   = apply_filters( 'graphql_type_name', $name, $config, $this );
		$config['values'] = self::prepare_values( $config['values'], $config['name'] );
		parent::__construct( $config );
	}

	/**
	 * Generate a safe / sanitized Enum value from a string.
	 *
	 * @param  string $value Enum value.
	 * @return string
	 */
	public static function get_safe_name( string $value ) {
		$sanitized_enum_name = graphql_format_name( $value, '_' );

		// If the sanitized name is empty, we want to return the original value so it displays in the error.
		if ( ! empty( $sanitized_enum_name ) ) {
			$value = $sanitized_enum_name;
		}

		$safe_name = strtoupper( $value );

		// Enum names must start with a letter or underscore.
		if ( ! preg_match( '#^[_a-zA-Z]#', $safe_name ) ) {
			return '_' . $safe_name;
		}

		return $safe_name;
	}

	/**
	 * This function sorts the values and applies a filter to allow for easily
	 * extending/modifying the shape of the Schema for the enum.
	 *
	 * @param array<string,mixed> $values
	 * @param string              $type_name
	 * @return array<string,mixed>
	 * @since 0.0.5
	 */
	private static function prepare_values( $values, $type_name ) {
		/**
		 * Filter all object fields, passing the $typename as a param
		 *
		 * This is useful when several different types need to be easily filtered at once. . .for example,
		 * if ALL types with a field of a certain name needed to be adjusted, or something to that tune
		 *
		 * @param array<string,mixed> $values
		 */
		$values = apply_filters( 'graphql_enum_values', $values );

		/**
		 * Pass the values through a filter
		 *
		 * Filter for lcfirst( $type_name ) was added for backward compatibility
		 *
		 * This is useful for more targeted filtering, and is applied after the general filter, to allow for
		 * more specific overrides
		 *
		 * @param array<string,mixed> $values
		 *
		 * @since 0.0.5
		 */
		$values = apply_filters( 'graphql_' . lcfirst( $type_name ) . '_values', $values );
		$values = apply_filters( 'graphql_' . $type_name . '_values', $values );

		/**
		 * Sort the values alphabetically by key. This makes reading through docs much easier
		 *
		 * @since 0.0.5
		 */
		ksort( $values );

		/**
		 * Return the filtered, sorted $fields
		 *
		 * @since 0.0.5
		 */
		return $values;
	}
}


// File: wp-graphql\src\Type\WPInputObjectType.php
<?php
namespace WPGraphQL\Type;

use GraphQL\Type\Definition\InputObjectType;
use WPGraphQL\Registry\TypeRegistry;

/**
 * Class WPInputObjectType
 *
 * Input types should extend this class to take advantage of the helper methods for formatting
 * and adding consistent filters.
 *
 * @package WPGraphQL\Type
 * @since 0.0.5
 */
class WPInputObjectType extends InputObjectType {

	/**
	 * WPInputObjectType constructor.
	 *
	 * @param array<string,mixed>              $config
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 */
	public function __construct( array $config, TypeRegistry $type_registry ) {
		$name           = $config['name'];
		$config['name'] = apply_filters( 'graphql_type_name', $name, $config, $this );

		/**
		 * Setup the fields
		 *
		 * @return array<string,array<string,mixed>>
		 */
		if ( ! empty( $config['fields'] ) && is_array( $config['fields'] ) ) {
			$config['fields'] = function () use ( $config, $type_registry ) {
				$fields = $this->prepare_fields( $config['fields'], $config['name'], $config, $type_registry );
				$fields = $type_registry->prepare_fields( $fields, $config['name'] );

				return $fields;
			};
		}

		parent::__construct( $config );
	}

	/**
	 * Prepare_fields
	 *
	 * This function sorts the fields and applies a filter to allow for easily
	 * extending/modifying the shape of the Schema for the type.
	 *
	 * @param array<string,array<string,mixed>> $fields
	 * @param string                            $type_name
	 * @param array<string,mixed>               $config
	 * @param \WPGraphQL\Registry\TypeRegistry  $type_registry
	 * @return array<string,array<string,mixed>>
	 * @since 0.0.5
	 */
	public function prepare_fields( array $fields, string $type_name, array $config, TypeRegistry $type_registry ) {

		/**
		 * Filter all object fields, passing the $typename as a param
		 *
		 * This is useful when several different types need to be easily filtered at once. . .for example,
		 * if ALL types with a field of a certain name needed to be adjusted, or something to that tune
		 *
		 * @param array<string,array<string,mixed>> $fields        The array of fields for the object config
		 * @param string                            $type_name     The name of the object type
		 * @param array<string,mixed>               $config        The type config
		 * @param \WPGraphQL\Registry\TypeRegistry  $type_registry The TypeRegistry instance
		 */
		$fields = apply_filters( 'graphql_input_fields', $fields, $type_name, $config, $type_registry );

		/**
		 * Filter once with lowercase, once with uppercase for Back Compat.
		 */
		$lc_type_name = lcfirst( $type_name );
		$uc_type_name = ucfirst( $type_name );

		/**
		 * Filter the fields with the typename explicitly in the filter name
		 *
		 * This is useful for more targeted filtering, and is applied after the general filter, to allow for
		 * more specific overrides
		 *
		 * @param array<string,array<string,mixed>> $fields        The array of fields for the object config
		 * @param \WPGraphQL\Registry\TypeRegistry  $type_registry The TypeRegistry instance
		 */
		$fields = apply_filters( "graphql_{$lc_type_name}_fields", $fields, $type_registry );

		/**
		 * Filter the fields with the typename explicitly in the filter name
		 *
		 * This is useful for more targeted filtering, and is applied after the general filter, to allow for
		 * more specific overrides
		 *
		 * @param array<string,array<string,mixed>> $fields        The array of fields for the object config
		 * @param \WPGraphQL\Registry\TypeRegistry  $type_registry The TypeRegistry instance
		 */
		$fields = apply_filters( "graphql_{$uc_type_name}_fields", $fields, $type_registry );

		/**
		 * Sort the fields alphabetically by key. This makes reading through docs much easier
		 *
		 * @since 0.0.2
		 */
		ksort( $fields );

		/**
		 * Return the filtered, sorted $fields
		 *
		 * @since 0.0.5
		 */
		return $fields;
	}
}


// File: wp-graphql\src\Type\WPInterfaceTrait.php
<?php
namespace WPGraphQL\Type;

use GraphQL\Type\Definition\InterfaceType;
use WPGraphQL\Registry\TypeRegistry;

/**
 * Trait WPInterfaceTrait
 *
 * This Trait includes methods to help Interfaces and ObjectTypes ensure they implement
 * the proper inherited interfaces
 *
 * @package WPGraphQL\Type
 */
trait WPInterfaceTrait {

	/**
	 * Given an array of interfaces, this gets the Interfaces the Type should implement including inherited interfaces.
	 *
	 * @return \GraphQL\Type\Definition\InterfaceType[]
	 */
	protected function get_implemented_interfaces(): array {
		if ( ! isset( $this->config['interfaces'] ) || ! is_array( $this->config['interfaces'] ) || empty( $this->config['interfaces'] ) ) {
			$interfaces = parent::getInterfaces();
		} else {
			$interfaces = $this->config['interfaces'];
		}

		/**
		 * Filters the interfaces applied to an object type
		 *
		 * @param string[]                   $interfaces     List of interfaces applied to the Object Type
		 * @param array<string,mixed>        $config         The config for the Object Type
		 * @param mixed|\WPGraphQL\Type\WPInterfaceType|\WPGraphQL\Type\WPObjectType $type The Type instance
		 */
		$interfaces = apply_filters( 'graphql_type_interfaces', $interfaces, $this->config, $this );

		if ( empty( $interfaces ) || ! is_array( $interfaces ) ) {
			return $interfaces;
		}

		$new_interfaces = [];

		foreach ( $interfaces as $interface ) {
			if ( $interface instanceof InterfaceType && $interface->name !== $this->name ) {
				$new_interfaces[ $interface->name ] = $interface;
				continue;
			}

			// surface when interfaces are trying to be registered with invalid configuration
			if ( ! is_string( $interface ) ) {
				graphql_debug(
					sprintf(
						// translators: %s is the name of the GraphQL type.
						__( 'Invalid Interface registered to the "%s" Type. Interfaces can only be registered with an interface name or a valid instance of an InterfaceType', 'wp-graphql' ),
						$this->name
					),
					[ 'invalid_interface' => $interface ]
				);
				continue;
			}

			// Prevent an interface from implementing itself
			if ( strtolower( $this->config['name'] ) === strtolower( $interface ) ) {
				graphql_debug(
					sprintf(
						// translators: %s is the name of the interface.
						__( 'The "%s" Interface attempted to implement itself, which is not allowed', 'wp-graphql' ),
						$interface
					)
				);
				continue;
			}

			$interface_type = $this->type_registry->get_type( $interface );
			if ( ! $interface_type instanceof InterfaceType ) {
				graphql_debug(
					sprintf(
						// translators: %1$s is the name of the interface, %2$s is the name of the type.
						__( '"%1$s" is not a valid Interface Type and cannot be implemented as an Interface on the "%2$s" Type', 'wp-graphql' ),
						$interface,
						$this->name
					)
				);
				continue;
			}

			$new_interfaces[ $interface ] = $interface_type;
			$interface_interfaces         = $interface_type->getInterfaces();

			if ( empty( $interface_interfaces ) ) {
				continue;
			}

			foreach ( $interface_interfaces as $interface_interface_name => $interface_interface ) {
				if ( ! $interface_interface instanceof InterfaceType ) {
					continue;
				}

				$new_interfaces[ $interface_interface_name ] = $interface_interface;
			}
		}

		return array_unique( $new_interfaces );
	}

	/**
	 * Given a type it will return a string representation of the type.
	 *
	 * This is used for optimistic comparison of the arg types.
	 *
	 * @param string|array<string,mixed>|mixed $type A GraphQL Type
	 */
	private function field_arg_type_to_string( $type ): string {
		// Bail if the type is empty.
		if ( empty( $type ) ) {
			return '';
		} elseif ( is_string( $type ) ) {
			// If the type is already a string, return it as is.
			return $type;
		} elseif ( ! is_array( $type ) ) {
			// If the type is not an array, we can't do anything with it.
			return '';
		}

		// Arrays mean the type can be nested in modifiers.
		$output   = '';
		$modifier = array_keys( $type )[0];
		$type     = $type[ $modifier ];
		switch ( $modifier ) {
			case 'list_of':
				$output = '[' . $this->field_arg_type_to_string( $type ) . ']';
				break;
			case 'non_null':
				$output = '!' . $this->field_arg_type_to_string( $type );
				break;
		}

		return $output;
	}

	/**
	 * Returns the fields for a Type, applying any missing fields defined on interfaces implemented on the type
	 *
	 * @param array<mixed>                     $config
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @return array<mixed>
	 * @throws \Exception
	 */
	protected function get_fields( array $config, TypeRegistry $type_registry ): array {
		$fields = $config['fields'];

		$fields = array_filter( $fields );

		/**
		 * Get the fields of interfaces and ensure they exist as fields of this type.
		 *
		 * Types are still responsible for ensuring the fields resolve properly.
		 */
		$interface_fields = [];

		if ( ! empty( $this->getInterfaces() ) && is_array( $this->getInterfaces() ) ) {
			foreach ( $this->getInterfaces() as $interface_type ) {
				if ( ! $interface_type instanceof InterfaceType ) {
					$interface_type = $type_registry->get_type( $interface_type );
				}

				if ( ! $interface_type instanceof InterfaceType ) {
					continue;
				}

				$interface_config_fields = $interface_type->getFields();

				if ( empty( $interface_config_fields ) ) {
					continue;
				}

				foreach ( $interface_config_fields as $interface_field_name => $interface_field ) {
					$interface_fields[ $interface_field_name ] = $interface_field->config;
				}
			}
		}

		// diff the $interface_fields and the $fields
		// if the field is not in $fields, add it
		$diff = ! empty( $interface_fields ) ? array_diff_key( $interface_fields, $fields ) : [];

		// If the Interface has fields defined that are not defined
		// on the Object Type, add them to the Object Type
		if ( ! empty( $diff ) ) {
			$fields = array_merge( $fields, $diff );
		}

		foreach ( $fields as $field_name => $field ) {
			$new_field = $field;

			// If the field does not have a type, attempt to inherit it from the interface.
			if ( ! isset( $new_field['type'] ) ) {
				// If the field doesn't exist in the interface, we have no way to determine (and later register) the type.
				if ( ! isset( $interface_fields[ $field_name ] ) ) {
					unset( $fields[ $field_name ] );
					continue;
				}

				$new_field['type'] = $interface_fields[ $field_name ]['type'];
			}

			// Inherit the description from the interface if it's not set on the field.
			if ( empty( $new_field['description'] ) && ! empty( $interface_fields[ $field_name ]['description'] ) ) {
				$new_field['description'] = $interface_fields[ $field_name ]['description'];
			}

			// Inherit the resolver from the interface if it's not set on the field.
			if ( empty( $new_field['resolve'] ) && ! empty( $interface_fields[ $field_name ]['resolve'] ) ) {
				$new_field['resolve'] = $interface_fields[ $field_name ]['resolve'];
			}

			// If the args aren't explicitly defined, inherit them from the interface.
			// If they're both set, we need to merge them.
			if ( empty( $new_field['args'] ) && ! empty( $interface_fields[ $field_name ]['args'] ) ) {
				$new_field['args'] = $interface_fields[ $field_name ]['args'];
			} elseif ( ! empty( $new_field['args'] ) && ! empty( $interface_fields[ $field_name ]['args'] ) ) {
				// Set field args to the interface fields to be overwrite with the new field args.
				$field_args = $interface_fields[ $field_name ]['args'];

				foreach ( $new_field['args'] as $arg_name => $arg_definition ) {
					// If the arg is not defined in the interface, we can use the current arg definition.
					if ( empty( $field_args[ $arg_name ] ) ) {
						$field_args[ $arg_name ] = $arg_definition;
						continue;
					}

					// Check if the interface arg type is different from the new field arg type.
					$new_field_arg_type = $this->field_arg_type_to_string( $arg_definition['type'] );
					$interface_arg_type = $field_args[ $arg_name ]['type']();
					if ( ! empty( $new_field_arg_type ) && $interface_arg_type !== $new_field_arg_type ) {
						graphql_debug(
							sprintf(
								/* translators: 1: Object type name, 2: Field name, 3: Argument name, 4: Expected argument type, 5: Actual argument type. */
								__(
									'Interface field argument "%1$s.%2$s(%3$s:)" expected to be of type "%4$s" but got "%5$s". Please ensure the field arguments match the interface field arguments or rename the argument.',
									'wp-graphql'
								),
								$config['name'],
								$field_name,
								$arg_name,
								$interface_arg_type,
								$new_field_arg_type
							)
						);
						continue;
					}

					// Set the field args to the new field args.
					$field_args[ $arg_name ] = array_merge( $field_args[ $arg_name ], $arg_definition );
				}

				$new_field['args'] = array_merge( $interface_fields[ $field_name ]['args'], $new_field['args'] );
			}

			// Update the field.
			$fields[ $field_name ] = $new_field;
		}

		$fields = $this->prepare_fields( $fields, $config['name'], $config );
		$fields = $type_registry->prepare_fields( $fields, $config['name'] );

		$this->fields = $fields;
		return $this->fields;
	}
}


// File: wp-graphql\src\Type\WPInterfaceType.php
<?php

namespace WPGraphQL\Type;

use GraphQL\Type\Definition\InterfaceType;
use WPGraphQL\Registry\TypeRegistry;

class WPInterfaceType extends InterfaceType {

	use WPInterfaceTrait;

	/**
	 * Instance of the TypeRegistry as an Interface needs knowledge of available Types
	 *
	 * @var \WPGraphQL\Registry\TypeRegistry
	 */
	public $type_registry;

	/**
	 * @var array<string,mixed>
	 */
	public $config;

	/**
	 * @var array<string, array<string, mixed>>
	 */
	public $fields;

	/**
	 * @var array<string, array<string, mixed>>
	 */
	public $interfaces;

	/**
	 * WPInterfaceType constructor.
	 *
	 * @param array<string,mixed>              $config
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @throws \Exception
	 */
	public function __construct( array $config, TypeRegistry $type_registry ) {
		$this->type_registry = $type_registry;

		$this->config = $config;

		$name             = ucfirst( $config['name'] );
		$config['name']   = apply_filters( 'graphql_type_name', $name, $config, $this );
		$config['fields'] = ! empty( $this->fields ) ? $this->fields : $this->get_fields( $config, $this->type_registry );

		$config['resolveType'] = function ( $obj ) use ( $config ) {
			$type = null;
			if ( is_callable( $config['resolveType'] ) ) {
				$type = call_user_func( $config['resolveType'], $obj );
			}

			/**
			 * Filter the resolve type method for all interfaces
			 *
			 * @param mixed $type The Type to resolve to, based on the object being resolved.
			 * @param mixed $obj  The Object being resolved.
			 * @param \WPGraphQL\Type\WPInterfaceType $wp_interface_type The WPInterfaceType instance.
			 */
			return apply_filters( 'graphql_interface_resolve_type', $type, $obj, $this );
		};

		/**
		 * Filter the config of WPInterfaceType
		 *
		 * @param array<string,mixed>             $config Array of configuration options passed to the WPInterfaceType when instantiating a new type
		 * @param \WPGraphQL\Type\WPInterfaceType $wp_interface_type The instance of the WPInterfaceType class
		 */
		$config = apply_filters( 'graphql_wp_interface_type_config', $config, $this );

		parent::__construct( $config );
	}

	/**
	 * Get interfaces implemented by this Interface
	 *
	 * @return \GraphQL\Type\Definition\InterfaceType[]
	 */
	public function getInterfaces(): array {
		return $this->get_implemented_interfaces();
	}

	/**
	 * This function sorts the fields and applies a filter to allow for easily
	 * extending/modifying the shape of the Schema for the type.
	 *
	 * @param array<string,array<string,mixed>> $fields The array of fields for the object config
	 * @param string                            $type_name The name of the type to prepare fields for
	 * @param array<string,mixed>               $config    The config for the Object Type
	 * @return array<string,array<string,mixed>>
	 * @since 0.0.5
	 */
	public function prepare_fields( array $fields, string $type_name, array $config ): array {

		/**
		 * Filter all interface fields, passing the $typename as a param
		 *
		 * This is useful when several different types need to be easily filtered at once. . .for example,
		 * if ALL types with a field of a certain name needed to be adjusted, or something to that tune
		 *
		 * @param array<string,array<string,mixed>> $fields    The array of fields for the object config
		 * @param string                            $type_name The name of the object type
		 */
		$fields = apply_filters( 'graphql_interface_fields', $fields, $type_name );

		/**
		 * Filter once with lowercase, once with uppercase for Back Compat.
		 */
		$lc_type_name = lcfirst( $type_name );
		$uc_type_name = ucfirst( $type_name );

		/**
		 * Filter the fields with the typename explicitly in the filter name
		 *
		 * This is useful for more targeted filtering, and is applied after the general filter, to allow for
		 * more specific overrides
		 *
		 * @param array<string,array<string,mixed>> $fields The array of fields for the object config
		 */
		$fields = apply_filters( "graphql_{$lc_type_name}_fields", $fields );

		/**
		 * Filter the fields with the typename explicitly in the filter name
		 *
		 * This is useful for more targeted filtering, and is applied after the general filter, to allow for
		 * more specific overrides
		 *
		 * @param array<string,array<string,mixed>> $fields The array of fields for the object config
		 */
		$fields = apply_filters( "graphql_{$uc_type_name}_fields", $fields );

		/**
		 * This sorts the fields alphabetically by the key, which is super handy for making the schema readable,
		 * as it ensures it's not output in just random order
		 */
		ksort( $fields );

		return $fields;
	}
}


// File: wp-graphql\src\Type\WPMutationType.php
<?php
namespace WPGraphQL\Type;

use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Registry\TypeRegistry;

/**
 * Class WPMutationType
 *
 * @package WPGraphQL\Type
 */
class WPMutationType {
	/**
	 * Configuration for how auth should be handled on the connection field
	 *
	 * @var array<string,mixed>
	 */
	protected $auth;

	/**
	 * The config for the connection
	 *
	 * @var array<string,mixed>
	 */
	protected $config;

	/**
	 * The name of the mutation field
	 *
	 * @var string
	 */
	protected $mutation_name;

	/**
	 * Whether the user must be authenticated to use the mutation.
	 *
	 * @var bool
	 */
	protected $is_private;

	/**
	 * The mutation input field config.
	 *
	 * @var array<string,array<string,mixed>>
	 */
	protected $input_fields;

	/**
	 * The mutation output field config.
	 *
	 * @var array<string,array<string,mixed>>
	 */
	protected $output_fields;

	/**
	 * The resolver function to resolve the mutation
	 *
	 * @var callable(mixed $root,array<string,mixed> $args,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info): array<string,mixed>
	 */
	protected $resolve_mutation;

	/**
	 * The WPGraphQL TypeRegistry
	 *
	 * @var \WPGraphQL\Registry\TypeRegistry
	 */
	protected $type_registry;

	/**
	 * WPMutationType constructor.
	 *
	 * @param array<string,mixed>              $config        The config array for the mutation
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry Instance of the WPGraphQL Type Registry
	 *
	 * @throws \Exception
	 */
	public function __construct( array $config, TypeRegistry $type_registry ) {

		/**
		 * Filter the config of WPMutationType
		 *
		 * @param array<string,mixed>            $config           Array of configuration options passed to the WPMutationType when instantiating a new type
		 * @param \WPGraphQL\Type\WPMutationType $wp_mutation_type The instance of the WPMutationType class
		 *
		 * @since 1.13.0
		 */
		$config = apply_filters( 'graphql_wp_mutation_type_config', $config, $this );

		if ( ! $this->is_config_valid( $config ) ) {
			return;
		}

		$this->config        = $config;
		$this->type_registry = $type_registry;
		$this->mutation_name = $config['name'];

		// Bail if the mutation should be excluded from the schema.
		if ( ! $this->should_register() ) {
			return;
		}

		$this->auth             = array_key_exists( 'auth', $config ) && is_array( $config['auth'] ) ? $config['auth'] : [];
		$this->is_private       = array_key_exists( 'isPrivate', $config ) ? $config['isPrivate'] : false;
		$this->input_fields     = $this->get_input_fields();
		$this->output_fields    = $this->get_output_fields();
		$this->resolve_mutation = $this->get_resolver();

		/**
		 * Run an action when the WPMutationType is instantiating.
		 *
		 * @param array<string,mixed>            $config           Array of configuration options passed to the WPObjectType when instantiating a new type
		 * @param \WPGraphQL\Type\WPMutationType $wp_mutation_type The instance of the WPMutationType class
		 *
		 * @since 1.13.0
		 */
		do_action( 'graphql_wp_mutation_type', $config, $this );

		$this->register_mutation();
	}

	/**
	 * Validates that essential key/value pairs are passed to the connection config.
	 *
	 * @param array<string,mixed> $config The config array for the mutation
	 */
	protected function is_config_valid( array $config ): bool {
		$is_valid = true;

		if ( ! array_key_exists( 'name', $config ) || ! is_string( $config['name'] ) ) {
			graphql_debug(
				__( 'Mutation config needs to have a valid name.', 'wp-graphql' ),
				[
					'config' => $config,
				]
			);
			$is_valid = false;
		}

		if ( ! array_key_exists( 'mutateAndGetPayload', $config ) || ! is_callable( $config['mutateAndGetPayload'] ) ) {
			graphql_debug(
				__( 'Mutation config needs to have "mutateAndGetPayload" defined as a callable.', 'wp-graphql' ),
				[
					'config' => $config,
				]
			);
			$is_valid = false;
		}

		return $is_valid;
	}

	/**
	 * Gets the mutation input fields.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	protected function get_input_fields(): array {
		$input_fields = [
			'clientMutationId' => [
				'type'        => 'String',
				'description' => __( 'This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions.', 'wp-graphql' ),
			],
		];

		if ( ! empty( $this->config['inputFields'] ) && is_array( $this->config['inputFields'] ) ) {
			$input_fields = array_merge( $input_fields, $this->config['inputFields'] );
		}

		return $input_fields;
	}

	/**
	 * Gets the mutation output fields.
	 *
	 * @return array<string,array<string,mixed>>
	 */
	protected function get_output_fields(): array {
		$output_fields = [
			'clientMutationId' => [
				'type'        => 'String',
				'description' => __( 'If a \'clientMutationId\' input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions.', 'wp-graphql' ),
			],
		];

		if ( ! empty( $this->config['outputFields'] ) && is_array( $this->config['outputFields'] ) ) {
			$output_fields = array_merge( $output_fields, $this->config['outputFields'] );
		}

		return $output_fields;
	}

	/**
	 * Gets the resolver callable for the mutation.
	 *
	 * @return callable(mixed $root,array<string,mixed> $args,\WPGraphQL\AppContext $context,\GraphQL\Type\Definition\ResolveInfo $info): array<string,mixed>
	 */
	protected function get_resolver(): callable {
		return function ( $root, array $args, AppContext $context, ResolveInfo $info ) {
			$unfiltered_input = $args['input'];

			$unfiltered_input = $args['input'];

			/**
			 * Filters the mutation input before it's passed to the `mutateAndGetPayload` callback.
			 *
			 * @param array<string,mixed>                  $input         The mutation input args.
			 * @param \WPGraphQL\AppContext                $context       The AppContext object.
			 * @param \GraphQL\Type\Definition\ResolveInfo $info          The ResolveInfo object.
			 * @param string                               $mutation_name The name of the mutation field.
			 */
			$input = apply_filters( 'graphql_mutation_input', $unfiltered_input, $context, $info, $this->mutation_name );

			/**
			 * Filter to short circuit the mutateAndGetPayload callback.
			 * Returning anything other than null will stop the callback for the mutation from executing,
			 * and will return your data or execute your callback instead.
			 *
			 * @param array<string,mixed>|callable|null   $payload.            The payload returned from the callback. Null by default.
			 * @param string                $mutation_name       The name of the mutation field.
			 * @param callable|\Closure     $mutateAndGetPayload The callback for the mutation.
			 * @param array<string,mixed>   $input               The mutation input args.
			 * @param \WPGraphQL\AppContext $context             The AppContext object.
			 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo object.
			 */
			$pre = apply_filters( 'graphql_pre_mutate_and_get_payload', null, $this->mutation_name, $this->config['mutateAndGetPayload'], $input, $context, $info );

			if ( ! is_null( $pre ) ) {
				$payload = is_callable( $pre ) ? $pre( $input, $context, $info ) : $pre;
			} else {
				$payload = $this->config['mutateAndGetPayload']( $input, $context, $info );

				/**
				 * Filters the payload returned from the default mutateAndGetPayload callback.
				 *
				 * @param array<string,mixed>   $payload The payload returned from the callback.
				 * @param string                $mutation_name The name of the mutation field.
				 * @param array<string,mixed>   $input The mutation input args.
				 * @param \WPGraphQL\AppContext $context The AppContext object.
				 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo object.
				 */
				$payload = apply_filters( 'graphql_mutation_payload', $payload, $this->mutation_name, $input, $context, $info );
			}

			/**
			 * Fires after the mutation payload has been returned from the `mutateAndGetPayload` callback.
			 *
			 * @param array<string,mixed>                  $payload          The Payload returned from the mutation.
			 * @param array<string,mixed>                  $input            The mutation input args, after being filtered by 'graphql_mutation_input'.
			 * @param array<string,mixed>                  $unfiltered_input The unfiltered input args of the mutation
			 * @param \WPGraphQL\AppContext                $context          The AppContext object.
			 * @param \GraphQL\Type\Definition\ResolveInfo $info             The ResolveInfo object.
			 * @param string                               $mutation_name    The name of the mutation field.
			 */
			do_action( 'graphql_mutation_response', $payload, $input, $unfiltered_input, $context, $info, $this->mutation_name );

			// Add the client mutation ID to the payload
			if ( ! empty( $input['clientMutationId'] ) ) {
				$payload['clientMutationId'] = $input['clientMutationId'];
			}

			return $payload;
		};
	}

	/**
	 * Registers the input args for the mutation.
	 */
	protected function register_mutation_input(): void {
		$input_name = $this->mutation_name . 'Input';

		if ( $this->type_registry->has_type( $input_name ) ) {
			return;
		}

		$this->type_registry->register_input_type(
			$input_name,
			[
				// translators: %s is the name of the mutation.
				'description'       => sprintf( __( 'Input for the %1$s mutation.', 'wp-graphql' ), $this->mutation_name ),
				'fields'            => $this->input_fields,
				'deprecationReason' => ! empty( $this->config['deprecationReason'] ) ? $this->config['deprecationReason'] : null,
			]
		);
	}

	/**
	 * Registers the payload type to the Schema.
	 */
	protected function register_mutation_payload(): void {
		$object_name = $this->mutation_name . 'Payload';

		if ( $this->type_registry->has_type( $object_name ) ) {
			return;
		}

		$this->type_registry->register_object_type(
			$object_name,
			[
				// translators: %s is the name of the mutation.
				'description'       => sprintf( __( 'The payload for the %s mutation.', 'wp-graphql' ), $this->mutation_name ),
				'fields'            => $this->output_fields,
				'deprecationReason' => ! empty( $this->config['deprecationReason'] ) ? $this->config['deprecationReason'] : null,
			]
		);
	}

	/**
	 * Registers the mutation in the Graph.
	 *
	 * @throws \Exception
	 */
	protected function register_mutation_field(): void {
		$field_config = array_merge(
			$this->config,
			[
				'args'        => [
					'input' => [
						'type'              => [ 'non_null' => $this->mutation_name . 'Input' ],
						// translators: %s is the name of the mutation.
						'description'       => sprintf( __( 'Input for the %s mutation', 'wp-graphql' ), $this->mutation_name ),
						'deprecationReason' => ! empty( $this->config['deprecationReason'] ) ? $this->config['deprecationReason'] : null,
					],
				],
				'auth'        => $this->auth,
				// translators: %s is the name of the mutation.
				'description' => ! empty( $this->config['description'] ) ? $this->config['description'] : sprintf( __( 'The %s mutation', 'wp-graphql' ), $this->mutation_name ),
				'isPrivate'   => $this->is_private,
				'type'        => $this->mutation_name . 'Payload',
				'resolve'     => $this->resolve_mutation,
				'name'        => lcfirst( $this->mutation_name ),
			]
		);

		$this->type_registry->register_field(
			'RootMutation',
			lcfirst( $this->mutation_name ),
			$field_config
		);
	}

	/**
	 * Registers the Mutation Types and field to the Schema.
	 *
	 * @throws \Exception
	 */
	protected function register_mutation(): void {
		$this->register_mutation_payload();
		$this->register_mutation_input();
		$this->register_mutation_field();
	}

	/**
	 * Checks whether the mutation should be registered to the schema.
	 */
	protected function should_register(): bool {
		// Dont register mutations if they have been excluded from the schema.
		$excluded_mutations = $this->type_registry->get_excluded_mutations();
		if ( in_array( strtolower( $this->mutation_name ), $excluded_mutations, true ) ) {
			return false;
		}

		return true;
	}
}


// File: wp-graphql\src\Type\WPObjectType.php
<?php

namespace WPGraphQL\Type;

use GraphQL\Type\Definition\ObjectType;
use WPGraphQL\Data\DataSource;
use WPGraphQL\Registry\TypeRegistry;

/**
 * Class WPObjectType
 *
 * Object Types should extend this class to take advantage of the helper methods
 * and consistent filters.
 *
 * @package WPGraphQL\Type
 * @since   0.0.5
 */
class WPObjectType extends ObjectType {

	use WPInterfaceTrait;

	/**
	 * Holds the node_interface definition allowing WPObjectTypes
	 * to easily define themselves as a node type by implementing
	 * self::$node_interface
	 *
	 * @var array<string,mixed>|\WPGraphQL\Type\InterfaceType\Node $node_interface
	 * @since 0.0.5
	 */
	private static $node_interface;

	/**
	 * Instance of the Type Registry
	 *
	 * @var \WPGraphQL\Registry\TypeRegistry
	 */
	public $type_registry;

	/**
	 * @var array<string,mixed>
	 */
	public $config;

	/**
	 * @var array<string, array<string, mixed>>
	 */
	public $fields;

	/**
	 * @var array<\GraphQL\Type\Definition\InterfaceType>
	 */
	public $interfaces;

	/**
	 * WPObjectType constructor.
	 *
	 * @param array<string,mixed>              $config
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @throws \Exception
	 * @since 0.0.5
	 */
	public function __construct( $config, TypeRegistry $type_registry ) {

		/**
		 * Get the Type Registry
		 */
		$this->type_registry = $type_registry;

		/**
		 * Filter the config of WPObjectType
		 *
		 * @param array<string,mixed>          $config         Array of configuration options passed to the WPObjectType when instantiating a new type
		 * @param \WPGraphQL\Type\WPObjectType $wp_object_type The instance of the WPObjectType class
		 */
		$config = apply_filters( 'graphql_wp_object_type_config', $config, $this );

		$this->config = $config;

		/**
		 * Set the Types to start with capitals
		 */
		$name           = ucfirst( $config['name'] );
		$config['name'] = apply_filters( 'graphql_type_name', $name, $config, $this );

		/**
		 * Setup the fields
		 *
		 * @return array<string, array<string, mixed>> $fields
		 */
		$config['fields'] = ! empty( $this->fields ) ? $this->fields : $this->get_fields( $config, $this->type_registry );

		/**
		 * Run an action when the WPObjectType is instantiating
		 *
		 * @param array<string,mixed>          $config         Array of configuration options passed to the WPObjectType when instantiating a new type
		 * @param \WPGraphQL\Type\WPObjectType $wp_object_type The instance of the WPObjectType class
		 */
		do_action( 'graphql_wp_object_type', $config, $this );

		parent::__construct( $config );
	}

	/**
	 * Get the interfaces implemented by the ObjectType
	 *
	 * @return \GraphQL\Type\Definition\InterfaceType[]
	 */
	public function getInterfaces(): array {
		if ( ! empty( $this->interfaces ) ) {
			return $this->interfaces;
		}
		$this->interfaces = $this->get_implemented_interfaces();
		return $this->interfaces;
	}

	/**
	 * Node_interface
	 *
	 * This returns the node_interface definition allowing
	 * WPObjectTypes to easily implement the node_interface
	 *
	 * @return array<string,mixed>|\WPGraphQL\Type\InterfaceType\Node
	 * @since 0.0.5
	 */
	public static function node_interface() {
		if ( null === self::$node_interface ) {
			$node_interface       = DataSource::get_node_definition();
			self::$node_interface = $node_interface['nodeInterface'];
		}

		return self::$node_interface;
	}

	/**
	 * This function sorts the fields and applies a filter to allow for easily
	 * extending/modifying the shape of the Schema for the type.
	 *
	 * @param array<string,mixed> $fields    The array of fields for the object config
	 * @param string              $type_name The name of the type to prepare fields for
	 * @param array<string,mixed> $config    The config for the Object Type
	 *
	 * @return array<string,mixed>
	 * @since 0.0.5
	 */
	public function prepare_fields( $fields, $type_name, $config ) {

		/**
		 * Filter all object fields, passing the $typename as a param
		 *
		 * This is useful when several different types need to be easily filtered at once. . .for example,
		 * if ALL types with a field of a certain name needed to be adjusted, or something to that tune
		 *
		 * @param array<string,mixed>              $fields         The array of fields for the object config
		 * @param string                           $type_name      The name of the object type
		 * @param \WPGraphQL\Type\WPObjectType     $wp_object_type The WPObjectType Class
		 * @param \WPGraphQL\Registry\TypeRegistry $type_registry  The Type Registry
		 */
		$fields = apply_filters( 'graphql_object_fields', $fields, $type_name, $this, $this->type_registry );

		/**
		 * Filter once with lowercase, once with uppercase for Back Compat.
		 */
		$lc_type_name = lcfirst( $type_name );
		$uc_type_name = ucfirst( $type_name );

		/**
		 * Filter the fields with the typename explicitly in the filter name
		 *
		 * This is useful for more targeted filtering, and is applied after the general filter, to allow for
		 * more specific overrides
		 *
		 * @param array<string,mixed>              $fields         The array of fields for the object config
		 * @param \WPGraphQL\Type\WPObjectType     $wp_object_type The WPObjectType Class
		 * @param \WPGraphQL\Registry\TypeRegistry $type_registry  The Type Registry
		 */
		$fields = apply_filters( "graphql_{$lc_type_name}_fields", $fields, $this, $this->type_registry );

		/**
		 * Filter the fields with the typename explicitly in the filter name
		 *
		 * This is useful for more targeted filtering, and is applied after the general filter, to allow for
		 * more specific overrides
		 *
		 * @param array<string,mixed>              $fields         The array of fields for the object config
		 * @param \WPGraphQL\Type\WPObjectType     $wp_object_type The WPObjectType Class
		 * @param \WPGraphQL\Registry\TypeRegistry $type_registry  The Type Registry
		 */
		$fields = apply_filters( "graphql_{$uc_type_name}_fields", $fields, $this, $this->type_registry );

		/**
		 * This sorts the fields alphabetically by the key, which is super handy for making the schema readable,
		 * as it ensures it's not output in just random order
		 */
		ksort( $fields );

		return $fields;
	}
}


// File: wp-graphql\src\Type\WPScalar.php
<?php
namespace WPGraphQL\Type;

use GraphQL\Type\Definition\CustomScalarType;
use WPGraphQL\Registry\TypeRegistry;

/**
 * Class WPScalar
 *
 * @package WPGraphQL\Type
 */
class WPScalar extends CustomScalarType {

	/**
	 * WPScalar constructor.
	 *
	 * @param array<string,mixed>              $config
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 */
	public function __construct( array $config, TypeRegistry $type_registry ) {
		$name           = $config['name'];
		$config['name'] = apply_filters( 'graphql_type_name', $name, $config, $this );
		$config         = apply_filters( 'graphql_custom_scalar_config', $config, $type_registry );

		parent::__construct( $config );
	}
}


// File: wp-graphql\src\Type\WPUnionType.php
<?php

namespace WPGraphQL\Type;

use GraphQL\Type\Definition\UnionType;
use WPGraphQL\Registry\TypeRegistry;

/**
 * Class WPUnionType
 *
 * Union Types should extend this class to take advantage of the helper methods
 * and consistent filters.
 *
 * @package WPGraphQL\Type\Union
 * @since   0.0.30
 */
class WPUnionType extends UnionType {

	/**
	 * @var \WPGraphQL\Registry\TypeRegistry
	 */
	public $type_registry;

	/**
	 * WPUnionType constructor.
	 *
	 * @param array<string,mixed>              $config The Config to setup a Union Type
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @since 0.0.30
	 */
	public function __construct( array $config, TypeRegistry $type_registry ) {
		$this->type_registry = $type_registry;

		/**
		 * Set the Types to start with capitals
		 */
		$name           = ucfirst( $config['name'] );
		$config['name'] = apply_filters( 'graphql_type_name', $name, $config, $this );

		$config['types'] = function () use ( $config ) {
			$prepared_types = [];
			if ( ! empty( $config['typeNames'] ) && is_array( $config['typeNames'] ) ) {
				$prepared_types = [];
				foreach ( $config['typeNames'] as $type_name ) {
					/**
					 * Skip if the type is excluded from the schema.
					 */
					if ( in_array( strtolower( $type_name ), $this->type_registry->get_excluded_types(), true ) ) {
						continue;
					}

					$prepared_types[] = $this->type_registry->get_type( $type_name );
				}
			}

			return $prepared_types;
		};

		$config['resolveType'] = function ( $obj ) use ( $config ) {
			$type = null;
			if ( is_callable( $config['resolveType'] ) ) {
				$type = call_user_func( $config['resolveType'], $obj );
			}

			/**
			 * Filter the resolve type method for all unions
			 *
			 * @param mixed $type The Type to resolve to, based on the object being resolved
			 * @param mixed $obj  The Object being resolved
			 * @param \WPGraphQL\Type\WPUnionType $wp_union_type The WPUnionType instance
			 */
			return apply_filters( 'graphql_union_resolve_type', $type, $obj, $this );
		};

		/**
		 * Filter the possible_types to allow systems to add to the possible resolveTypes.
		 *
		 * @param mixed                       $types         The possible types for the Union
		 * @param array<string,mixed>         $config        The config for the Union Type
		 * @param \WPGraphQL\Type\WPUnionType $wp_union_type The WPUnionType instance
		 *
		 * @return mixed|array
		 */
		$config['types'] = apply_filters( 'graphql_union_possible_types', $config['types'], $config, $this );

		/**
		 * Filter the config of WPUnionType
		 *
		 * @param array<string,mixed>         $config        Array of configuration options passed to the WPUnionType when instantiating a new type
		 * @param \WPGraphQL\Type\WPUnionType $wp_union_type The instance of the WPUnionType class
		 *
		 * @since 0.0.30
		 */
		$config = apply_filters( 'graphql_wp_union_type_config', $config, $this );

		/**
		 * Run an action when the WPUnionType is instantiating
		 *
		 * @param array<string,mixed>       $config        Array of configuration options passed to the WPUnionType when instantiating a new type
		 * @param \WPGraphQL\Type\WPUnionType $wp_union_type The instance of the WPUnionType class
		 */
		do_action( 'graphql_wp_union_type', $config, $this );

		parent::__construct( $config );
	}
}


// File: wp-graphql\src\Type\Connection\Comments.php
<?php

namespace WPGraphQL\Type\Connection;

use WPGraphQL\Data\Connection\CommentConnectionResolver;
use WPGraphQL\Data\DataSource;
use WPGraphQL\Model\Comment;
use WPGraphQL\Model\User;

/**
 * Class Comments
 *
 * This class organizes the registration of connections to Comments
 *
 * @package WPGraphQL\Type\Connection
 */
class Comments {

	/**
	 * Register connections to Comments.
	 *
	 * Connections from Post Objects to Comments are handled in \Registry\Utils\PostObject.
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_connections() {

		/**
		 * Register connection from RootQuery to Comments
		 */
		register_graphql_connection( self::get_connection_config() );

		/**
		 * Register connection from User to Comments
		 */
		register_graphql_connection(
			self::get_connection_config(
				[
					'fromType' => 'User',
					'resolve'  => static function ( User $user, $args, $context, $info ) {
						$resolver = new CommentConnectionResolver( $user, $args, $context, $info );

						return $resolver->set_query_arg( 'user_id', absint( $user->userId ) )->get_connection();
					},

				]
			)
		);

		register_graphql_connection(
			self::get_connection_config(
				[
					'fromType'           => 'Comment',
					'toType'             => 'Comment',
					'fromFieldName'      => 'parent',
					'connectionTypeName' => 'CommentToParentCommentConnection',
					'oneToOne'           => true,
					'resolve'            => static function ( Comment $comment, $args, $context, $info ) {
						$resolver = new CommentConnectionResolver( $comment, $args, $context, $info );

						return ! empty( $comment->comment_parent_id ) ? $resolver->one_to_one()->set_query_arg( 'comment__in', [ $comment->comment_parent_id ] )->get_connection() : null;
					},
				]
			)
		);

		/**
		 * Register connection from Comment to children comments
		 */
		register_graphql_connection(
			self::get_connection_config(
				[
					'fromType'      => 'Comment',
					'fromFieldName' => 'replies',
					'resolve'       => static function ( Comment $comment, $args, $context, $info ) {
						$resolver = new CommentConnectionResolver( $comment, $args, $context, $info );

						return $resolver->set_query_arg( 'parent', absint( $comment->commentId ) )->get_connection();
					},
				]
			)
		);
	}

	/**
	 * Given an array of $args, this returns the connection config, merging the provided args
	 * with the defaults
	 *
	 * @param array<string,mixed> $args
	 *
	 * @return array<string,mixed>
	 */
	public static function get_connection_config( $args = [] ) {
		$defaults = [
			'fromType'       => 'RootQuery',
			'toType'         => 'Comment',
			'fromFieldName'  => 'comments',
			'connectionArgs' => self::get_connection_args(),
			'resolve'        => static function ( $root, $args, $context, $info ) {
				return DataSource::resolve_comments_connection( $root, $args, $context, $info );
			},
		];

		return array_merge( $defaults, $args );
	}

	/**
	 * This returns the connection args for the Comment connection
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_connection_args() {
		return [
			'authorEmail'        => [
				'type'        => 'String',
				'description' => __( 'Comment author email address.', 'wp-graphql' ),
			],
			'authorUrl'          => [
				'type'        => 'String',
				'description' => __( 'Comment author URL.', 'wp-graphql' ),
			],
			'authorIn'           => [
				'type'        => [
					'list_of' => 'ID',
				],
				'description' => __( 'Array of author IDs to include comments for.', 'wp-graphql' ),
			],
			'authorNotIn'        => [
				'type'        => [
					'list_of' => 'ID',
				],
				'description' => __( 'Array of author IDs to exclude comments for.', 'wp-graphql' ),
			],
			'commentIn'          => [
				'type'        => [
					'list_of' => 'ID',
				],
				'description' => __( 'Array of comment IDs to include.', 'wp-graphql' ),
			],
			'commentNotIn'       => [
				'type'        => [
					'list_of' => 'ID',
				],
				'description' => __( 'Array of IDs of users whose unapproved comments will be returned by the query regardless of status.', 'wp-graphql' ),
			],
			'commentType'        => [
				'type'        => 'String',
				'description' => __( 'Include comments of a given type.', 'wp-graphql' ),
			],
			'commentTypeIn'      => [
				'type'        => [
					'list_of' => 'String',
				],
				'description' => __( 'Include comments from a given array of comment types.', 'wp-graphql' ),
			],
			'commentTypeNotIn'   => [
				'type'        => 'String',
				'description' => __( 'Exclude comments from a given array of comment types.', 'wp-graphql' ),
			],
			'contentAuthor'      => [
				'type'        => [
					'list_of' => 'ID',
				],
				'description' => __( 'Content object author ID to limit results by.', 'wp-graphql' ),
			],
			'contentAuthorIn'    => [
				'type'        => [
					'list_of' => 'ID',
				],
				'description' => __( 'Array of author IDs to retrieve comments for.', 'wp-graphql' ),
			],
			'contentAuthorNotIn' => [
				'type'        => [
					'list_of' => 'ID',
				],
				'description' => __( 'Array of author IDs *not* to retrieve comments for.', 'wp-graphql' ),
			],
			'contentId'          => [
				'type'        => 'ID',
				'description' => __( 'Limit results to those affiliated with a given content object ID.', 'wp-graphql' ),
			],
			'contentIdIn'        => [
				'type'        => [
					'list_of' => 'ID',
				],
				'description' => __( 'Array of content object IDs to include affiliated comments for.', 'wp-graphql' ),
			],
			'contentIdNotIn'     => [
				'type'        => [
					'list_of' => 'ID',
				],
				'description' => __( 'Array of content object IDs to exclude affiliated comments for.', 'wp-graphql' ),
			],
			'contentStatus'      => [
				'type'        => [
					'list_of' => 'PostStatusEnum',
				],
				'description' => __( 'Array of content object statuses to retrieve affiliated comments for. Pass \'any\' to match any value.', 'wp-graphql' ),
			],
			'contentType'        => [
				'type'        => [
					'list_of' => 'ContentTypeEnum',
				],
				'description' => __( 'Content object type or array of types to retrieve affiliated comments for. Pass \'any\' to match any value.', 'wp-graphql' ),
			],
			'contentName'        => [
				'type'        => 'String',
				'description' => __( 'Content object name (i.e. slug ) to retrieve affiliated comments for.', 'wp-graphql' ),
			],
			'contentParent'      => [
				'type'        => 'Int',
				'description' => __( 'Content Object parent ID to retrieve affiliated comments for.', 'wp-graphql' ),
			],
			'includeUnapproved'  => [
				'type'        => [
					'list_of' => 'ID',
				],
				'description' => __( 'Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty', 'wp-graphql' ),
			],
			'karma'              => [
				'type'        => 'Int',
				'description' => __( 'Karma score to retrieve matching comments for.', 'wp-graphql' ),
			],
			'orderby'            => [
				'type'        => 'CommentsConnectionOrderbyEnum',
				'description' => __( 'Field to order the comments by.', 'wp-graphql' ),
			],
			'order'              => [
				'type'        => 'OrderEnum',
				'description' => __( 'The cardinality of the order of the connection', 'wp-graphql' ),
			],
			'parent'             => [
				'type'        => 'Int',
				'description' => __( 'Parent ID of comment to retrieve children of.', 'wp-graphql' ),
			],
			'parentIn'           => [
				'type'        => [
					'list_of' => 'ID',
				],
				'description' => __( 'Array of parent IDs of comments to retrieve children for.', 'wp-graphql' ),
			],
			'parentNotIn'        => [
				'type'        => [
					'list_of' => 'ID',
				],
				'description' => __( 'Array of parent IDs of comments *not* to retrieve children for.', 'wp-graphql' ),
			],
			'search'             => [
				'type'        => 'String',
				'description' => __( 'Search term(s) to retrieve matching comments for.', 'wp-graphql' ),
			],
			'status'             => [
				'type'        => 'String',
				'description' => __( 'Comment status to limit results by.', 'wp-graphql' ),
			],
			'userId'             => [
				'type'        => 'ID',
				'description' => __( 'Include comments for a specific user ID.', 'wp-graphql' ),
			],
		];
	}
}


// File: wp-graphql\src\Type\Connection\MenuItems.php
<?php

namespace WPGraphQL\Type\Connection;

use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Data\Connection\MenuItemConnectionResolver;
use WPGraphQL\Model\Menu;
use WPGraphQL\Model\MenuItem;

/**
 * Class MenuItems
 *
 * This class organizes registration of connections to MenuItems
 *
 * @package WPGraphQL\Type\Connection
 */
class MenuItems {

	/**
	 * Register connections to MenuItems
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_connections() {

		/**
		 * Register the RootQueryToMenuItemsConnection
		 */
		register_graphql_connection( self::get_connection_config() );

		/**
		 * Registers the ChildItems connection to the MenuItem Type
		 * MenuItemToMenuItemConnection
		 */
		register_graphql_connection(
			self::get_connection_config(
				[
					'fromType'      => 'MenuItem',
					'fromFieldName' => 'childItems',
					'resolve'       => static function ( MenuItem $menu_item, $args, AppContext $context, ResolveInfo $info ) {
						if ( empty( $menu_item->menuId ) || empty( $menu_item->databaseId ) ) {
							return null;
						}

						$resolver = new MenuItemConnectionResolver( $menu_item, $args, $context, $info );
						$resolver->set_query_arg( 'nav_menu', $menu_item->menuId );
						$resolver->set_query_arg( 'meta_key', '_menu_item_menu_item_parent' );
						$resolver->set_query_arg( 'meta_value', (int) $menu_item->databaseId );
						return $resolver->get_connection();
					},
				]
			)
		);

		/**
		 * Register the MenuToMenuItemsConnection
		 */
		register_graphql_connection(
			self::get_connection_config(
				[
					'fromType' => 'Menu',
					'toType'   => 'MenuItem',
					'resolve'  => static function ( Menu $menu, $args, AppContext $context, ResolveInfo $info ) {
						$resolver = new MenuItemConnectionResolver( $menu, $args, $context, $info );
						$resolver->set_query_arg(
							'tax_query',
							[
								[
									'taxonomy'         => 'nav_menu',
									'field'            => 'term_id',
									'terms'            => (int) $menu->menuId,
									'include_children' => true,
									'operator'         => 'IN',
								],
							]
						);

						return $resolver->get_connection();
					},
				]
			)
		);
	}

	/**
	 * Given an array of $args, returns the args for the connection with the provided args merged
	 *
	 * @param array<string,mixed> $args
	 *
	 * @return array<string,mixed>
	 */
	public static function get_connection_config( $args = [] ) {
		return array_merge(
			[
				'fromType'       => 'RootQuery',
				'fromFieldName'  => 'menuItems',
				'toType'         => 'MenuItem',
				'connectionArgs' => [
					'id'               => [
						'type'        => 'Int',
						'description' => __( 'The database ID of the object', 'wp-graphql' ),
					],
					'location'         => [
						'type'        => 'MenuLocationEnum',
						'description' => __( 'The menu location for the menu being queried', 'wp-graphql' ),
					],
					'parentId'         => [
						'type'        => 'ID',
						'description' => __( 'The ID of the parent menu object', 'wp-graphql' ),
					],
					'parentDatabaseId' => [
						'type'        => 'Int',
						'description' => __( 'The database ID of the parent menu object', 'wp-graphql' ),
					],
				],
				'resolve'        => static function ( $source, $args, $context, $info ) {
					$resolver = new MenuItemConnectionResolver( $source, $args, $context, $info );

					return $resolver->get_connection();
				},
			],
			$args
		);
	}
}


// File: wp-graphql\src\Type\Connection\PostObjects.php
<?php

namespace WPGraphQL\Type\Connection;

use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Data\Connection\PostObjectConnectionResolver;
use WPGraphQL\Data\DataSource;
use WPGraphQL\Model\Comment;
use WPGraphQL\Model\Post;
use WPGraphQL\Model\PostType;
use WPGraphQL\Model\User;
use WPGraphQL\Utils\Utils;
use WP_Post_Type;
use WP_Taxonomy;

/**
 * Class PostObjects
 *
 * This class organizes the registration of connections to PostObjects
 *
 * @package WPGraphQL\Type\Connection
 */
class PostObjects {

	/**
	 * Registers the various connections from other Types to PostObjects
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_connections() {
		register_graphql_connection(
			[
				'fromType'       => 'ContentType',
				'toType'         => 'ContentNode',
				'fromFieldName'  => 'contentNodes',
				'connectionArgs' => self::get_connection_args(),
				'queryClass'     => 'WP_Query',
				'resolve'        => static function ( PostType $post_type, $args, AppContext $context, ResolveInfo $info ) {
					$resolver = new PostObjectConnectionResolver( $post_type, $args, $context, $info );
					$resolver->set_query_arg( 'post_type', $post_type->name );

					return $resolver->get_connection();
				},
			]
		);

		register_graphql_connection(
			[
				'fromType'      => 'Comment',
				'toType'        => 'ContentNode',
				'queryClass'    => 'WP_Query',
				'oneToOne'      => true,
				'fromFieldName' => 'commentedOn',
				'resolve'       => static function ( Comment $comment, $args, AppContext $context, ResolveInfo $info ) {
					if ( empty( $comment->comment_post_ID ) || ! absint( $comment->comment_post_ID ) ) {
						return null;
					}
					$id       = absint( $comment->comment_post_ID );
					$resolver = new PostObjectConnectionResolver( $comment, $args, $context, $info, 'any' );

					return $resolver->one_to_one()->set_query_arg( 'p', $id )->set_query_arg( 'post_parent', null )->get_connection();
				},
			]
		);

		register_graphql_connection(
			[
				'fromType'      => 'NodeWithRevisions',
				'toType'        => 'ContentNode',
				'fromFieldName' => 'revisionOf',
				'description'   => __( 'If the current node is a revision, this field exposes the node this is a revision of. Returns null if the node is not a revision of another node.', 'wp-graphql' ),
				'oneToOne'      => true,
				'resolve'       => static function ( Post $post, $args, AppContext $context, ResolveInfo $info ) {
					if ( ! $post->isRevision || ! isset( $post->parentDatabaseId ) || ! absint( $post->parentDatabaseId ) ) {
						return null;
					}

					$resolver = new PostObjectConnectionResolver( $post, $args, $context, $info );
					$resolver->set_query_arg( 'p', $post->parentDatabaseId );

					return $resolver->one_to_one()->get_connection();
				},
			]
		);

		register_graphql_connection(
			[
				'fromType'       => 'RootQuery',
				'toType'         => 'ContentNode',
				'queryClass'     => 'WP_Query',
				'fromFieldName'  => 'contentNodes',
				'connectionArgs' => self::get_connection_args(),
				'resolve'        => static function ( $source, $args, $context, $info ) {
					$post_types = isset( $args['where']['contentTypes'] ) && is_array( $args['where']['contentTypes'] ) ? $args['where']['contentTypes'] : \WPGraphQL::get_allowed_post_types();

					return DataSource::resolve_post_objects_connection( $source, $args, $context, $info, $post_types );
				},
			]
		);

		register_graphql_connection(
			[
				'fromType'           => 'HierarchicalContentNode',
				'toType'             => 'ContentNode',
				'fromFieldName'      => 'parent',
				'connectionTypeName' => 'HierarchicalContentNodeToParentContentNodeConnection',
				'description'        => __( 'The parent of the node. The parent object can be of various types', 'wp-graphql' ),
				'oneToOne'           => true,
				'resolve'            => static function ( Post $post, $args, AppContext $context, ResolveInfo $info ) {
					if ( ! isset( $post->parentDatabaseId ) || ! absint( $post->parentDatabaseId ) ) {
						return null;
					}

					$resolver = new PostObjectConnectionResolver( $post, $args, $context, $info );
					$resolver->set_query_arg( 'p', $post->parentDatabaseId );

					return $resolver->one_to_one()->get_connection();
				},
			]
		);

		register_graphql_connection(
			[
				'fromType'           => 'HierarchicalContentNode',
				'fromFieldName'      => 'children',
				'toType'             => 'ContentNode',
				'connectionTypeName' => 'HierarchicalContentNodeToContentNodeChildrenConnection',
				'connectionArgs'     => self::get_connection_args(),
				'queryClass'         => 'WP_Query',
				'resolve'            => static function ( Post $post, $args, $context, $info ) {
					if ( $post->isRevision ) {
						$id = $post->parentDatabaseId;
					} else {
						$id = $post->ID;
					}

					$resolver = new PostObjectConnectionResolver( $post, $args, $context, $info, 'any' );
					$resolver->set_query_arg( 'post_parent', $id );

					return $resolver->get_connection();
				},
			]
		);

		register_graphql_connection(
			[
				'fromType'           => 'HierarchicalContentNode',
				'toType'             => 'ContentNode',
				'fromFieldName'      => 'ancestors',
				'connectionArgs'     => self::get_connection_args(),
				'connectionTypeName' => 'HierarchicalContentNodeToContentNodeAncestorsConnection',
				'queryClass'         => 'WP_Query',
				'description'        => __( 'Returns ancestors of the node. Default ordered as lowest (closest to the child) to highest (closest to the root).', 'wp-graphql' ),
				'resolve'            => static function ( Post $post, $args, $context, $info ) {
					$ancestors = get_ancestors( $post->ID, '', 'post_type' );
					if ( empty( $ancestors ) || ! is_array( $ancestors ) ) {
						return null;
					}
					$resolver = new PostObjectConnectionResolver( $post, $args, $context, $info );
					$resolver->set_query_arg( 'post__in', $ancestors );
					$resolver->set_query_arg( 'orderby', 'post__in' );

					return $resolver->get_connection();
				},
			]
		);

		/**
		 * Register Connections to PostObjects
		 *
		 * @var \WP_Post_Type[] $allowed_post_types
		 */
		$allowed_post_types = \WPGraphQL::get_allowed_post_types( 'objects' );

		foreach ( $allowed_post_types as $post_type_object ) {

			/**
			 * Registers the RootQuery connection for each post_type
			 */
			if ( true === $post_type_object->graphql_register_root_connection && 'revision' !== $post_type_object->name ) {
				$root_query_from_field_name = Utils::format_field_name( $post_type_object->graphql_plural_name );

				// Prevent field name conflicts with the singular PostObject type.
				if ( $post_type_object->graphql_single_name === $post_type_object->graphql_plural_name ) {
					$root_query_from_field_name = 'all' . ucfirst( $post_type_object->graphql_single_name );
				}

				register_graphql_connection(
					self::get_connection_config(
						$post_type_object,
						[
							'fromFieldName' => $root_query_from_field_name,
						]
					)
				);
			}

			/**
			 * Any post type that supports author should have a connection from User->Author
			 */
			if ( true === post_type_supports( $post_type_object->name, 'author' ) ) {

				/**
				 * Registers the User connection for each post_type
				 */
				register_graphql_connection(
					self::get_connection_config(
						$post_type_object,
						[
							'fromType' => 'User',
							'resolve'  => static function ( User $user, $args, AppContext $context, ResolveInfo $info ) use ( $post_type_object ) {
								$resolver = new PostObjectConnectionResolver( $user, $args, $context, $info, $post_type_object->name );
								$resolver->set_query_arg( 'author', $user->userId );

								return $resolver->get_connection();
							},
						]
					)
				);
			}
		}
	}

	/**
	 * Given the Post Type Object and an array of args, this returns an array of args for use in
	 * registering a connection.
	 *
	 * @param mixed|\WP_Post_Type|\WP_Taxonomy $graphql_object The post type object for the post_type having a
	 * connection registered to it
	 * @param array<string,mixed>              $args           The custom args to modify the connection registration
	 *
	 * @return array<string,mixed>
	 */
	public static function get_connection_config( $graphql_object, $args = [] ) {
		$connection_args = self::get_connection_args( [], $graphql_object );

		if ( 'revision' === $graphql_object->name ) {
			unset( $connection_args['status'] );
			unset( $connection_args['stati'] );
		}

		return array_merge(
			[
				'fromType'       => 'RootQuery',
				'toType'         => $graphql_object->graphql_single_name,
				'queryClass'     => 'WP_Query',
				'fromFieldName'  => lcfirst( $graphql_object->graphql_plural_name ),
				'connectionArgs' => $connection_args,
				'resolve'        => static function ( $root, $args, $context, $info ) use ( $graphql_object ) {
					return DataSource::resolve_post_objects_connection( $root, $args, $context, $info, $graphql_object->name );
				},
			],
			$args
		);
	}

	/**
	 * Given an optional array of args, this returns the args to be used in the connection
	 *
	 * @param array<string,array<string,mixed>> $args             The args to modify the defaults
	 * @param mixed|\WP_Post_Type|\WP_Taxonomy  $post_type_object The post type the connection is going to
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_connection_args( $args = [], $post_type_object = null ) {
		$fields = [
			/**
			 * Search Parameter
			 *
			 * @see   : https://codex.wordpress.org/Class_Reference/WP_Query#Search_Parameter
			 * @since 0.0.5
			 */
			'search'      => [
				'name'        => 'search',
				'type'        => 'String',
				'description' => __( 'Show Posts based on a keyword search', 'wp-graphql' ),
			],

			/**
			 * Post & Page Parameters
			 *
			 * @see   : https://codex.wordpress.org/Class_Reference/WP_Query#Post_.26_Page_Parameters
			 * @since 0.0.5
			 */
			'id'          => [
				'type'        => 'Int',
				'description' => __( 'Specific database ID of the object', 'wp-graphql' ),
			],
			'in'          => [
				'type'        => [
					'list_of' => 'ID',
				],
				'description' => __( 'Array of IDs for the objects to retrieve', 'wp-graphql' ),
			],
			'notIn'       => [
				'type'        => [
					'list_of' => 'ID',
				],
				'description' => __( 'Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored', 'wp-graphql' ),
			],
			'name'        => [
				'type'        => 'String',
				'description' => __( 'Slug / post_name of the object', 'wp-graphql' ),
			],
			'nameIn'      => [
				'type'        => [
					'list_of' => 'String',
				],
				'description' => __( 'Specify objects to retrieve. Use slugs', 'wp-graphql' ),
			],
			'parent'      => [
				'type'        => 'ID',
				'description' => __( 'Use ID to return only children. Use 0 to return only top-level items', 'wp-graphql' ),
			],
			'parentIn'    => [
				'type'        => [
					'list_of' => 'ID',
				],
				'description' => __( 'Specify objects whose parent is in an array', 'wp-graphql' ),
			],
			'parentNotIn' => [
				'type'        => [
					'list_of' => 'ID',
				],
				'description' => __( 'Specify posts whose parent is not in an array', 'wp-graphql' ),
			],
			'title'       => [
				'type'        => 'String',
				'description' => __( 'Title of the object', 'wp-graphql' ),
			],

			/**
			 * Password parameters
			 *
			 * @see   : https://codex.wordpress.org/Class_Reference/WP_Query#Password_Parameters
			 * @since 0.0.2
			 */
			'hasPassword' => [
				'type'        => 'Boolean',
				'description' => __( 'True for objects with passwords; False for objects without passwords; null for all objects with or without passwords', 'wp-graphql' ),
			],
			'password'    => [
				'type'        => 'String',
				'description' => __( 'Show posts with a specific password.', 'wp-graphql' ),
			],

			/**
			 * NOTE: post_type is intentionally not supported on connections to Single post types as
			 * the connection to the singular Post Type already sets this argument as the entry
			 * point to the Graph
			 *
			 * @see   : https://codex.wordpress.org/Class_Reference/WP_Query#Type_Parameters
			 * @since 0.0.2
			 */

			/**
			 * Status parameters
			 *
			 * @see   : https://developer.wordpress.org/reference/classes/wp_query/#status-parameters
			 * @since 0.0.2
			 */
			'status'      => [
				'type'        => 'PostStatusEnum',
				'description' => __( 'Show posts with a specific status.', 'wp-graphql' ),
			],
			'stati'       => [
				'type'        => [
					'list_of' => 'PostStatusEnum',
				],
				'description' => __( 'Retrieve posts where post status is in an array.', 'wp-graphql' ),
			],

			/**
			 * Order & Orderby parameters
			 *
			 * @see   : https://codex.wordpress.org/Class_Reference/WP_Query#Order_.26_Orderby_Parameters
			 * @since 0.0.2
			 */
			'orderby'     => [
				'type'        => [
					'list_of' => 'PostObjectsConnectionOrderbyInput',
				],
				'description' => __( 'What parameter to use to order the objects by.', 'wp-graphql' ),
			],

			/**
			 * Date parameters
			 *
			 * @see https://developer.wordpress.org/reference/classes/wp_query/#date-parameters
			 */
			'dateQuery'   => [
				'type'        => 'DateQueryInput',
				'description' => __( 'Filter the connection based on dates', 'wp-graphql' ),
			],

			/**
			 * Mime type parameters
			 *
			 * @see https://developer.wordpress.org/reference/classes/wp_query/#mime-type-parameters
			 */
			'mimeType'    => [
				'type'        => 'MimeTypeEnum',
				'description' => __( 'Get objects with a specific mimeType property', 'wp-graphql' ),
			],
		];

		/**
		 * If the connection is to a single post type, add additional arguments.
		 *
		 * If the connection is to many post types, the `$post_type_object` will not be an instance
		 * of \WP_Post_Type, and we should not add these additional arguments because it
		 * confuses the connection args for connections of plural post types.
		 *
		 * For example, if you have one Post Type that supports author and another that doesn't
		 * we don't want to expose the `author` filter for a plural connection of multiple post types
		 * as it's misleading to be able to filter by author on a post type that doesn't have
		 * authors.
		 *
		 * If folks want to enable these arguments, they can filter them back in per-connection, but
		 * by default WPGraphQL is exposing the least common denominator (the fields that are shared
		 * by _all_ post types in a multi-post-type connection)
		 *
		 * Here's a practical example:
		 *
		 * Lets's say you register a "House" post type and it doesn't support author.
		 *
		 * The "House" Post Type will show in the `contentNodes` connection, which is a connection
		 * to many post types.
		 *
		 * We could (pseudo code) query like so:
		 *
		 * {
		 *   contentNodes( where: { contentTypes: [ HOUSE ] ) {
		 *     nodes {
		 *       id
		 *       title
		 *       ...on House {
		 *         ...someHouseFields
		 *       }
		 *     }
		 *   }
		 * }
		 *
		 * But since houses don't have authors, it doesn't make sense to have WPGraphQL expose the
		 * ability to query four houses filtered by author.
		 *
		 * ```
		 *{
		 *   contentNodes( where: { author: "some author input" contentTypes: [ HOUSE ] ) {
		 *     nodes {
		 *       id
		 *       title
		 *       ...on House {
		 *         ...someHouseFields
		 *       }
		 *     }
		 *   }
		 * }
		 * ```
		 *
		 * We want to output filters on connections based on what's actually possible, and filtering
		 * houses by author isn't possible, so exposing it in the Schema is quite misleading to
		 * consumers.
		 */
		if ( isset( $post_type_object ) && $post_type_object instanceof WP_Post_Type ) {

			/**
			 * Add arguments to post types that support author
			 */
			if ( true === post_type_supports( $post_type_object->name, 'author' ) ) {
				/**
				 * Author $args
				 *
				 * @see   : https://codex.wordpress.org/Class_Reference/WP_Query#Author_Parameters
				 * @since 0.0.5
				 */
				$fields['author']      = [
					'type'        => 'Int',
					'description' => __( 'The user that\'s connected as the author of the object. Use the userId for the author object.', 'wp-graphql' ),
				];
				$fields['authorName']  = [
					'type'        => 'String',
					'description' => __( 'Find objects connected to the author by the author\'s nicename', 'wp-graphql' ),
				];
				$fields['authorIn']    = [
					'type'        => [
						'list_of' => 'ID',
					],
					'description' => __( 'Find objects connected to author(s) in the array of author\'s userIds', 'wp-graphql' ),
				];
				$fields['authorNotIn'] = [
					'type'        => [
						'list_of' => 'ID',
					],
					'description' => __( 'Find objects NOT connected to author(s) in the array of author\'s userIds', 'wp-graphql' ),
				];
			}

			$connected_taxonomies = get_object_taxonomies( $post_type_object->name );
			if ( ! empty( $connected_taxonomies ) && in_array( 'category', $connected_taxonomies, true ) ) {
				/**
				 * Category $args
				 *
				 * @see   : https://codex.wordpress.org/Class_Reference/WP_Query#Category_Parameters
				 * @since 0.0.5
				 */
				$fields['categoryId']    = [
					'type'        => 'Int',
					'description' => __( 'Category ID', 'wp-graphql' ),
				];
				$fields['categoryName']  = [
					'type'        => 'String',
					'description' => __( 'Use Category Slug', 'wp-graphql' ),
				];
				$fields['categoryIn']    = [
					'type'        => [
						'list_of' => 'ID',
					],
					'description' => __( 'Array of category IDs, used to display objects from one category OR another', 'wp-graphql' ),
				];
				$fields['categoryNotIn'] = [
					'type'        => [
						'list_of' => 'ID',
					],
					'description' => __( 'Array of category IDs, used to display objects from one category OR another', 'wp-graphql' ),
				];
			}

			if ( ! empty( $connected_taxonomies ) && in_array( 'post_tag', $connected_taxonomies, true ) ) {
				/**
				 * Tag $args
				 *
				 * @see   : https://codex.wordpress.org/Class_Reference/WP_Query#Tag_Parameters
				 * @since 0.0.5
				 */
				$fields['tag']        = [
					'type'        => 'String',
					'description' => __( 'Tag Slug', 'wp-graphql' ),
				];
				$fields['tagId']      = [
					'type'        => 'String',
					'description' => __( 'Use Tag ID', 'wp-graphql' ),
				];
				$fields['tagIn']      = [
					'type'        => [
						'list_of' => 'ID',
					],
					'description' => __( 'Array of tag IDs, used to display objects from one tag OR another', 'wp-graphql' ),
				];
				$fields['tagNotIn']   = [
					'type'        => [
						'list_of' => 'ID',
					],
					'description' => __( 'Array of tag IDs, used to display objects from one tag OR another', 'wp-graphql' ),
				];
				$fields['tagSlugAnd'] = [
					'type'        => [
						'list_of' => 'String',
					],
					'description' => __( 'Array of tag slugs, used to display objects from one tag AND another', 'wp-graphql' ),
				];
				$fields['tagSlugIn']  = [
					'type'        => [
						'list_of' => 'String',
					],
					'description' => __( 'Array of tag slugs, used to include objects in ANY specified tags', 'wp-graphql' ),
				];
			}
		} elseif ( $post_type_object instanceof WP_Taxonomy ) {
			/**
			 * Taxonomy-specific Content Type $args
			 *
			 * @see   : https://developer.wordpress.org/reference/classes/wp_query/#post-type-parameters
			 */
			$args['contentTypes'] = [
				'type'        => [ 'list_of' => 'ContentTypesOf' . \WPGraphQL\Utils\Utils::format_type_name( $post_type_object->graphql_single_name ) . 'Enum' ],
				'description' => __( 'The Types of content to filter', 'wp-graphql' ),
			];
		} else {
			/**
			 * Handle cases when the connection is for many post types
			 */

			/**
			 * Content Type $args
			 *
			 * @see   : https://developer.wordpress.org/reference/classes/wp_query/#post-type-parameters
			 */
			$args['contentTypes'] = [
				'type'        => [ 'list_of' => 'ContentTypeEnum' ],
				'description' => __( 'The Types of content to filter', 'wp-graphql' ),
			];
		}

		return array_merge( $fields, $args );
	}
}


// File: wp-graphql\src\Type\Connection\Taxonomies.php
<?php

namespace WPGraphQL\Type\Connection;

use WPGraphQL\Data\Connection\TaxonomyConnectionResolver;
use WPGraphQL\Model\PostType;

class Taxonomies {

	/**
	 * Registers connections to the Taxonomy type
	 *
	 * @return void
	 */
	public static function register_connections() {
		register_graphql_connection(
			[
				'fromType'      => 'RootQuery',
				'toType'        => 'Taxonomy',
				'fromFieldName' => 'taxonomies',
				'resolve'       => static function ( $source, $args, $context, $info ) {
					$resolver = new TaxonomyConnectionResolver( $source, $args, $context, $info );
					return $resolver->get_connection();
				},
			]
		);

		register_graphql_connection(
			[
				'fromType'      => 'ContentType',
				'toType'        => 'Taxonomy',
				'fromFieldName' => 'connectedTaxonomies',
				'resolve'       => static function ( PostType $source, $args, $context, $info ) {
					if ( empty( $source->taxonomies ) ) {
						return null;
					}
					$resolver = new TaxonomyConnectionResolver( $source, $args, $context, $info );
					$resolver->set_query_arg( 'in', $source->taxonomies );
					return $resolver->get_connection();
				},
			]
		);
	}
}


// File: wp-graphql\src\Type\Connection\TermObjects.php
<?php

namespace WPGraphQL\Type\Connection;

use WPGraphQL\Data\Connection\TermObjectConnectionResolver;
use WPGraphQL\Data\DataSource;
use WPGraphQL\Utils\Utils;

/**
 * Class TermObjects
 *
 * This class organizes the registration of connections to TermObjects
 *
 * @package WPGraphQL\Type\Connection
 */
class TermObjects {

	/**
	 * Register connections to TermObjects
	 *
	 * @return void
	 */
	public static function register_connections() {
		register_graphql_connection(
			[
				'fromType'       => 'RootQuery',
				'toType'         => 'TermNode',
				'queryClass'     => 'WP_Term_Query',
				'fromFieldName'  => 'terms',
				'connectionArgs' => self::get_connection_args(
					[
						'taxonomies' => [
							'type'        => [ 'list_of' => 'TaxonomyEnum' ],
							'description' => __( 'The Taxonomy to filter terms by', 'wp-graphql' ),
						],
					]
				),
				'resolve'        => static function ( $source, $args, $context, $info ) {
					$taxonomies = isset( $args['where']['taxonomies'] ) && is_array( $args['where']['taxonomies'] ) ? $args['where']['taxonomies'] : \WPGraphQL::get_allowed_taxonomies();
					$resolver   = new TermObjectConnectionResolver( $source, $args, $context, $info, array_values( $taxonomies ) );

					return $resolver->get_connection();
				},
			]
		);

		/** @var \WP_Taxonomy[] $allowed_taxonomies */
		$allowed_taxonomies = \WPGraphQL::get_allowed_taxonomies( 'objects' );

		/**
		 * Loop through the allowed_taxonomies to register appropriate connections
		 */
		foreach ( $allowed_taxonomies as $tax_object ) {
			if ( ! $tax_object->graphql_register_root_connection ) {
				continue;
			}

			$root_query_from_field_name = Utils::format_field_name( $tax_object->graphql_plural_name );

			// Prevent field name conflicts with the singular TermObject type.
			if ( $tax_object->graphql_single_name === $tax_object->graphql_plural_name ) {
				$root_query_from_field_name = 'all' . ucfirst( $tax_object->graphql_single_name );
			}

			/**
			 * Registers the RootQuery connection for each allowed taxonomy's TermObjects
			 */
			register_graphql_connection(
				self::get_connection_config(
					$tax_object,
					[
						'fromFieldName' => $root_query_from_field_name,
					]
				)
			);
		}
	}

	/**
	 * Given the Taxonomy Object and an array of args, this returns an array of args for use in
	 * registering a connection.
	 *
	 * @param \WP_Taxonomy        $tax_object        The taxonomy object for the taxonomy having a connection registered to it
	 * @param array<string,mixed> $args              The custom args to modify the connection registration
	 *
	 * @return array<string,mixed>
	 */
	public static function get_connection_config( $tax_object, $args = [] ) {
		$defaults = [
			'fromType'       => 'RootQuery',
			'queryClass'     => 'WP_Term_Query',
			'toType'         => $tax_object->graphql_single_name,
			'fromFieldName'  => $tax_object->graphql_plural_name,
			'connectionArgs' => self::get_connection_args(),
			'resolve'        => static function ( $root, $args, $context, $info ) use ( $tax_object ) {
				return DataSource::resolve_term_objects_connection( $root, $args, $context, $info, $tax_object->name );
			},
		];

		return array_merge( $defaults, $args );
	}

	/**
	 * Given an optional array of args, this returns the args to be used in the connection
	 *
	 * @param array<string,array<string,mixed>> $args The args to modify the defaults
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_connection_args( $args = [] ) {
		return array_merge(
			[
				'childless'           => [
					'type'        => 'Boolean',
					'description' => __( 'True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false.', 'wp-graphql' ),
				],
				'childOf'             => [
					'type'        => 'Int',
					'description' => __( 'Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0.', 'wp-graphql' ),
				],
				'cacheDomain'         => [
					'type'        => 'String',
					'description' => __( 'Unique cache key to be produced when this query is stored in an object cache. Default is \'core\'.', 'wp-graphql' ),
				],
				'descriptionLike'     => [
					'type'        => 'String',
					'description' => __( 'Retrieve terms where the description is LIKE the input value. Default empty.', 'wp-graphql' ),
				],
				'exclude'             => [ // phpcs:ignore WordPressVIPMinimum.Performance.WPQueryParams.PostNotIn_exclude
					'type'        => [
						'list_of' => 'ID',
					],
					'description' => __( 'Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array.', 'wp-graphql' ),
				],
				'excludeTree'         => [
					'type'        => [
						'list_of' => 'ID',
					],
					'description' => __( 'Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array.', 'wp-graphql' ),
				],
				'hideEmpty'           => [
					'type'        => 'Boolean',
					'description' => __( 'Whether to hide terms not assigned to any posts. Accepts true or false. Default false', 'wp-graphql' ),
				],
				'hierarchical'        => [
					'type'        => 'Boolean',
					'description' => __( 'Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true.', 'wp-graphql' ),
				],
				'include'             => [
					'type'        => [
						'list_of' => 'ID',
					],
					'description' => __( 'Array of term ids to include. Default empty array.', 'wp-graphql' ),
				],
				'name'                => [
					'type'        => [
						'list_of' => 'String',
					],
					'description' => __( 'Array of names to return term(s) for. Default empty.', 'wp-graphql' ),
				],
				'nameLike'            => [
					'type'        => 'String',
					'description' => __( 'Retrieve terms where the name is LIKE the input value. Default empty.', 'wp-graphql' ),
				],
				'objectIds'           => [
					'type'        => [
						'list_of' => 'ID',
					],
					'description' => __( 'Array of object IDs. Results will be limited to terms associated with these objects.', 'wp-graphql' ),
				],
				'orderby'             => [
					'type'        => 'TermObjectsConnectionOrderbyEnum',
					'description' => __( 'Field(s) to order terms by. Defaults to \'name\'.', 'wp-graphql' ),
				],
				'order'               => [
					'type'        => 'OrderEnum',
					'description' => __( 'Direction the connection should be ordered in', 'wp-graphql' ),
				],
				'padCounts'           => [
					'type'        => 'Boolean',
					'description' => __( 'Whether to pad the quantity of a term\'s children in the quantity of each term\'s "count" object variable. Default false.', 'wp-graphql' ),
				],
				'parent'              => [
					'type'        => 'Int',
					'description' => __( 'Parent term ID to retrieve direct-child terms of. Default empty.', 'wp-graphql' ),
				],
				'search'              => [
					'type'        => 'String',
					'description' => __( 'Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty.', 'wp-graphql' ),
				],
				'slug'                => [
					'type'        => [
						'list_of' => 'String',
					],
					'description' => __( 'Array of slugs to return term(s) for. Default empty.', 'wp-graphql' ),
				],
				'termTaxonomId'       => [
					'type'              => [
						'list_of' => 'ID',
					],
					'description'       => __( 'Array of term taxonomy IDs, to match when querying terms.', 'wp-graphql' ),
					'deprecationReason' => __( 'Use `termTaxonomyId` instead', 'wp-graphql' ),
				],
				'termTaxonomyId'      => [
					'type'        => [
						'list_of' => 'ID',
					],
					'description' => __( 'Array of term taxonomy IDs, to match when querying terms.', 'wp-graphql' ),
				],
				'updateTermMetaCache' => [
					'type'        => 'Boolean',
					'description' => __( 'Whether to prime meta caches for matched terms. Default true.', 'wp-graphql' ),
				],
			],
			$args
		);
	}
}


// File: wp-graphql\src\Type\Connection\Users.php
<?php
namespace WPGraphQL\Type\Connection;

use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Data\Connection\UserConnectionResolver;
use WPGraphQL\Data\DataSource;
use WPGraphQL\Model\Post;
use WPGraphQL\Utils\Utils;

/**
 * Class Users
 *
 * This class organizes the registration of connections to Users
 *
 * @package WPGraphQL\Type\Connection
 */
class Users {

	/**
	 * Register connections to Users
	 *
	 * @return void
	 */
	public static function register_connections() {

		/**
		 * Connection from RootQuery to Users
		 */
		register_graphql_connection(
			[
				'fromType'       => 'RootQuery',
				'toType'         => 'User',
				'fromFieldName'  => 'users',
				'resolve'        => static function ( $source, $args, $context, $info ) {
					return DataSource::resolve_users_connection( $source, $args, $context, $info );
				},
				'connectionArgs' => self::get_connection_args(),
			]
		);

		register_graphql_connection(
			[
				'fromType'           => 'ContentNode',
				'toType'             => 'User',
				'connectionTypeName' => 'ContentNodeToEditLockConnection',
				'edgeFields'         => [
					'lockTimestamp' => [
						'type'        => 'String',
						'description' => __( 'The timestamp for when the node was last edited', 'wp-graphql' ),
						'resolve'     => static function ( $edge ) {
							if ( isset( $edge['source'] ) && ( $edge['source'] instanceof Post ) ) {
								$edit_lock = $edge['source']->editLock;
								$time      = ( is_array( $edit_lock ) && ! empty( $edit_lock[0] ) ) ? $edit_lock[0] : null;
								return ! empty( $time ) ? Utils::prepare_date_response( $time, gmdate( 'Y-m-d H:i:s', $time ) ) : null;
							}
							return null;
						},
					],
				],
				'fromFieldName'      => 'editingLockedBy',
				'description'        => __( 'If a user has edited the node within the past 15 seconds, this will return the user that last edited. Null if the edit lock doesn\'t exist or is greater than 15 seconds', 'wp-graphql' ),
				'oneToOne'           => true,
				'resolve'            => static function ( Post $source, $args, $context, $info ) {
					if ( ! isset( $source->editLock[1] ) || ! absint( $source->editLock[1] ) ) {
						return null;
					}

					$resolver = new UserConnectionResolver( $source, $args, $context, $info );
					$resolver->one_to_one()->set_query_arg( 'include', [ absint( $source->editLock[1] ) ] );

					return $resolver->get_connection();
				},
			]
		);

		register_graphql_connection(
			[
				'fromType'           => 'ContentNode',
				'toType'             => 'User',
				'fromFieldName'      => 'lastEditedBy',
				'connectionTypeName' => 'ContentNodeToEditLastConnection',
				'description'        => __( 'The user that most recently edited the node', 'wp-graphql' ),
				'oneToOne'           => true,
				'resolve'            => static function ( Post $source, $args, $context, $info ) {
					if ( empty( $source->editLastId ) ) {
						return null;
					}

					$resolver = new UserConnectionResolver( $source, $args, $context, $info );
					$resolver->set_query_arg( 'include', [ absint( $source->editLastId ) ] );
					return $resolver->one_to_one()->get_connection();
				},
			]
		);

		register_graphql_connection(
			[
				'fromType'      => 'NodeWithAuthor',
				'toType'        => 'User',
				'fromFieldName' => 'author',
				'oneToOne'      => true,
				'resolve'       => static function ( Post $post, $args, AppContext $context, ResolveInfo $info ) {
					if ( empty( $post->authorDatabaseId ) ) {
						return null;
					}

					$resolver = new UserConnectionResolver( $post, $args, $context, $info );
					$resolver->set_query_arg( 'include', [ absint( $post->authorDatabaseId ) ] );
					return $resolver->one_to_one()->get_connection();
				},
			]
		);
	}

	/**
	 * Returns the connection args for use in the connection
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_connection_args() {
		return [
			'role'              => [
				'type'        => 'UserRoleEnum',
				'description' => __( 'An array of role names that users must match to be included in results. Note that this is an inclusive list: users must match *each* role.', 'wp-graphql' ),
			],
			'roleIn'            => [
				'type'        => [
					'list_of' => 'UserRoleEnum',
				],
				'description' => __( 'An array of role names. Matched users must have at least one of these roles.', 'wp-graphql' ),
			],
			'roleNotIn'         => [
				'type'        => [
					'list_of' => 'UserRoleEnum',
				],
				'description' => __( 'An array of role names to exclude. Users matching one or more of these roles will not be included in results.', 'wp-graphql' ),
			],
			'include'           => [
				'type'        => [
					'list_of' => 'Int',
				],
				'description' => __( 'Array of userIds to include.', 'wp-graphql' ),
			],
			'exclude'           => [ // phpcs:ignore WordPressVIPMinimum.Performance.WPQueryParams.PostNotIn_exclude
				'type'        => [
					'list_of' => 'Int',
				],
				'description' => __( 'Array of userIds to exclude.', 'wp-graphql' ),
			],
			'search'            => [
				'type'        => 'String',
				'description' => __( 'Search keyword. Searches for possible string matches on columns. When "searchColumns" is left empty, it tries to determine which column to search in based on search string.', 'wp-graphql' ),
			],
			'searchColumns'     => [
				'type'        => [
					'list_of' => 'UsersConnectionSearchColumnEnum',
				],
				'description' => __( 'Array of column names to be searched. Accepts \'ID\', \'login\', \'nicename\', \'email\', \'url\'.', 'wp-graphql' ),
			],
			'hasPublishedPosts' => [
				'type'        => [
					'list_of' => 'ContentTypeEnum',
				],
				'description' => __( 'Pass an array of post types to filter results to users who have published posts in those post types.', 'wp-graphql' ),
			],
			'nicename'          => [
				'type'        => 'String',
				'description' => __( 'The user nicename.', 'wp-graphql' ),
			],
			'nicenameIn'        => [
				'type'        => [
					'list_of' => 'String',
				],
				'description' => __( 'An array of nicenames to include. Users matching one of these nicenames will be included in results.', 'wp-graphql' ),
			],
			'nicenameNotIn'     => [
				'type'        => [
					'list_of' => 'String',
				],
				'description' => __( 'An array of nicenames to exclude. Users matching one of these nicenames will not be included in results.', 'wp-graphql' ),
			],
			'login'             => [
				'type'        => 'String',
				'description' => __( 'The user login.', 'wp-graphql' ),
			],
			'loginIn'           => [
				'type'        => [
					'list_of' => 'String',
				],
				'description' => __( 'An array of logins to include. Users matching one of these logins will be included in results.', 'wp-graphql' ),
			],
			'loginNotIn'        => [
				'type'        => [
					'list_of' => 'String',
				],
				'description' => __( 'An array of logins to exclude. Users matching one of these logins will not be included in results.', 'wp-graphql' ),
			],
			'orderby'           => [
				'type'        => [
					'list_of' => 'UsersConnectionOrderbyInput',
				],
				'description' => __( 'What parameter to use to order the objects by.', 'wp-graphql' ),
			],
		];
	}
}


// File: wp-graphql\src\Type\Enum\AvatarRatingEnum.php
<?php
namespace WPGraphQL\Type\Enum;

class AvatarRatingEnum {

	/**
	 * Register the AvatarRatingEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'AvatarRatingEnum',
			[
				'description' => __( "What rating to display avatars up to. Accepts 'G', 'PG', 'R', 'X', and are judged in that order. Default is the value of the 'avatar_rating' option", 'wp-graphql' ),
				'values'      => [
					'G'  => [
						'description' => 'Indicates a G level avatar rating level.',
						'value'       => 'G',
					],
					'PG' => [
						'description' => 'Indicates a PG level avatar rating level.',
						'value'       => 'PG',
					],
					'R'  => [
						'description' => 'Indicates an R level avatar rating level.',
						'value'       => 'R',
					],
					'X'  => [
						'description' => 'Indicates an X level avatar rating level.',
						'value'       => 'X',
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\CommentNodeIdTypeEnum.php
<?php
namespace WPGraphQL\Type\Enum;

/**
 * Class CommentNodeIdTypeEnum
 *
 * @package WPGraphQL\Type\Enum
 */
class CommentNodeIdTypeEnum {

	/**
	 * Register the CommentNodeIdTypeEnum
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'CommentNodeIdTypeEnum',
			[
				'description' => __( 'The Type of Identifier used to fetch a single comment node. Default is "ID". To be used along with the "id" field.', 'wp-graphql' ),
				'values'      => [
					'ID'          => [
						'name'        => 'ID',
						'value'       => 'global_id',
						'description' => __( 'Identify a resource by the (hashed) Global ID.', 'wp-graphql' ),
					],
					'DATABASE_ID' => [
						'name'        => 'DATABASE_ID',
						'value'       => 'database_id',
						'description' => __( 'Identify a resource by the Database ID.', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\CommentsConnectionOrderbyEnum.php
<?php
namespace WPGraphQL\Type\Enum;

class CommentsConnectionOrderbyEnum {

	/**
	 * Register the CommentsConnectionOrderbyEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'CommentsConnectionOrderbyEnum',
			[
				'description' => __( 'Options for ordering the connection', 'wp-graphql' ),
				'values'      => [
					'COMMENT_AGENT'        => [
						'description' => __( 'Order by browser user agent of the commenter.', 'wp-graphql' ),
						'value'       => 'comment_agent',
					],
					'COMMENT_APPROVED'     => [
						'description' => __( 'Order by approval status of the comment.', 'wp-graphql' ),
						'value'       => 'comment_approved',
					],
					'COMMENT_AUTHOR'       => [
						'description' => __( 'Order by name of the comment author.', 'wp-graphql' ),
						'value'       => 'comment_author',
					],
					'COMMENT_AUTHOR_EMAIL' => [
						'description' => __( 'Order by e-mail of the comment author.', 'wp-graphql' ),
						'value'       => 'comment_author_email',
					],
					'COMMENT_AUTHOR_IP'    => [
						'description' => __( 'Order by IP address of the comment author.', 'wp-graphql' ),
						'value'       => 'comment_author_IP',
					],
					'COMMENT_AUTHOR_URL'   => [
						'description' => __( 'Order by URL address of the comment author.', 'wp-graphql' ),
						'value'       => 'comment_author_url',
					],
					'COMMENT_CONTENT'      => [
						'description' => __( 'Order by the comment contents.', 'wp-graphql' ),
						'value'       => 'comment_content',
					],
					'COMMENT_DATE'         => [
						'description' => __( 'Order by date/time timestamp of the comment.', 'wp-graphql' ),
						'value'       => 'comment_date',
					],
					'COMMENT_DATE_GMT'     => [
						'description' => __( 'Order by GMT timezone date/time timestamp of the comment.', 'wp-graphql' ),
						'value'       => 'comment_date_gmt',
					],
					'COMMENT_ID'           => [
						'description' => __( 'Order by the globally unique identifier for the comment object', 'wp-graphql' ),
						'value'       => 'comment_ID',
					],
					'COMMENT_IN'           => [
						'description' => __( 'Order by the array list of comment IDs listed in the where clause.', 'wp-graphql' ),
						'value'       => 'comment__in',
					],
					'COMMENT_KARMA'        => [
						'description' => __( 'Order by the comment karma score.', 'wp-graphql' ),
						'value'       => 'comment_karma',
					],
					'COMMENT_PARENT'       => [
						'description' => __( 'Order by the comment parent ID.', 'wp-graphql' ),
						'value'       => 'comment_parent',
					],
					'COMMENT_POST_ID'      => [
						'description' => __( 'Order by the post object ID.', 'wp-graphql' ),
						'value'       => 'comment_post_ID',
					],
					'COMMENT_TYPE'         => [
						'description' => __( 'Order by the the type of comment, such as \'comment\', \'pingback\', or \'trackback\'.', 'wp-graphql' ),
						'value'       => 'comment_type',
					],
					'USER_ID'              => [
						'description' => __( 'Order by the user ID.', 'wp-graphql' ),
						'value'       => 'user_id',
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\CommentStatusEnum.php
<?php

namespace WPGraphQL\Type\Enum;

use WPGraphQL\Type\WPEnumType;

class CommentStatusEnum {

	/**
	 * Register the CommentStatusEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		$values = [];

		$stati = get_comment_statuses();

		/**
		 * Loop through the post_stati
		 */
		foreach ( $stati as $status => $name ) {
			$values[ WPEnumType::get_safe_name( $status ) ] = [
				// translators: %s is the name of the comment status
				'description' => sprintf( __( 'Comments with the %1$s status', 'wp-graphql' ), $name ),
				'value'       => $status,
			];
		}

		register_graphql_enum_type(
			'CommentStatusEnum',
			[
				'description' => __( 'The status of the comment object.', 'wp-graphql' ),
				'values'      => $values,
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\ContentNodeIdTypeEnum.php
<?php

namespace WPGraphQL\Type\Enum;

class ContentNodeIdTypeEnum {

	/**
	 * Register the Enum used for setting the field to identify content nodes by
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'ContentNodeIdTypeEnum',
			[
				'description' => __( 'The Type of Identifier used to fetch a single resource. Default is ID.', 'wp-graphql' ),
				'values'      => self::get_values(),
			]
		);

		/** @var \WP_Post_Type[] */
		$allowed_post_types = \WPGraphQL::get_allowed_post_types( 'objects' );

		foreach ( $allowed_post_types as $post_type_object ) {
			$values = self::get_values();

			if ( ! $post_type_object->hierarchical ) {
				$values['SLUG'] = [
					'name'        => 'SLUG',
					'value'       => 'slug',
					'description' => __( 'Identify a resource by the slug. Available to non-hierarchcial Types where the slug is a unique identifier.', 'wp-graphql' ),
				];
			}

			if ( 'attachment' === $post_type_object->name ) {
				$values['SOURCE_URL'] = [
					'name'        => 'SOURCE_URL',
					'value'       => 'source_url',
					'description' => __( 'Identify a media item by its source url', 'wp-graphql' ),
				];
			}

			/**
			 * Register a unique Enum per Post Type. This allows for granular control
			 * over filtering and customizing the values available per Post Type.
			 */
			register_graphql_enum_type(
				$post_type_object->graphql_single_name . 'IdType',
				[
					'description' => __( 'The Type of Identifier used to fetch a single resource. Default is ID.', 'wp-graphql' ),
					'values'      => $values,
				]
			);
		}
	}

	/**
	 * Get the values for the Enum definitions
	 *
	 * @return array<string,array<string,string>>
	 */
	public static function get_values() {
		return [
			'ID'          => [
				'name'        => 'ID',
				'value'       => 'global_id',
				'description' => __( 'Identify a resource by the (hashed) Global ID.', 'wp-graphql' ),
			],
			'DATABASE_ID' => [
				'name'        => 'DATABASE_ID',
				'value'       => 'database_id',
				'description' => __( 'Identify a resource by the Database ID.', 'wp-graphql' ),
			],
			'URI'         => [
				'name'        => 'URI',
				'value'       => 'uri',
				'description' => __( 'Identify a resource by the URI.', 'wp-graphql' ),
			],
		];
	}
}


// File: wp-graphql\src\Type\Enum\ContentTypeEnum.php
<?php

namespace WPGraphQL\Type\Enum;

use WPGraphQL\Type\WPEnumType;
use WPGraphQL\Utils\Utils;

class ContentTypeEnum {

	/**
	 * Register the ContentTypeEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		$values = [];

		/**
		 * Get the allowed post types
		 *
		 * @var string[] $allowed_post_types
		 */
		$allowed_post_types = \WPGraphQL::get_allowed_post_types();

		/**
		 * Loop through the post types and create an array
		 * of values for use in the enum type.
		 */
		foreach ( $allowed_post_types as $allowed_post_type ) {
			$values[ WPEnumType::get_safe_name( $allowed_post_type ) ] = [
				'value'       => $allowed_post_type,
				'description' => __( 'The Type of Content object', 'wp-graphql' ),
			];
		}

		register_graphql_enum_type(
			'ContentTypeEnum',
			[
				'description' => __( 'Allowed Content Types', 'wp-graphql' ),
				'values'      => $values,
			]
		);

		/**
		 * Register a ContentTypesOf${taxonomyName}Enum for each taxonomy
		 *
		 * @var \WP_Taxonomy[] $allowed_taxonomies
		 */
		$allowed_taxonomies = \WPGraphQL::get_allowed_taxonomies( 'objects' );
		foreach ( $allowed_taxonomies as $tax_object ) {
			/**
			 * Loop through the taxonomy's object type and create an array
			 * of values for use in the enum type.
			 */
			$taxonomy_values = [];
			foreach ( $tax_object->object_type as $tax_object_type ) {
				// Skip object types that are not allowed by WPGraphQL
				if ( ! array_key_exists( $tax_object_type, $allowed_post_types ) ) {
					continue;
				}

				$taxonomy_values[ WPEnumType::get_safe_name( $tax_object_type ) ] = [
					'name'        => WPEnumType::get_safe_name( $tax_object_type ),
					'value'       => $tax_object_type,
					'description' => __( 'The Type of Content object', 'wp-graphql' ),
				];
			}

			if ( ! empty( $taxonomy_values ) ) {
				register_graphql_enum_type(
					'ContentTypesOf' . Utils::format_type_name( $tax_object->graphql_single_name ) . 'Enum',
					[
						'description' => sprintf(
							// translators: %s is the taxonomy's GraphQL name.
							__( 'Allowed Content Types of the %s taxonomy.', 'wp-graphql' ),
							Utils::format_type_name( $tax_object->graphql_single_name )
						),
						'values'      => $taxonomy_values,
					]
				);
			}
		}
	}
}


// File: wp-graphql\src\Type\Enum\ContentTypeIdTypeEnum.php
<?php

namespace WPGraphQL\Type\Enum;

class ContentTypeIdTypeEnum {

	/**
	 * Register the ContentTypeIdTypeEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'ContentTypeIdTypeEnum',
			[
				'description' => __( 'The Type of Identifier used to fetch a single Content Type node. To be used along with the "id" field. Default is "ID".', 'wp-graphql' ),
				'values'      => [
					'ID'   => [
						'name'        => 'ID',
						'value'       => 'id',
						'description' => __( 'The globally unique ID', 'wp-graphql' ),
					],
					'NAME' => [
						'name'        => 'NAME',
						'value'       => 'name',
						'description' => __( 'The name of the content type.', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\MediaItemSizeEnum.php
<?php

namespace WPGraphQL\Type\Enum;

use WPGraphQL\Type\WPEnumType;

class MediaItemSizeEnum {

	/**
	 * Register the MediaItemSizeEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		/**
		 * This returns an empty array on the VIP Go platform.
		 */
		$sizes = get_intermediate_image_sizes(); // phpcs:ignore WordPressVIPMinimum.Functions.RestrictedFunctions.get_intermediate_image_sizes_get_intermediate_image_sizes

		$values      = [];
		$image_sizes = ! empty( $sizes ) && is_array( $sizes ) ? $sizes : [
			'thumbnail',
			'medium',
			'medium_large',
			'large',
			'full',
		];

		/**
		 * Loop through the image_sizes
		 */
		foreach ( $image_sizes as $image_size ) {
			$values[ WPEnumType::get_safe_name( $image_size ) ] = [
				'description' => sprintf(
					// translators: %1$s is the image size.
					__( 'MediaItem with the %1$s size', 'wp-graphql' ),
					$image_size
				),
				'value'       => $image_size,
			];
		}

		register_graphql_enum_type(
			'MediaItemSizeEnum',
			[
				'description' => __( 'The size of the media item object.', 'wp-graphql' ),
				'values'      => $values,
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\MediaItemStatusEnum.php
<?php

namespace WPGraphQL\Type\Enum;

use WPGraphQL\Type\WPEnumType;

class MediaItemStatusEnum {

	/**
	 * Register the MediaItemStatusEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		$values = [];

		$post_stati = [
			'inherit',
			'private',
			'trash',
			'auto-draft',
		];

		/**
		 * Loop through the post_stati
		 */
		foreach ( $post_stati as $status ) {
			$values[ WPEnumType::get_safe_name( $status ) ] = [
				'description' => sprintf(
					// translators: %1$s is the post status.
					__( 'Objects with the %1$s status', 'wp-graphql' ),
					$status
				),
				'value'       => $status,
			];
		}

		register_graphql_enum_type(
			'MediaItemStatusEnum',
			[
				'description' => __( 'The status of the media item object.', 'wp-graphql' ),
				'values'      => $values,
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\MenuItemNodeIdTypeEnum.php
<?php
namespace WPGraphQL\Type\Enum;

/**
 * Class MenuItemNodeIdTypeEnum
 *
 * @package WPGraphQL\Type\Enum
 */
class MenuItemNodeIdTypeEnum {

	/**
	 * Register the MenuItemNodeIdTypeEnum
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'MenuItemNodeIdTypeEnum',
			[
				'description' => __( 'The Type of Identifier used to fetch a single node. Default is "ID". To be used along with the "id" field.', 'wp-graphql' ),
				'values'      => [
					'ID'          => [
						'name'        => 'ID',
						'value'       => 'global_id',
						'description' => __( 'Identify a resource by the (hashed) Global ID.', 'wp-graphql' ),
					],
					'DATABASE_ID' => [
						'name'        => 'DATABASE_ID',
						'value'       => 'database_id',
						'description' => __( 'Identify a resource by the Database ID.', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\MenuLocationEnum.php
<?php
namespace WPGraphQL\Type\Enum;

use WPGraphQL\Data\DataSource;
use WPGraphQL\Type\WPEnumType;

class MenuLocationEnum {

	/**
	 * Register the MenuLocationEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		$values = [];

		$locations = DataSource::get_registered_nav_menu_locations();

		if ( ! empty( $locations ) && is_array( $locations ) ) {
			foreach ( $locations as $location ) {
				$values[ WPEnumType::get_safe_name( $location ) ] = [
					'value'       => $location,
					'description' => sprintf(
						// translators: %s is the menu location name.
						__( 'Put the menu in the %s location', 'wp-graphql' ),
						$location
					),
				];
			}
		}

		if ( empty( $values ) ) {
			$values['EMPTY'] = [
				'value'       => 'Empty menu location',
				'description' => __( 'Empty menu location', 'wp-graphql' ),
			];
		}

		register_graphql_enum_type(
			'MenuLocationEnum',
			[
				'description' => __( 'Registered menu locations', 'wp-graphql' ),
				'values'      => $values,
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\MenuNodeIdTypeEnum.php
<?php
namespace WPGraphQL\Type\Enum;

/**
 * Class MenuNodeIdTypeEnum
 *
 * @package WPGraphQL\Type\Enum
 */
class MenuNodeIdTypeEnum {

	/**
	 * Register the MenuNodeIdTypeEnum
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'MenuNodeIdTypeEnum',
			[
				'description' => __( 'The Type of Identifier used to fetch a single node. Default is "ID". To be used along with the "id" field.', 'wp-graphql' ),
				'values'      => [
					'ID'          => [
						'name'        => 'ID',
						'value'       => 'global_id',
						'description' => __( 'Identify a menu node by the (hashed) Global ID.', 'wp-graphql' ),
					],
					'DATABASE_ID' => [
						'name'        => 'DATABASE_ID',
						'value'       => 'database_id',
						'description' => __( 'Identify a menu node by the Database ID.', 'wp-graphql' ),
					],
					'LOCATION'    => [
						'name'        => 'LOCATION',
						'value'       => 'location',
						'description' => __( 'Identify a menu node by the slug of menu location to which it is assigned', 'wp-graphql' ),
					],
					'NAME'        => [
						'name'        => 'NAME',
						'value'       => 'name',
						'description' => __( 'Identify a menu node by its name', 'wp-graphql' ),
					],
					'SLUG'        => [
						'name'        => 'SLUG',
						'value'       => 'slug',
						'description' => __( 'Identify a menu node by its slug', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\MimeTypeEnum.php
<?php

namespace WPGraphQL\Type\Enum;

use WPGraphQL\Type\WPEnumType;

class MimeTypeEnum {

	/**
	 * Register the MimeTypeEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		$values = [
			'IMAGE_JPEG' => [
				'value'       => 'image/jpeg',
				'description' => __( 'An image in the JPEG format', 'wp-graphql' ),
			],
		];

		$allowed_mime_types = get_allowed_mime_types();

		if ( ! empty( $allowed_mime_types ) ) {
			$values = [];
			foreach ( $allowed_mime_types as $mime_type ) {
				$values[ WPEnumType::get_safe_name( $mime_type ) ] = [
					'value'       => $mime_type,
					'description' => sprintf(
						// translators: %s is the mime type.
						__( '%s mime type.', 'wp-graphql' ),
						$mime_type
					),
				];
			}
		}

		register_graphql_enum_type(
			'MimeTypeEnum',
			[
				'description' => __( 'The MimeType of the object', 'wp-graphql' ),
				'values'      => $values,
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\OrderEnum.php
<?php

namespace WPGraphQL\Type\Enum;

class OrderEnum {

	/**
	 * Register the OrderEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'OrderEnum',
			[
				'description'  => __( 'The cardinality of the connection order', 'wp-graphql' ),
				'values'       => [
					'ASC'  => [
						'value'       => 'ASC',
						'description' => __( 'Sort the query result set in an ascending order', 'wp-graphql' ),
					],
					'DESC' => [
						'value'       => 'DESC',
						'description' => __( 'Sort the query result set in a descending order', 'wp-graphql' ),
					],
				],
				'defaultValue' => 'DESC',
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\PluginStatusEnum.php
<?php

namespace WPGraphQL\Type\Enum;

class PluginStatusEnum {

	/**
	 * Register the PluginStatusEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'PluginStatusEnum',
			[
				'description'  => __( 'The status of the WordPress plugin.', 'wp-graphql' ),
				'values'       => self::get_enum_values(),
				'defaultValue' => 'ACTIVE',
			]
		);
	}

	/**
	 * Returns the array configuration for the GraphQL enum values.
	 *
	 * @return array<string,array<string,string>>
	 */
	protected static function get_enum_values() {
		$values = [
			'ACTIVE'          => [
				'value'       => 'active',
				'description' => __( 'The plugin is currently active.', 'wp-graphql' ),
			],
			'DROP_IN'         => [
				'value'       => 'dropins',
				'description' => __( 'The plugin is a drop-in plugin.', 'wp-graphql' ),

			],
			'INACTIVE'        => [
				'value'       => 'inactive',
				'description' => __( 'The plugin is currently inactive.', 'wp-graphql' ),
			],
			'MUST_USE'        => [
				'value'       => 'mustuse',
				'description' => __( 'The plugin is a must-use plugin.', 'wp-graphql' ),
			],
			'PAUSED'          => [
				'value'       => 'paused',
				'description' => __( 'The plugin is technically active but was paused while loading.', 'wp-graphql' ),
			],
			'RECENTLY_ACTIVE' => [
				'value'       => 'recently_activated',
				'description' => __( 'The plugin was active recently.', 'wp-graphql' ),
			],
			'UPGRADE'         => [
				'value'       => 'upgrade',
				'description' => __( 'The plugin has an upgrade available.', 'wp-graphql' ),
			],
		];

		// Multisite enums
		if ( is_multisite() ) {
			$values['NETWORK_ACTIVATED'] = [
				'value'       => 'network_activated',
				'description' => __( 'The plugin is activated on the multisite network.', 'wp-graphql' ),
			];
			$values['NETWORK_INACTIVE']  = [
				'value'       => 'network_inactive',
				'description' => __( 'The plugin is installed on the multisite network, but is currently inactive.', 'wp-graphql' ),
			];
		}

		return $values;
	}
}


// File: wp-graphql\src\Type\Enum\PostObjectFieldFormatEnum.php
<?php

namespace WPGraphQL\Type\Enum;

class PostObjectFieldFormatEnum {

	/**
	 * Register the PostObjectFieldFormatEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'PostObjectFieldFormatEnum',
			[
				'description' => __( 'The format of post field data.', 'wp-graphql' ),
				'values'      => [
					'RAW'      => [
						'name'        => 'RAW',
						'description' => __( 'Provide the field value directly from database. Null on unauthenticated requests.', 'wp-graphql' ),
						'value'       => 'raw',
					],
					'RENDERED' => [
						'name'        => 'RENDERED',
						'description' => __( 'Provide the field value as rendered by WordPress. Default.', 'wp-graphql' ),
						'value'       => 'rendered',
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\PostObjectsConnectionDateColumnEnum.php
<?php

namespace WPGraphQL\Type\Enum;

class PostObjectsConnectionDateColumnEnum {

	/**
	 * Register the PostObjectsConnectionDateColumnEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'PostObjectsConnectionDateColumnEnum',
			[
				'description' => __( 'The column to use when filtering by date', 'wp-graphql' ),
				'values'      => [
					'DATE'     => [
						'value'       => 'post_date',
						'description' => __( 'The date the comment was created in local time.', 'wp-graphql' ),
					],
					'MODIFIED' => [
						'value'       => 'post_modified',
						'description' => __( 'The most recent modification date of the comment.', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\PostObjectsConnectionOrderbyEnum.php
<?php

namespace WPGraphQL\Type\Enum;

class PostObjectsConnectionOrderbyEnum {

	/**
	 * Register the PostObjectsConnectionOrderbyEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'PostObjectsConnectionOrderbyEnum',
			[
				'description' => __( 'Field to order the connection by', 'wp-graphql' ),
				'values'      => [
					'AUTHOR'        => [
						'value'       => 'post_author',
						'description' => __( 'Order by author', 'wp-graphql' ),
					],
					'TITLE'         => [
						'value'       => 'post_title',
						'description' => __( 'Order by title', 'wp-graphql' ),
					],
					'SLUG'          => [
						'value'       => 'post_name',
						'description' => __( 'Order by slug', 'wp-graphql' ),
					],
					'MODIFIED'      => [
						'value'       => 'post_modified',
						'description' => __( 'Order by last modified date', 'wp-graphql' ),
					],
					'DATE'          => [
						'value'       => 'post_date',
						'description' => __( 'Order by publish date', 'wp-graphql' ),
					],
					'PARENT'        => [
						'value'       => 'post_parent',
						'description' => __( 'Order by parent ID', 'wp-graphql' ),
					],
					'IN'            => [
						'value'       => 'post__in',
						'description' => __( 'Preserve the ID order given in the IN array', 'wp-graphql' ),
					],
					'NAME_IN'       => [
						'value'       => 'post_name__in',
						'description' => __( 'Preserve slug order given in the NAME_IN array', 'wp-graphql' ),
					],
					'MENU_ORDER'    => [
						'value'       => 'menu_order',
						'description' => __( 'Order by the menu order value', 'wp-graphql' ),
					],
					'COMMENT_COUNT' => [
						'value'       => 'comment_count',
						'description' => __( 'Order by the number of comments it has acquired', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\PostStatusEnum.php
<?php

namespace WPGraphQL\Type\Enum;

use WPGraphQL\Type\WPEnumType;

class PostStatusEnum {

	/**
	 * Register the PostStatusEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		$post_status_enum_values = [
			'name'  => 'PUBLISH',
			'value' => 'publish',
		];

		$post_stati = get_post_stati();

		if ( ! empty( $post_stati ) && is_array( $post_stati ) ) {
			/**
			 * Reset the array
			 */
			$post_status_enum_values = [];
			/**
			 * Loop through the post_stati
			 */
			foreach ( $post_stati as $status ) {
				if ( ! is_string( $status ) ) {
					continue;
				}

				$post_status_enum_values[ WPEnumType::get_safe_name( $status ) ] = [
					'description' => sprintf(
						// translators: %1$s is the post status.
						__( 'Objects with the %1$s status', 'wp-graphql' ),
						$status
					),
					'value'       => $status,
				];
			}
		}

		register_graphql_enum_type(
			'PostStatusEnum',
			[
				'description' => __( 'The status of the object.', 'wp-graphql' ),
				'values'      => $post_status_enum_values,
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\RelationEnum.php
<?php

namespace WPGraphQL\Type\Enum;

class RelationEnum {

	/**
	 * Register the RelationEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'RelationEnum',
			[
				'description' => __( 'The logical relation between each item in the array when there are more than one.', 'wp-graphql' ),
				'values'      => [
					'AND' => [
						'name'        => 'AND',
						'value'       => 'AND',
						'description' => __( 'The logical AND condition returns true if both operands are true, otherwise, it returns false.', 'wp-graphql' ),
					],
					'OR'  => [
						'name'        => 'OR',
						'value'       => 'OR',
						'description' => __( 'The logical OR condition returns false if both operands are false, otherwise, it returns true.', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\ScriptLoadingStrategyEnum.php
<?php
/**
 * Register the ScriptLoadingStrategy Enum Type to the Schema
 *
 * @package WPGraphQL\Type\Enum
 * @since 1.19.0
 */

namespace WPGraphQL\Type\Enum;

/**
 * Class ScriptLoadingStrategyEnum
 */
class ScriptLoadingStrategyEnum {

	/**
	 * Register the ScriptLoadingStrategy Enum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'ScriptLoadingStrategyEnum',
			[
				'description' => __( 'The strategy to use when loading the script', 'wp-graphql' ),
				'values'      => [
					'ASYNC' => [
						'value'       => 'async',
						'description' => __( 'Use the script `async` attribute', 'wp-graphql' ),
					],
					'DEFER' => [
						'value'       => 'defer',
						'description' => __( 'Use the script `defer` attribute', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\TaxonomyEnum.php
<?php

namespace WPGraphQL\Type\Enum;

use WPGraphQL\Type\WPEnumType;

class TaxonomyEnum {

	/**
	 * Register the TaxonomyEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		/** @var \WP_Taxonomy[] $allowed_taxonomies */
		$allowed_taxonomies = \WPGraphQL::get_allowed_taxonomies( 'objects' );

		$values = [];

		/**
		 * Loop through the taxonomies and create an array
		 * of values for use in the enum type.
		 */

		foreach ( $allowed_taxonomies as $tax_object ) {
			if ( ! isset( $values[ WPEnumType::get_safe_name( $tax_object->graphql_single_name ) ] ) ) {
				$values[ WPEnumType::get_safe_name( $tax_object->graphql_single_name ) ] = [
					'value'       => $tax_object->name,
					'description' => sprintf(
						// translators: %s is the taxonomy name.
						__( 'Taxonomy enum %s', 'wp-graphql' ),
						$tax_object->name
					),
				];
			}
		}

		register_graphql_enum_type(
			'TaxonomyEnum',
			[
				'description' => __( 'Allowed taxonomies', 'wp-graphql' ),
				'values'      => $values,
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\TaxonomyIdTypeEnum.php
<?php

namespace WPGraphQL\Type\Enum;

class TaxonomyIdTypeEnum {

	/**
	 * Register the TaxonomyIdTypeEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'TaxonomyIdTypeEnum',
			[
				'description' => __( 'The Type of Identifier used to fetch a single Taxonomy node. To be used along with the "id" field. Default is "ID".', 'wp-graphql' ),
				'values'      => [
					'ID'   => [
						'name'        => 'ID',
						'value'       => 'id',
						'description' => __( 'The globally unique ID', 'wp-graphql' ),
					],
					'NAME' => [
						'name'        => 'NAME',
						'value'       => 'name',
						'description' => __( 'The name of the taxonomy', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\TermNodeIdTypeEnum.php
<?php

namespace WPGraphQL\Type\Enum;

class TermNodeIdTypeEnum {

	/**
	 * Register the Enum used for setting the field to identify term nodes by
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'TermNodeIdTypeEnum',
			[
				'description' => __( 'The Type of Identifier used to fetch a single resource. Default is "ID". To be used along with the "id" field.', 'wp-graphql' ),
				'values'      => self::get_values(),
			]
		);

		/**
		 * Register a unique Enum per Taxonomy. This allows for granular control
		 * over filtering and customizing the values available per Taxonomy.
		 *
		 * @var \WP_Taxonomy[] $allowed_taxonomies
		 */
		$allowed_taxonomies = \WPGraphQL::get_allowed_taxonomies( 'objects' );

		foreach ( $allowed_taxonomies as $tax_object ) {
			register_graphql_enum_type(
				$tax_object->graphql_single_name . 'IdType',
				[
					'description' => __( 'The Type of Identifier used to fetch a single resource. Default is ID.', 'wp-graphql' ),
					'values'      => self::get_values(),
				]
			);
		}
	}

	/**
	 * Get the values for the Enum definitions
	 *
	 * @return array<string,array<string,string>>
	 */
	public static function get_values() {
		return [
			'SLUG'        => [
				'name'        => 'SLUG',
				'value'       => 'slug',
				'description' => __( 'Url friendly name of the node', 'wp-graphql' ),
			],
			'NAME'        => [
				'name'        => 'NAME',
				'value'       => 'name',
				'description' => __( 'The name of the node', 'wp-graphql' ),
			],
			'ID'          => [
				'name'        => 'ID',
				'value'       => 'global_id',
				'description' => __( 'The hashed Global ID', 'wp-graphql' ),
			],
			'DATABASE_ID' => [
				'name'        => 'DATABASE_ID',
				'value'       => 'database_id',
				'description' => __( 'The Database ID for the node', 'wp-graphql' ),
			],
			'URI'         => [
				'name'        => 'URI',
				'value'       => 'uri',
				'description' => __( 'The URI for the node', 'wp-graphql' ),
			],
		];
	}
}


// File: wp-graphql\src\Type\Enum\TermObjectsConnectionOrderbyEnum.php
<?php
namespace WPGraphQL\Type\Enum;

class TermObjectsConnectionOrderbyEnum {

	/**
	 * Register the TermObjectsConnectionOrderbyEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'TermObjectsConnectionOrderbyEnum',
			[
				'description' => __( 'Options for ordering the connection by', 'wp-graphql' ),
				'values'      => [
					'NAME'        => [
						'value'       => 'name',
						'description' => __( 'Order the connection by name.', 'wp-graphql' ),
					],
					'SLUG'        => [
						'value'       => 'slug',
						'description' => __( 'Order the connection by slug.', 'wp-graphql' ),
					],
					'TERM_GROUP'  => [
						'value'       => 'term_group',
						'description' => __( 'Order the connection by term group.', 'wp-graphql' ),
					],
					'TERM_ID'     => [
						'value'       => 'term_id',
						'description' => __( 'Order the connection by term id.', 'wp-graphql' ),
					],
					'TERM_ORDER'  => [
						'value'       => 'term_order',
						'description' => __( 'Order the connection by term order.', 'wp-graphql' ),
					],
					'DESCRIPTION' => [
						'value'       => 'description',
						'description' => __( 'Order the connection by description.', 'wp-graphql' ),
					],
					'COUNT'       => [
						'value'       => 'count',
						'description' => __( 'Order the connection by item count.', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\TimezoneEnum.php
<?php

namespace WPGraphQL\Type\Enum;

use WPGraphQL\Type\WPEnumType;

class TimezoneEnum {

	/**
	 * Register the TimezoneEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		/**
		 * Logic for this taken from the `wp_timezone_choice` here:
		 * https://github.com/WordPress/WordPress/blob/c204ac4bc7972c9ca1e6b354ec8fb0851e255bc5/wp-includes/functions.php#L5191
		 */

		$enum_values = [];

		$locale           = get_locale();
		static $mo_loaded = false, $locale_loaded = null;

		$continents = [
			'Africa',
			'America',
			'Antarctica',
			'Arctic',
			'Asia',
			'Atlantic',
			'Australia',
			'Europe',
			'Indian',
			'Pacific',
		];

		// Load translations for continents and cities.
		if ( ! $mo_loaded || $locale !== $locale_loaded ) {
			$locale_loaded = $locale ? $locale : get_locale();
			$mofile        = WP_LANG_DIR . '/continents-cities-' . $locale_loaded . '.mo';
			unload_textdomain( 'continents-cities' );
			load_textdomain( 'continents-cities', $mofile );
			$mo_loaded = true;
		}

		$zonen = [];
		foreach ( timezone_identifiers_list() as $zone ) {
			$zone = explode( '/', $zone );

			if ( ! in_array( $zone[0], $continents, true ) ) {
				continue;
			}

			// This determines what gets set and translated - we don't translate Etc/* strings here, they are done later
			$exists = [
				$zone[0],
				! empty( $zone[1] ) ? $zone[1] : null,
				! empty( $zone[2] ) ? $zone[2] : null,
			];

			// phpcs:disable WordPress.WP.I18n.LowLevelTranslationFunction,WordPress.WP.I18n.NonSingularStringLiteralText
			$zonen[] = [
				'continent'   => $zone[0],
				'city'        => $exists[1] ? $zone[1] : '',
				'subcity'     => $exists[2] ? $zone[2] : '',
				't_continent' => translate( str_replace( '_', ' ', $zone[0] ), 'wp-graphql' ),
				't_city'      => $exists[1] ? translate( str_replace( '_', ' ', $zone[1] ), 'wp-graphql' ) : '',
				't_subcity'   => $exists[2] ? translate( str_replace( '_', ' ', $zone[2] ), 'wp-graphql' ) : '',
			];
			// phpcs:enable
		}
		usort( $zonen, '_wp_timezone_choice_usort_callback' );

		foreach ( $zonen as $zone ) {
			// Build value in an array to join later
			$value = [ $zone['continent'] ];
			if ( empty( $zone['city'] ) ) {
				// It's at the continent level (generally won't happen)
				$display = $zone['t_continent'];
			} else {
				// Add the city to the value
				$value[] = $zone['city'];
				$display = $zone['t_city'];
				if ( ! empty( $zone['subcity'] ) ) {
					// Add the subcity to the value
					$value[]  = $zone['subcity'];
					$display .= ' - ' . $zone['t_subcity'];
				}
			}
			// Build the value
			$value = join( '/', $value );

			$enum_values[ WPEnumType::get_safe_name( $value ) ] = [
				'value'       => $value,
				'description' => $display,
			];
		}
		$offset_range = [
			- 12,
			- 11.5,
			- 11,
			- 10.5,
			- 10,
			- 9.5,
			- 9,
			- 8.5,
			- 8,
			- 7.5,
			- 7,
			- 6.5,
			- 6,
			- 5.5,
			- 5,
			- 4.5,
			- 4,
			- 3.5,
			- 3,
			- 2.5,
			- 2,
			- 1.5,
			- 1,
			- 0.5,
			0,
			0.5,
			1,
			1.5,
			2,
			2.5,
			3,
			3.5,
			4,
			4.5,
			5,
			5.5,
			5.75,
			6,
			6.5,
			7,
			7.5,
			8,
			8.5,
			8.75,
			9,
			9.5,
			10,
			10.5,
			11,
			11.5,
			12,
			12.75,
			13,
			13.75,
			14,
		];
		foreach ( $offset_range as $offset ) {
			if ( 0 <= $offset ) {
				$offset_name = '+' . $offset;
			} else {
				$offset_name = (string) $offset;
			}
			$offset_value = $offset_name;
			$offset_name  = str_replace(
				[ '.25', '.5', '.75' ],
				[
					':15',
					':30',
					':45',
				],
				$offset_name
			);
			$offset_name  = 'UTC' . $offset_name;
			$offset_value = 'UTC' . $offset_value;

			// Intentionally avoid WPEnumType::get_safe_name here for specific timezone formatting
			$enum_values[ WPEnumType::get_safe_name( $offset_name ) ] = [
				'value'       => $offset_value,
				'description' => sprintf(
					// translators: %s is the UTC offset.
					__( 'UTC offset: %s', 'wp-graphql' ),
					$offset_name
				),
			];
		}

		register_graphql_enum_type(
			'TimezoneEnum',
			[
				'description' => __( 'Available timezones', 'wp-graphql' ),
				'values'      => $enum_values,
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\UserNodeIdTypeEnum.php
<?php
namespace WPGraphQL\Type\Enum;

class UserNodeIdTypeEnum {

	/**
	 * Register the Enum used for setting the field to identify User nodes by
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'UserNodeIdTypeEnum',
			[
				'description' => __( 'The Type of Identifier used to fetch a single User node. To be used along with the "id" field. Default is "ID".', 'wp-graphql' ),
				'values'      => self::get_values(),
			]
		);
	}

	/**
	 * Returns the values for the Enum.
	 *
	 * @return array<string,array<string,string>>
	 */
	public static function get_values() {
		return [
			'ID'          => [
				'name'        => 'ID',
				'value'       => 'global_id',
				'description' => __( 'The hashed Global ID', 'wp-graphql' ),
			],
			'DATABASE_ID' => [
				'name'        => 'DATABASE_ID',
				'value'       => 'database_id',
				'description' => __( 'The Database ID for the node', 'wp-graphql' ),
			],
			'URI'         => [
				'name'        => 'URI',
				'value'       => 'uri',
				'description' => __( 'The URI for the node', 'wp-graphql' ),
			],
			'SLUG'        => [
				'name'        => 'SLUG',
				'value'       => 'slug',
				'description' => __( 'The slug of the User', 'wp-graphql' ),
			],
			'EMAIL'       => [
				'name'        => 'EMAIL',
				'value'       => 'email',
				'description' => __( 'The Email of the User', 'wp-graphql' ),
			],
			'USERNAME'    => [
				'name'        => 'USERNAME',
				'value'       => 'login',
				'description' => __( 'The username the User uses to login with', 'wp-graphql' ),
			],
		];
	}
}


// File: wp-graphql\src\Type\Enum\UserRoleEnum.php
<?php

namespace WPGraphQL\Type\Enum;

use WPGraphQL\Type\WPEnumType;

class UserRoleEnum {

	/**
	 * Register the UserRoleEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		$all_roles = wp_roles()->roles;
		$roles     = [];

		foreach ( $all_roles as $key => $role ) {
			$formatted_role = WPEnumType::get_safe_name( isset( $role['name'] ) ? $role['name'] : $key );

			$roles[ $formatted_role ] = [
				'description' => __( 'User role with specific capabilities', 'wp-graphql' ),
				'value'       => $key,
			];
		}

		// Bail if there are no roles to register.
		if ( empty( $roles ) ) {
			return;
		}

		register_graphql_enum_type(
			'UserRoleEnum',
			[
				'description' => __( 'Names of available user roles', 'wp-graphql' ),
				'values'      => $roles,
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\UsersConnectionOrderbyEnum.php
<?php

namespace WPGraphQL\Type\Enum;

class UsersConnectionOrderbyEnum {

	/**
	 * Register the UsersConnectionOrderbyEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'UsersConnectionOrderbyEnum',
			[
				'description' => __( 'Field to order the connection by', 'wp-graphql' ),
				'values'      => [
					'DISPLAY_NAME' => [
						'value'       => 'display_name',
						'description' => __( 'Order by display name', 'wp-graphql' ),
					],
					'EMAIL'        => [
						'value'       => 'user_email',
						'description' => __( 'Order by email address', 'wp-graphql' ),
					],
					'LOGIN'        => [
						'value'       => 'user_login',
						'description' => __( 'Order by login', 'wp-graphql' ),
					],
					'LOGIN_IN'     => [
						'value'       => 'login__in',
						'description' => __( 'Preserve the login order given in the LOGIN_IN array', 'wp-graphql' ),
					],
					'NICE_NAME'    => [
						'value'       => 'user_nicename',
						'description' => __( 'Order by nice name', 'wp-graphql' ),
					],
					'NICE_NAME_IN' => [
						'value'       => 'nicename__in',
						'description' => __( 'Preserve the nice name order given in the NICE_NAME_IN array', 'wp-graphql' ),
					],
					'REGISTERED'   => [
						'value'       => 'user_registered',
						'description' => __( 'Order by registration date', 'wp-graphql' ),
					],
					'URL'          => [
						'value'       => 'user_url',
						'description' => __( 'Order by URL', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\Enum\UsersConnectionSearchColumnEnum.php
<?php

namespace WPGraphQL\Type\Enum;

class UsersConnectionSearchColumnEnum {

	/**
	 * Register the UsersConnectionSearchColumnEnum Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_enum_type(
			'UsersConnectionSearchColumnEnum',
			[
				'description' => __( 'Column used for searching for users.', 'wp-graphql' ),
				'values'      => [
					'ID'       => [
						'value'       => 'ID',
						'description' => __( 'The globally unique ID.', 'wp-graphql' ),
					],
					'LOGIN'    => [
						'value'       => 'user_login',
						'description' => __( 'The username the User uses to login with.', 'wp-graphql' ),
					],
					'NICENAME' => [
						'value'       => 'user_nicename',
						'description' => __( 'A URL-friendly name for the user. The default is the user\'s username.', 'wp-graphql' ),
					],
					'EMAIL'    => [
						'value'       => 'user_email',
						'description' => __( 'The user\'s email address.', 'wp-graphql' ),
					],
					'URL'      => [
						'value'       => 'user_url',
						'description' => __( 'The URL of the user\'s website.', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\Input\DateInput.php
<?php
namespace WPGraphQL\Type\Input;

class DateInput {

	/**
	 * Register the DateInput Input
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_input_type(
			'DateInput',
			[
				'description' => __( 'Date values', 'wp-graphql' ),
				'fields'      => [
					'year'  => [
						'type'        => 'Int',
						'description' => __( '4 digit year (e.g. 2017)', 'wp-graphql' ),
					],
					'month' => [
						'type'        => 'Int',
						'description' => __( 'Month number (from 1 to 12)', 'wp-graphql' ),
					],
					'day'   => [
						'type'        => 'Int',
						'description' => __( 'Day of the month (from 1 to 31)', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\Input\DateQueryInput.php
<?php

namespace WPGraphQL\Type\Input;

class DateQueryInput {

	/**
	 * Register the DateQueryInput Input
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_input_type(
			'DateQueryInput',
			[
				'description' => __( 'Filter the connection based on input', 'wp-graphql' ),
				'fields'      => [
					'year'      => [
						'type'        => 'Int',
						'description' => __( '4 digit year (e.g. 2017)', 'wp-graphql' ),
					],
					'month'     => [
						'type'        => 'Int',
						'description' => __( 'Month number (from 1 to 12)', 'wp-graphql' ),
					],
					'week'      => [
						'type'        => 'Int',
						'description' => __( 'Week of the year (from 0 to 53)', 'wp-graphql' ),
					],
					'day'       => [
						'type'        => 'Int',
						'description' => __( 'Day of the month (from 1 to 31)', 'wp-graphql' ),
					],
					'hour'      => [
						'type'        => 'Int',
						'description' => __( 'Hour (from 0 to 23)', 'wp-graphql' ),
					],
					'minute'    => [
						'type'        => 'Int',
						'description' => __( 'Minute (from 0 to 59)', 'wp-graphql' ),
					],
					'second'    => [
						'type'        => 'Int',
						'description' => __( 'Second (0 to 59)', 'wp-graphql' ),
					],
					'after'     => [
						'type'        => 'DateInput',
						'description' => __( 'Nodes should be returned after this date', 'wp-graphql' ),
					],
					'before'    => [
						'type'        => 'DateInput',
						'description' => __( 'Nodes should be returned before this date', 'wp-graphql' ),
					],
					'inclusive' => [
						'type'        => 'Boolean',
						'description' => __( 'For after/before, whether exact value should be matched or not', 'wp-graphql' ),
					],
					'compare'   => [
						'type'        => 'String',
						'description' => __( 'For after/before, whether exact value should be matched or not', 'wp-graphql' ),
					],
					'column'    => [
						'type'        => 'PostObjectsConnectionDateColumnEnum',
						'description' => __( 'Column to query against', 'wp-graphql' ),
					],
					'relation'  => [
						'type'        => 'RelationEnum',
						'description' => __( 'OR or AND, how the sub-arrays should be compared', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\Input\PostObjectsConnectionOrderbyInput.php
<?php

namespace WPGraphQL\Type\Input;

class PostObjectsConnectionOrderbyInput {

	/**
	 * Register the PostObjectsConnectionOrderbyInput Input
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_input_type(
			'PostObjectsConnectionOrderbyInput',
			[
				'description' => __( 'Options for ordering the connection', 'wp-graphql' ),
				'fields'      => [
					'field' => [
						'type'        => [
							'non_null' => 'PostObjectsConnectionOrderbyEnum',
						],
						'description' => __( 'The field to order the connection by', 'wp-graphql' ),
					],
					'order' => [
						'type'        => [
							'non_null' => 'OrderEnum',
						],
						'description' => __( 'Possible directions in which to order a list of items', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\Input\UsersConnectionOrderbyInput.php
<?php

namespace WPGraphQL\Type\Input;

class UsersConnectionOrderbyInput {

	/**
	 * Register the UsersConnectionOrderbyInput Input
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_input_type(
			'UsersConnectionOrderbyInput',
			[
				'description' => __( 'Options for ordering the connection', 'wp-graphql' ),
				'fields'      => [
					'field' => [
						'description' => __( 'The field name used to sort the results.', 'wp-graphql' ),
						'type'        => [
							'non_null' => 'UsersConnectionOrderbyEnum',
						],
					],
					'order' => [
						'description' => __( 'The cardinality of the order of the connection', 'wp-graphql' ),
						'type'        => 'OrderEnum',
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\Commenter.php
<?php

namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Model\User;
use WPGraphQL\Registry\TypeRegistry;

/**
 * Class CommenterInterface
 *
 * @package WPGraphQL\Type\InterfaceType
 */
class Commenter {

	/**
	 * Register the Commenter Interface
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @return void
	 */
	public static function register_type( TypeRegistry $type_registry ) {
		register_graphql_interface_type(
			'Commenter',
			[
				'description' => __( 'The author of a comment', 'wp-graphql' ),
				'interfaces'  => [ 'Node', 'DatabaseIdentifier' ],
				'resolveType' => static function ( $comment_author ) use ( $type_registry ) {
					if ( $comment_author instanceof User ) {
						$type = $type_registry->get_type( 'User' );
					} else {
						$type = $type_registry->get_type( 'CommentAuthor' );
					}

					return $type;
				},
				'fields'      => [
					'id'           => [
						'type'        => [
							'non_null' => 'ID',
						],
						'description' => __( 'The globally unique identifier for the comment author.', 'wp-graphql' ),
					],
					'avatar'       => [
						'type'        => 'Avatar',
						'description' => __( 'Avatar object for user. The avatar object can be retrieved in different sizes by specifying the size argument.', 'wp-graphql' ),
					],
					'databaseId'   => [
						'type'        => [
							'non_null' => 'Int',
						],
						'description' => __( 'Identifies the primary key from the database.', 'wp-graphql' ),
					],
					'name'         => [
						'type'        => 'String',
						'description' => __( 'The name of the author of a comment.', 'wp-graphql' ),
					],
					'email'        => [
						'type'        => 'String',
						'description' => __( 'The email address of the author of a comment.', 'wp-graphql' ),
					],
					'url'          => [
						'type'        => 'String',
						'description' => __( 'The url of the author of a comment.', 'wp-graphql' ),
					],
					'isRestricted' => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the author information is considered restricted. (not fully public)', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\Connection.php
<?php

namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Registry\TypeRegistry;

class Connection {
	/**
	 * Register the Connection Interface
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @throws \Exception
	 */
	public static function register_type( TypeRegistry $type_registry ): void {
		register_graphql_interface_type(
			'Connection',
			[
				'description' => __( 'A plural connection from one Node Type in the Graph to another Node Type, with support for relational data via "edges".', 'wp-graphql' ),
				'fields'      => [
					'pageInfo' => [
						'type'        => [ 'non_null' => 'PageInfo' ],
						'description' => __( 'Information about pagination in a connection.', 'wp-graphql' ),
					],
					'edges'    => [
						'type'        => [ 'non_null' => [ 'list_of' => [ 'non_null' => 'Edge' ] ] ],
						'description' => __( 'A list of edges (relational context) between connected nodes', 'wp-graphql' ),
					],
					'nodes'    => [
						'type'        => [ 'non_null' => [ 'list_of' => [ 'non_null' => 'Node' ] ] ],
						'description' => __( 'A list of connected nodes', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\ContentNode.php
<?php
namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Data\Connection\ContentTypeConnectionResolver;
use WPGraphQL\Data\Connection\EnqueuedScriptsConnectionResolver;
use WPGraphQL\Data\Connection\EnqueuedStylesheetConnectionResolver;
use WPGraphQL\Model\Post;
use WPGraphQL\Registry\TypeRegistry;

class ContentNode {

	/**
	 * Adds the ContentNode Type to the WPGraphQL Registry
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_type( TypeRegistry $type_registry ) {

		/**
		 * The Content interface represents Post Types and the common shared fields
		 * across Post Type Objects
		 */
		register_graphql_interface_type(
			'ContentNode',
			[
				'interfaces'  => [ 'Node', 'UniformResourceIdentifiable' ],
				'description' => __( 'Nodes used to manage content', 'wp-graphql' ),
				'connections' => [
					'contentType'         => [
						'toType'   => 'ContentType',
						'resolve'  => static function ( Post $source, $args, $context, $info ) {
							if ( $source->isRevision ) {
								$parent    = get_post( $source->parentDatabaseId );
								$post_type = $parent->post_type ?? null;
							} else {
								$post_type = $source->post_type ?? null;
							}

							if ( empty( $post_type ) ) {
								return null;
							}

							$resolver = new ContentTypeConnectionResolver( $source, $args, $context, $info );

							return $resolver->one_to_one()->set_query_arg( 'name', $post_type )->get_connection();
						},
						'oneToOne' => true,
					],
					'enqueuedScripts'     => [
						'toType'  => 'EnqueuedScript',
						'resolve' => static function ( $source, $args, $context, $info ) {
							$resolver = new EnqueuedScriptsConnectionResolver( $source, $args, $context, $info );

							return $resolver->get_connection();
						},
					],
					'enqueuedStylesheets' => [
						'toType'  => 'EnqueuedStylesheet',
						'resolve' => static function ( $source, $args, $context, $info ) {
							$resolver = new EnqueuedStylesheetConnectionResolver( $source, $args, $context, $info );
							return $resolver->get_connection();
						},
					],
				],
				'resolveType' => static function ( Post $post ) use ( $type_registry ) {

					/**
					 * The resolveType callback is used at runtime to determine what Type an object
					 * implementing the ContentNode Interface should be resolved as.
					 *
					 * You can filter this centrally using the "graphql_wp_interface_type_config" filter
					 * to override if you need something other than a Post object to be resolved via the
					 * $post->post_type attribute.
					 */
					$type      = null;
					$post_type = isset( $post->post_type ) ? $post->post_type : null;

					if ( isset( $post->post_type ) && 'revision' === $post->post_type ) {
						$parent = get_post( $post->parentDatabaseId );
						if ( $parent instanceof \WP_Post ) {
							$post_type = $parent->post_type;
						}
					}

					$post_type_object = ! empty( $post_type ) ? get_post_type_object( $post_type ) : null;

					if ( isset( $post_type_object->graphql_single_name ) ) {
						$type = $type_registry->get_type( $post_type_object->graphql_single_name );
					}

					return ! empty( $type ) ? $type : null;
				},
				'fields'      => [
					'contentTypeName'           => [
						'type'        => [ 'non_null' => 'String' ],
						'description' => __( 'The name of the Content Type the node belongs to', 'wp-graphql' ),
						'resolve'     => static function ( $node ) {
							return $node->post_type;
						},
					],
					'template'                  => [
						'type'        => 'ContentTemplate',
						'description' => __( 'The template assigned to a node of content', 'wp-graphql' ),
					],
					'databaseId'                => [
						'type'        => [
							'non_null' => 'Int',
						],
						'description' => __( 'The ID of the node in the database.', 'wp-graphql' ),
					],
					'date'                      => [
						'type'        => 'String',
						'description' => __( 'Post publishing date.', 'wp-graphql' ),
					],
					'dateGmt'                   => [
						'type'        => 'String',
						'description' => __( 'The publishing date set in GMT.', 'wp-graphql' ),
					],
					'enclosure'                 => [
						'type'        => 'String',
						'description' => __( 'The RSS enclosure for the object', 'wp-graphql' ),
					],
					'status'                    => [
						'type'        => 'String',
						'description' => __( 'The current status of the object', 'wp-graphql' ),
					],
					'slug'                      => [
						'type'        => 'String',
						'description' => __( 'The uri slug for the post. This is equivalent to the WP_Post->post_name field and the post_name column in the database for the "post_objects" table.', 'wp-graphql' ),
					],
					'modified'                  => [
						'type'        => 'String',
						'description' => __( 'The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time.', 'wp-graphql' ),
					],
					'modifiedGmt'               => [
						'type'        => 'String',
						'description' => __( 'The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT.', 'wp-graphql' ),
					],
					'guid'                      => [
						'type'        => 'String',
						'description' => __( 'The global unique identifier for this post. This currently matches the value stored in WP_Post->guid and the guid column in the "post_objects" database table.', 'wp-graphql' ),
					],
					'desiredSlug'               => [
						'type'        => 'String',
						'description' => __( 'The desired slug of the post', 'wp-graphql' ),
					],
					'link'                      => [
						'type'        => 'String',
						'description' => __( 'The permalink of the post', 'wp-graphql' ),
					],
					'isRestricted'              => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the object is restricted from the current viewer', 'wp-graphql' ),
					],
					'isPreview'                 => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the object is a node in the preview state', 'wp-graphql' ),
					],
					'previewRevisionDatabaseId' => [
						'type'        => 'Int',
						'description' => __( 'The database id of the preview node', 'wp-graphql' ),
					],
					'previewRevisionId'         => [
						'type'        => 'ID',
						'description' => __( 'Whether the object is a node in the preview state', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\ContentTemplate.php
<?php

namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Utils\Utils;

class ContentTemplate {

	/**
	 * Register the ContentTemplate Interface
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_interface_type(
			'ContentTemplate',
			[
				'description' => __( 'The template assigned to a node of content', 'wp-graphql' ),
				'fields'      => [
					'templateName' => [
						'type'        => 'String',
						'description' => __( 'The name of the template', 'wp-graphql' ),
					],
				],
				'resolveType' => static function ( $value ) {
					return isset( $value['__typename'] ) ? $value['__typename'] : 'DefaultTemplate';
				},
			]
		);
	}

	/**
	 * Register individual GraphQL objects for supported theme templates.
	 *
	 * @return void
	 */
	public static function register_content_template_types() {
		$page_templates            = [];
		$page_templates['default'] = 'DefaultTemplate';

		// Cycle through the registered post types and get the template information
		$allowed_post_types = \WPGraphQL::get_allowed_post_types();
		foreach ( $allowed_post_types as $post_type ) {
			$post_type_templates = wp_get_theme()->get_page_templates( null, $post_type );

			foreach ( $post_type_templates as $file => $name ) {
				$page_templates[ $file ] = $name;
			}
		}

		// Register each template to the schema
		foreach ( $page_templates as $file => $name ) {
			$template_type_name = Utils::format_type_name_for_wp_template( $name, $file );

			// If the type name is empty, log an error and continue.
			if ( empty( $template_type_name ) ) {
				graphql_debug(
					sprintf(
						// Translators: %s is the file name.
						__( 'Unable to register the %1s template file as a GraphQL Type. Either the template name or the file name must only use ASCII characters. "DefaultTemplate" will be used instead.', 'wp-graphql' ),
						(string) $file
					)
				);

				continue;
			}

			register_graphql_object_type(
				$template_type_name,
				[
					'interfaces'      => [ 'ContentTemplate' ],
					// Translators: Placeholder is the name of the GraphQL Type in the Schema
					'description'     => __( 'The template assigned to the node', 'wp-graphql' ),
					'fields'          => [
						'templateName' => [
							'resolve' => static function ( $template ) {
								return isset( $template['templateName'] ) ? $template['templateName'] : null;
							},
						],
					],
					'eagerlyLoadType' => true,
				]
			);
		}
	}
}


// File: wp-graphql\src\Type\InterfaceType\DatabaseIdentifier.php
<?php

namespace WPGraphQL\Type\InterfaceType;

/**
 * Class DatabaseIdentifier
 *
 * @package WPGraphQL\Type\InterfaceType
 */
class DatabaseIdentifier {

	/**
	 * Register the DatabaseIdentifier Interface.
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_interface_type(
			'DatabaseIdentifier',
			[
				'description' => __( 'Object that can be identified with a Database ID', 'wp-graphql' ),
				'fields'      => [
					'databaseId' => [
						'type'        => [ 'non_null' => 'Int' ],
						'description' => __( 'The unique identifier stored in the database', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\Edge.php
<?php

namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Registry\TypeRegistry;

class Edge {
	/**
	 * Register the Connection Interface
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @throws \Exception
	 */
	public static function register_type( TypeRegistry $type_registry ): void {
		register_graphql_interface_type(
			'Edge',
			[
				'description' => __( 'Relational context between connected nodes', 'wp-graphql' ),
				'fields'      => [
					'cursor' => [
						'type'        => 'String',
						'description' => __( 'Opaque reference to the nodes position in the connection. Value can be used with pagination args.', 'wp-graphql' ),
					],
					'node'   => [
						'type'        => [ 'non_null' => 'Node' ],
						'description' => __( 'The connected node', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\EnqueuedAsset.php
<?php
namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Registry\TypeRegistry;

/**
 * Class EnqueuedAsset
 *
 * @package WPGraphQL\Type
 */
class EnqueuedAsset {

	/**
	 * Register the Enqueued Script Type
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry The WPGraphQL Type Registry
	 *
	 * @return void
	 */
	public static function register_type( TypeRegistry $type_registry ) {
		register_graphql_interface_type(
			'EnqueuedAsset',
			[
				'description' => __( 'Asset enqueued by the CMS', 'wp-graphql' ),
				'resolveType' => static function ( $asset ) use ( $type_registry ) {

					/**
					 * The resolveType callback is used at runtime to determine what Type an object
					 * implementing the EnqueuedAsset Interface should be resolved as.
					 *
					 * You can filter this centrally using the "graphql_wp_interface_type_config" filter
					 * to override if you need something other than a Post object to be resolved via the
					 * $post->post_type attribute.
					 */
					$type = null;

					if ( isset( $asset['type'] ) ) {
						$type = $type_registry->get_type( $asset['type'] );
					}

					return ! empty( $type ) ? $type : null;
				},
				'fields'      => [
					'args'         => [
						'type'              => 'Boolean',
						'description'       => __( 'Deprecated', 'wp-graphql' ),
						'deprecationReason' => __( 'Use `EnqueuedAsset.media` instead.', 'wp-graphql' ),
					],
					'after'        => [
						'type'        => [ 'list_of' => 'String' ],
						'description' => __( 'The inline code to be run after the asset is loaded.', 'wp-graphql' ),
						'resolve'     => static function ( \_WP_Dependency $asset ) {
							if ( empty( $asset->extra['after'] ) ) {
								return null;
							}

							$after_scripts = array_map(
								static function ( $after ) {
									return is_string( $after ) ? $after : null;
								},
								$asset->extra['after']
							);

							return array_filter( $after_scripts );
						},
					],
					'before'       => [
						'type'        => [ 'list_of' => 'String' ],
						'description' => __( 'The inline code to be run before the asset is loaded.', 'wp-graphql' ),
						'resolve'     => static function ( \_WP_Dependency $asset ) {
							if ( empty( $asset->extra['before'] ) ) {
								return null;
							}

							$before_scripts = array_map(
								static function ( $before ) {
									return is_string( $before ) ? $before : null;
								},
								$asset->extra['before']
							);

							return array_filter( $before_scripts );
						},
					],
					'conditional'  => [
						'type'        => 'String',
						'description' => __( 'The HTML conditional comment for the enqueued asset. E.g. IE 6, lte IE 7, etc', 'wp-graphql' ),
						'resolve'     => static function ( \_WP_Dependency $asset ) {
							if ( ! isset( $asset->extra['conditional'] ) || ! is_string( $asset->extra['conditional'] ) ) {
								return null;
							}

							return $asset->extra['conditional'];
						},
					],
					'dependencies' => [
						'type'        => [ 'list_of' => 'EnqueuedAsset' ],
						'description' => __( 'Dependencies needed to use this asset', 'wp-graphql' ),
					],
					'id'           => [
						'type'        => [ 'non_null' => 'ID' ],
						'description' => __( 'The ID of the enqueued asset', 'wp-graphql' ),
					],
					'handle'       => [
						'type'        => 'String',
						'description' => __( 'The handle of the enqueued asset', 'wp-graphql' ),
					],
					'src'          => [
						'type'        => 'String',
						'description' => __( 'The source of the asset', 'wp-graphql' ),
						'resolve'     => static function ( \_WP_Dependency $stylesheet ) {
							return ! empty( $stylesheet->src ) && is_string( $stylesheet->src ) ? $stylesheet->src : null;
						},
					],
					'version'      => [
						'type'        => 'String',
						'description' => __( 'The version of the enqueued asset', 'wp-graphql' ),
					],
					'extra'        => [
						'type'              => 'String',
						'description'       => __( 'Extra information needed for the script', 'wp-graphql' ),
						'deprecationReason' => __( 'Use `EnqueuedScript.extraData` instead.', 'wp-graphql' ),
						'resolve'           => static function ( $asset ) {
							return isset( $asset->extra['data'] ) ? $asset->extra['data'] : null;
						},
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\HierarchicalContentNode.php
<?php
namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Registry\TypeRegistry;

/**
 * Class HierarchicalContentNode
 *
 * @package WPGraphQL\Type\InterfaceType
 */
class HierarchicalContentNode {

	/**
	 * Register the HierarchicalContentNode Interface Type
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @throws \Exception
	 */
	public static function register_type( TypeRegistry $type_registry ): void {
		register_graphql_interface_type(
			'HierarchicalContentNode',
			[
				'description' => __( 'Content node with hierarchical (parent/child) relationships', 'wp-graphql' ),
				'interfaces'  => [
					'Node',
					'ContentNode',
					'DatabaseIdentifier',
					'HierarchicalNode',
				],
				'fields'      => [
					'parentId'         => [
						'type'        => 'ID',
						'description' => __( 'The globally unique identifier of the parent node.', 'wp-graphql' ),
					],
					'parentDatabaseId' => [
						'type'        => 'Int',
						'description' => __( 'Database id of the parent node', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\HierarchicalNode.php
<?php

namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Registry\TypeRegistry;

/**
 * Class HierarchicalNode
 *
 * @package WPGraphQL\Type\InterfaceType
 */
class HierarchicalNode {

	/**
	 * Register the HierarchicalNode Interface Type
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @throws \Exception
	 */
	public static function register_type( TypeRegistry $type_registry ): void {
		register_graphql_interface_type(
			'HierarchicalNode',
			[
				'description' => __( 'Node with hierarchical (parent/child) relationships', 'wp-graphql' ),
				'interfaces'  => [
					'Node',
					'DatabaseIdentifier',
				],
				'fields'      => [
					'parentId'         => [
						'type'        => 'ID',
						'description' => __( 'The globally unique identifier of the parent node.', 'wp-graphql' ),
					],
					'parentDatabaseId' => [
						'type'        => 'Int',
						'description' => __( 'Database id of the parent node', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\HierarchicalTermNode.php
<?php
namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Registry\TypeRegistry;

/**
 * Class HierarchicalTermNode
 *
 * @package WPGraphQL\Type\InterfaceType
 */
class HierarchicalTermNode {

	/**
	 * Register the HierarchicalTermNode Interface Type
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @throws \Exception
	 */
	public static function register_type( TypeRegistry $type_registry ): void {
		register_graphql_interface_type(
			'HierarchicalTermNode',
			[
				'description' => __( 'Term node with hierarchical (parent/child) relationships', 'wp-graphql' ),
				'interfaces'  => [
					'Node',
					'TermNode',
					'DatabaseIdentifier',
					'HierarchicalNode',
				],
				'fields'      => [
					'parentId'         => [
						'type'        => 'ID',
						'description' => __( 'The globally unique identifier of the parent node.', 'wp-graphql' ),
					],
					'parentDatabaseId' => [
						'type'        => 'Int',
						'description' => __( 'Database id of the parent node', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\MenuItemLinkable.php
<?php

namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Model\Post;
use WPGraphQL\Model\Term;
use WPGraphQL\Registry\TypeRegistry;

class MenuItemLinkable {

	/**
	 * Registers the MenuItemLinkable Interface Type
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry Instance of the WPGraphQL Type Registry
	 *
	 * @throws \Exception
	 */
	public static function register_type( TypeRegistry $type_registry ): void {
		register_graphql_interface_type(
			'MenuItemLinkable',
			[
				'description' => __( 'Nodes that can be linked to as Menu Items', 'wp-graphql' ),
				'interfaces'  => [ 'Node', 'UniformResourceIdentifiable', 'DatabaseIdentifier' ],
				'fields'      => [],
				'resolveType' => static function ( $node ) use ( $type_registry ) {
					switch ( true ) {
						case $node instanceof Post:
							/** @var \WP_Post_Type $post_type_object */
							$post_type_object = get_post_type_object( $node->post_type );
							$type             = $type_registry->get_type( $post_type_object->graphql_single_name );
							break;
						case $node instanceof Term:
							/** @var \WP_Taxonomy $tax_object */
							$tax_object = get_taxonomy( $node->taxonomyName );
							$type       = $type_registry->get_type( $tax_object->graphql_single_name );
							break;
						default:
							$type = null;
					}

					return $type;
				},
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\Node.php
<?php
namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Data\DataSource;

class Node {

	/**
	 * Register the Node interface
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_interface_type(
			'Node',
			[
				'description' => __( 'An object with an ID', 'wp-graphql' ),
				'fields'      => [
					'id' => [
						'type'        => [ 'non_null' => 'ID' ],
						'description' => __( 'The globally unique ID for the object', 'wp-graphql' ),
					],
				],
				'resolveType' => static function ( $node ) {
					return DataSource::resolve_node_type( $node );
				},
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\NodeWithAuthor.php
<?php
namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Registry\TypeRegistry;

class NodeWithAuthor {
	/**
	 * Registers the NodeWithAuthor Type to the Schema
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @return void
	 */
	public static function register_type( TypeRegistry $type_registry ) {
		register_graphql_interface_type(
			'NodeWithAuthor',
			[
				'interfaces'  => [ 'Node' ],
				'description' => __( 'A node that can have an author assigned to it', 'wp-graphql' ),
				'fields'      => [
					'authorId'         => [
						'type'        => 'ID',
						'description' => __( 'The globally unique identifier of the author of the node', 'wp-graphql' ),
					],
					'authorDatabaseId' => [
						'type'        => 'Int',
						'description' => __( 'The database identifier of the author of the node', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\NodeWithComments.php
<?php
namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Registry\TypeRegistry;

class NodeWithComments {
	/**
	 * Registers the NodeWithComments Type to the Schema
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @return void
	 */
	public static function register_type( TypeRegistry $type_registry ) {
		register_graphql_interface_type(
			'NodeWithComments',
			[
				'interfaces'  => [ 'Node' ],
				'description' => __( 'A node that can have comments associated with it', 'wp-graphql' ),
				'fields'      => [
					'commentCount'  => [
						'type'        => 'Int',
						'description' => __( 'The number of comments. Even though WPGraphQL denotes this field as an integer, in WordPress this field should be saved as a numeric string for compatibility.', 'wp-graphql' ),
					],
					'commentStatus' => [
						'type'        => 'String',
						'description' => __( 'Whether the comments are open or closed for this particular post.', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\NodeWithContentEditor.php
<?php
namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Registry\TypeRegistry;

class NodeWithContentEditor {
	/**
	 * Registers the NodeWithContentEditor Type to the Schema
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @return void
	 */
	public static function register_type( TypeRegistry $type_registry ) {
		register_graphql_interface_type(
			'NodeWithContentEditor',
			[
				'interfaces'  => [ 'Node' ],
				'description' => __( 'A node that supports the content editor', 'wp-graphql' ),
				'fields'      => [
					'content' => [
						'type'        => 'String',
						'description' => __( 'The content of the post.', 'wp-graphql' ),
						'args'        => [
							'format' => [
								'type'        => 'PostObjectFieldFormatEnum',
								'description' => __( 'Format of the field output', 'wp-graphql' ),
							],
						],
						'resolve'     => static function ( $source, $args ) {
							if ( isset( $args['format'] ) && 'raw' === $args['format'] ) {
								// @codingStandardsIgnoreLine.
								return $source->contentRaw;
							}

							// @codingStandardsIgnoreLine.
							return $source->contentRendered;
						},
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\NodeWithExcerpt.php
<?php
namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Registry\TypeRegistry;

class NodeWithExcerpt {

	/**
	 * Registers the NodeWithExcerpt Type to the Schema
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @return void
	 */
	public static function register_type( TypeRegistry $type_registry ) {
		register_graphql_interface_type(
			'NodeWithExcerpt',
			[
				'interfaces'  => [ 'Node' ],
				'description' => __( 'A node that can have an excerpt', 'wp-graphql' ),
				'fields'      => [
					'excerpt' => [
						'type'        => 'String',
						'description' => __( 'The excerpt of the post.', 'wp-graphql' ),
						'args'        => [
							'format' => [
								'type'        => 'PostObjectFieldFormatEnum',
								'description' => __( 'Format of the field output', 'wp-graphql' ),
							],
						],
						'resolve'     => static function ( $source, $args ) {
							if ( isset( $args['format'] ) && 'raw' === $args['format'] ) {
								// @codingStandardsIgnoreLine.
								return $source->excerptRaw;
							}

							// @codingStandardsIgnoreLine.
							return $source->excerptRendered;
						},
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\NodeWithFeaturedImage.php
<?php
namespace WPGraphQL\Type\InterfaceType;

use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Data\Connection\PostObjectConnectionResolver;
use WPGraphQL\Model\Post;
use WPGraphQL\Registry\TypeRegistry;

class NodeWithFeaturedImage {

	/**
	 * Registers the NodeWithFeaturedImage Type to the Schema
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_type( TypeRegistry $type_registry ) {
		register_graphql_interface_type(
			'NodeWithFeaturedImage',
			[
				'description' => __( 'A node that can have a featured image set', 'wp-graphql' ),
				'interfaces'  => [ 'Node' ],
				'connections' => [
					'featuredImage' => [
						'toType'   => 'MediaItem',
						'oneToOne' => true,
						'resolve'  => static function ( Post $post, $args, AppContext $context, ResolveInfo $info ) {
							if ( empty( $post->featuredImageDatabaseId ) ) {
								return null;
							}

							$resolver = new PostObjectConnectionResolver( $post, $args, $context, $info, 'attachment' );
							$resolver->set_query_arg( 'p', absint( $post->featuredImageDatabaseId ) );

							return $resolver->one_to_one()->get_connection();
						},
					],
				],
				'fields'      => [
					'featuredImageId'         => [
						'type'        => 'ID',
						'description' => __( 'Globally unique ID of the featured image assigned to the node', 'wp-graphql' ),
					],
					'featuredImageDatabaseId' => [
						'type'        => 'Int',
						'description' => __( 'The database identifier for the featured image node assigned to the content node', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\NodeWithPageAttributes.php
<?php
namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Registry\TypeRegistry;

class NodeWithPageAttributes {

	/**
	 * Registers the NodeWithPageAttributes Type to the Schema
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @return void
	 */
	public static function register_type( TypeRegistry $type_registry ) {
		register_graphql_interface_type(
			'NodeWithPageAttributes',
			[
				'interfaces'  => [ 'Node' ],
				'description' => __( 'A node that can have page attributes', 'wp-graphql' ),
				'fields'      => [
					'menuOrder' => [
						'type'        => 'Int',
						'description' => __( 'A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types.', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\NodeWithRevisions.php
<?php
namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Registry\TypeRegistry;

class NodeWithRevisions {

	/**
	 * Registers the NodeWithRevisions Type to the Schema
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @return void
	 */
	public static function register_type( TypeRegistry $type_registry ) {
		register_graphql_interface_type(
			'NodeWithRevisions',
			[
				'interfaces'  => [ 'Node' ],
				'description' => __( 'A node that can have revisions', 'wp-graphql' ),
				'fields'      => [
					'isRevision' => [
						'type'        => 'Boolean',
						'description' => __( 'True if the node is a revision of another node', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\NodeWithTemplate.php
<?php
namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Registry\TypeRegistry;

class NodeWithTemplate {

	/**
	 * Registers the NodeWithTemplate Type to the Schema
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @return void
	 */
	public static function register_type( TypeRegistry $type_registry ) {
		register_graphql_interface_type(
			'NodeWithTemplate',
			[
				'description' => __( 'A node that can have a template associated with it', 'wp-graphql' ),
				'interfaces'  => [ 'Node' ],
				'fields'      => [
					'template' => [
						'description' => __( 'The template assigned to the node', 'wp-graphql' ),
						'type'        => 'ContentTemplate',
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\NodeWithTitle.php
<?php
namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Registry\TypeRegistry;

class NodeWithTitle {

	/**
	 * Registers the NodeWithTitle Type to the Schema
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @return void
	 */
	public static function register_type( TypeRegistry $type_registry ) {
		register_graphql_interface_type(
			'NodeWithTitle',
			[
				'interfaces'  => [ 'Node' ],
				'description' => __( 'A node that NodeWith a title', 'wp-graphql' ),
				'fields'      => [
					'title' => [
						'type'        => 'String',
						'description' => __( 'The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made.', 'wp-graphql' ),
						'args'        => [
							'format' => [
								'type'        => 'PostObjectFieldFormatEnum',
								'description' => __( 'Format of the field output', 'wp-graphql' ),
							],
						],
						'resolve'     => static function ( $source, $args ) {
							if ( isset( $args['format'] ) && 'raw' === $args['format'] ) {
								// @codingStandardsIgnoreLine.
								return $source->titleRaw;
							}

							// @codingStandardsIgnoreLine.
							return $source->titleRendered;
						},
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\NodeWithTrackbacks.php
<?php
namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Registry\TypeRegistry;

class NodeWithTrackbacks {

	/**
	 * Registers the NodeWithTrackbacks Type to the Schema
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @return void
	 */
	public static function register_type( TypeRegistry $type_registry ) {
		register_graphql_interface_type(
			'NodeWithTrackbacks',
			[
				'interfaces'  => [ 'Node' ],
				'description' => __( 'A node that can have trackbacks and pingbacks', 'wp-graphql' ),
				'fields'      => [
					'toPing'     => [
						'type'        => [ 'list_of' => 'String' ],
						'description' => __( 'URLs queued to be pinged.', 'wp-graphql' ),
					],
					'pinged'     => [
						'type'        => [ 'list_of' => 'String' ],
						'description' => __( 'URLs that have been pinged.', 'wp-graphql' ),
					],
					'pingStatus' => [
						'type'        => 'String',
						'description' => __( 'Whether the pings are open or closed for this particular post.', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\OneToOneConnection.php
<?php

namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Registry\TypeRegistry;

class OneToOneConnection {
	/**
	 * Register the Connection Interface
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @throws \Exception
	 */
	public static function register_type( TypeRegistry $type_registry ): void {
		register_graphql_interface_type(
			'OneToOneConnection',
			[
				'description' => __( 'A singular connection from one Node to another, with support for relational data on the "edge" of the connection.', 'wp-graphql' ),
				'interfaces'  => [ 'Edge' ],
				'fields'      => [
					'node' => [
						'type'        => [ 'non_null' => 'Node' ],
						'description' => __( 'The connected node', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\PageInfo.php
<?php

namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Registry\TypeRegistry;

class PageInfo {
	/**
	 * Register the PageInfo Interface
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @throws \Exception
	 */
	public static function register_type( TypeRegistry $type_registry ): void {
		register_graphql_interface_type(
			'WPPageInfo',
			[
				'description' => __( 'Information about pagination in a connection.', 'wp-graphql' ),
				'interfaces'  => [ 'PageInfo' ],
				'fields'      => self::get_fields(),
			]
		);

		register_graphql_interface_type(
			'PageInfo',
			[
				'description' => __( 'Information about pagination in a connection.', 'wp-graphql' ),
				'fields'      => self::get_fields(),
			]
		);
	}

	/**
	 * Get the fields for the PageInfo Type
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_fields(): array {
		return [
			'hasNextPage'     => [
				'type'        => [
					'non_null' => 'Boolean',
				],
				'description' => __( 'When paginating forwards, are there more items?', 'wp-graphql' ),
			],
			'hasPreviousPage' => [
				'type'        => [
					'non_null' => 'Boolean',
				],
				'description' => __( 'When paginating backwards, are there more items?', 'wp-graphql' ),
			],
			'startCursor'     => [
				'type'        => 'String',
				'description' => __( 'When paginating backwards, the cursor to continue.', 'wp-graphql' ),
			],
			'endCursor'       => [
				'type'        => 'String',
				'description' => __( 'When paginating forwards, the cursor to continue.', 'wp-graphql' ),
			],
		];
	}
}


// File: wp-graphql\src\Type\InterfaceType\Previewable.php
<?php

namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Model\Post;
use WPGraphQL\Registry\TypeRegistry;

class Previewable {

	/**
	 * Adds the Previewable Type to the WPGraphQL Registry
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @throws \Exception
	 */
	public static function register_type( TypeRegistry $type_registry ): void {
		register_graphql_interface_type(
			'Previewable',
			[
				'description' => __( 'Nodes that can be seen in a preview (unpublished) state.', 'wp-graphql' ),
				'fields'      => [
					'isPreview'                 => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the object is a node in the preview state', 'wp-graphql' ),
					],
					'previewRevisionDatabaseId' => [
						'type'        => 'Int',
						'description' => __( 'The database id of the preview node', 'wp-graphql' ),
					],
					'previewRevisionId'         => [
						'type'        => 'ID',
						'description' => __( 'Whether the object is a node in the preview state', 'wp-graphql' ),
					],
				],
				'resolveType' => static function ( Post $post ) use ( $type_registry ) {
					$type = 'Post';

					$post_type_object = isset( $post->post_type ) ? get_post_type_object( $post->post_type ) : null;

					if ( isset( $post_type_object->graphql_single_name ) ) {
						$type = $type_registry->get_type( $post_type_object->graphql_single_name );
					}

					return $type;
				},
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\TermNode.php
<?php

namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Data\Connection\EnqueuedScriptsConnectionResolver;
use WPGraphQL\Data\Connection\EnqueuedStylesheetConnectionResolver;
use WPGraphQL\Model\Term;
use WPGraphQL\Registry\TypeRegistry;

class TermNode {

	/**
	 * Register the TermNode Interface
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_type( TypeRegistry $type_registry ) {
		register_graphql_interface_type(
			'TermNode',
			[
				'interfaces'  => [ 'Node', 'UniformResourceIdentifiable' ],
				'connections' => [
					'enqueuedScripts'     => [
						'toType'  => 'EnqueuedScript',
						'resolve' => static function ( $source, $args, $context, $info ) {
							$resolver = new EnqueuedScriptsConnectionResolver( $source, $args, $context, $info );

							return $resolver->get_connection();
						},
					],
					'enqueuedStylesheets' => [
						'toType'  => 'EnqueuedStylesheet',
						'resolve' => static function ( $source, $args, $context, $info ) {
							$resolver = new EnqueuedStylesheetConnectionResolver( $source, $args, $context, $info );
							return $resolver->get_connection();
						},
					],
				],
				'description' => __( 'Terms are nodes within a Taxonomy, used to group and relate other nodes.', 'wp-graphql' ),
				'resolveType' => static function ( $term ) use ( $type_registry ) {

					/**
					 * The resolveType callback is used at runtime to determine what Type an object
					 * implementing the TermNode Interface should be resolved as.
					 *
					 * You can filter this centrally using the "graphql_wp_interface_type_config" filter
					 * to override if you need something other than a Post object to be resolved via the
					 * $post->post_type attribute.
					 */
					$type = null;

					if ( isset( $term->taxonomyName ) ) {
						$tax_object = get_taxonomy( $term->taxonomyName );
						if ( isset( $tax_object->graphql_single_name ) ) {
							$type = $type_registry->get_type( $tax_object->graphql_single_name );
						}
					}

					return ! empty( $type ) ? $type : null;
				},
				'fields'      => [
					'databaseId'     => [
						'type'        => [ 'non_null' => 'Int' ],
						'description' => __( 'Identifies the primary key from the database.', 'wp-graphql' ),
						'resolve'     => static function ( Term $term ) {
							return absint( $term->term_id );
						},
					],
					'count'          => [
						'type'        => 'Int',
						'description' => __( 'The number of objects connected to the object', 'wp-graphql' ),
					],
					'description'    => [
						'type'        => 'String',
						'description' => __( 'The description of the object', 'wp-graphql' ),
					],
					'name'           => [
						'type'        => 'String',
						'description' => __( 'The human friendly name of the object.', 'wp-graphql' ),
					],
					'slug'           => [
						'type'        => 'String',
						'description' => __( 'An alphanumeric identifier for the object unique to its type.', 'wp-graphql' ),
					],
					'termGroupId'    => [
						'type'        => 'Int',
						'description' => __( 'The ID of the term group that this term object belongs to', 'wp-graphql' ),
					],
					'termTaxonomyId' => [
						'type'        => 'Int',
						'description' => __( 'The taxonomy ID that the object is associated with', 'wp-graphql' ),
					],
					'taxonomyName'   => [
						'type'        => 'String',
						'description' => __( 'The name of the taxonomy that the object is associated with', 'wp-graphql' ),
					],
					'isRestricted'   => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the object is restricted from the current viewer', 'wp-graphql' ),
					],
					'link'           => [
						'type'        => 'String',
						'description' => __( 'The link to the term', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\InterfaceType\UniformResourceIdentifiable.php
<?php

namespace WPGraphQL\Type\InterfaceType;

use WPGraphQL\Model\Comment;
use WPGraphQL\Model\Post;
use WPGraphQL\Model\PostType;
use WPGraphQL\Model\Term;
use WPGraphQL\Model\User;
use WPGraphQL\Registry\TypeRegistry;

class UniformResourceIdentifiable {

	/**
	 * Registers the UniformResourceIdentifiable Interface to the Schema.
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 * @return void
	 */
	public static function register_type( TypeRegistry $type_registry ) {
		register_graphql_interface_type(
			'UniformResourceIdentifiable',
			[
				'interfaces'  => [ 'Node' ],
				'description' => __( 'Any node that has a URI', 'wp-graphql' ),
				'fields'      => [
					'uri'           => [
						'type'        => 'String',
						'description' => __( 'The unique resource identifier path', 'wp-graphql' ),
					],
					'id'            => [
						'type'        => [ 'non_null' => 'ID' ],
						'description' => __( 'The globally unique ID for the object', 'wp-graphql' ),
					],
					'isContentNode' => [
						'type'        => [ 'non_null' => 'Boolean' ],
						'description' => __( 'Whether the node is a Content Node', 'wp-graphql' ),
						'resolve'     => static function ( $node ) {
							return $node instanceof Post;
						},
					],
					'isTermNode'    => [
						'type'        => [ 'non_null' => 'Boolean' ],
						'description' => __( 'Whether the node is a Term', 'wp-graphql' ),
						'resolve'     => static function ( $node ) {
							return $node instanceof Term;
						},
					],
					'isFrontPage'   => [
						'type'        => [ 'non_null' => 'Bool' ],
						'description' => __( 'Whether the node represents the front page.', 'wp-graphql' ),
						'resolve'     => static function ( $node, $args, $context, $info ) {
							return isset( $node->isFrontPage ) && (bool) $node->isFrontPage;
						},
					],
					'isPostsPage'   => [
						'type'        => [ 'non_null' => 'Bool' ],
						'description' => __( 'Whether  the node represents the blog page.', 'wp-graphql' ),
						'resolve'     => static function ( $node, $args, $context, $info ) {
							return isset( $node->isPostsPage ) && (bool) $node->isPostsPage;
						},
					],
					'isComment'     => [
						'type'        => [ 'non_null' => 'Boolean' ],
						'description' => __( 'Whether the node is a Comment', 'wp-graphql' ),
						'resolve'     => static function ( $node ) {
							return $node instanceof Comment;
						},
					],
				],
				'resolveType' => static function ( $node ) use ( $type_registry ) {
					switch ( true ) {
						case $node instanceof Post:
							/** @var \WP_Post_Type $post_type_object */
							$post_type_object = get_post_type_object( $node->post_type );
							$type             = $type_registry->get_type( $post_type_object->graphql_single_name );
							break;
						case $node instanceof Term:
							/** @var \WP_Taxonomy $tax_object */
							$tax_object = get_taxonomy( $node->taxonomyName );
							$type       = $type_registry->get_type( $tax_object->graphql_single_name );
							break;
						case $node instanceof User:
							$type = $type_registry->get_type( 'User' );
							break;
						case $node instanceof PostType:
							$type = $type_registry->get_type( 'ContentType' );
							break;
						case $node instanceof Comment:
							$type = $type_registry->get_type( 'Comment' );
							break;
						default:
							$type = null;
					}

					return $type;
				},
			]
		);
	}
}


// File: wp-graphql\src\Type\ObjectType\Avatar.php
<?php

namespace WPGraphQL\Type\ObjectType;

use WPGraphQL\Model\Avatar as AvatarModel;

class Avatar {

	/**
	 * Register the Avatar Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_object_type(
			'Avatar',
			[
				'description' => __( 'Avatars are profile images for users. WordPress by default uses the Gravatar service to host and fetch avatars from.', 'wp-graphql' ),
				'model'       => AvatarModel::class,
				'fields'      => [
					'size'         => [
						'type'        => 'Int',
						'description' => __( 'The size of the avatar in pixels. A value of 96 will match a 96px x 96px gravatar image.', 'wp-graphql' ),
					],
					'height'       => [
						'type'        => 'Int',
						'description' => __( 'Height of the avatar image.', 'wp-graphql' ),
					],
					'width'        => [
						'type'        => 'Int',
						'description' => __( 'Width of the avatar image.', 'wp-graphql' ),
					],
					'default'      => [
						'type'        => 'String',
						'description' => __( "URL for the default image or a default type. Accepts '404' (return a 404 instead of a default image), 'retro' (8bit), 'monsterid' (monster), 'wavatar' (cartoon face), 'indenticon' (the 'quilt'), 'mystery', 'mm', or 'mysteryman' (The Oyster Man), 'blank' (transparent GIF), or 'gravatar_default' (the Gravatar logo).", 'wp-graphql' ),
					],
					'forceDefault' => [
						'type'        => 'Bool',
						'description' => __( 'Whether to always show the default image, never the Gravatar.', 'wp-graphql' ),
					],
					'rating'       => [
						'type'        => 'String',
						'description' => __( "What rating to display avatars up to. Accepts 'G', 'PG', 'R', 'X', and are judged in that order.", 'wp-graphql' ),
					],
					'scheme'       => [
						'type'        => 'String',
						'description' => __( 'Type of url scheme to use. Typically HTTP vs. HTTPS.', 'wp-graphql' ),
					],
					'extraAttr'    => [
						'type'        => 'String',
						'description' => __( 'HTML attributes to insert in the IMG element. Is not sanitized.', 'wp-graphql' ),
					],
					'foundAvatar'  => [
						'type'        => 'Bool',
						'description' => __( 'Whether the avatar was successfully found.', 'wp-graphql' ),
					],
					'url'          => [
						'type'        => 'String',
						'description' => __( 'URL for the gravatar image source.', 'wp-graphql' ),
					],
					'isRestricted' => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the object is restricted from the current viewer', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\ObjectType\Comment.php
<?php

namespace WPGraphQL\Type\ObjectType;

use WPGraphQL\AppContext;
use WPGraphQL\Model\Comment as CommentModel;

/**
 * Class Comment
 *
 * @package WPGraphQL\Type\Object
 */
class Comment {

	/**
	 * Register Comment Type
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_object_type(
			'Comment',
			[
				'description' => __( 'A Comment object', 'wp-graphql' ),
				'model'       => CommentModel::class,
				'interfaces'  => [ 'Node', 'DatabaseIdentifier', 'UniformResourceIdentifiable' ],
				'connections' => [
					'author' => [
						'toType'      => 'Commenter',
						'description' => __( 'The author of the comment', 'wp-graphql' ),
						'oneToOne'    => true,
						'resolve'     => static function ( $comment, $_args, AppContext $context ) {
							$node = null;

							// try and load the user node
							if ( ! empty( $comment->userId ) ) {
								$node = $context->get_loader( 'user' )->load( absint( $comment->userId ) );
							}

							// If no node is loaded, fallback to the
							// public comment author data
							if ( ! $node || ( true === $node->isPrivate ) ) {
								$node = ! empty( $comment->commentId ) ? $context->get_loader( 'comment_author' )->load( $comment->commentId ) : null;
							}

							return [
								'node'   => $node,
								'source' => $comment,
							];
						},
					],
				],
				'fields'      => [
					'agent'            => [
						'type'        => 'String',
						'description' => __( 'User agent used to post the comment. This field is equivalent to WP_Comment->comment_agent and the value matching the "comment_agent" column in SQL.', 'wp-graphql' ),
					],
					'approved'         => [
						'type'              => 'Boolean',
						'description'       => __( 'The approval status of the comment. This field is equivalent to WP_Comment->comment_approved and the value matching the "comment_approved" column in SQL.', 'wp-graphql' ),
						'deprecationReason' => __( 'Deprecated in favor of the `status` field', 'wp-graphql' ),
						'resolve'           => static function ( $comment ) {
							return 'approve' === $comment->status;
						},
					],
					'authorIp'         => [
						'type'        => 'String',
						'description' => __( 'IP address for the author. This field is equivalent to WP_Comment->comment_author_IP and the value matching the "comment_author_IP" column in SQL.', 'wp-graphql' ),
					],
					'commentId'        => [
						'type'              => 'Int',
						'description'       => __( 'ID for the comment, unique among comments.', 'wp-graphql' ),
						'deprecationReason' => __( 'Deprecated in favor of databaseId', 'wp-graphql' ),
					],
					'content'          => [
						'type'        => 'String',
						'description' => __( 'Content of the comment. This field is equivalent to WP_Comment->comment_content and the value matching the "comment_content" column in SQL.', 'wp-graphql' ),
						'args'        => [
							'format' => [
								'type'        => 'PostObjectFieldFormatEnum',
								'description' => __( 'Format of the field output', 'wp-graphql' ),
							],
						],
						'resolve'     => static function ( \WPGraphQL\Model\Comment $comment, $args ) {
							if ( isset( $args['format'] ) && 'raw' === $args['format'] ) {
								return isset( $comment->contentRaw ) ? $comment->contentRaw : null;
							} else {
								return isset( $comment->contentRendered ) ? $comment->contentRendered : null;
							}
						},
					],
					'date'             => [
						'type'        => 'String',
						'description' => __( 'Date the comment was posted in local time. This field is equivalent to WP_Comment->date and the value matching the "date" column in SQL.', 'wp-graphql' ),
					],
					'dateGmt'          => [
						'type'        => 'String',
						'description' => __( 'Date the comment was posted in GMT. This field is equivalent to WP_Comment->date_gmt and the value matching the "date_gmt" column in SQL.', 'wp-graphql' ),
					],
					'id'               => [
						'description' => __( 'The globally unique identifier for the comment object', 'wp-graphql' ),
					],
					'isRestricted'     => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the object is restricted from the current viewer', 'wp-graphql' ),
					],
					'karma'            => [
						'type'        => 'Int',
						'description' => __( 'Karma value for the comment. This field is equivalent to WP_Comment->comment_karma and the value matching the "comment_karma" column in SQL.', 'wp-graphql' ),
					],
					'link'             => [
						'type'        => 'String',
						'description' => __( 'The permalink of the comment', 'wp-graphql' ),
					],
					'parentId'         => [
						'type'        => 'ID',
						'description' => __( 'The globally unique identifier of the parent comment node.', 'wp-graphql' ),
					],
					'parentDatabaseId' => [
						'type'        => 'Int',
						'description' => __( 'The database id of the parent comment node or null if it is the root comment', 'wp-graphql' ),
					],
					'status'           => [
						'type'        => 'CommentStatusEnum',
						'description' => __( 'The approval status of the comment. This field is equivalent to WP_Comment->comment_approved and the value matching the "comment_approved" column in SQL.', 'wp-graphql' ),
					],
					'type'             => [
						'type'        => 'String',
						'description' => __( 'Type of comment. This field is equivalent to WP_Comment->comment_type and the value matching the "comment_type" column in SQL.', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\ObjectType\CommentAuthor.php
<?php

namespace WPGraphQL\Type\ObjectType;

use WPGraphQL\Model\CommentAuthor as CommentAuthorModel;

class CommentAuthor {

	/**
	 * Register the CommentAuthor Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_object_type(
			'CommentAuthor',
			[
				'description'     => __( 'A Comment Author object', 'wp-graphql' ),
				'interfaces'      => [ 'Node', 'Commenter' ],
				'model'           => CommentAuthorModel::class,
				'eagerlyLoadType' => true,
				'fields'          => [
					'id'           => [
						'description' => __( 'The globally unique identifier for the comment author object', 'wp-graphql' ),
					],
					'name'         => [
						'type'        => 'String',
						'description' => __( 'The name for the comment author.', 'wp-graphql' ),
					],
					'email'        => [
						'type'        => 'String',
						'description' => __( 'The email for the comment author', 'wp-graphql' ),
					],
					'url'          => [
						'type'        => 'String',
						'description' => __( 'The url the comment author.', 'wp-graphql' ),
					],
					'isRestricted' => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the object is restricted from the current viewer', 'wp-graphql' ),
					],
					'avatar'       => [
						'args'    => [
							'size'         => [
								'type'         => 'Int',
								'description'  => __( 'The size attribute of the avatar field can be used to fetch avatars of different sizes. The value corresponds to the dimension in pixels to fetch. The default is 96 pixels.', 'wp-graphql' ),
								'defaultValue' => 96,
							],
							'forceDefault' => [
								'type'        => 'Boolean',
								'description' => __( 'Whether to always show the default image, never the Gravatar. Default false', 'wp-graphql' ),
							],
							'rating'       => [
								'type'        => 'AvatarRatingEnum',
								'description' => __( 'The rating level of the avatar.', 'wp-graphql' ),
							],

						],
						'resolve' => static function ( $comment_author, $args ) {
							/**
							 * If the $comment_author is a user, the User model only returns the email address if the requesting user is authenticated.
							 * But, to resolve the Avatar we need a valid email, even for unauthenticated requests.
							 *
							 * If the email isn't visible, we use the comment ID to retrieve it, then use it to resolve the avatar.
							 *
							 * The email address is not publicly exposed, adhering to the rules of the User model.
							 */
							$comment_author_email = ! empty( $comment_author->email ) ? $comment_author->email : get_comment_author_email( $comment_author->databaseId );

							if ( empty( $comment_author_email ) ) {
								return null;
							}

							$avatar_args = [];
							if ( is_numeric( $args['size'] ) ) {
								$avatar_args['size'] = absint( $args['size'] );
								if ( ! $avatar_args['size'] ) {
									$avatar_args['size'] = 96;
								}
							}

							if ( ! empty( $args['forceDefault'] ) && true === $args['forceDefault'] ) {
								$avatar_args['force_default'] = true;
							}

							if ( ! empty( $args['rating'] ) ) {
								$avatar_args['rating'] = esc_sql( (string) $args['rating'] );
							}

							$avatar = get_avatar_data( $comment_author_email, $avatar_args );

							// if there's no url returned, return null
							if ( empty( $avatar['url'] ) ) {
								return null;
							}

							return new \WPGraphQL\Model\Avatar( $avatar );
						},
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\ObjectType\ContentType.php
<?php

namespace WPGraphQL\Type\ObjectType;

use WPGraphQL\Model\PostType;

class ContentType {

	/**
	 * Register the ContentType Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		$interfaces = [ 'Node', 'UniformResourceIdentifiable' ];

		register_graphql_object_type(
			'ContentType',
			[
				'description' => __( 'An Post Type object', 'wp-graphql' ),
				'interfaces'  => $interfaces,
				'model'       => PostType::class,
				'fields'      => [
					'id'                  => [
						'description' => __( 'The globally unique identifier of the post-type object.', 'wp-graphql' ),
					],
					'name'                => [
						'type'        => 'String',
						'description' => __( 'The internal name of the post type. This should not be used for display purposes.', 'wp-graphql' ),
					],
					'label'               => [
						'type'        => 'String',
						'description' => __( 'Display name of the content type.', 'wp-graphql' ),
					],
					'labels'              => [
						'type'        => 'PostTypeLabelDetails',
						'description' => __( 'Details about the content type labels.', 'wp-graphql' ),
					],
					'description'         => [
						'type'        => 'String',
						'description' => __( 'Description of the content type.', 'wp-graphql' ),
					],
					'public'              => [
						'type'        => 'Boolean',
						'description' => __( 'Whether a content type is intended for use publicly either via the admin interface or by front-end users. While the default settings of exclude_from_search, publicly_queryable, show_ui, and show_in_nav_menus are inherited from public, each does not rely on this relationship and controls a very specific intention.', 'wp-graphql' ),
					],
					'hierarchical'        => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the content type is hierarchical, for example pages.', 'wp-graphql' ),
					],
					'excludeFromSearch'   => [
						'type'        => 'Boolean',
						'description' => __( 'Whether to exclude nodes of this content type from front end search results.', 'wp-graphql' ),
					],
					'publiclyQueryable'   => [
						'type'        => 'Boolean',
						'description' => __( 'Whether queries can be performed on the front end for the content type as part of parse_request().', 'wp-graphql' ),
					],
					'showUi'              => [
						'type'        => 'Boolean',
						'description' => __( 'Whether to generate and allow a UI for managing this content type in the admin.', 'wp-graphql' ),
					],
					'showInMenu'          => [
						'type'        => 'Boolean',
						'description' => __( 'Where to show the content type in the admin menu. To work, $show_ui must be true. If true, the post type is shown in its own top level menu. If false, no menu is shown. If a string of an existing top level menu (eg. "tools.php" or "edit.php?post_type=page"), the post type will be placed as a sub-menu of that.', 'wp-graphql' ),
					],
					'showInNavMenus'      => [
						'type'        => 'Boolean',
						'description' => __( 'Makes this content type available for selection in navigation menus.', 'wp-graphql' ),
					],
					'showInAdminBar'      => [
						'type'        => 'Boolean',
						'description' => __( 'Makes this content type available via the admin bar.', 'wp-graphql' ),
					],
					'menuPosition'        => [
						'type'        => 'Int',
						'description' => __( 'The position of this post type in the menu. Only applies if show_in_menu is true.', 'wp-graphql' ),
					],
					'menuIcon'            => [
						'type'        => 'String',
						'description' => __( 'The name of the icon file to display as a menu icon.', 'wp-graphql' ),
					],
					'hasArchive'          => [
						'type'        => 'Boolean',
						'description' => __( 'Whether this content type should have archives. Content archives are generated by type and by date.', 'wp-graphql' ),
					],
					'canExport'           => [
						'type'        => 'Boolean',
						'description' => __( 'Whether this content type should can be exported.', 'wp-graphql' ),
					],
					'deleteWithUser'      => [
						'type'        => 'Boolean',
						'description' => __( 'Whether content of this type should be deleted when the author of it is deleted from the system.', 'wp-graphql' ),
					],
					'showInRest'          => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the content type is associated with a route under the the REST API "wp/v2" namespace.', 'wp-graphql' ),
					],
					'restBase'            => [
						'type'        => 'String',
						'description' => __( 'Name of content type to display in REST API "wp/v2" namespace.', 'wp-graphql' ),
					],
					'restControllerClass' => [
						'type'        => 'String',
						'description' => __( 'The REST Controller class assigned to handling this content type.', 'wp-graphql' ),
					],
					'showInGraphql'       => [
						'type'        => 'Boolean',
						'description' => __( 'Whether to add the content type to the GraphQL Schema.', 'wp-graphql' ),
					],
					'graphqlSingleName'   => [
						'type'        => 'String',
						'description' => __( 'The singular name of the content type within the GraphQL Schema.', 'wp-graphql' ),
					],
					'graphqlPluralName'   => [
						'type'        => 'String',
						'description' => __( 'The plural name of the content type within the GraphQL Schema.', 'wp-graphql' ),
					],
					'isRestricted'        => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the object is restricted from the current viewer', 'wp-graphql' ),
					],
					'isFrontPage'         => [
						'type'        => [ 'non_null' => 'Bool' ],
						'description' => __( 'Whether this page is set to the static front page.', 'wp-graphql' ),
					],
					'isPostsPage'         => [
						'type'        => [ 'non_null' => 'Bool' ],
						'description' => __( 'Whether this page is set to the blog posts page.', 'wp-graphql' ),
					],
				],

			]
		);
	}
}


// File: wp-graphql\src\Type\ObjectType\EnqueuedScript.php
<?php

namespace WPGraphQL\Type\ObjectType;

use GraphQLRelay\Relay;

/**
 * Class EnqueuedScript
 *
 * @package WPGraphQL\Type\Object
 */
class EnqueuedScript {

	/**
	 * Register the EnqueuedScript Type
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_object_type(
			'EnqueuedScript',
			[
				'description' => __( 'Script enqueued by the CMS', 'wp-graphql' ),
				'interfaces'  => [ 'Node', 'EnqueuedAsset' ],
				'fields'      => [
					'id'           => [
						'type'        => [ 'non_null' => 'ID' ],
						'description' => __( 'The global ID of the enqueued script', 'wp-graphql' ),
						'resolve'     => static function ( $asset ) {
							return isset( $asset->handle ) ? Relay::toGlobalId( 'enqueued_script', $asset->handle ) : null;
						},
					],
					'dependencies' => [
						'type'        => [ 'list_of' => 'EnqueuedScript' ],
						'description' => __( 'Dependencies needed to use this asset', 'wp-graphql' ),
					],
					'extraData'    => [
						'type'        => 'String',
						'description' => __( 'Extra data supplied to the enqueued script', 'wp-graphql' ),
						'resolve'     => static function ( \_WP_Dependency $script ) {
							if ( ! isset( $script->extra['data'] ) || ! is_string( $script->extra['data'] ) ) {
								return null;
							}

							return $script->extra['data'];
						},
					],
					'strategy'     => [
						'type'        => 'ScriptLoadingStrategyEnum',
						'description' => __( 'The loading strategy to use on the script tag', 'wp-graphql' ),
						'resolve'     => static function ( \_WP_Dependency $script ) {
							if ( ! isset( $script->extra['strategy'] ) || ! is_string( $script->extra['strategy'] ) ) {
								return null;
							}

							return $script->extra['strategy'];
						},
					],
					'version'      => [
						'description' => __( 'The version of the enqueued script', 'wp-graphql' ),
						'resolve'     => static function ( \_WP_Dependency $script ) {
							/** @var \WP_Scripts $wp_scripts */
							global $wp_scripts;

							return ! empty( $script->ver ) && is_string( $script->ver ) ? $script->ver : $wp_scripts->default_version;
						},
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\ObjectType\EnqueuedStylesheet.php
<?php

namespace WPGraphQL\Type\ObjectType;

use GraphQLRelay\Relay;

/**
 * Class EnqueuedStylesheet
 *
 * @package WPGraphQL\Type\Object
 */
class EnqueuedStylesheet {

	/**
	 * Register the EnqueuedStylesheet Type
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_object_type(
			'EnqueuedStylesheet',
			[
				'description' => __( 'Stylesheet enqueued by the CMS', 'wp-graphql' ),
				'interfaces'  => [ 'Node', 'EnqueuedAsset' ],
				'fields'      => [
					'id'           => [
						'type'        => [ 'non_null' => 'ID' ],
						'description' => __( 'The global ID of the enqueued stylesheet', 'wp-graphql' ),
						'resolve'     => static function ( $asset ) {
							return ! empty( $asset->handle ) ? Relay::toGlobalId( 'enqueued_stylesheet', $asset->handle ) : null;
						},
					],
					'dependencies' => [
						'type'        => [ 'list_of' => 'EnqueuedStylesheet' ],
						'description' => __( 'Dependencies needed to use this asset', 'wp-graphql' ),
					],
					'isRtl'        => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the enqueued style is RTL or not', 'wp-graphql' ),
						'resolve'     => static function ( \_WP_Dependency $stylesheet ) {
							return ! empty( $stylesheet->extra['rtl'] );
						},
					],
					'media'        => [
						'type'        => 'String',
						'description' => __( 'The media attribute to use for the link', 'wp-graphql' ),
						'resolve'     => static function ( \_WP_Dependency $stylesheet ) {
							return ! empty( $stylesheet->args ) && is_string( $stylesheet->args ) ? esc_attr( $stylesheet->args ) : 'all';
						},
					],
					'path'         => [
						'type'        => 'String',
						'description' => __( 'The absolute path to the enqueued style. Set when the stylesheet is meant to load inline.', 'wp-graphql' ),
						'resolve'     => static function ( \_WP_Dependency $stylesheet ) {
							return ! empty( $stylesheet->extra['path'] ) && is_string( $stylesheet->extra['path'] ) ? $stylesheet->extra['path'] : null;
						},
					],
					'rel'          => [
						'type'        => 'String',
						'description' => __( 'The `rel` attribute to use for the link', 'wp-graphql' ),
						'resolve'     => static function ( \_WP_Dependency $stylesheet ) {
							return ! empty( $stylesheet->extra['alt'] ) ? 'alternate stylesheet' : 'stylesheet';
						},
					],
					'suffix'       => [
						'type'        => 'String',
						'description' => __( 'Optional suffix, used in combination with RTL', 'wp-graphql' ),
						'resolve'     => static function ( \_WP_Dependency $stylesheet ) {
							return ! empty( $stylesheet->extra['suffix'] ) && is_string( $stylesheet->extra['suffix'] ) ? $stylesheet->extra['suffix'] : null;
						},
					],
					'title'        => [
						'type'        => 'String',
						'description' => __( 'The title of the enqueued style. Used for preferred/alternate stylesheets.', 'wp-graphql' ),
						'resolve'     => static function ( \_WP_Dependency $stylesheet ) {
							return ! empty( $stylesheet->extra['title'] ) && is_string( $stylesheet->extra['title'] ) ? $stylesheet->extra['title'] : null;
						},
					],
					'version'      => [
						'type'        => 'String',
						'description' => __( 'The version of the enqueued style', 'wp-graphql' ),
						'resolve'     => static function ( \_WP_Dependency $stylesheet ) {
							global $wp_styles;

							return ! empty( $stylesheet->ver ) && is_string( $stylesheet->ver ) ? $stylesheet->ver : $wp_styles->default_version;
						},
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\ObjectType\MediaDetails.php
<?php

namespace WPGraphQL\Type\ObjectType;

class MediaDetails {

	/**
	 * Register the MediaDetails type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_object_type(
			'MediaDetails',
			[
				'description' => __( 'File details for a Media Item', 'wp-graphql' ),
				'fields'      => [
					'width'  => [
						'type'        => 'Int',
						'description' => __( 'The width of the mediaItem', 'wp-graphql' ),
					],
					'height' => [
						'type'        => 'Int',
						'description' => __( 'The height of the mediaItem', 'wp-graphql' ),
					],
					'file'   => [
						'type'        => 'String',
						'description' => __( 'The filename of the mediaItem', 'wp-graphql' ),
					],
					'sizes'  => [
						'type'        => [
							'list_of' => 'MediaSize',
						],
						'args'        => [
							'exclude' => [ // phpcs:ignore WordPressVIPMinimum.Performance.WPQueryParams.PostNotIn_exclude
								'type'        => [ 'list_of' => 'MediaItemSizeEnum' ],
								'description' => __( 'The sizes to exclude. Will take precedence over `include`.', 'wp-graphql' ),
							],
							'include' => [
								'type'        => [ 'list_of' => 'MediaItemSizeEnum' ],
								'description' => __( 'The sizes to include. Can be overridden by `exclude`.', 'wp-graphql' ),
							],
						],
						'description' => __( 'The available sizes of the mediaItem', 'wp-graphql' ),
						'resolve'     => static function ( $media_details, array $args ) {
							// Bail early.
							if ( empty( $media_details['sizes'] ) ) {
								return null;
							}

							// If the include arg is set, only include the sizes specified.
							if ( ! empty( $args['include'] ) ) {
								$media_details['sizes'] = array_intersect_key( $media_details['sizes'], array_flip( $args['include'] ) );
							}

							// If the exclude arg is set, exclude the sizes specified.
							if ( ! empty( $args['exclude'] ) ) {
								$media_details['sizes'] = array_diff_key( $media_details['sizes'], array_flip( $args['exclude'] ) );
							}

							$sizes = [];

							foreach ( $media_details['sizes'] as $size_name => $size ) {
								$size['ID']   = $media_details['ID'];
								$size['name'] = $size_name;
								$sizes[]      = $size;
							}

							return ! empty( $sizes ) ? $sizes : null;
						},
					],
					'meta'   => [
						'type'        => 'MediaItemMeta',
						'description' => __( 'Meta information associated with the mediaItem', 'wp-graphql' ),
						'resolve'     => static function ( $media_details ) {
							return ! empty( $media_details['image_meta'] ) ? $media_details['image_meta'] : null;
						},
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\ObjectType\MediaItemMeta.php
<?php

namespace WPGraphQL\Type\ObjectType;

/**
 * Class MediaItemMeta
 *
 * @package WPGraphQL\Type\ObjectType
 */
class MediaItemMeta {

	/**
	 * Register the MediaItemMeta Type
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_object_type(
			'MediaItemMeta',
			[
				'description' => __( 'Meta connected to a MediaItem', 'wp-graphql' ),
				'fields'      => [
					'aperture'         => [
						'type'        => 'Float',
						'description' => __( 'Aperture measurement of the media item.', 'wp-graphql' ),
					],
					'credit'           => [
						'type'        => 'String',
						'description' => __( 'The original creator of the media item.', 'wp-graphql' ),
					],
					'camera'           => [
						'type'        => 'String',
						'description' => __( 'Information about the camera used to create the media item.', 'wp-graphql' ),
					],
					'caption'          => [
						'type'        => 'String',
						'description' => __( 'The text string description associated with the media item.', 'wp-graphql' ),
					],
					'createdTimestamp' => [
						'type'        => 'Int',
						'description' => __( 'The date/time when the media was created.', 'wp-graphql' ),
						'resolve'     => static function ( $meta ) {
							return ! empty( $meta['created_timestamp'] ) ? $meta['created_timestamp'] : null;
						},
					],
					'copyright'        => [
						'type'        => 'String',
						'description' => __( 'Copyright information associated with the media item.', 'wp-graphql' ),
					],
					'focalLength'      => [
						'type'        => 'Float',
						'description' => __( 'The focal length value of the media item.', 'wp-graphql' ),
						'resolve'     => static function ( $meta ) {
							return ! empty( $meta['focal_length'] ) ? $meta['focal_length'] : null;
						},
					],
					'iso'              => [
						'type'        => 'Int',
						'description' => __( 'The ISO (International Organization for Standardization) value of the media item.', 'wp-graphql' ),
					],
					'shutterSpeed'     => [
						'type'        => 'Float',
						'description' => __( 'The shutter speed information of the media item.', 'wp-graphql' ),
						'resolve'     => static function ( $meta ) {
							return ! empty( $meta['shutter_speed'] ) ? $meta['shutter_speed'] : null;
						},
					],
					'title'            => [
						'type'        => 'String',
						'description' => __( 'A useful title for the media item.', 'wp-graphql' ),
					],
					'orientation'      => [
						'type'        => 'String',
						'description' => __( 'The vertical or horizontal aspect of the media item.', 'wp-graphql' ),
					],
					'keywords'         => [
						'type'        => [
							'list_of' => 'String',
						],
						'description' => __( 'List of keywords used to describe or identfy the media item.', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\ObjectType\MediaSize.php
<?php

namespace WPGraphQL\Type\ObjectType;

class MediaSize {

	/**
	 * Register the MediaSize
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_object_type(
			'MediaSize',
			[
				'description' => __( 'Details of an available size for a media item', 'wp-graphql' ),
				'fields'      => [
					'name'      => [
						'type'        => 'String',
						'description' => __( 'The referenced size name', 'wp-graphql' ),
					],
					'file'      => [
						'type'        => 'String',
						'description' => __( 'The filename of the referenced size', 'wp-graphql' ),
					],
					'width'     => [
						'type'        => 'String',
						'description' => __( 'The width of the referenced size', 'wp-graphql' ),
					],
					'height'    => [
						'type'        => 'String',
						'description' => __( 'The height of the referenced size', 'wp-graphql' ),
					],
					'mimeType'  => [
						'type'        => 'String',
						'description' => __( 'The mime type of the referenced size', 'wp-graphql' ),
						'resolve'     => static function ( $image ) {
							return ! empty( $image['mime-type'] ) ? $image['mime-type'] : null;
						},
					],
					'fileSize'  => [
						'type'        => 'Int',
						'description' => __( 'The filesize of the resource', 'wp-graphql' ),
						'resolve'     => static function ( $image ) {
							if ( ! empty( $image['ID'] ) && ! empty( $image['file'] ) ) {
								$original_file = get_attached_file( absint( $image['ID'] ) );
								$filesize_path = ! empty( $original_file ) ? path_join( dirname( $original_file ), $image['file'] ) : null;

								return ! empty( $filesize_path ) ? filesize( $filesize_path ) : null;
							}

							return null;
						},
					],
					'sourceUrl' => [
						'type'        => 'String',
						'description' => __( 'The url of the referenced size', 'wp-graphql' ),
						'resolve'     => static function ( $image ) {
							$src_url = null;

							if ( ! empty( $image['ID'] ) ) {
								$src = wp_get_attachment_image_src( absint( $image['ID'] ), $image['name'] );
								if ( ! empty( $src ) ) {
									$src_url = $src[0];
								}
							} elseif ( ! empty( $image['file'] ) ) {
								$src_url = $image['file'];
							}

							return $src_url;
						},
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\ObjectType\Menu.php
<?php

namespace WPGraphQL\Type\ObjectType;

use WPGraphQL\Model\Menu as MenuModel;

class Menu {

	/**
	 * Register the Menu object type
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_object_type(
			'Menu',
			[
				'description' => __( 'Menus are the containers for navigation items. Menus can be assigned to menu locations, which are typically registered by the active theme.', 'wp-graphql' ),
				'interfaces'  => [ 'Node', 'DatabaseIdentifier' ],
				'model'       => MenuModel::class,
				'fields'      => [
					'id'           => [
						'description' => __( 'The globally unique identifier of the nav menu object.', 'wp-graphql' ),
					],
					'count'        => [
						'type'        => 'Int',
						'description' => __( 'The number of items in the menu', 'wp-graphql' ),
					],
					'menuId'       => [
						'type'              => 'Int',
						'description'       => __( 'WP ID of the nav menu.', 'wp-graphql' ),
						'deprecationReason' => __( 'Deprecated in favor of the databaseId field', 'wp-graphql' ),
					],
					'name'         => [
						'type'        => 'String',
						'description' => esc_html__( 'Display name of the menu. Equivalent to WP_Term->name.', 'wp-graphql' ),
					],
					'slug'         => [
						'type'        => 'String',
						'description' => esc_html__( 'The url friendly name of the menu. Equivalent to WP_Term->slug', 'wp-graphql' ),
					],
					'isRestricted' => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the object is restricted from the current viewer', 'wp-graphql' ),
					],
					'locations'    => [
						'type'        => [
							'list_of' => 'MenuLocationEnum',
						],
						'description' => __( 'The locations a menu is assigned to', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\ObjectType\MenuItem.php
<?php

namespace WPGraphQL\Type\ObjectType;

use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Data\Connection\MenuConnectionResolver;
use WPGraphQL\Data\Connection\PostObjectConnectionResolver;
use WPGraphQL\Data\Connection\TermObjectConnectionResolver;
use WPGraphQL\Model\MenuItem as MenuItemModel;

class MenuItem {

	/**
	 * Register the MenuItem Type
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_object_type(
			'MenuItem',
			[
				'description' => __( 'Navigation menu items are the individual items assigned to a menu. These are rendered as the links in a navigation menu.', 'wp-graphql' ),
				'interfaces'  => [ 'Node', 'DatabaseIdentifier' ],
				'model'       => MenuItemModel::class,
				'connections' => [
					'connectedNode' => [
						'toType'      => 'MenuItemLinkable',
						'description' => __( 'Connection from MenuItem to it\'s connected node', 'wp-graphql' ),
						'oneToOne'    => true,
						'resolve'     => static function ( MenuItemModel $menu_item, $args, AppContext $context, ResolveInfo $info ) {
							if ( ! isset( $menu_item->databaseId ) ) {
								return null;
							}

							$object_id   = (int) get_post_meta( $menu_item->databaseId, '_menu_item_object_id', true );
							$object_type = get_post_meta( $menu_item->databaseId, '_menu_item_type', true );

							/**
							 * When this filter returns anything other than null it will be used as the resolved connection for the menu item's connected node, short-circuiting the default resolution.
							 *
							 * This is useful since we often add taxonomy terms to menus but would prefer to represent the menu item in other ways.
							 * E.g., a linked post object (or vice-versa).
							 *
							 * @param ?\GraphQL\Deferred                   $deferred_connection The AbstractConnectionResolver's connection, or null to continue with the default resolution.
							 * @param \WPGraphQL\Model\MenuItem            $menu_item           The MenuItem model.
							 * @param array<string,mixed>                  $args                The GraphQL args for the connection.
							 * @param \WPGraphQL\AppContext                $context             The AppContext object.
							 * @param \GraphQL\Type\Definition\ResolveInfo $info                The ResolveInfo object.
							 * @param int                                  $object_id           The ID of the connected object.
							 * @param string                               $object_type         The type of the connected object.
							 */
							$deferred_connection = apply_filters( 'graphql_pre_resolve_menu_item_connected_node', null, $menu_item, $args, $context, $info, $object_id, $object_type );

							if ( null !== $deferred_connection ) {
								return $deferred_connection;
							}

							// Handle the default resolution.
							switch ( $object_type ) {
								// Post object
								case 'post_type':
									$resolver = new PostObjectConnectionResolver( $menu_item, $args, $context, $info, 'any' );
									$resolver->set_query_arg( 'p', $object_id );

									// connected objects to menu items can be any post status
									$resolver->set_query_arg( 'post_status', 'any' );
									break;

								// Taxonomy term
								case 'taxonomy':
									$resolver = new TermObjectConnectionResolver( $menu_item, $args, $context, $info );
									$resolver->set_query_arg( 'include', $object_id );
									break;
								default:
									$resolver = null;
									break;
							}

							return null !== $resolver ? $resolver->one_to_one()->get_connection() : null;
						},
					],
					'menu'          => [
						'toType'      => 'Menu',
						'description' => __( 'The Menu a MenuItem is part of', 'wp-graphql' ),
						'oneToOne'    => true,
						'resolve'     => static function ( MenuItemModel $menu_item, $args, $context, $info ) {
							$resolver = new MenuConnectionResolver( $menu_item, $args, $context, $info );
							$resolver->set_query_arg( 'include', $menu_item->menuDatabaseId );

							return $resolver->one_to_one()->get_connection();
						},
					],
				],
				'fields'      => [
					'id'               => [
						'description' => __( 'The globally unique identifier of the nav menu item object.', 'wp-graphql' ),
					],
					'parentId'         => [
						'type'        => 'ID',
						'description' => __( 'The globally unique identifier of the parent nav menu item object.', 'wp-graphql' ),
					],
					'parentDatabaseId' => [
						'type'        => 'Int',
						'description' => __( 'The database id of the parent menu item or null if it is the root', 'wp-graphql' ),
					],
					'cssClasses'       => [
						'type'        => [
							'list_of' => 'String',
						],
						'description' => __( 'Class attribute for the menu item link', 'wp-graphql' ),
					],
					'description'      => [
						'type'        => 'String',
						'description' => __( 'Description of the menu item.', 'wp-graphql' ),
					],
					'label'            => [
						'type'        => 'String',
						'description' => __( 'Label or title of the menu item.', 'wp-graphql' ),
					],
					'linkRelationship' => [
						'type'        => 'String',
						'description' => __( 'Link relationship (XFN) of the menu item.', 'wp-graphql' ),
					],
					'menuItemId'       => [
						'type'              => 'Int',
						'description'       => __( 'WP ID of the menu item.', 'wp-graphql' ),
						'deprecationReason' => __( 'Deprecated in favor of the databaseId field', 'wp-graphql' ),
					],
					'target'           => [
						'type'        => 'String',
						'description' => __( 'Target attribute for the menu item link.', 'wp-graphql' ),
					],
					'title'            => [
						'type'        => 'String',
						'description' => __( 'Title attribute for the menu item link', 'wp-graphql' ),
					],
					'url'              => [
						'type'        => 'String',
						'description' => __( 'URL or destination of the menu item.', 'wp-graphql' ),
					],
					// Note: this field is added to the MenuItem type instead of applied by the "UniformResourceIdentifiable" interface
					// because a MenuItem is not identifiable by a uri, the connected resource is identifiable by the uri.
					'uri'              => [
						'type'        => 'String',
						'description' => __( 'The uri of the resource the menu item links to', 'wp-graphql' ),
					],
					'path'             => [
						'type'        => 'String',
						'description' => __( 'Path for the resource. Relative path for internal resources. Absolute path for external resources.', 'wp-graphql' ),
					],
					'isRestricted'     => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the object is restricted from the current viewer', 'wp-graphql' ),
					],
					'order'            => [
						'type'        => 'Int',
						'description' => __( 'Menu item order', 'wp-graphql' ),
					],
					'locations'        => [
						'type'        => [
							'list_of' => 'MenuLocationEnum',
						],
						'description' => __( 'The locations the menu item\'s Menu is assigned to', 'wp-graphql' ),
					],
					'connectedObject'  => [
						'type'              => 'MenuItemObjectUnion',
						'deprecationReason' => __( 'Deprecated in favor of the connectedNode field', 'wp-graphql' ),
						'description'       => __( 'The object connected to this menu item.', 'wp-graphql' ),
						'resolve'           => static function ( $menu_item, array $args, AppContext $context, $info ) {
							$object_id   = intval( get_post_meta( $menu_item->menuItemId, '_menu_item_object_id', true ) );
							$object_type = get_post_meta( $menu_item->menuItemId, '_menu_item_type', true );

							switch ( $object_type ) {
								// Post object
								case 'post_type':
									$resolved_object = $context->get_loader( 'post' )->load_deferred( $object_id );
									break;

								// Taxonomy term
								case 'taxonomy':
									$resolved_object = $context->get_loader( 'term' )->load_deferred( $object_id );
									break;
								default:
									$resolved_object = null;
									break;
							}

							/**
							 * Allow users to override how nav menu items are resolved.
							 * This is useful since we often add taxonomy terms to menus
							 * but would prefer to represent the menu item in other ways,
							 * e.g., a linked post object (or vice-versa).
							 *
							 * @param \WP_Post|\WP_Term                    $resolved_object Post or term connected to MenuItem
							 * @param array<string,mixed>                  $args            Array of arguments input in the field as part of the GraphQL query
							 * @param \WPGraphQL\AppContext                $context         Object containing app context that gets passed down the resolve tree
							 * @param \GraphQL\Type\Definition\ResolveInfo $info            Info about fields passed down the resolve tree
							 * @param int                                  $object_id       Post or term ID of connected object
							 * @param string                               $object_type     Type of connected object ("post_type" or "taxonomy")
							 *
							 * @since 0.0.30
							 */
							return apply_filters_deprecated(
								'graphql_resolve_menu_item',
								[
									$resolved_object,
									$args,
									$context,
									$info,
									$object_id,
									$object_type,
								],
								'1.22.0',
								'graphql_pre_resolve_menu_item_connected_node',
								__( 'Use the `graphql_pre_resolve_menu_item_connected_node` filter on `connectedNode` instead.', 'wp-graphql' )
							);
						},
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\ObjectType\Plugin.php
<?php

namespace WPGraphQL\Type\ObjectType;

use WPGraphQL\Model\Plugin as PluginModel;

/**
 * Class Plugin
 *
 * @package WPGraphQL\Type\Object
 */
class Plugin {

	/**
	 * Registers the Plugin Type to the Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_object_type(
			'Plugin',
			[
				'interfaces'  => [ 'Node' ],
				'model'       => PluginModel::class,
				'description' => __( 'An plugin object', 'wp-graphql' ),
				'fields'      => [
					'id'           => [
						'description' => __( 'The globally unique identifier of the plugin object.', 'wp-graphql' ),
					],
					'name'         => [
						'type'        => 'String',
						'description' => __( 'Display name of the plugin.', 'wp-graphql' ),
					],
					'pluginUri'    => [
						'type'        => 'String',
						'description' => __( 'URI for the plugin website. This is useful for directing users for support requests etc.', 'wp-graphql' ),
					],
					'description'  => [
						'type'        => 'String',
						'description' => __( 'Description of the plugin.', 'wp-graphql' ),
					],
					'author'       => [
						'type'        => 'String',
						'description' => __( 'Name of the plugin author(s), may also be a company name.', 'wp-graphql' ),
					],
					'authorUri'    => [
						'type'        => 'String',
						'description' => __( 'URI for the related author(s)/company website.', 'wp-graphql' ),
					],
					'version'      => [
						'type'        => 'String',
						'description' => __( 'Current version of the plugin.', 'wp-graphql' ),
					],
					'isRestricted' => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the object is restricted from the current viewer', 'wp-graphql' ),
					],
					'path'         => [
						'type'        => 'String',
						'description' => __( 'Plugin path.', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\ObjectType\PostObject.php
<?php

namespace WPGraphQL\Type\ObjectType;

use WPGraphQL\Registry\TypeRegistry;
use WP_Post_Type;

/**
 * WPObject - PostObject
 *
 * @package WPGraphQL\Type
 * @deprecated 1.12.0
 */
class PostObject {

	/**
	 * Registers a post_type WPObject type to the schema.
	 *
	 * @param \WP_Post_Type                    $post_type_object Post type.
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry The Type Registry
	 *
	 * @return void
	 * @throws \Exception
	 * @deprecated 1.12.0
	 */
	public static function register_post_object_types( WP_Post_Type $post_type_object, TypeRegistry $type_registry ) {
		_deprecated_function( __FUNCTION__, '1.12.0', esc_attr( \WPGraphQL\Registry\Utils\PostObject::class ) . '::register_types()' );

		\WPGraphQL\Registry\Utils\PostObject::register_types( $post_type_object );
	}

	/**
	 * Registers common post type fields on schema type corresponding to provided post type object.
	 *
	 * @param \WP_Post_Type                    $post_type_object Post type.
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry The Type Registry
	 *
	 * @deprecated 1.12.0
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_fields( $post_type_object, $type_registry ) {
		_deprecated_function( __FUNCTION__, '1.12.0', esc_attr( \WPGraphQL\Registry\Utils\PostObject::class ) . '::get_fields()' );

		return \WPGraphQL\Registry\Utils\PostObject::get_fields( $post_type_object );
	}
}


// File: wp-graphql\src\Type\ObjectType\PostTypeLabelDetails.php
<?php

namespace WPGraphQL\Type\ObjectType;

/**
 * Class PostTypeLabelDetails
 *
 * @package WPGraphQL\Type\Object
 */
class PostTypeLabelDetails {

	/**
	 * Register the PostTypeLabelDetails type
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_object_type(
			'PostTypeLabelDetails',
			[
				'description' => __( 'Details for labels of the PostType', 'wp-graphql' ),
				'fields'      => [
					'name'                => [
						'type'        => 'String',
						'description' => __( 'General name for the post type, usually plural.', 'wp-graphql' ),
					],
					'singularName'        => [
						'type'        => 'String',
						'description' => __( 'Name for one object of this post type.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->singular_name ) ? $labels->singular_name : null;
						},
					],
					'addNew'              => [
						'type'        => 'String',
						'description' => __( 'Default is ‘Add New’ for both hierarchical and non-hierarchical types.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->add_new ) ? $labels->add_new : null;
						},
					],
					'addNewItem'          => [
						'type'        => 'String',
						'description' => __( 'Label for adding a new singular item.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->add_new_item ) ? $labels->add_new_item : null;
						},
					],
					'editItem'            => [
						'type'        => 'String',
						'description' => __( 'Label for editing a singular item.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->edit_item ) ? $labels->edit_item : null;
						},
					],
					'newItem'             => [
						'type'        => 'String',
						'description' => __( 'Label for the new item page title.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->new_item ) ? $labels->new_item : null;
						},
					],
					'viewItem'            => [
						'type'        => 'String',
						'description' => __( 'Label for viewing a singular item.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->view_item ) ? $labels->view_item : null;
						},
					],
					'viewItems'           => [
						'type'        => 'String',
						'description' => __( 'Label for viewing post type archives.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->view_items ) ? $labels->view_items : null;
						},
					],
					'searchItems'         => [
						'type'        => 'String',
						'description' => __( 'Label for searching plural items.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->search_items ) ? $labels->search_items : null;
						},
					],
					'notFound'            => [
						'type'        => 'String',
						'description' => __( 'Label used when no items are found.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->not_found ) ? $labels->not_found : null;
						},
					],
					'notFoundInTrash'     => [
						'type'        => 'String',
						'description' => __( 'Label used when no items are in the trash.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->not_found_in_trash ) ? $labels->not_found_in_trash : null;
						},
					],
					'parentItemColon'     => [
						'type'        => 'String',
						'description' => __( 'Label used to prefix parents of hierarchical items.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->parent_item_colon ) ? $labels->parent_item_colon : null;
						},
					],
					'allItems'            => [
						'type'        => 'String',
						'description' => __( 'Label to signify all items in a submenu link.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->all_items ) ? $labels->all_items : null;
						},
					],
					'archives'            => [
						'type'        => 'String',
						'description' => __( 'Label for archives in nav menus', 'wp-graphql' ),
					],
					'attributes'          => [
						'type'        => 'String',
						'description' => __( 'Label for the attributes meta box.', 'wp-graphql' ),
					],
					'insertIntoItem'      => [
						'type'        => 'String',
						'description' => __( 'Label for the media frame button.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->insert_into_item ) ? $labels->insert_into_item : null;
						},
					],
					'uploadedToThisItem'  => [
						'type'        => 'String',
						'description' => __( 'Label for the media frame filter.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->uploaded_to_this_item ) ? $labels->uploaded_to_this_item : null;
						},
					],
					'featuredImage'       => [
						'type'        => 'String',
						'description' => __( 'Label for the Featured Image meta box title.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->featured_image ) ? $labels->featured_image : null;
						},
					],
					'setFeaturedImage'    => [
						'type'        => 'String',
						'description' => __( 'Label for setting the featured image.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->set_featured_image ) ? $labels->set_featured_image : null;
						},
					],
					'removeFeaturedImage' => [
						'type'        => 'String',
						'description' => __( 'Label for removing the featured image.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->remove_featured_image ) ? $labels->remove_featured_image : null;
						},
					],
					'useFeaturedImage'    => [
						'type'        => 'String',
						'description' => __( 'Label in the media frame for using a featured image.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->use_featured_item ) ? $labels->use_featured_item : null;
						},
					],
					'menuName'            => [
						'type'        => 'String',
						'description' => __( 'Label for the menu name.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->menu_name ) ? $labels->menu_name : null;
						},
					],
					'filterItemsList'     => [
						'type'        => 'String',
						'description' => __( 'Label for the table views hidden heading.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->filter_items_list ) ? $labels->filter_items_list : null;
						},
					],
					'itemsListNavigation' => [
						'type'        => 'String',
						'description' => __( 'Label for the table pagination hidden heading.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->items_list_navigation ) ? $labels->items_list_navigation : null;
						},
					],
					'itemsList'           => [
						'type'        => 'String',
						'description' => __( 'Label for the table hidden heading.', 'wp-graphql' ),
						'resolve'     => static function ( $labels ) {
							return ! empty( $labels->items_list ) ? $labels->items_list : null;
						},
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\ObjectType\RootMutation.php
<?php

namespace WPGraphQL\Type\ObjectType;

class RootMutation {

	/**
	 * Register RootMutation type
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_object_type(
			'RootMutation',
			[
				'description' => __( 'The root mutation', 'wp-graphql' ),
				'fields'      => [
					'increaseCount' => [
						'type'        => 'Int',
						'description' => __( 'Increase the count.', 'wp-graphql' ),
						'args'        => [
							'count' => [
								'type'        => 'Int',
								'description' => __( 'The count to increase', 'wp-graphql' ),
							],
						],
						'resolve'     => static function ( $root, $args ) {
							return isset( $args['count'] ) ? absint( $args['count'] ) + 1 : null;
						},
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\ObjectType\RootQuery.php
<?php

namespace WPGraphQL\Type\ObjectType;

use GraphQL\Error\UserError;
use GraphQL\Type\Definition\ResolveInfo;
use GraphQLRelay\Relay;
use WPGraphQL\AppContext;
use WPGraphQL\Data\Connection\ContentTypeConnectionResolver;
use WPGraphQL\Data\Connection\EnqueuedScriptsConnectionResolver;
use WPGraphQL\Data\Connection\EnqueuedStylesheetConnectionResolver;
use WPGraphQL\Data\Connection\MenuConnectionResolver;
use WPGraphQL\Data\Connection\PostObjectConnectionResolver;
use WPGraphQL\Data\Connection\ThemeConnectionResolver;
use WPGraphQL\Data\Connection\UserRoleConnectionResolver;
use WPGraphQL\Data\DataSource;
use WPGraphQL\Model\Post;
use WPGraphQL\Type\Connection\PostObjects;
use WPGraphQL\Utils\Utils;

/**
 * Class RootQuery
 *
 * @package WPGraphQL\Type\Object
 */
class RootQuery {

	/**
	 * Register the RootQuery type
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_object_type(
			'RootQuery',
			[
				'description' => __( 'The root entry point into the Graph', 'wp-graphql' ),
				'connections' => [
					'contentTypes'          => [
						'toType'  => 'ContentType',
						'resolve' => static function ( $source, $args, $context, $info ) {
							$resolver = new ContentTypeConnectionResolver( $source, $args, $context, $info );

							return $resolver->get_connection();
						},
					],
					'menus'                 => [
						'toType'         => 'Menu',
						'connectionArgs' => [
							'id'       => [
								'type'        => 'Int',
								'description' => __( 'The database ID of the object', 'wp-graphql' ),
							],
							'location' => [
								'type'        => 'MenuLocationEnum',
								'description' => __( 'The menu location for the menu being queried', 'wp-graphql' ),
							],
							'slug'     => [
								'type'        => 'String',
								'description' => __( 'The slug of the menu to query items for', 'wp-graphql' ),
							],
						],
						'resolve'        => static function ( $source, $args, $context, $info ) {
							$resolver = new MenuConnectionResolver( $source, $args, $context, $info, 'nav_menu' );

							return $resolver->get_connection();
						},
					],
					'plugins'               => [
						'toType'         => 'Plugin',
						'connectionArgs' => [
							'search' => [
								'name'        => 'search',
								'type'        => 'String',
								'description' => __( 'Show plugin based on a keyword search.', 'wp-graphql' ),
							],
							'status' => [
								'type'        => 'PluginStatusEnum',
								'description' => __( 'Show plugins with a specific status.', 'wp-graphql' ),
							],
							'stati'  => [
								'type'        => [ 'list_of' => 'PluginStatusEnum' ],
								'description' => __( 'Retrieve plugins where plugin status is in an array.', 'wp-graphql' ),
							],
						],
						'resolve'        => static function ( $root, $args, $context, $info ) {
							return DataSource::resolve_plugins_connection( $root, $args, $context, $info );
						},
					],
					'registeredScripts'     => [
						'toType'  => 'EnqueuedScript',
						'resolve' => static function ( $source, $args, $context, $info ) {

							// The connection resolver expects the source to include
							// enqueuedScriptsQueue
							$source                       = new \stdClass();
							$source->enqueuedScriptsQueue = [];
							global $wp_scripts;
							do_action( 'wp_enqueue_scripts' );
							$source->enqueuedScriptsQueue = array_keys( $wp_scripts->registered );
							$resolver                     = new EnqueuedScriptsConnectionResolver( $source, $args, $context, $info );

							return $resolver->get_connection();
						},
					],
					'registeredStylesheets' => [
						'toType'  => 'EnqueuedStylesheet',
						'resolve' => static function ( $source, $args, $context, $info ) {

							// The connection resolver expects the source to include
							// enqueuedStylesheetsQueue
							$source                           = new \stdClass();
							$source->enqueuedStylesheetsQueue = [];
							global $wp_styles;
							do_action( 'wp_enqueue_scripts' );
							$source->enqueuedStylesheetsQueue = array_keys( $wp_styles->registered );
							$resolver                         = new EnqueuedStylesheetConnectionResolver( $source, $args, $context, $info );

							return $resolver->get_connection();
						},
					],
					'themes'                => [
						'toType'  => 'Theme',
						'resolve' => static function ( $root, $args, $context, $info ) {
							$resolver = new ThemeConnectionResolver( $root, $args, $context, $info );

							return $resolver->get_connection();
						},
					],
					'revisions'             => [
						'toType'         => 'ContentNode',
						'queryClass'     => 'WP_Query',
						'connectionArgs' => PostObjects::get_connection_args(),
						'resolve'        => static function ( $root, $args, $context, $info ) {
							$resolver = new PostObjectConnectionResolver( $root, $args, $context, $info, 'revision' );

							return $resolver->get_connection();
						},
					],
					'userRoles'             => [
						'toType'        => 'UserRole',
						'fromFieldName' => 'userRoles',
						'resolve'       => static function ( $user, $args, $context, $info ) {
							$resolver = new UserRoleConnectionResolver( $user, $args, $context, $info );

							return $resolver->get_connection();
						},
					],
				],
				'fields'      => [
					'allSettings' => [
						'type'        => 'Settings',
						'description' => __( 'Entry point to get all settings for the site', 'wp-graphql' ),
						'resolve'     => static function () {
							return true;
						},
					],
					'comment'     => [
						'type'        => 'Comment',
						'description' => __( 'Returns a Comment', 'wp-graphql' ),
						'args'        => [
							'id'     => [
								'type'        => [
									'non_null' => 'ID',
								],
								'description' => __( 'Unique identifier for the comment node.', 'wp-graphql' ),
							],
							'idType' => [
								'type'        => 'CommentNodeIdTypeEnum',
								'description' => __( 'Type of unique identifier to fetch a comment by. Default is Global ID', 'wp-graphql' ),
							],
						],
						'resolve'     => static function ( $_source, array $args, AppContext $context ) {
							$id_type = isset( $args['idType'] ) ? $args['idType'] : 'id';

							switch ( $id_type ) {
								case 'database_id':
									$id = absint( $args['id'] );
									break;
								default:
									$id_components = Relay::fromGlobalId( $args['id'] );
									if ( ! isset( $id_components['id'] ) || ! absint( $id_components['id'] ) ) {
										throw new UserError( esc_html__( 'The ID input is invalid', 'wp-graphql' ) );
									}
									$id = absint( $id_components['id'] );

									break;
							}

							return $context->get_loader( 'comment' )->load_deferred( $id );
						},
					],
					'contentNode' => [
						'type'        => 'ContentNode',
						'description' => __( 'A node used to manage content', 'wp-graphql' ),
						'args'        => [
							'id'          => [
								'type'        => [
									'non_null' => 'ID',
								],
								'description' => __( 'Unique identifier for the content node.', 'wp-graphql' ),
							],
							'idType'      => [
								'type'        => 'ContentNodeIdTypeEnum',
								'description' => __( 'Type of unique identifier to fetch a content node by. Default is Global ID', 'wp-graphql' ),
							],
							'contentType' => [
								'type'        => 'ContentTypeEnum',
								'description' => __( 'The content type the node is used for. Required when idType is set to "name" or "slug"', 'wp-graphql' ),
							],
							'asPreview'   => [
								'type'        => 'Boolean',
								'description' => __( 'Whether to return the Preview Node instead of the Published Node. When the ID of a Node is provided along with asPreview being set to true, the preview node with un-published changes will be returned instead of the published node. If no preview node exists or the requester doesn\'t have proper capabilities to preview, no node will be returned. If the ID provided is a URI and has a preview query arg, it will be used as a fallback if the "asPreview" argument is not explicitly provided as an argument.', 'wp-graphql' ),
							],
						],
						'resolve'     => static function ( $_root, $args, AppContext $context ) {
							$idType = $args['idType'] ?? 'global_id';
							switch ( $idType ) {
								case 'uri':
									return $context->node_resolver->resolve_uri(
										$args['id'],
										[
											'nodeType'  => 'ContentNode',
											'asPreview' => $args['asPreview'] ?? null,
										]
									);
								case 'database_id':
									$post_id = absint( $args['id'] );
									break;
								case 'global_id':
								default:
									$id_components = Relay::fromGlobalId( $args['id'] );
									if ( ! isset( $id_components['id'] ) || ! absint( $id_components['id'] ) ) {
										throw new UserError( esc_html__( 'The ID input is invalid. Make sure you set the proper idType for your input.', 'wp-graphql' ) );
									}
									$post_id = absint( $id_components['id'] );
									break;
							}

							if ( isset( $args['asPreview'] ) && true === $args['asPreview'] ) {
								$post_id = Utils::get_post_preview_id( $post_id );
							}

							$allowed_post_types   = \WPGraphQL::get_allowed_post_types();
							$allowed_post_types[] = 'revision';

							return absint( $post_id ) ? $context->get_loader( 'post' )->load_deferred( $post_id )->then(
								static function ( $post ) use ( $allowed_post_types ) {

									// if the post isn't an instance of a Post model, return
									if ( ! $post instanceof Post ) {
										return null;
									}

									if ( ! isset( $post->post_type ) || ! in_array( $post->post_type, $allowed_post_types, true ) ) {
										return null;
									}

									return $post;
								}
							) : null;
						},
					],
					'contentType' => [
						'type'        => 'ContentType',
						'description' => __( 'Fetch a Content Type node by unique Identifier', 'wp-graphql' ),
						'args'        => [
							'id'     => [
								'type'        => [ 'non_null' => 'ID' ],
								'description' => __( 'Unique Identifier for the Content Type node.', 'wp-graphql' ),
							],
							'idType' => [
								'type'        => 'ContentTypeIdTypeEnum',
								'description' => __( 'Type of unique identifier to fetch a content type by. Default is Global ID', 'wp-graphql' ),
							],
						],
						'resolve'     => static function ( $_root, $args, $context ) {
							$id_type = isset( $args['idType'] ) ? $args['idType'] : 'id';

							$id = null;
							switch ( $id_type ) {
								case 'name':
									$id = $args['id'];
									break;
								case 'id':
								default:
									$id_parts = Relay::fromGlobalId( $args['id'] );
									if ( isset( $id_parts['id'] ) ) {
										$id = $id_parts['id'];
									}
							}

							return ! empty( $id ) ? $context->get_loader( 'post_type' )->load_deferred( $id ) : null;
						},
					],
					'taxonomy'    => [
						'type'        => 'Taxonomy',
						'description' => __( 'Fetch a Taxonomy node by unique Identifier', 'wp-graphql' ),
						'args'        => [
							'id'     => [
								'type'        => [ 'non_null' => 'ID' ],
								'description' => __( 'Unique Identifier for the Taxonomy node.', 'wp-graphql' ),
							],
							'idType' => [
								'type'        => 'TaxonomyIdTypeEnum',
								'description' => __( 'Type of unique identifier to fetch a taxonomy by. Default is Global ID', 'wp-graphql' ),
							],
						],
						'resolve'     => static function ( $_root, $args, $context ) {
							$id_type = isset( $args['idType'] ) ? $args['idType'] : 'id';

							$id = null;
							switch ( $id_type ) {
								case 'name':
									$id = $args['id'];
									break;
								case 'id':
								default:
									$id_parts = Relay::fromGlobalId( $args['id'] );
									if ( isset( $id_parts['id'] ) ) {
										$id = $id_parts['id'];
									}
							}

							return ! empty( $id ) ? $context->get_loader( 'taxonomy' )->load_deferred( $id ) : null;
						},
					],
					'node'        => [
						'type'        => 'Node',
						'description' => __( 'Fetches an object given its ID', 'wp-graphql' ),
						'args'        => [
							'id' => [
								'type'        => 'ID',
								'description' => __( 'The unique identifier of the node', 'wp-graphql' ),
							],
						],
						'resolve'     => static function ( $root, $args, AppContext $context, ResolveInfo $info ) {
							return ! empty( $args['id'] ) ? DataSource::resolve_node( $args['id'], $context, $info ) : null;
						},
					],
					'nodeByUri'   => [
						'type'        => 'UniformResourceIdentifiable',
						'description' => __( 'Fetches an object given its Unique Resource Identifier', 'wp-graphql' ),
						'args'        => [
							'uri' => [
								'type'        => [ 'non_null' => 'String' ],
								'description' => __( 'Unique Resource Identifier in the form of a path or permalink for a node. Ex: "/hello-world"', 'wp-graphql' ),
							],
						],
						'resolve'     => static function ( $root, $args, AppContext $context ) {
							return ! empty( $args['uri'] ) ? $context->node_resolver->resolve_uri( $args['uri'] ) : null;
						},
					],
					'menu'        => [
						'type'        => 'Menu',
						'description' => __( 'A WordPress navigation menu', 'wp-graphql' ),
						'args'        => [
							'id'     => [
								'type'        => [
									'non_null' => 'ID',
								],
								'description' => __( 'The globally unique identifier of the menu.', 'wp-graphql' ),
							],
							'idType' => [
								'type'        => 'MenuNodeIdTypeEnum',
								'description' => __( 'Type of unique identifier to fetch a menu by. Default is Global ID', 'wp-graphql' ),
							],
						],
						'resolve'     => static function ( $source, array $args, AppContext $context ) {
							$id_type = isset( $args['idType'] ) ? $args['idType'] : 'id';

							switch ( $id_type ) {
								case 'database_id':
									$id = absint( $args['id'] );
									break;
								case 'location':
									$locations = get_nav_menu_locations();

									if ( ! isset( $locations[ $args['id'] ] ) || ! absint( $locations[ $args['id'] ] ) ) {
										throw new UserError( esc_html__( 'No menu set for the provided location', 'wp-graphql' ) );
									}

									$id = absint( $locations[ $args['id'] ] );
									break;
								case 'name':
									$menu = new \WP_Term_Query(
										[
											'taxonomy' => 'nav_menu',
											'fields'   => 'ids',
											'name'     => $args['id'],
											'include_children' => false,
											'count'    => false,
										]
									);
									$id   = ! empty( $menu->terms ) ? (int) $menu->terms[0] : null;
									break;
								case 'slug':
									$menu = new \WP_Term_Query(
										[
											'taxonomy' => 'nav_menu',
											'fields'   => 'ids',
											'slug'     => $args['id'],
											'include_children' => false,
											'count'    => false,
										]
									);
									$id   = ! empty( $menu->terms ) ? (int) $menu->terms[0] : null;
									break;
								default:
									$id_components = Relay::fromGlobalId( $args['id'] );
									if ( ! isset( $id_components['id'] ) || ! absint( $id_components['id'] ) ) {
										throw new UserError( esc_html__( 'The ID input is invalid', 'wp-graphql' ) );
									}
									$id = absint( $id_components['id'] );

									break;
							}

							return ! empty( $id ) ? $context->get_loader( 'term' )->load_deferred( absint( $id ) ) : null;
						},
					],
					'menuItem'    => [
						'type'        => 'MenuItem',
						'description' => __( 'A WordPress navigation menu item', 'wp-graphql' ),
						'args'        => [
							'id'     => [
								'type'        => [
									'non_null' => 'ID',
								],
								'description' => __( 'The globally unique identifier of the menu item.', 'wp-graphql' ),
							],
							'idType' => [
								'type'        => 'MenuItemNodeIdTypeEnum',
								'description' => __( 'Type of unique identifier to fetch a menu item by. Default is Global ID', 'wp-graphql' ),
							],
						],
						'resolve'     => static function ( $source, array $args, AppContext $context ) {
							$id_type = isset( $args['idType'] ) ? $args['idType'] : 'id';

							switch ( $id_type ) {
								case 'database_id':
									$id = absint( $args['id'] );
									break;
								default:
									$id_components = Relay::fromGlobalId( $args['id'] );
									if ( ! isset( $id_components['id'] ) || ! absint( $id_components['id'] ) ) {
										throw new UserError( esc_html__( 'The ID input is invalid', 'wp-graphql' ) );
									}
									$id = absint( $id_components['id'] );

									break;
							}

							return $context->get_loader( 'post' )->load_deferred( absint( $id ) );
						},
					],
					'plugin'      => [
						'type'        => 'Plugin',
						'description' => __( 'A WordPress plugin', 'wp-graphql' ),
						'args'        => [
							'id' => [
								'type'        => [
									'non_null' => 'ID',
								],
								'description' => __( 'The globally unique identifier of the plugin.', 'wp-graphql' ),
							],
						],
						'resolve'     => static function ( $source, array $args, AppContext $context ) {
							$id_components = Relay::fromGlobalId( $args['id'] );

							return ! empty( $id_components['id'] ) ? $context->get_loader( 'plugin' )->load_deferred( $id_components['id'] ) : null;
						},
					],
					'termNode'    => [
						'type'        => 'TermNode',
						'description' => __( 'A node in a taxonomy used to group and relate content nodes', 'wp-graphql' ),
						'args'        => [
							'id'       => [
								'type'        => [
									'non_null' => 'ID',
								],
								'description' => __( 'Unique identifier for the term node.', 'wp-graphql' ),
							],
							'idType'   => [
								'type'        => 'TermNodeIdTypeEnum',
								'description' => __( 'Type of unique identifier to fetch a term node by. Default is Global ID', 'wp-graphql' ),
							],
							'taxonomy' => [
								'type'        => 'TaxonomyEnum',
								'description' => __( 'The taxonomy of the tern node. Required when idType is set to "name" or "slug"', 'wp-graphql' ),
							],
						],
						'resolve'     => static function ( $root, $args, AppContext $context ) {
							$idType  = isset( $args['idType'] ) ? $args['idType'] : 'global_id';
							$term_id = null;

							switch ( $idType ) {
								case 'slug':
								case 'name':
								case 'database_id':
									$taxonomy = isset( $args['taxonomy'] ) ? $args['taxonomy'] : null;
									if ( empty( $taxonomy ) && in_array(
										$idType,
										[
											'name',
											'slug',
										],
										true
									) ) {
										throw new UserError( esc_html__( 'When fetching a Term Node by "slug" or "name", the "taxonomy" also needs to be set as an input.', 'wp-graphql' ) );
									}
									if ( 'database_id' === $idType ) {
										$term = get_term( absint( $args['id'] ) );
									} else {
										$term = get_term_by( $idType, $args['id'], $taxonomy );
									}
									$term_id = isset( $term->term_id ) ? absint( $term->term_id ) : null;

									break;
								case 'uri':
									return $context->node_resolver->resolve_uri(
										$args['id'],
										[
											'nodeType' => 'TermNode',
										]
									);
								case 'global_id':
								default:
									$id_components = Relay::fromGlobalId( $args['id'] );
									if ( ! isset( $id_components['id'] ) || ! absint( $id_components['id'] ) ) {
										throw new UserError( esc_html__( 'The ID input is invalid', 'wp-graphql' ) );
									}
									$term_id = absint( $id_components['id'] );
									break;
							}

							return ! empty( $term_id ) ? $context->get_loader( 'term' )->load_deferred( $term_id ) : null;
						},
					],
					'theme'       => [
						'type'        => 'Theme',
						'description' => __( 'A Theme object', 'wp-graphql' ),
						'args'        => [
							'id' => [
								'type'        => [
									'non_null' => 'ID',
								],
								'description' => __( 'The globally unique identifier of the theme.', 'wp-graphql' ),
							],
						],
						'resolve'     => static function ( $source, array $args ) {
							$id_components = Relay::fromGlobalId( $args['id'] );

							return DataSource::resolve_theme( $id_components['id'] );
						},
					],
					'user'        => [
						'type'        => 'User',
						'description' => __( 'Returns a user', 'wp-graphql' ),
						'args'        => [
							'id'     => [
								'type'        => [
									'non_null' => 'ID',
								],
								'description' => __( 'The globally unique identifier of the user.', 'wp-graphql' ),
							],
							'idType' => [
								'type'        => 'UserNodeIdTypeEnum',
								'description' => __( 'Type of unique identifier to fetch a user by. Default is Global ID', 'wp-graphql' ),
							],
						],
						'resolve'     => static function ( $source, array $args, $context ) {
							$idType = isset( $args['idType'] ) ? $args['idType'] : 'id';

							switch ( $idType ) {
								case 'database_id':
									$id = absint( $args['id'] );
									break;
								case 'uri':
									return $context->node_resolver->resolve_uri(
										$args['id'],
										[
											'nodeType' => 'User',
										]
									);
								case 'login':
									$current_user = wp_get_current_user();
									if ( $current_user->user_login !== $args['id'] ) {
										if ( ! current_user_can( 'list_users' ) ) {
											throw new UserError( esc_html__( 'You do not have permission to request a User by Username', 'wp-graphql' ) );
										}
									}

									$user = get_user_by( 'login', $args['id'] );
									$id   = isset( $user->ID ) ? $user->ID : null;
									break;
								case 'email':
									$current_user = wp_get_current_user();
									if ( $current_user->user_email !== $args['id'] ) {
										if ( ! current_user_can( 'list_users' ) ) {
											throw new UserError( esc_html__( 'You do not have permission to request a User by Email', 'wp-graphql' ) );
										}
									}

									$user = get_user_by( 'email', $args['id'] );
									$id   = isset( $user->ID ) ? $user->ID : null;
									break;
								case 'slug':
									$user = get_user_by( 'slug', $args['id'] );
									$id   = isset( $user->ID ) ? $user->ID : null;
									break;
								case 'id':
								default:
									$id_components = Relay::fromGlobalId( $args['id'] );
									$id            = absint( $id_components['id'] );
									break;
							}

							return ! empty( $id ) ? $context->get_loader( 'user' )->load_deferred( $id ) : null;
						},
					],
					'userRole'    => [
						'type'        => 'UserRole',
						'description' => __( 'Returns a user role', 'wp-graphql' ),
						'args'        => [
							'id' => [
								'type'        => [
									'non_null' => 'ID',
								],
								'description' => __( 'The globally unique identifier of the user object.', 'wp-graphql' ),
							],
						],
						'resolve'     => static function ( $source, array $args ) {
							$id_components = Relay::fromGlobalId( $args['id'] );

							return DataSource::resolve_user_role( $id_components['id'] );
						},
					],
					'viewer'      => [
						'type'        => 'User',
						'description' => __( 'Returns the current user', 'wp-graphql' ),
						'resolve'     => static function ( $source, array $args, AppContext $context ) {
							return ! empty( $context->viewer->ID ) ? $context->get_loader( 'user' )->load_deferred( $context->viewer->ID ) : null;
						},
					],
				],
			]
		);
	}

	/**
	 * Register RootQuery fields for Post Objects of supported post types
	 *
	 * @return void
	 */
	public static function register_post_object_fields() {
		/** @var \WP_Post_Type[] */
		$allowed_post_types = \WPGraphQL::get_allowed_post_types( 'objects', [ 'graphql_register_root_field' => true ] );

		foreach ( $allowed_post_types as $post_type_object ) {
			register_graphql_field(
				'RootQuery',
				$post_type_object->graphql_single_name,
				[
					'type'        => $post_type_object->graphql_single_name,
					'description' => sprintf(
						// translators: %1$s is the post type GraphQL name, %2$s is the post type description
						__( 'An object of the %1$s Type. %2$s', 'wp-graphql' ),
						$post_type_object->graphql_single_name,
						$post_type_object->description
					),
					'args'        => [
						'id'        => [
							'type'        => [
								'non_null' => 'ID',
							],
							'description' => __( 'The globally unique identifier of the object.', 'wp-graphql' ),
						],
						'idType'    => [
							'type'        => $post_type_object->graphql_single_name . 'IdType',
							'description' => __( 'Type of unique identifier to fetch by. Default is Global ID', 'wp-graphql' ),
						],
						'asPreview' => [
							'type'        => 'Boolean',
							'description' => __( 'Whether to return the Preview Node instead of the Published Node. When the ID of a Node is provided along with asPreview being set to true, the preview node with un-published changes will be returned instead of the published node. If no preview node exists or the requester doesn\'t have proper capabilities to preview, no node will be returned. If the ID provided is a URI and has a preview query arg, it will be used as a fallback if the "asPreview" argument is not explicitly provided as an argument.', 'wp-graphql' ),
						],
					],
					'resolve'     => static function ( $source, array $args, AppContext $context ) use ( $post_type_object ) {
						$idType  = isset( $args['idType'] ) ? $args['idType'] : 'global_id';
						$post_id = null;
						switch ( $idType ) {
							case 'slug':
								return $context->node_resolver->resolve_uri(
									$args['id'],
									[
										'name'      => $args['id'],
										'post_type' => $post_type_object->name,
										'nodeType'  => 'ContentNode',
										'asPreview' => $args['asPreview'] ?? null,
									]
								);
							case 'uri':
								return $context->node_resolver->resolve_uri(
									$args['id'],
									[
										'post_type' => $post_type_object->name,
										'archive'   => false,
										'nodeType'  => 'ContentNode',
										'asPreview' => $args['asPreview'] ?? null,
									]
								);
							case 'database_id':
								$post_id = absint( $args['id'] );
								break;
							case 'source_url':
								$url     = $args['id'];
								$post_id = attachment_url_to_postid( $url ); // phpcs:ignore WordPressVIPMinimum.Functions.RestrictedFunctions.attachment_url_to_postid_attachment_url_to_postid
								if ( empty( $post_id ) ) {
									return null;
								}
								$post_id = absint( attachment_url_to_postid( $url ) ); // phpcs:ignore WordPressVIPMinimum.Functions.RestrictedFunctions.attachment_url_to_postid_attachment_url_to_postid
								break;
							case 'global_id':
							default:
								$id_components = Relay::fromGlobalId( $args['id'] );
								if ( ! isset( $id_components['id'] ) || ! absint( $id_components['id'] ) ) {
									throw new UserError( esc_html__( 'The ID input is invalid. Make sure you set the proper idType for your input.', 'wp-graphql' ) );
								}
								$post_id = absint( $id_components['id'] );
								break;
						}

						if ( isset( $args['asPreview'] ) && true === $args['asPreview'] ) {
							$post_id = Utils::get_post_preview_id( $post_id );
						}

						return absint( $post_id ) ? $context->get_loader( 'post' )->load_deferred( $post_id )->then(
							static function ( $post ) use ( $post_type_object ) {

								// if the post isn't an instance of a Post model, return
								if ( ! $post instanceof Post ) {
									return null;
								}

								if ( ! isset( $post->post_type ) || ! in_array(
									$post->post_type,
									[
										'revision',
										$post_type_object->name,
									],
									true
								) ) {
									return null;
								}

								return $post;
							}
						) : null;
					},
				]
			);
			$post_by_args = [
				'id'  => [
					'type'        => 'ID',
					'description' => sprintf(
						// translators: %s is the post type's GraphQL name.
						__( 'Get the %s object by its global ID', 'wp-graphql' ),
						$post_type_object->graphql_single_name
					),
				],
				$post_type_object->graphql_single_name . 'Id' => [
					'type'        => 'Int',
					'description' => sprintf(
						// translators: %s is the post type's GraphQL name.
						__( 'Get the %s by its database ID', 'wp-graphql' ),
						$post_type_object->graphql_single_name
					),
				],
				'uri' => [
					'type'        => 'String',
					'description' => sprintf(
						// translators: %s is the post type's GraphQL name.
						__( 'Get the %s by its uri', 'wp-graphql' ),
						$post_type_object->graphql_single_name
					),
				],
			];
			if ( false === $post_type_object->hierarchical ) {
				$post_by_args['slug'] = [
					'type'        => 'String',
					'description' => sprintf(
						// translators: %s is the post type's GraphQL name.
						__( 'Get the %s by its slug (only available for non-hierarchical types)', 'wp-graphql' ),
						$post_type_object->graphql_single_name
					),
				];
			}

			/**
			 * @deprecated Deprecated in favor of single node entry points
			 */
			register_graphql_field(
				'RootQuery',
				$post_type_object->graphql_single_name . 'By',
				[
					'type'              => $post_type_object->graphql_single_name,
					'deprecationReason' => __( 'Deprecated in favor of using the single entry point for this type with ID and IDType fields. For example, instead of postBy( id: "" ), use post(id: "" idType: "")', 'wp-graphql' ),
					'description'       => sprintf(
						// translators: %s is the post type's GraphQL name.
						__( 'A %s object', 'wp-graphql' ),
						$post_type_object->graphql_single_name
					),
					'args'              => $post_by_args,
					'resolve'           => static function ( $source, array $args, $context ) use ( $post_type_object ) {
						$post_id = 0;

						if ( ! empty( $args['id'] ) ) {
							$id_components = Relay::fromGlobalId( $args['id'] );
							if ( empty( $id_components['id'] ) || empty( $id_components['type'] ) ) {
								throw new UserError( esc_html__( 'The "id" is invalid', 'wp-graphql' ) );
							}
							$post_id = absint( $id_components['id'] );
						} elseif ( ! empty( $args[ lcfirst( $post_type_object->graphql_single_name . 'Id' ) ] ) ) {
							$id      = $args[ lcfirst( $post_type_object->graphql_single_name . 'Id' ) ];
							$post_id = absint( $id );
						} elseif ( ! empty( $args['uri'] ) ) {
							return $context->node_resolver->resolve_uri(
								$args['uri'],
								[
									'post_type' => $post_type_object->name,
									'archive'   => false,
									'nodeType'  => 'ContentNode',
								]
							);
						} elseif ( ! empty( $args['slug'] ) ) {
							$slug = esc_html( $args['slug'] );

							return $context->node_resolver->resolve_uri(
								$slug,
								[
									'name'      => $slug,
									'post_type' => $post_type_object->name,
									'nodeType'  => 'ContentNode',
								]
							);
						}

						return $context->get_loader( 'post' )->load_deferred( $post_id )->then(
							static function ( $post ) use ( $post_type_object ) {

								// if the post type object isn't an instance of WP_Post_Type, return
								if ( ! $post_type_object instanceof \WP_Post_Type ) {
									return null;
								}

								// if the post isn't an instance of a Post model, return
								if ( ! $post instanceof Post ) {
									return null;
								}

								if ( ! isset( $post->post_type ) || ! in_array(
									$post->post_type,
									[
										'revision',
										$post_type_object->name,
									],
									true
								) ) {
									return null;
								}

								return $post;
							}
						);
					},
				]
			);
		}
	}

	/**
	 * Register RootQuery fields for Term Objects of supported taxonomies
	 *
	 * @return void
	 */
	public static function register_term_object_fields() {
		/** @var \WP_Taxonomy[] $allowed_taxonomies */
		$allowed_taxonomies = \WPGraphQL::get_allowed_taxonomies( 'objects', [ 'graphql_register_root_field' => true ] );

		foreach ( $allowed_taxonomies as $tax_object ) {
			register_graphql_field(
				'RootQuery',
				$tax_object->graphql_single_name,
				[
					'type'        => $tax_object->graphql_single_name,
					'description' => sprintf(
						// translators: %s is the taxonomys' GraphQL name.
						__( 'A % object', 'wp-graphql' ),
						$tax_object->graphql_single_name
					),
					'args'        => [
						'id'     => [
							'type'        => [
								'non_null' => 'ID',
							],
							'description' => __( 'The globally unique identifier of the object.', 'wp-graphql' ),
						],
						'idType' => [
							'type'        => $tax_object->graphql_single_name . 'IdType',
							'description' => __( 'Type of unique identifier to fetch by. Default is Global ID', 'wp-graphql' ),
						],
					],
					'resolve'     => static function ( $_source, array $args, $context ) use ( $tax_object ) {
						$idType  = isset( $args['idType'] ) ? $args['idType'] : 'global_id';
						$term_id = null;

						switch ( $idType ) {
							case 'slug':
							case 'name':
							case 'database_id':
								if ( 'database_id' === $idType ) {
									$idType = 'id';
								}
								$term    = get_term_by( $idType, $args['id'], $tax_object->name );
								$term_id = isset( $term->term_id ) ? absint( $term->term_id ) : null;
								break;
							case 'uri':
								return $context->node_resolver->resolve_uri(
									$args['id'],
									[
										'nodeType' => 'TermNode',
										'taxonomy' => $tax_object->name,
									]
								);
							case 'global_id':
							default:
								$id_components = Relay::fromGlobalId( $args['id'] );
								if ( ! isset( $id_components['id'] ) || ! absint( $id_components['id'] ) ) {
									throw new UserError( esc_html__( 'The ID input is invalid', 'wp-graphql' ) );
								}
								$term_id = absint( $id_components['id'] );
								break;
						}

						return ! empty( $term_id ) ? $context->get_loader( 'term' )->load_deferred( (int) $term_id ) : null;
					},
				]
			);
		}
	}
}


// File: wp-graphql\src\Type\ObjectType\SettingGroup.php
<?php

namespace WPGraphQL\Type\ObjectType;

use GraphQL\Error\UserError;
use WPGraphQL\Data\DataSource;
use WPGraphQL\Registry\TypeRegistry;

class SettingGroup {

	/**
	 * Register each settings group to the GraphQL Schema
	 *
	 * @param string                           $group_name    The name of the setting group
	 * @param string                           $group         The settings group config
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry The WPGraphQL TypeRegistry
	 *
	 * @return string|null
	 * @throws \Exception
	 */
	public static function register_settings_group( string $group_name, string $group, TypeRegistry $type_registry ) {
		$fields = self::get_settings_group_fields( $group_name, $group, $type_registry );

		// if the settings group doesn't have any fields that
		// will map to the WPGraphQL Schema,
		// don't register the settings group Type to the schema
		if ( empty( $fields ) ) {
			return null;
		}

		register_graphql_object_type(
			ucfirst( $group_name ) . 'Settings',
			[
				// translators: %s is the name of the setting group.
				'description' => sprintf( __( 'The %s setting type', 'wp-graphql' ), $group_name ),
				'fields'      => $fields,
			]
		);

		return ucfirst( $group_name ) . 'Settings';
	}

	/**
	 * Given the name of a registered settings group, retrieve GraphQL fields for the group
	 *
	 * @param string                           $group_name Name of the settings group to retrieve fields for
	 * @param string                           $group      The settings group config
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry The WPGraphQL TypeRegistry
	 *
	 * @return array<string,array<string,mixed>>|null
	 */
	public static function get_settings_group_fields( string $group_name, string $group, TypeRegistry $type_registry ) {
		$setting_fields = DataSource::get_setting_group_fields( $group, $type_registry );
		$fields         = [];

		if ( ! empty( $setting_fields ) && is_array( $setting_fields ) ) {
			foreach ( $setting_fields as $key => $setting_field ) {
				if ( ! isset( $setting_field['type'] ) || ! $type_registry->get_type( $setting_field['type'] ) ) {
					continue;
				}

				/**
				 * Determine if the individual setting already has a
				 * REST API name, if not use the option name.
				 * Then, sanitize the field name to be camelcase
				 */
				if ( ! empty( $setting_field['show_in_rest']['name'] ) ) {
					$field_key = $setting_field['show_in_rest']['name'];
				} else {
					$field_key = $key;
				}

				$field_key = graphql_format_name( $field_key, ' ', '/[^a-zA-Z0-9 -]/' );
				$field_key = lcfirst( str_replace( '_', ' ', ucwords( $field_key, '_' ) ) );
				$field_key = lcfirst( str_replace( '-', ' ', ucwords( $field_key, '_' ) ) );
				$field_key = lcfirst( str_replace( ' ', '', ucwords( $field_key, ' ' ) ) );

				if ( ! empty( $key ) && ! empty( $field_key ) ) {

					/**
					 * Dynamically build the individual setting and it's fields
					 * then add it to the fields array
					 */
					$fields[ $field_key ] = [
						'type'        => $type_registry->get_type( $setting_field['type'] ),
						// translators: %s is the name of the setting group.
						'description' => isset( $setting_field['description'] ) && ! empty( $setting_field['description'] ) ? $setting_field['description'] : sprintf( __( 'The %s Settings Group', 'wp-graphql' ), $setting_field['type'] ),
						'resolve'     => static function () use ( $setting_field ) {

							/**
							 * Check to see if the user querying the email field has the 'manage_options' capability
							 * All other options should be public by default
							 */
							if ( 'admin_email' === $setting_field['key'] ) {
								if ( ! current_user_can( 'manage_options' ) ) {
									throw new UserError( esc_html__( 'Sorry, you do not have permission to view this setting.', 'wp-graphql' ) );
								}
							}

							$option = ! empty( $setting_field['key'] ) ? get_option( $setting_field['key'] ) : null;

							switch ( $setting_field['type'] ) {
								case 'integer':
								case 'int':
									return absint( $option );
								case 'string':
									return (string) $option;
								case 'boolean':
								case 'bool':
									return (bool) $option;
								case 'number':
								case 'float':
									return (float) $option;
							}

							return ! empty( $option ) ? $option : null;
						},
					];
				}
			}
		}

		return $fields;
	}
}


// File: wp-graphql\src\Type\ObjectType\Settings.php
<?php

namespace WPGraphQL\Type\ObjectType;

use GraphQL\Error\UserError;
use WPGraphQL\Data\DataSource;
use WPGraphQL\Registry\TypeRegistry;

/**
 * Class Settings
 *
 * @package WPGraphQL\Type\Object
 */
class Settings {

	/**
	 * Registers a Settings Type with fields for all settings based on settings
	 * registered using the core register_setting API
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry The WPGraphQL TypeRegistry
	 *
	 * @return void
	 */
	public static function register_type( TypeRegistry $type_registry ) {
		$fields = self::get_fields( $type_registry );

		if ( empty( $fields ) ) {
			return;
		}

		register_graphql_object_type(
			'Settings',
			[
				'description' => __( 'All of the registered settings', 'wp-graphql' ),
				'fields'      => $fields,
			]
		);
	}

	/**
	 * Returns an array of fields for all settings based on the `register_setting` WordPress API
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry The WPGraphQL TypeRegistry
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_fields( TypeRegistry $type_registry ) {
		$registered_settings = DataSource::get_allowed_settings( $type_registry );
		$fields              = [];

		if ( ! empty( $registered_settings ) && is_array( $registered_settings ) ) {

			/**
			 * Loop through the $settings_array and build thevar
			 * setting with
			 * proper fields
			 */
			foreach ( $registered_settings as $key => $setting_field ) {
				if ( ! isset( $setting_field['type'] ) || ! $type_registry->get_type( $setting_field['type'] ) ) {
					continue;
				}

				/**
				 * Determine if the individual setting already has a
				 * REST API name, if not use the option name.
				 * Then, sanitize the field name to be camelcase
				 */
				if ( ! empty( $setting_field['show_in_rest']['name'] ) ) {
					$field_key = $setting_field['show_in_rest']['name'];
				} else {
					$field_key = $key;
				}

				$group = DataSource::format_group_name( $setting_field['group'] );

				$field_key = lcfirst( graphql_format_name( $field_key, ' ', '/[^a-zA-Z0-9 -]/' ) );
				$field_key = lcfirst( str_replace( '_', ' ', ucwords( $field_key, '_' ) ) );
				$field_key = lcfirst( str_replace( '-', ' ', ucwords( $field_key, '_' ) ) );
				$field_key = lcfirst( str_replace( ' ', '', ucwords( $field_key, ' ' ) ) );

				$field_key = $group . 'Settings' . ucfirst( $field_key );

				if ( ! empty( $key ) ) {

					/**
					 * Dynamically build the individual setting and it's fields
					 * then add it to $fields
					 */
					$fields[ $field_key ] = [
						'type'        => $setting_field['type'],
						// translators: %s is the name of the setting group.
						'description' => sprintf( __( 'Settings of the the %s Settings Group', 'wp-graphql' ), $setting_field['type'] ),
						'resolve'     => static function () use ( $setting_field, $key ) {
							/**
							 * Check to see if the user querying the email field has the 'manage_options' capability
							 * All other options should be public by default
							 */
							if ( 'admin_email' === $key && ! current_user_can( 'manage_options' ) ) {
								throw new UserError( esc_html__( 'Sorry, you do not have permission to view this setting.', 'wp-graphql' ) );
							}

							$option = get_option( (string) $key );

							switch ( $setting_field['type'] ) {
								case 'integer':
									$option = absint( $option );
									break;
								case 'string':
									$option = ! empty( $option ) ? (string) $option : '';
									break;
								case 'boolean':
									$option = (bool) $option;
									break;
								case 'number':
									$option = (float) $option;
									break;
							}

							return isset( $option ) ? $option : null;
						},
					];
				}
			}
		}

		return $fields;
	}
}


// File: wp-graphql\src\Type\ObjectType\Taxonomy.php
<?php

namespace WPGraphQL\Type\ObjectType;

use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;
use WPGraphQL\Data\Connection\ContentTypeConnectionResolver;
use WPGraphQL\Data\Connection\TermObjectConnectionResolver;
use WPGraphQL\Model\Taxonomy as TaxonomyModel;

class Taxonomy {

	/**
	 * Register the Taxonomy type to the GraphQL Schema
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_object_type(
			'Taxonomy',
			[
				'description' => __( 'A taxonomy object', 'wp-graphql' ),
				'interfaces'  => [ 'Node' ],
				'model'       => TaxonomyModel::class,
				'connections' => [
					'connectedContentTypes' => [
						'toType'      => 'ContentType',
						'description' => __( 'List of Content Types associated with the Taxonomy', 'wp-graphql' ),
						'resolve'     => static function ( TaxonomyModel $taxonomy, $args, AppContext $context, ResolveInfo $info ) {
							$connected_post_types = ! empty( $taxonomy->object_type ) ? $taxonomy->object_type : [];
							$resolver             = new ContentTypeConnectionResolver( $taxonomy, $args, $context, $info );
							$resolver->set_query_arg( 'contentTypeNames', $connected_post_types );
							return $resolver->get_connection();
						},
					],
					'connectedTerms'        => [
						'toType'               => 'TermNode',
						'connectionInterfaces' => [ 'TermNodeConnection' ],
						'description'          => __( 'List of Term Nodes associated with the Taxonomy', 'wp-graphql' ),
						'resolve'              => static function ( TaxonomyModel $source, $args, AppContext $context, ResolveInfo $info ) {
							$taxonomies = [ $source->name ];

							$resolver = new TermObjectConnectionResolver( $source, $args, $context, $info, $taxonomies );

							return $resolver->get_connection();
						},
					],
				],
				'fields'      => [
					'id'                  => [
						'description' => __( 'The globally unique identifier of the taxonomy object.', 'wp-graphql' ),
					],
					'name'                => [
						'type'        => 'String',
						'description' => __( 'The display name of the taxonomy. This field is equivalent to WP_Taxonomy->label', 'wp-graphql' ),
					],
					'label'               => [
						'type'        => 'String',
						'description' => __( 'Name of the taxonomy shown in the menu. Usually plural.', 'wp-graphql' ),
					],
					// @todo: add "labels" field
					'description'         => [
						'type'        => 'String',
						'description' => __( 'Description of the taxonomy. This field is equivalent to WP_Taxonomy->description', 'wp-graphql' ),
					],
					'public'              => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the taxonomy is publicly queryable', 'wp-graphql' ),
					],
					'isRestricted'        => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the object is restricted from the current viewer', 'wp-graphql' ),
					],
					'hierarchical'        => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the taxonomy is hierarchical', 'wp-graphql' ),
					],
					'showUi'              => [
						'type'        => 'Boolean',
						'description' => __( 'Whether to generate and allow a UI for managing terms in this taxonomy in the admin', 'wp-graphql' ),
					],
					'showInMenu'          => [
						'type'        => 'Boolean',
						'description' => __( 'Whether to show the taxonomy in the admin menu', 'wp-graphql' ),
					],
					'showInNavMenus'      => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the taxonomy is available for selection in navigation menus.', 'wp-graphql' ),
					],
					'showCloud'           => [
						'type'        => 'Boolean',
						'description' => __( 'Whether to show the taxonomy as part of a tag cloud widget. This field is equivalent to WP_Taxonomy->show_tagcloud', 'wp-graphql' ),
					],
					'showInQuickEdit'     => [
						'type'        => 'Boolean',
						'description' => __( 'Whether to show the taxonomy in the quick/bulk edit panel.', 'wp-graphql' ),
					],
					'showInAdminColumn'   => [
						'type'        => 'Boolean',
						'description' => __( 'Whether to display a column for the taxonomy on its post type listing screens.', 'wp-graphql' ),
					],
					'showInRest'          => [
						'type'        => 'Boolean',
						'description' => __( 'Whether to add the post type route in the REST API "wp/v2" namespace.', 'wp-graphql' ),
					],
					'restBase'            => [
						'type'        => 'String',
						'description' => __( 'Name of content type to display in REST API "wp/v2" namespace.', 'wp-graphql' ),
					],
					'restControllerClass' => [
						'type'        => 'String',
						'description' => __( 'The REST Controller class assigned to handling this content type.', 'wp-graphql' ),
					],
					'showInGraphql'       => [
						'type'        => 'Boolean',
						'description' => __( 'Whether to add the post type to the GraphQL Schema.', 'wp-graphql' ),
					],
					'graphqlSingleName'   => [
						'type'        => 'String',
						'description' => __( 'The singular name of the post type within the GraphQL Schema.', 'wp-graphql' ),
					],
					'graphqlPluralName'   => [
						'type'        => 'String',
						'description' => __( 'The plural name of the post type within the GraphQL Schema.', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\ObjectType\TermObject.php
<?php

namespace WPGraphQL\Type\ObjectType;

use WP_Taxonomy;

/**
 * Class TermObject
 *
 * @package WPGraphQL\Type\Object
 * @deprecated 1.12.0
 */
class TermObject {

	/**
	 * Register the Type for each kind of Taxonomy
	 *
	 * @param \WP_Taxonomy $tax_object The taxonomy being registered
	 *
	 * @return void
	 * @throws \Exception
	 * @deprecated 1.12.0
	 */
	public static function register_taxonomy_object_type( WP_Taxonomy $tax_object ) {
		_deprecated_function( __FUNCTION__, '1.12.0', esc_attr( \WPGraphQL\Registry\Utils\TermObject::class ) . '::register_types()' );

		\WPGraphQL\Registry\Utils\TermObject::register_types( $tax_object );
	}
}


// File: wp-graphql\src\Type\ObjectType\Theme.php
<?php

namespace WPGraphQL\Type\ObjectType;

use WPGraphQL\Model\Theme as ThemeModel;

/**
 * Class Theme
 *
 * @package WPGraphQL\Type\Object
 */
class Theme {

	/**
	 * Register the Theme Type
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_object_type(
			'Theme',
			[
				'description' => __( 'A theme object', 'wp-graphql' ),
				'interfaces'  => [ 'Node' ],
				'model'       => ThemeModel::class,
				'fields'      => [
					'id'           => [
						'description' => __( 'The globally unique identifier of the theme object.', 'wp-graphql' ),
					],
					'slug'         => [
						'type'        => 'String',
						'description' => __( 'The theme slug is used to internally match themes. Theme slugs can have subdirectories like: my-theme/sub-theme. This field is equivalent to WP_Theme->get_stylesheet().', 'wp-graphql' ),
					],
					'name'         => [
						'type'        => 'String',
						'description' => __( 'Display name of the theme. This field is equivalent to WP_Theme->get( "Name" ).', 'wp-graphql' ),
					],
					'screenshot'   => [
						'type'        => 'String',
						'description' => __( 'The URL of the screenshot for the theme. The screenshot is intended to give an overview of what the theme looks like. This field is equivalent to WP_Theme->get_screenshot().', 'wp-graphql' ),
					],
					'themeUri'     => [
						'type'        => 'String',
						'description' => __( 'A URI if the theme has a website associated with it. The Theme URI is handy for directing users to a theme site for support etc. This field is equivalent to WP_Theme->get( "ThemeURI" ).', 'wp-graphql' ),
					],
					'description'  => [
						'type'        => 'String',
						'description' => __( 'The description of the theme. This field is equivalent to WP_Theme->get( "Description" ).', 'wp-graphql' ),
					],
					'author'       => [
						'type'        => 'String',
						'description' => __( 'Name of the theme author(s), could also be a company name. This field is equivalent to WP_Theme->get( "Author" ).', 'wp-graphql' ),
					],
					'authorUri'    => [
						'type'        => 'String',
						'description' => __( 'URI for the author/company website. This field is equivalent to WP_Theme->get( "AuthorURI" ).', 'wp-graphql' ),
					],
					'tags'         => [
						'type'        => [
							'list_of' => 'String',
						],
						'description' => __( 'URI for the author/company website. This field is equivalent to WP_Theme->get( "Tags" ).', 'wp-graphql' ),
					],
					'version'      => [
						'type'        => 'String',
						'description' => __( 'The current version of the theme. This field is equivalent to WP_Theme->get( "Version" ).', 'wp-graphql' ),
					],
					'isRestricted' => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the object is restricted from the current viewer', 'wp-graphql' ),
					],
				],

			]
		);
	}
}


// File: wp-graphql\src\Type\ObjectType\User.php
<?php

namespace WPGraphQL\Type\ObjectType;

use WPGraphQL\Data\Connection\EnqueuedScriptsConnectionResolver;
use WPGraphQL\Data\Connection\EnqueuedStylesheetConnectionResolver;
use WPGraphQL\Data\Connection\PostObjectConnectionResolver;
use WPGraphQL\Data\Connection\UserRoleConnectionResolver;
use WPGraphQL\Data\DataSource;
use WPGraphQL\Model\User as UserModel;
use WPGraphQL\Type\Connection\PostObjects;

/**
 * Class User
 *
 * @package WPGraphQL\Type\Object
 */
class User {

	/**
	 * Registers the User type
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_object_type(
			'User',
			[
				'description' => __( 'A User object', 'wp-graphql' ),
				'model'       => UserModel::class,
				'interfaces'  => [ 'Node', 'UniformResourceIdentifiable', 'Commenter', 'DatabaseIdentifier' ],
				'connections' => [
					'enqueuedScripts'     => [
						'toType'  => 'EnqueuedScript',
						'resolve' => static function ( $source, $args, $context, $info ) {
							$resolver = new EnqueuedScriptsConnectionResolver( $source, $args, $context, $info );

							return $resolver->get_connection();
						},
					],
					'enqueuedStylesheets' => [
						'toType'  => 'EnqueuedStylesheet',
						'resolve' => static function ( $source, $args, $context, $info ) {
							$resolver = new EnqueuedStylesheetConnectionResolver( $source, $args, $context, $info );

							return $resolver->get_connection();
						},
					],
					'revisions'           => [
						'toType'             => 'ContentNode',
						'connectionTypeName' => 'UserToRevisionsConnection',
						'queryClass'         => 'WP_Query',
						'description'        => __( 'Connection between the User and Revisions authored by the user', 'wp-graphql' ),
						'connectionArgs'     => PostObjects::get_connection_args(),
						'resolve'            => static function ( $root, $args, $context, $info ) {
							$resolver = new PostObjectConnectionResolver( $root, $args, $context, $info, 'revision' );

							return $resolver->get_connection();
						},
					],
					'roles'               => [
						'toType'        => 'UserRole',
						'fromFieldName' => 'roles',
						'resolve'       => static function ( UserModel $user, $args, $context, $info ) {
							$resolver = new UserRoleConnectionResolver( $user, $args, $context, $info );

							// abort if no roles are set
							if ( empty( $user->roles ) ) {
								return null;
							}

							// Only get roles matching the slugs of the roles belonging to the user
							$resolver->set_query_arg( 'slugIn', $user->roles );
							return $resolver->get_connection();
						},
					],
				],
				'fields'      => [
					'id'                     => [
						'description' => __( 'The globally unique identifier for the user object.', 'wp-graphql' ),
					],
					'databaseId'             => [
						'type'        => [ 'non_null' => 'Int' ],
						'description' => __( 'Identifies the primary key from the database.', 'wp-graphql' ),
						'resolve'     => static function ( \WPGraphQL\Model\User $user ) {
							return absint( $user->userId );
						},
					],
					'capabilities'           => [
						'type'        => [
							'list_of' => 'String',
						],
						'description' => __( 'A list of capabilities (permissions) granted to the user', 'wp-graphql' ),
					],
					'capKey'                 => [
						'type'        => 'String',
						'description' => __( 'User metadata option name. Usually it will be "wp_capabilities".', 'wp-graphql' ),
					],
					'email'                  => [
						'type'        => 'String',
						'description' => __( 'Email address of the user. This is equivalent to the WP_User->user_email property.', 'wp-graphql' ),
					],
					'firstName'              => [
						'type'        => 'String',
						'description' => __( 'First name of the user. This is equivalent to the WP_User->user_first_name property.', 'wp-graphql' ),
					],
					'lastName'               => [
						'type'        => 'String',
						'description' => __( 'Last name of the user. This is equivalent to the WP_User->user_last_name property.', 'wp-graphql' ),
					],
					'extraCapabilities'      => [
						'type'        => [
							'list_of' => 'String',
						],
						'description' => __( 'A complete list of capabilities including capabilities inherited from a role. This is equivalent to the array keys of WP_User->allcaps.', 'wp-graphql' ),
					],
					'description'            => [
						'type'        => 'String',
						'description' => __( 'Description of the user.', 'wp-graphql' ),
					],
					'username'               => [
						'type'        => 'String',
						'description' => __( 'Username for the user. This field is equivalent to WP_User->user_login.', 'wp-graphql' ),
					],
					'name'                   => [
						'type'        => 'String',
						'description' => __( 'Display name of the user. This is equivalent to the WP_User->display_name property.', 'wp-graphql' ),
					],
					'registeredDate'         => [
						'type'        => 'String',
						'description' => __( 'The date the user registered or was created. The field follows a full ISO8601 date string format.', 'wp-graphql' ),
					],
					'nickname'               => [
						'type'        => 'String',
						'description' => __( 'Nickname of the user.', 'wp-graphql' ),
					],
					'url'                    => [
						'type'        => 'String',
						'description' => __( 'A website url that is associated with the user.', 'wp-graphql' ),
					],
					'slug'                   => [
						'type'        => 'String',
						'description' => __( 'The slug for the user. This field is equivalent to WP_User->user_nicename', 'wp-graphql' ),
					],
					'nicename'               => [
						'type'        => 'String',
						'description' => __( 'The nicename for the user. This field is equivalent to WP_User->user_nicename', 'wp-graphql' ),
					],
					'locale'                 => [
						'type'        => 'String',
						'description' => __( 'The preferred language locale set for the user. Value derived from get_user_locale().', 'wp-graphql' ),
					],
					'userId'                 => [
						'type'              => 'Int',
						'description'       => __( 'The Id of the user. Equivalent to WP_User->ID', 'wp-graphql' ),
						'deprecationReason' => __( 'Deprecated in favor of the databaseId field', 'wp-graphql' ),
					],
					'isRestricted'           => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the object is restricted from the current viewer', 'wp-graphql' ),
					],
					'shouldShowAdminToolbar' => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the Toolbar should be displayed when the user is viewing the site.', 'wp-graphql' ),
					],
					'avatar'                 => [
						'args'    => [
							'size'         => [
								'type'         => 'Int',
								'description'  => __( 'The size attribute of the avatar field can be used to fetch avatars of different sizes. The value corresponds to the dimension in pixels to fetch. The default is 96 pixels.', 'wp-graphql' ),
								'defaultValue' => 96,
							],
							'forceDefault' => [
								'type'        => 'Boolean',
								'description' => __( 'Whether to always show the default image, never the Gravatar. Default false', 'wp-graphql' ),
							],
							'rating'       => [
								'type'        => 'AvatarRatingEnum',
								'description' => __( 'The rating level of the avatar.', 'wp-graphql' ),
							],

						],
						'resolve' => static function ( $user, $args ) {
							$avatar_args = [];
							if ( is_numeric( $args['size'] ) ) {
								$avatar_args['size'] = absint( $args['size'] );
								if ( ! $avatar_args['size'] ) {
									$avatar_args['size'] = 96;
								}
							}

							if ( ! empty( $args['forceDefault'] ) && true === $args['forceDefault'] ) {
								$avatar_args['force_default'] = true;
							}

							if ( ! empty( $args['rating'] ) ) {
								$avatar_args['rating'] = esc_sql( $args['rating'] );
							}

							return DataSource::resolve_avatar( $user->userId, $avatar_args );
						},
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\ObjectType\UserRole.php
<?php

namespace WPGraphQL\Type\ObjectType;

use WPGraphQL\Model\UserRole as UserRoleModel;

class UserRole {

	/**
	 * Register the UserRole Type
	 *
	 * @return void
	 */
	public static function register_type() {
		register_graphql_object_type(
			'UserRole',
			[
				'description' => __( 'A user role object', 'wp-graphql' ),
				'model'       => UserRoleModel::class,
				'interfaces'  => [ 'Node' ],
				'fields'      => [
					'id'           => [
						'description' => __( 'The globally unique identifier for the user role object.', 'wp-graphql' ),
					],
					'name'         => [
						'type'        => 'String',
						'description' => __( 'The registered name of the role', 'wp-graphql' ),
					],
					'capabilities' => [
						'type'        => [
							'list_of' => 'String',
						],
						'description' => __( 'The capabilities that belong to this role', 'wp-graphql' ),
					],
					'displayName'  => [
						'type'        => 'String',
						'description' => __( 'The display name of the role', 'wp-graphql' ),
					],
					'isRestricted' => [
						'type'        => 'Boolean',
						'description' => __( 'Whether the object is restricted from the current viewer', 'wp-graphql' ),
					],
				],
			]
		);
	}
}


// File: wp-graphql\src\Type\Union\MenuItemObjectUnion.php
<?php

namespace WPGraphQL\Type\Union;

use WPGraphQL\Model\Post;
use WPGraphQL\Model\Term;
use WPGraphQL\Registry\TypeRegistry;

/**
 * Class MenuItemObjectUnion
 *
 * @package WPGraphQL\Type\Union
 * @deprecated
 */
class MenuItemObjectUnion {

	/**
	 * Registers the Type
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @return void
	 * @throws \Exception
	 */
	public static function register_type( TypeRegistry $type_registry ) {
		register_graphql_union_type(
			'MenuItemObjectUnion',
			[
				'typeNames'   => self::get_possible_types(),
				'description' => __( 'Deprecated in favor of MenuItemLinkeable Interface', 'wp-graphql' ),
				'resolveType' => static function ( $obj ) use ( $type_registry ) {
					_doing_it_wrong( 'MenuItemObjectUnion', esc_attr__( 'The MenuItemObjectUnion GraphQL type is deprecated in favor of MenuItemLinkeable Interface', 'wp-graphql' ), '0.10.3' );
					// Post object
					if ( $obj instanceof Post && isset( $obj->post_type ) && ! empty( $obj->post_type ) ) {
						/** @var \WP_Post_Type $post_type_object */
						$post_type_object = get_post_type_object( $obj->post_type );

						return $type_registry->get_type( $post_type_object->graphql_single_name );
					}

					// Taxonomy term
					if ( $obj instanceof Term && ! empty( $obj->taxonomyName ) ) {
						/** @var \WP_Taxonomy $tax_object */
						$tax_object = get_taxonomy( $obj->taxonomyName );

						return $type_registry->get_type( $tax_object->graphql_single_name );
					}

					return $obj;
				},
			]
		);
	}

	/**
	 * Returns a list of possible types for the union
	 *
	 * @return string[]
	 */
	public static function get_possible_types() {

		/**
		 * The possible types for MenuItems should be just the TermObjects and PostTypeObjects that are
		 * registered to "show_in_graphql" and "show_in_nav_menus"
		 */
		$args = [
			'show_in_nav_menus' => true,
			'graphql_kind'      => 'object',
		];

		$possible_types = [];

		/**
		 * Add post types that are allowed in WPGraphQL.
		 *
		 * @var \WP_Post_Type $post_type_object
		 */
		foreach ( \WPGraphQL::get_allowed_post_types( 'objects', $args ) as $post_type_object ) {
			if ( isset( $post_type_object->graphql_single_name ) ) {
				$possible_types[] = $post_type_object->graphql_single_name;
			}
		}

		// Add taxonomies that are allowed in WPGraphQL.
		foreach ( \WPGraphQL::get_allowed_taxonomies( 'objects', $args ) as $tax_object ) {
			if ( isset( $tax_object->graphql_single_name ) ) {
				$possible_types[] = $tax_object->graphql_single_name;
			}
		}

		return $possible_types;
	}
}


// File: wp-graphql\src\Type\Union\PostObjectUnion.php
<?php

namespace WPGraphQL\Type\Union;

use WPGraphQL\Registry\TypeRegistry;

/**
 * Class PostObjectUnion
 *
 * @package WPGraphQL\Type\Union
 * @deprecated use ContentNode interface instead
 */
class PostObjectUnion {

	/**
	 * Registers the Type
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @throws \Exception
	 */
	public static function register_type( TypeRegistry $type_registry ): void {
		register_graphql_union_type(
			'PostObjectUnion',
			[
				'name'        => 'PostObjectUnion',
				'typeNames'   => self::get_possible_types(),
				'description' => __( 'Union between the post, page and media item types', 'wp-graphql' ),
				'resolveType' => static function ( $value ) use ( $type_registry ) {
					_doing_it_wrong( 'PostObjectUnion', esc_attr__( 'The PostObjectUnion GraphQL type is deprecated. Use the ContentNode interface instead.', 'wp-graphql' ), '1.14.1' );

					$type = null;
					if ( isset( $value->post_type ) ) {
						$post_type_object = get_post_type_object( $value->post_type );
						if ( isset( $post_type_object->graphql_single_name ) ) {
							$type = $type_registry->get_type( $post_type_object->graphql_single_name );
						}
					}

					return ! empty( $type ) ? $type : null;
				},
			]
		);
	}

	/**
	 * Returns a list of possible types for the union
	 *
	 * @return string[]
	 */
	public static function get_possible_types() {
		$possible_types = [];
		/** @var \WP_Post_Type[] */
		$allowed_post_types = \WPGraphQL::get_allowed_post_types( 'objects', [ 'graphql_kind' => 'object' ] );

		foreach ( $allowed_post_types as $post_type_object ) {
			if ( empty( $possible_types[ $post_type_object->name ] ) && isset( $post_type_object->graphql_single_name ) ) {
				$possible_types[ $post_type_object->name ] = $post_type_object->graphql_single_name;
			}
		}

		return $possible_types;
	}
}


// File: wp-graphql\src\Type\Union\TermObjectUnion.php
<?php
namespace WPGraphQL\Type\Union;

use WPGraphQL\Registry\TypeRegistry;

/**
 * Class TermObjectUnion
 *
 * @package WPGraphQL\Type\Union
 * @deprecated use TermNode interface instead
 */
class TermObjectUnion {

	/**
	 * Registers the Type
	 *
	 * @param \WPGraphQL\Registry\TypeRegistry $type_registry
	 *
	 * @throws \Exception
	 */
	public static function register_type( TypeRegistry $type_registry ): void {
		register_graphql_union_type(
			'TermObjectUnion',
			[
				'kind'        => 'union',
				'typeNames'   => self::get_possible_types(),
				'description' => __( 'Union between the Category, Tag and PostFormatPost types', 'wp-graphql' ),
				'resolveType' => static function ( $value ) use ( $type_registry ) {
					_doing_it_wrong( 'TermObjectUnion', esc_attr__( 'The TermObjectUnion GraphQL type is deprecated. Use the TermNode interface instead.', 'wp-graphql' ), '1.14.1' );

					$type = null;
					if ( isset( $value->taxonomyName ) ) {
						$tax_object = get_taxonomy( $value->taxonomyName );
						if ( isset( $tax_object->graphql_single_name ) ) {
							$type = $type_registry->get_type( $tax_object->graphql_single_name );
						}
					}

					return ! empty( $type ) ? $type : null;
				},
			]
		);
	}

	/**
	 * Returns a list of possible types for the union
	 *
	 * @return array<string,string>
	 */
	public static function get_possible_types() {
		$possible_types = [];
		/** @var \WP_Taxonomy[] $allowed_taxonomies */
		$allowed_taxonomies = \WPGraphQL::get_allowed_taxonomies( 'objects', [ 'graphql_kind' => 'object' ] );

		foreach ( $allowed_taxonomies as $tax_object ) {
			if ( empty( $possible_types[ $tax_object->name ] ) ) {
				if ( isset( $tax_object->graphql_single_name ) ) {
					$possible_types[ $tax_object->name ] = $tax_object->graphql_single_name;
				}
			}
		}

		return $possible_types;
	}
}


// File: wp-graphql\src\Utils\DebugLog.php
<?php
namespace WPGraphQL\Utils;

/**
 * Class DebugLog
 *
 * @package WPGraphQL\Utils
 */
class DebugLog {

	/**
	 * The log items.
	 *
	 * @var array<string,mixed>[]
	 */
	protected $logs;

	/**
	 * Whether logs are enabled
	 *
	 * @var bool
	 */
	protected $logs_enabled;

	/**
	 * DebugLog constructor.
	 */
	public function __construct() {

		// Instantiate array to start capturing logs
		$this->logs = [];

		// Whether WPGraphQL Debug is enabled
		$enabled = \WPGraphQL::debug();

		/**
		 * Filters whether GraphQL Debug is enabled enabled. Serves as the default state for enabling debug logs.
		 *
		 * @param bool $enabled Whether logs are enabled or not
		 * @param \WPGraphQL\Utils\DebugLog $debug_log The DebugLog class instance
		 */
		$this->logs_enabled = apply_filters( 'graphql_debug_logs_enabled', $enabled, $this );
	}

	/**
	 * Given a message and a config, a log entry is added to the log
	 *
	 * @param mixed|string|mixed[] $message The debug log message
	 * @param array<string,mixed>  $config Config for the debug log. Set type and any additional information to log
	 *
	 * @return array<string,mixed>
	 */
	public function add_log_entry( $message, $config = [] ) {
		if ( empty( $message ) ) {
			return [];
		}

		$type = 'GRAPHQL_DEBUG';

		if ( ! is_array( $config ) ) {
			$config = [];
		}

		if ( isset( $config['type'] ) ) {
			unset( $config['message'] );
		}

		if ( isset( $config['backtrace'] ) ) {
			$config['stack'] = $config['backtrace'];
			unset( $config['backtrace'] );
		}

		if ( isset( $config['type'] ) ) {
			$type = $config['type'];
			unset( $config['type'] );
		}

		if ( ! isset( $this->logs[ wp_json_encode( $message ) ] ) ) {
			$log_entry = array_merge(
				[
					'type'    => $type,
					'message' => $message,
				],
				$config
			);

			$this->logs[ wp_json_encode( $message ) ] = $log_entry;

			/**
			 * Filter the log entry for the debug log
			 *
			 * @param array<string,mixed> $log    The log entry
			 * @param array<string,mixed> $config The config passed in with the log entry
			 */
			return apply_filters( 'graphql_debug_log_entry', $log_entry, $config );
		}

		return [];
	}

	/**
	 * Returns the debug log
	 *
	 * @return array<string,mixed>[]
	 */
	public function get_logs() {

		/**
		 * Init the debug logger
		 *
		 * @param \WPGraphQL\Utils\DebugLog $instance The DebugLog instance
		 */
		do_action( 'graphql_get_debug_log', $this );

		// If GRAPHQL_DEBUG is not enabled on the server, set a default message
		if ( ! $this->logs_enabled ) {
			$this->logs = [
				[
					'type'    => 'DEBUG_LOGS_INACTIVE',
					'message' => __( 'GraphQL Debug logging is not active. To see debug logs, GRAPHQL_DEBUG must be enabled.', 'wp-graphql' ),
				],
			];
		}

		/**
		 * Return the filtered debug log
		 *
		 * @param array<string,mixed>[]     $logs     The logs to be output with the request
		 * @param \WPGraphQL\Utils\DebugLog $instance The Debug Log class
		 */
		return apply_filters( 'graphql_debug_log', array_values( $this->logs ), $this );
	}
}


// File: wp-graphql\src\Utils\InstrumentSchema.php
<?php

namespace WPGraphQL\Utils;

use GraphQL\Error\UserError;
use GraphQL\Executor\Executor;
use GraphQL\Type\Definition\FieldDefinition;
use GraphQL\Type\Definition\ResolveInfo;
use GraphQL\Type\Definition\Type;
use WPGraphQL\AppContext;

/**
 * Class InstrumentSchema
 *
 * @package WPGraphQL\Data
 */
class InstrumentSchema {

	/**
	 * @param \GraphQL\Type\Definition\Type $type Instance of the Schema.
	 * @param string                        $type_name Name of the Type
	 */
	public static function instrument_resolvers( Type $type, string $type_name ): Type {
		if ( ! method_exists( $type, 'getFields' ) ) {
			return $type;
		}

		$fields = $type->getFields();

		$fields                 = ! empty( $fields ) ? self::wrap_fields( $fields, $type->name ) : [];
		$type->name             = ucfirst( esc_html( $type->name ) );
		$type->description      = ! empty( $type->description ) ? esc_html( $type->description ) : '';
		$type->config['fields'] = $fields;

		return $type;
	}

	/**
	 * Wrap Fields
	 *
	 * This wraps fields to provide sanitization on fields output by introspection queries
	 * (description/deprecation reason) and provides hooks to resolvers.
	 *
	 * @param mixed[] $fields    The fields configured for a Type
	 * @param string  $type_name The Type name
	 *
	 * @return mixed[]
	 */
	protected static function wrap_fields( array $fields, string $type_name ) {
		if ( empty( $fields ) ) {
			return $fields;
		}

		foreach ( $fields as $field_key => $field ) {

			/**
			 * Filter the field definition
			 *
			 * @param \GraphQL\Type\Definition\FieldDefinition $field The field definition
			 * @param string          $type_name The name of the Type the field belongs to
			 */
			$field = apply_filters( 'graphql_field_definition', $field, $type_name );

			if ( ! $field instanceof FieldDefinition ) {
				return $field;
			}

			/**
			 * Get the fields resolve function
			 *
			 * @since 0.0.1
			 */
			$field_resolver = is_callable( $field->resolveFn ) ? $field->resolveFn : null;

			/**
			 * Sanitize the description and deprecation reason
			 */
			$field->description       = ! empty( $field->description ) && is_string( $field->description ) ? esc_html( $field->description ) : '';
			$field->deprecationReason = ! empty( $field->deprecationReason ) && is_string( $field->description ) ? esc_html( $field->deprecationReason ) : null;

			/**
			 * Replace the existing field resolve method with a new function that captures data about
			 * the resolver to be stored in the resolver_report
			 *
			 * @param mixed                                $source  The source passed down the Resolve Tree
			 * @param array<string,mixed>                  $args    The args for the field
			 * @param \WPGraphQL\AppContext                $context The AppContext passed down the ResolveTree
			 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo passed down the ResolveTree
			 *
			 * @return mixed
			 * @throws \Exception
			 * @since 0.0.1
			 */
			$field->resolveFn = static function ( $source, array $args, AppContext $context, ResolveInfo $info ) use ( $field_resolver, $type_name, $field_key, $field ) {

				/**
				 * Fire an action BEFORE the field resolves
				 *
				 * @param mixed                                    $source         The source passed down the Resolve Tree
				 * @param array<string,mixed>                      $args           The args for the field
				 * @param \WPGraphQL\AppContext                    $context        The AppContext passed down the ResolveTree
				 * @param \GraphQL\Type\Definition\ResolveInfo     $info           The ResolveInfo passed down the ResolveTree
				 * @param ?callable                                $field_resolver The Resolve function for the field
				 * @param string                                   $type_name      The name of the type the fields belong to
				 * @param string                                   $field_key      The name of the field
				 * @param \GraphQL\Type\Definition\FieldDefinition $field          The Field Definition for the resolving field
				 */
				do_action( 'graphql_before_resolve_field', $source, $args, $context, $info, $field_resolver, $type_name, $field_key, $field );

				/**
				 * Create unique custom "nil" value which is different from the build-in PHP null, false etc.
				 * When this custom "nil" is returned we can know that the filter did not try to preresolve
				 * the field because it does not equal with anything but itself.
				 */
				$nil = new \stdClass();

				/**
				 * When this filter return anything other than the $nil it will be used as the resolved value
				 * and the execution of the actual resolved is skipped. This filter can be used to implement
				 * field level caches or for efficiently hiding data by returning null.
				 *
				 * @param mixed                                    $nil            Unique nil value
				 * @param mixed                                    $source         The source passed down the Resolve Tree
				 * @param array<string,mixed>                      $args           The args for the field
				 * @param \WPGraphQL\AppContext                    $context        The AppContext passed down the ResolveTree
				 * @param \GraphQL\Type\Definition\ResolveInfo     $info           The ResolveInfo passed down the ResolveTree
				 * @param string                                   $type_name      The name of the type the fields belong to
				 * @param string                                   $field_key      The name of the field
				 * @param \GraphQL\Type\Definition\FieldDefinition $field          The Field Definition for the resolving field
				 * @param ?callable                                $field_resolver The default field resolver
				 */
				$result = apply_filters( 'graphql_pre_resolve_field', $nil, $source, $args, $context, $info, $type_name, $field_key, $field, $field_resolver );

				/**
				 * Check if the field pre-resolved
				 */
				if ( $nil === $result ) {
					/**
					 * If the current field doesn't have a resolve function, use the defaultFieldResolver,
					 * otherwise use the $field_resolver
					 */
					if ( null === $field_resolver ) {
						$result = Executor::defaultFieldResolver( $source, $args, $context, $info );
					} else {
						$result = $field_resolver( $source, $args, $context, $info );
					}
				}

				/**
				 * Fire an action before the field resolves
				 *
				 * @param mixed                                    $result          The result of the field resolution
				 * @param mixed                                    $source          The source passed down the Resolve Tree
				 * @param array<string,mixed>                      $args            The args for the field
				 * @param \WPGraphQL\AppContext                    $context         The AppContext passed down the ResolveTree
				 * @param \GraphQL\Type\Definition\ResolveInfo     $info            The ResolveInfo passed down the ResolveTree
				 * @param string                                   $type_name       The name of the type the fields belong to
				 * @param string                                   $field_key       The name of the field
				 * @param \GraphQL\Type\Definition\FieldDefinition $field The Field Definition for the resolving field
				 * @param ?callable                                $field_resolver  The default field resolver
				 */
				$result = apply_filters( 'graphql_resolve_field', $result, $source, $args, $context, $info, $type_name, $field_key, $field, $field_resolver );

				/**
				 * Fire an action AFTER the field resolves
				 *
				 * @param mixed                                    $source         The source passed down the Resolve Tree
				 * @param array<string,mixed>                      $args           The args for the field
				 * @param \WPGraphQL\AppContext                    $context        The AppContext passed down the ResolveTree
				 * @param \GraphQL\Type\Definition\ResolveInfo     $info           The ResolveInfo passed down the ResolveTree
				 * @param ?callable                                $field_resolver The Resolve function for the field
				 * @param string                                   $type_name      The name of the type the fields belong to
				 * @param string                                   $field_key      The name of the field
				 * @param \GraphQL\Type\Definition\FieldDefinition $field          The Field Definition for the resolving field
				 * @param mixed                                    $result         The result of the field resolver
				 */
				do_action( 'graphql_after_resolve_field', $source, $args, $context, $info, $field_resolver, $type_name, $field_key, $field, $result );

				return $result;
			};
		}

		/**
		 * Return the fields
		 */
		return $fields;
	}

	/**
	 * Check field permissions when resolving. If the check fails, an error will be thrown.
	 *
	 * This takes into account auth params defined in the Schema
	 *
	 * @param mixed                                    $source         The source passed down the Resolve Tree
	 * @param array<string,mixed>                      $args           The args for the field
	 * @param \WPGraphQL\AppContext                    $context        The AppContext passed down the ResolveTree
	 * @param \GraphQL\Type\Definition\ResolveInfo     $info           The ResolveInfo passed down the ResolveTree
	 * @param mixed|callable|string                    $field_resolver The Resolve function for the field
	 * @param string                                   $type_name      The name of the type the fields belong to
	 * @param string                                   $field_key      The name of the field
	 * @param \GraphQL\Type\Definition\FieldDefinition $field          The Field Definition for the resolving field
	 *
	 * @return void
	 *
	 * @throws \GraphQL\Error\UserError
	 */
	public static function check_field_permissions( $source, array $args, AppContext $context, ResolveInfo $info, $field_resolver, string $type_name, string $field_key, FieldDefinition $field ) {
		if ( ( ! isset( $field->config['auth'] ) || ! is_array( $field->config['auth'] ) ) && ! isset( $field->config['isPrivate'] ) ) {
			return;
		}

		/**
		 * Set the default auth error message
		 */
		$default_auth_error_message = __( 'You do not have permission to view this', 'wp-graphql' );
		$default_auth_error_message = apply_filters( 'graphql_field_resolver_auth_error_message', $default_auth_error_message, $field );

		/**
		 * Retrieve permissions error message.
		 */
		$auth_error = isset( $field->config['auth']['errorMessage'] ) && ! empty( $field->config['auth']['errorMessage'] )
			? $field->config['auth']['errorMessage']
			: $default_auth_error_message;

		/**
		 * If the user is authenticated, and the field has a custom auth callback configured
		 * execute the callback before continuing resolution
		 */
		if ( isset( $field->config['auth']['callback'] ) && is_callable( $field->config['auth']['callback'] ) ) {
			$authorized = call_user_func( $field->config['auth']['callback'], $field, $field_key, $source, $args, $context, $info, $field_resolver );

			// If callback returns explicit false throw.
			if ( false === $authorized ) {
				throw new UserError( esc_html( $auth_error ) );
			}

			return;
		}

		/**
		 * If the schema for the field is configured to "isPrivate" or has "auth" configured,
		 * make sure the user is authenticated before resolving the field
		 */
		if ( isset( $field->config['isPrivate'] ) && true === $field->config['isPrivate'] && empty( get_current_user_id() ) ) {
			throw new UserError( esc_html( $auth_error ) );
		}

		/**
		 * If the user is authenticated and the field has "allowedCaps" configured,
		 * ensure the user has at least one of the allowedCaps before resolving
		 */
		if ( isset( $field->config['auth']['allowedCaps'] ) && is_array( $field->config['auth']['allowedCaps'] ) ) {
			$caps = ! empty( wp_get_current_user()->allcaps ) ? wp_get_current_user()->allcaps : [];
			if ( empty( array_intersect( array_keys( $caps ), array_values( $field->config['auth']['allowedCaps'] ) ) ) ) {
				throw new UserError( esc_html( $auth_error ) );
			}
		}

		/**
		 * If the user is authenticated and the field has "allowedRoles" configured,
		 * ensure the user has at least one of the allowedRoles before resolving
		 */
		if ( isset( $field->config['auth']['allowedRoles'] ) && is_array( $field->config['auth']['allowedRoles'] ) ) {
			$roles         = ! empty( wp_get_current_user()->roles ) ? wp_get_current_user()->roles : [];
			$allowed_roles = array_values( $field->config['auth']['allowedRoles'] );
			if ( empty( array_intersect( array_values( $roles ), array_values( $allowed_roles ) ) ) ) {
				throw new UserError( esc_html( $auth_error ) );
			}
		}
	}
}


// File: wp-graphql\src\Utils\Preview.php
<?php

namespace WPGraphQL\Utils;

class Preview {

	/**
	 * This filters the post meta for previews. Since WordPress core does not save meta for
	 * revisions this resolves calls to get_post_meta() using the meta of the revisions parent (the
	 * published version of the post).
	 *
	 * For plugins (such as ACF) that do store meta on revisions, the filter
	 * "graphql_resolve_revision_meta_from_parent" can be used to opt-out of this default behavior
	 * and instead return meta from the revision object instead of the parent.
	 *
	 * @param mixed       $default_value The default value of the meta
	 * @param int         $object_id     The ID of the object the meta is for
	 * @param string|null $meta_key      The meta key
	 * @param bool|null   $single        Whether the meta is a single value
	 *
	 * @return mixed
	 */
	public static function filter_post_meta_for_previews( $default_value, int $object_id, ?string $meta_key = null, ?bool $single = false ) {
		if ( ! is_graphql_request() ) {
			return $default_value;
		}

		/**
		 * Filters whether to resolve revision metadata from the parent node
		 * by default.
		 *
		 * @param bool    $should    Whether to resolve using the parent object. Default true.
		 * @param int     $object_id The ID of the object to resolve meta for
		 * @param ?string $meta_key  The key for the meta to resolve
		 * @param ?bool   $single    Whether a single value should be returned
		 */
		$resolve_revision_meta_from_parent = apply_filters( 'graphql_resolve_revision_meta_from_parent', true, $object_id, $meta_key, $single );

		if ( false === $resolve_revision_meta_from_parent ) {
			return $default_value;
		}

		$post = get_post( $object_id );

		if ( ! $post instanceof \WP_Post ) {
			return $default_value;
		}

		if ( 'revision' === $post->post_type ) {
			$parent   = get_post( $post->post_parent );
			$meta_key = ! empty( $meta_key ) ? $meta_key : '';

			return isset( $parent->ID ) && absint( $parent->ID ) ? get_post_meta( $parent->ID, $meta_key, (bool) $single ) : $default_value;
		}

		return $default_value;
	}
}


// File: wp-graphql\src\Utils\QueryAnalyzer.php
<?php

namespace WPGraphQL\Utils;

use GraphQL\Error\SyntaxError;
use GraphQL\Language\Parser;
use GraphQL\Language\Visitor;
use GraphQL\Server\OperationParams;
use GraphQL\Type\Definition\FieldDefinition;
use GraphQL\Type\Definition\InterfaceType;
use GraphQL\Type\Definition\ListOfType;
use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Schema;
use GraphQL\Utils\TypeInfo;
use WPGraphQL;
use WPGraphQL\Request;
use WPGraphQL\WPSchema;

/**
 * This class is used to identify "keys" relevant to the GraphQL Request.
 *
 * These keys can be used to identify common patterns across documents.
 *
 * A common use case would be for caching a GraphQL request and tagging the cached
 * object with these keys, then later using these keys to evict the cached
 * document.
 *
 * These keys can also be used by loggers to identify patterns, etc.
 */
class QueryAnalyzer {

	/**
	 * @var \GraphQL\Type\Schema
	 */
	protected $schema;

	/**
	 * Types that are referenced in the query
	 *
	 * @var string[]
	 */
	protected $queried_types = [];

	/**
	 * @var string
	 */
	protected $root_operation = '';

	/**
	 * Models that are referenced in the query
	 *
	 * @var string[]
	 */
	protected $models = [];

	/**
	 * Types in the query that are lists
	 *
	 * @var string[]
	 */
	protected $list_types = [];

	/**
	 * @var string[]|int[]
	 */
	protected $runtime_nodes = [];

	/**
	 * @var array<string,int[]|string[]>
	 */
	protected $runtime_nodes_by_type = [];

	/**
	 * @var string
	 */
	protected $query_id;

	/**
	 * @var \WPGraphQL\Request
	 */
	protected $request;

	/**
	 * @var Int The character length limit for headers
	 */
	protected $header_length_limit;

	/**
	 * @var string The keys that were skipped from being returned in the X-GraphQL-Keys header.
	 */
	protected $skipped_keys = '';

	/**
	 * @var string[] The GraphQL keys to return in the X-GraphQL-Keys header.
	 */
	protected $graphql_keys = [];

	/**
	 * @var mixed[] Track all Types that were queried as a list
	 */
	protected $queried_list_types = [];

	/**
	 * @var ?bool Whether the Query Analyzer is enabled for the specific or not.
	 */
	protected $is_enabled_for_query;

	/**
	 * Checks whether the Query Analyzer is enabled on the site.
	 *
	 * @uses `graphql_query_analyzer_enabled` filter.
	 */
	public static function is_enabled(): bool {
		$is_debug_enabled = WPGraphQL::debug();

		// The query analyzer is enabled if WPGraphQL Debugging is enabled
		$query_analyzer_enabled = $is_debug_enabled;

		// If WPGraphQL Debugging is not enabled, check the setting
		if ( ! $is_debug_enabled ) {
			$query_analyzer_enabled = get_graphql_setting( 'query_analyzer_enabled', 'off' );
			$query_analyzer_enabled = 'on' === $query_analyzer_enabled;
		}

		/**
		 * Filters whether to analyze queries for all GraphQL requests.
		 *
		 * @param bool $should_track_types Whether to analyze queries or not. Defaults to `true` if GraphQL Debugging is enabled, otherwise `false`.
		 */
		return apply_filters( 'graphql_should_analyze_queries', $query_analyzer_enabled );
	}

	/**
	 * @param \WPGraphQL\Request $request The GraphQL request being executed
	 */
	public function __construct( Request $request ) {
		$this->request       = $request;
		$this->schema        = $request->schema;
		$this->runtime_nodes = [];
		$this->models        = [];
		$this->list_types    = [];
		$this->queried_types = [];
	}

	/**
	 * Gets the request object.
	 */
	public function get_request(): Request {
		return $this->request;
	}

	/**
	 * Checks if the Query Analyzer is enabled.
	 *
	 * @uses `graphql_should_analyze_queries` filter.
	 */
	public function is_enabled_for_query(): bool {
		if ( ! isset( $this->is_enabled_for_query ) ) {
			$is_enabled = self::is_enabled();

			/**
			 * Filters whether to analyze queries or for a specific GraphQL request.
			 *
			 * @param bool          $should_analyze_queries Whether to analyze queries for the current request. Defaults to the value of `graphql_query_analyzer_enabled` filter.
			 * @param \WPGraphQL\Request $request               The GraphQL request being executed
			 */
			$should_analyze_queries = apply_filters( 'graphql_should_analyze_query', $is_enabled, $this->get_request() );

			$this->is_enabled_for_query = true === $should_analyze_queries;
		}

		return $this->is_enabled_for_query;
	}

	/**
	 * Initialize the QueryAnalyzer.
	 */
	public function init(): void {
		$should_analyze_queries = $this->is_enabled_for_query();

		// If query analyzer is disabled, bail
		if ( true !== $should_analyze_queries ) {
			return;
		}

		$this->graphql_keys = [];
		$this->skipped_keys = '';

		/**
		 * Many clients have an 8k (8192 characters) header length cap.
		 *
		 * This is the total for ALL headers, not just individual headers.
		 *
		 * SEE: https://nodejs.org/en/blog/vulnerability/november-2018-security-releases/#denial-of-service-with-large-http-headers-cve-2018-12121
		 *
		 * In order to respect this, we have a default limit of 4000 characters for the X-GraphQL-Keys header
		 * to allow for other headers to total up to 8k.
		 *
		 * This value can be filtered to be increased or decreased.
		 *
		 * If you see "Parse Error: Header overflow" errors in your client, you might want to decrease this value.
		 *
		 * On the other hand, if you've increased your allowed header length in your client
		 * (i.e. https://github.com/wp-graphql/wp-graphql/issues/2535#issuecomment-1262499064) then you might want to increase this so that keys are not truncated.
		 *
		 * @param int $header_length_limit The max limit in (binary) bytes headers should be. Anything longer will be truncated.
		 */
		$this->header_length_limit = apply_filters( 'graphql_query_analyzer_header_length_limit', 4000 );

		// track keys related to the query
		add_action( 'do_graphql_request', [ $this, 'determine_graphql_keys' ], 10, 4 );

		// Track models loaded during execution
		add_filter( 'graphql_dataloader_get_model', [ $this, 'track_nodes' ], 10, 1 );

		// Expose query analyzer data in extensions
		add_filter(
			'graphql_request_results',
			[
				$this,
				'show_query_analyzer_in_extensions',
			],
			10,
			5
		);
	}

	/**
	 * Determine the keys associated with the GraphQL document being executed
	 *
	 * @param ?string                         $query     The GraphQL query
	 * @param ?string                         $operation The name of the operation
	 * @param ?array<string,mixed>            $variables Variables to be passed to your GraphQL request
	 * @param \GraphQL\Server\OperationParams $params The Operation Params. This includes any extra params,
	 * such as extensions or any other modifications to the request body
	 *
	 * @throws \Exception
	 */
	public function determine_graphql_keys( ?string $query, ?string $operation, ?array $variables, OperationParams $params ): void {

		// @todo: support for QueryID?

		// if the query is empty, get it from the request params
		if ( empty( $query ) ) {
			$query = $this->request->params->query ?: null;
		}

		if ( empty( $query ) ) {
			return;
		}

		$query_id       = Utils::get_query_id( $query );
		$this->query_id = $query_id ?: uniqid( 'gql:', true );

		// if there's a query (either saved or part of the request params)
		// get the GraphQL Types being asked for by the query
		$this->list_types    = $this->set_list_types( $this->schema, $query );
		$this->queried_types = $this->set_query_types( $this->schema, $query );
		$this->models        = $this->set_query_models( $this->schema, $query );

		/**
		 * @param \WPGraphQL\Utils\QueryAnalyzer $query_analyzer The instance of the query analyzer
		 * @param string        $query          The query string being executed
		 */
		do_action( 'graphql_determine_graphql_keys', $this, $query );
	}

	/**
	 * @return string[]
	 */
	public function get_list_types(): array {
		return array_unique( $this->list_types );
	}

	/**
	 * @return string[]
	 */
	public function get_query_types(): array {
		return array_unique( $this->queried_types );
	}

	/**
	 * @return string[]
	 */
	public function get_query_models(): array {
		return array_unique( $this->models );
	}

	/**
	 * @return string[]|int[]
	 */
	public function get_runtime_nodes(): array {
		/**
		 * @param string[]|int[] $runtime_nodes Nodes that were resolved during execution
		 */
		$runtime_nodes = apply_filters( 'graphql_query_analyzer_get_runtime_nodes', $this->runtime_nodes );

		return array_unique( $runtime_nodes );
	}

	/**
	 * Get the root operation of the query.
	 */
	public function get_root_operation(): string {
		return $this->root_operation;
	}

	/**
	 * Returns the operation name of the query, if there is one
	 */
	public function get_operation_name(): ?string {
		$operation_name = ! empty( $this->request->params->operation ) ? $this->request->params->operation : null;

		if ( empty( $operation_name ) ) {

			// If the query is not set on the params, return null
			if ( ! isset( $this->request->params->query ) ) {
				return null;
			}

			try {
				$ast            = Parser::parse( $this->request->params->query );
				$operation_name = ! empty( $ast->definitions[0]->name->value ) ? $ast->definitions[0]->name->value : null;
			} catch ( SyntaxError $error ) {
				return null;
			}
		}

		return ! empty( $operation_name ) ? 'operation:' . $operation_name : null;
	}

	/**
	 * Get the query id.
	 */
	public function get_query_id(): ?string {
		return $this->query_id;
	}

	/**
	 * @param \GraphQL\Type\Definition\Type            $type The Type of field
	 * @param \GraphQL\Type\Definition\FieldDefinition $field_def The field definition the type is for
	 * @param mixed                                    $parent_type The Parent Type
	 * @param bool                                     $is_list_type Whether the field is a list type field
	 *
	 * @return  \GraphQL\Type\Definition\Type|String|null
	 */
	public static function get_wrapped_field_type( Type $type, FieldDefinition $field_def, $parent_type, bool $is_list_type = false ) {
		if ( ! isset( $parent_type->name ) || 'RootQuery' !== $parent_type->name ) {
			return null;
		}

		if ( $type instanceof NonNull || $type instanceof ListOfType ) {
			if ( $type instanceof ListOfType && isset( $parent_type->name ) ) {
				$is_list_type = true;
			}

			return self::get_wrapped_field_type( $type->getWrappedType(), $field_def, $parent_type, $is_list_type );
		}

		// Determine if we're dealing with a connection
		if ( $type instanceof ObjectType || $type instanceof InterfaceType ) {
			$interfaces      = $type->getInterfaces();
			$interface_names = ! empty( $interfaces ) ? array_map(
				static function ( InterfaceType $interface_obj ) {
					return $interface_obj->name;
				},
				$interfaces
			) : [];

			if ( array_key_exists( 'Connection', $interface_names ) ) {
				if ( isset( $field_def->config['fromType'] ) && ( 'rootquery' !== strtolower( $field_def->config['fromType'] ) ) ) {
					return null;
				}

				$to_type = $field_def->config['toType'] ?? null;
				if ( empty( $to_type ) ) {
					return null;
				}

				return $to_type;
			}

			if ( ! $is_list_type ) {
				return null;
			}

			return $type;
		}

		return null;
	}

	/**
	 * Given the Schema and a query string, return a list of GraphQL Types that are being asked for
	 * by the query.
	 *
	 * @param ?\GraphQL\Type\Schema $schema The WPGraphQL Schema
	 * @param ?string               $query  The query string
	 *
	 * @return string[]
	 * @throws \GraphQL\Error\SyntaxError|\Exception
	 */
	public function set_list_types( ?Schema $schema, ?string $query ): array {

		/**
		 * @param string[]|null         $null   Default value for the filter
		 * @param ?\GraphQL\Type\Schema $schema The WPGraphQL Schema for the current request
		 * @param ?string               $query  The query string being requested
		 */
		$null               = null;
		$pre_get_list_types = apply_filters( 'graphql_pre_query_analyzer_get_list_types', $null, $schema, $query );

		if ( null !== $pre_get_list_types ) {
			return $pre_get_list_types;
		}

		if ( empty( $query ) || null === $schema ) {
			return [];
		}

		try {
			$ast = Parser::parse( $query );
		} catch ( SyntaxError $error ) {
			return [];
		}

		$type_map  = [];
		$type_info = new TypeInfo( $schema );

		$visitor = [
			'enter' => static function ( $node, $key, $_parent, $path, $ancestors ) use ( $type_info, &$type_map, $schema ) {
				$parent_type = $type_info->getParentType();

				if ( 'Field' !== $node->kind ) {
					Visitor::skipNode();
				}

				$type_info->enter( $node );
				$field_def = $type_info->getFieldDef();

				if ( ! $field_def instanceof FieldDefinition ) {
					return;
				}

				// Determine the wrapped type, which also determines if it's a listOf
				$field_type = $field_def->getType();
				$field_type = self::get_wrapped_field_type( $field_type, $field_def, $parent_type );

				if ( null === $field_type ) {
					return;
				}

				if ( ! empty( $field_type ) && is_string( $field_type ) ) {
					$field_type = $schema->getType( ucfirst( $field_type ) );
				}

				if ( ! $field_type ) {
					return;
				}

				$field_type = $schema->getType( $field_type );

				if ( ! $field_type instanceof ObjectType && ! $field_type instanceof InterfaceType ) {
					return;
				}

				// If the type being queried is an interface (i.e. ContentNode) the publishing a new
				// item of any of the possible types (post, page, etc) should invalidate
				// this query, so we need to tag this query with `list:$possible_type` for each possible type
				if ( $field_type instanceof InterfaceType ) {
					$possible_types = $schema->getPossibleTypes( $field_type );
					if ( ! empty( $possible_types ) ) {
						foreach ( $possible_types as $possible_type ) {
							$type_map[] = 'list:' . strtolower( $possible_type );
						}
					}
				} else {
					$type_map[] = 'list:' . strtolower( $field_type );
				}
			},
			'leave' => static function ( $node, $key, $_parent, $path, $ancestors ) use ( $type_info ) {
				$type_info->leave( $node );
			},
		];

		Visitor::visit( $ast, Visitor::visitWithTypeInfo( $type_info, $visitor ) );
		$map = array_values( array_unique( array_filter( $type_map ) ) );

		return apply_filters( 'graphql_cache_collection_get_list_types', $map, $schema, $query, $type_info );
	}

	/**
	 * Given the Schema and a query string, return a list of GraphQL Types that are being asked for
	 * by the query.
	 *
	 * @param ?\GraphQL\Type\Schema $schema The WPGraphQL Schema
	 * @param ?string               $query  The query string
	 *
	 * @return string[]
	 * @throws \Exception
	 */
	public function set_query_types( ?Schema $schema, ?string $query ): array {

		/**
		 * @param string[]|null         $null   Default value for the filter
		 * @param ?\GraphQL\Type\Schema $schema The WPGraphQL Schema for the current request
		 * @param ?string               $query  The query string being requested
		 */
		$null                = null;
		$pre_get_query_types = apply_filters( 'graphql_pre_query_analyzer_get_query_types', $null, $schema, $query );

		if ( null !== $pre_get_query_types ) {
			return $pre_get_query_types;
		}

		if ( empty( $query ) || null === $schema ) {
			return [];
		}
		try {
			$ast = Parser::parse( $query );
		} catch ( SyntaxError $error ) {
			return [];
		}
		$type_map  = [];
		$type_info = new TypeInfo( $schema );
		$visitor   = [
			'enter' => function ( $node, $key, $_parent, $path, $ancestors ) use ( $type_info, &$type_map, $schema ) {
				$type_info->enter( $node );
				$type = $type_info->getType();
				if ( ! $type ) {
					return;
				}

				if ( empty( $this->root_operation ) ) {
					if ( $type === $schema->getQueryType() ) {
						$this->root_operation = 'Query';
					}

					if ( $type === $schema->getMutationType() ) {
						$this->root_operation = 'Mutation';
					}

					if ( $type === $schema->getSubscriptionType() ) {
						$this->root_operation = 'Subscription';
					}
				}

				$named_type = Type::getNamedType( $type );

				if ( $named_type instanceof InterfaceType ) {
					$possible_types = $schema->getPossibleTypes( $named_type );
					foreach ( $possible_types as $possible_type ) {
						$type_map[] = strtolower( $possible_type );
					}
				} elseif ( $named_type instanceof ObjectType ) {
					$type_map[] = strtolower( $named_type );
				}
			},
			'leave' => static function ( $node, $key, $_parent, $path, $ancestors ) use ( $type_info ) {
				$type_info->leave( $node );
			},
		];

		Visitor::visit( $ast, Visitor::visitWithTypeInfo( $type_info, $visitor ) );
		$map = array_values( array_unique( array_filter( $type_map ) ) );

		return apply_filters( 'graphql_cache_collection_get_query_types', $map, $schema, $query, $type_info );
	}

	/**
	 * Given the Schema and a query string, return a list of GraphQL model names that are being
	 * asked for by the query.
	 *
	 * @param ?\GraphQL\Type\Schema $schema The WPGraphQL Schema
	 * @param ?string               $query  The query string
	 *
	 * @return string[]
	 * @throws \GraphQL\Error\SyntaxError|\Exception
	 */
	public function set_query_models( ?Schema $schema, ?string $query ): array {

		/**
		 * @param string[]|null         $null   Default value for the filter
		 * @param ?\GraphQL\Type\Schema $schema The WPGraphQL Schema for the current request
		 * @param ?string               $query  The query string being requested
		 */
		$null           = null;
		$pre_get_models = apply_filters( 'graphql_pre_query_analyzer_get_models', $null, $schema, $query );

		if ( null !== $pre_get_models ) {
			return $pre_get_models;
		}

		if ( empty( $query ) || null === $schema ) {
			return [];
		}
		try {
			$ast = Parser::parse( $query );
		} catch ( SyntaxError $error ) {
			return [];
		}
		$type_map  = [];
		$type_info = new TypeInfo( $schema );
		$visitor   = [
			'enter' => static function ( $node, $key, $_parent, $path, $ancestors ) use ( $type_info, &$type_map, $schema ) {
				$type_info->enter( $node );
				$type = $type_info->getType();
				if ( ! $type ) {
					return;
				}

				$named_type = Type::getNamedType( $type );

				if ( $named_type instanceof InterfaceType ) {
					$possible_types = $schema->getPossibleTypes( $named_type );
					foreach ( $possible_types as $possible_type ) {
						if ( ! isset( $possible_type->config['model'] ) ) {
							continue;
						}
						$type_map[] = $possible_type->config['model'];
					}
				} elseif ( $named_type instanceof ObjectType ) {
					if ( ! isset( $named_type->config['model'] ) ) {
						return;
					}
					$type_map[] = $named_type->config['model'];
				}
			},
			'leave' => static function ( $node, $key, $_parent, $path, $ancestors ) use ( $type_info ) {
				$type_info->leave( $node );
			},
		];

		Visitor::visit( $ast, Visitor::visitWithTypeInfo( $type_info, $visitor ) );
		$map = array_values( array_unique( array_filter( $type_map ) ) );

		return apply_filters( 'graphql_cache_collection_get_query_models', $map, $schema, $query, $type_info );
	}

	/**
	 * Track the nodes that were resolved by ensuring the Node's model
	 * matches one of the models asked for in the query
	 *
	 * @param mixed $model The Model to be returned by the loader
	 *
	 * @return mixed
	 */
	public function track_nodes( $model ) {
		if ( isset( $model->id ) && in_array( get_class( $model ), $this->get_query_models(), true ) ) {

			// Is this model type part of the requested/returned data in the asked for query?

			/**
			 * Filter the node ID before returning to the list of resolved nodes
			 *
			 * @param int             $model_id      The ID of the model (node) being returned
			 * @param object          $model         The Model object being returned
			 * @param string[]|int[]  $runtime_nodes The runtimes nodes already collected
			 */
			$node_id = apply_filters( 'graphql_query_analyzer_runtime_node', $model->id, $model, $this->runtime_nodes );

			$node_type = Utils::get_node_type_from_id( $node_id );

			if ( empty( $this->runtime_nodes_by_type[ $node_type ] ) || ! in_array( $node_id, $this->runtime_nodes_by_type[ $node_type ], true ) ) {
				$this->runtime_nodes_by_type[ $node_type ][] = $node_id;
			}

			$this->runtime_nodes[] = $node_id;
		}

		return $model;
	}

	/**
	 * Returns graphql keys for use in debugging and headers.
	 *
	 * @return string[]
	 */
	public function get_graphql_keys() {
		if ( ! empty( $this->graphql_keys ) ) {
			return $this->graphql_keys;
		}

		$keys        = [];
		$return_keys = '';

		if ( $this->get_query_id() ) {
			$keys[] = $this->get_query_id();
		}

		if ( ! empty( $this->get_root_operation() ) ) {
			$keys[] = 'graphql:' . $this->get_root_operation();
		}

		if ( ! empty( $this->get_operation_name() ) ) {
			$keys[] = $this->get_operation_name();
		}

		if ( ! empty( $this->get_list_types() ) ) {
			$keys = array_merge( $keys, $this->get_list_types() );
		}

		if ( ! empty( $this->get_runtime_nodes() ) ) {
			$keys = array_merge( $keys, $this->get_runtime_nodes() );
		}

		if ( ! empty( $keys ) ) {
			$all_keys = implode( ' ', array_unique( array_values( $keys ) ) );

			// Use the header_length_limit to wrap the words with a separator
			$wrapped = wordwrap( $all_keys, $this->header_length_limit, '\n' );

			// explode the string at the separator. This creates an array of chunks that
			// can be used to expose the keys in multiple headers, each under the header_length_limit
			$chunks = explode( '\n', $wrapped );

			// Iterate over the chunks
			foreach ( $chunks as $index => $chunk ) {
				if ( 0 === $index ) {
					$return_keys = $chunk;
				} else {
					$this->skipped_keys = trim( $this->skipped_keys . ' ' . $chunk );
				}
			}
		}

		$skipped_keys_array = ! empty( $this->skipped_keys ) ? explode( ' ', $this->skipped_keys ) : [];
		$return_keys_array  = ! empty( $return_keys ) ? explode( ' ', $return_keys ) : [];
		$skipped_types      = [];

		$runtime_node_types = array_keys( $this->runtime_nodes_by_type );

		if ( ! empty( $skipped_keys_array ) ) {
			foreach ( $skipped_keys_array as $skipped_key ) {
				foreach ( $runtime_node_types as $node_type ) {
					if ( in_array( 'skipped:' . $node_type, $skipped_types, true ) ) {
						continue;
					}
					if ( in_array( $skipped_key, $this->runtime_nodes_by_type[ $node_type ], true ) ) {
						$skipped_types[] = 'skipped:' . $node_type;
						break;
					}
				}
			}
		}

		// If there are any skipped types, append them to the GraphQL Keys
		if ( ! empty( $skipped_types ) ) {
			$skipped_types_string = implode( ' ', $skipped_types );
			$return_keys         .= ' ' . $skipped_types_string;
		}

		/**
		 * @param array<string,mixed> $graphql_keys       Information about the keys and skipped keys returned by the Query Analyzer
		 * @param string              $return_keys        The keys returned to the X-GraphQL-Keys header
		 * @param string              $skipped_keys       The Keys that were skipped (truncated due to size limit) from the X-GraphQL-Keys header
		 * @param string[]            $return_keys_array  The keys returned to the X-GraphQL-Keys header, in array instead of string
		 * @param string[]            $skipped_keys_array The keys skipped, in array instead of string
		 */
		$this->graphql_keys = apply_filters(
			'graphql_query_analyzer_graphql_keys',
			[
				'keys'             => $return_keys,
				'keysLength'       => strlen( $return_keys ),
				'keysCount'        => ! empty( $return_keys_array ) ? count( $return_keys_array ) : 0,
				'skippedKeys'      => $this->skipped_keys,
				'skippedKeysSize'  => strlen( $this->skipped_keys ),
				'skippedKeysCount' => ! empty( $skipped_keys_array ) ? count( $skipped_keys_array ) : 0,
				'skippedTypes'     => $skipped_types,
			],
			$return_keys,
			$this->skipped_keys,
			$return_keys_array,
			$skipped_keys_array
		);

		return $this->graphql_keys;
	}

	/**
	 * Return headers
	 *
	 * @param array<string,mixed> $headers The array of headers being returned
	 *
	 * @return array<string,mixed>
	 */
	public function get_headers( array $headers = [] ): array {
		$keys = $this->get_graphql_keys();

		if ( ! empty( $keys ) ) {
			$headers['X-GraphQL-Query-ID'] = $this->query_id ?: null;
			$headers['X-GraphQL-Keys']     = $keys['keys'] ?: null;
		}

		/**
		 * @param array<string,mixed> $headers The array of headers being returned
		 * @param \WPGraphQL\Utils\QueryAnalyzer $query_analyzer The instance of the query analyzer
		 */
		return apply_filters( 'graphql_query_analyzer_get_headers', $headers, $this );
	}

	/**
	 * Outputs Query Analyzer data in the extensions response
	 *
	 * @param mixed                    $response
	 * @param \WPGraphQL\WPSchema      $schema         The WPGraphQL Schema
	 * @param string|null              $operation_name The operation name being executed
	 * @param string|null              $request        The GraphQL Request being made
	 * @param array<string,mixed>|null $variables      The variables sent with the request
	 *
	 * @return array<string,mixed>|object|null
	 */
	public function show_query_analyzer_in_extensions( $response, WPSchema $schema, ?string $operation_name, ?string $request, ?array $variables ) {
		$should = $this->is_enabled_for_query() && WPGraphQL::debug();

		/**
		 * @param bool                     $should         Whether the query analyzer output should be displayed in the Extensions output. Defaults to true if the query analyzer is enabled for the request and WPGraphQL Debugging is enabled.
		 * @param mixed                    $response       The response of the WPGraphQL Request being executed
		 * @param \WPGraphQL\WPSchema      $schema The WPGraphQL Schema
		 * @param string|null              $operation_name The operation name being executed
		 * @param string|null              $request        The GraphQL Request being made
		 * @param array<string,mixed>|null $variables      The variables sent with the request
		 */
		$should_show_query_analyzer_in_extensions = apply_filters( 'graphql_should_show_query_analyzer_in_extensions', $should, $response, $schema, $operation_name, $request, $variables );

		// If the query analyzer output is disabled,
		// don't show the output in the response
		if ( false === $should_show_query_analyzer_in_extensions ) {
			return $response;
		}

		$keys = $this->get_graphql_keys();

		if ( ! empty( $response ) ) {
			if ( is_array( $response ) ) {
				$response['extensions']['queryAnalyzer'] = $keys ?: null;
			} elseif ( is_object( $response ) ) {
				// @phpstan-ignore-next-line
				$response->extensions['queryAnalyzer'] = $keys ?: null;
			}
		}

		return $response;
	}
}


// File: wp-graphql\src\Utils\QueryLog.php
<?php

namespace WPGraphQL\Utils;

/**
 * Class QueryLog
 *
 * @package WPGraphQL\Utils
 */
class QueryLog {

	/**
	 * Whether Query Logs are enabled
	 *
	 * @var bool
	 */
	protected $query_logs_enabled;

	/**
	 * The user role query logs should be limited to
	 *
	 * @var string
	 */
	protected $query_log_user_role;

	/**
	 * Initialize Query Logging
	 *
	 * @return void
	 */
	public function init() {

		// Check whether Query Logs have been enabled from the settings page
		$enabled                  = get_graphql_setting( 'query_logs_enabled', 'off' );
		$this->query_logs_enabled = 'on' === $enabled;

		$this->query_log_user_role = get_graphql_setting( 'query_log_user_role', 'manage_options' );

		if ( ! $this->query_logs_enabled ) {
			return;
		}

		add_action( 'init', [ $this, 'init_save_queries' ] );
		add_filter( 'graphql_request_results', [ $this, 'show_results' ], 10, 5 );
	}

	/**
	 * Tell WordPress to start saving queries.
	 *
	 * NOTE: This will affect all requests, not just GraphQL requests.
	 *
	 * @return void
	 */
	public function init_save_queries() {
		if ( is_graphql_http_request() && ! defined( 'SAVEQUERIES' ) ) {
			define( 'SAVEQUERIES', true );
		}
	}

	/**
	 * Determine if the requesting user can see logs
	 *
	 * @return bool
	 */
	public function user_can_see_logs() {
		$can_see = false;

		// If logs are disabled, user cannot see logs
		if ( ! $this->query_logs_enabled ) {
			$can_see = false;
		} elseif ( 'any' === $this->query_log_user_role ) {
			// If "any" is the selected role, anyone can see the logs
			$can_see = true;
		} else {
			// Get the current users roles
			$user = wp_get_current_user();

			// If the user doesn't have roles or the selected role isn't one the user has, the
			// user cannot see roles;
			if ( in_array( $this->query_log_user_role, $user->roles, true ) ) {
				$can_see = true;
			}
		}

		/**
		 * Filter whether the logs can be seen in the request results or not
		 *
		 * @param bool $can_see Whether the requester can see the logs or not
		 */
		return apply_filters( 'graphql_user_can_see_query_logs', $can_see );
	}

	/**
	 * Filter the results of the GraphQL Response to include the Query Log
	 *
	 * @param mixed               $response
	 * @param \WPGraphQL\WPSchema $schema The WPGraphQL Schema
	 * @param string              $operation_name The operation name being executed
	 * @param string              $request        The GraphQL Request being made
	 * @param array<string,mixed> $variables      The variables sent with the request
	 *
	 * @return mixed[]
	 */
	public function show_results( $response, $schema, $operation_name, $request, $variables ) {
		$query_log = $this->get_query_log();

		// If the user cannot see the logs, return the response as-is without the logs
		if ( ! $this->user_can_see_logs() ) {
			return $response;
		}

		if ( ! empty( $response ) ) {
			if ( is_array( $response ) ) {
				$response['extensions']['queryLog'] = $query_log;
			} elseif ( is_object( $response ) ) {
				// @phpstan-ignore-next-line
				$response->extensions['queryLog'] = $query_log;
			}
		}

		return $response;
	}

	/**
	 * Return the query log produced from the logs stored by WPDB.
	 *
	 * @return array<string,mixed>
	 */
	public function get_query_log() {
		global $wpdb;

		$save_queries_value = defined( 'SAVEQUERIES' ) && true === SAVEQUERIES ? 'true' : 'false';
		$default_message    = sprintf(
			// translators: %s is the value of the SAVEQUERIES constant
			__( 'Query Logging has been disabled. The \'SAVEQUERIES\' Constant is set to \'%s\' on your server.', 'wp-graphql' ),
			$save_queries_value
		);

		// Default message
		$trace = [ $default_message ];

		if ( ! empty( $wpdb->queries ) && is_array( $wpdb->queries ) ) {
			$queries = array_map(
				static function ( $query ) {
					return [
						'sql'   => $query[0],
						'time'  => $query[1],
						'stack' => $query[2],
					];
				},
				$wpdb->queries
			);

			$times      = wp_list_pluck( $queries, 'time' );
			$total_time = array_sum( $times );
			$trace      = [
				'queryCount' => count( $queries ),
				'totalTime'  => $total_time,
				'queries'    => $queries,
			];
		}

		/**
		 * Filter the trace
		 *
		 * @param mixed[]                   $trace     The trace to return
		 * @param \WPGraphQL\Utils\QueryLog $instance  The QueryLog class instance
		 */
		return apply_filters( 'graphql_tracing_response', $trace, $this );
	}
}


// File: wp-graphql\src\Utils\Tracing.php
<?php

namespace WPGraphQL\Utils;

use GraphQL\Type\Definition\ResolveInfo;
use WPGraphQL\AppContext;

/**
 * Class Tracing
 *
 * Sets up trace data to track how long individual fields take to resolve in WPGraphQL
 *
 * @package WPGraphQL\Utils
 */
class Tracing {

	/**
	 * Whether Tracing is enabled
	 *
	 * @var bool
	 */
	public $tracing_enabled;

	/**
	 * Stores the logs for the trace
	 *
	 * @var array<string,mixed>[]
	 */
	public $trace_logs = [];

	/**
	 * The start microtime
	 *
	 * @var float
	 */
	public $request_start_microtime;

	/**
	 * The start timestamp
	 *
	 * @var float
	 */
	public $request_start_timestamp;

	/**
	 * The end microtime
	 *
	 * @var float
	 */
	public $request_end_microtime;

	/**
	 * The end timestamp
	 *
	 * @var float
	 */
	public $request_end_timestamp;

	/**
	 * The trace for the current field being resolved
	 *
	 * @var array<string,mixed>
	 */
	public $field_trace = [];

	/**
	 * The version of the Apollo Tracing Spec
	 *
	 * @var int
	 */
	public $trace_spec_version = 1;

	/**
	 * The user role tracing is limited to
	 *
	 * @var string
	 */
	public $tracing_user_role;

	/**
	 * Initialize tracing
	 *
	 * @return void
	 */
	public function init() {

		// Check whether Query Logs have been enabled from the settings page
		$enabled               = get_graphql_setting( 'tracing_enabled', 'off' );
		$this->tracing_enabled = 'on' === $enabled;

		$this->tracing_user_role = get_graphql_setting( 'tracing_user_role', 'manage_options' );

		if ( ! $this->tracing_enabled ) {
			return;
		}

		add_filter( 'do_graphql_request', [ $this, 'init_trace' ] );
		add_action( 'graphql_execute', [ $this, 'end_trace' ], 99, 0 );
		add_filter( 'graphql_access_control_allow_headers', [ $this, 'return_tracing_headers' ] );
		add_filter(
			'graphql_request_results',
			[
				$this,
				'add_tracing_to_response_extensions',
			],
			10,
			1
		);
		add_action( 'graphql_before_resolve_field', [ $this, 'init_field_resolver_trace' ], 10, 4 );
		add_action( 'graphql_after_resolve_field', [ $this, 'end_field_resolver_trace' ], 10 );
	}

	/**
	 * Sets the timestamp and microtime for the start of the request
	 *
	 * @return float
	 */
	public function init_trace() {
		$this->request_start_microtime = microtime( true );
		$this->request_start_timestamp = $this->format_timestamp( $this->request_start_microtime );

		return $this->request_start_timestamp;
	}

	/**
	 * Sets the timestamp and microtime for the end of the request
	 *
	 * @return void
	 */
	public function end_trace() {
		$this->request_end_microtime = microtime( true );
		$this->request_end_timestamp = $this->format_timestamp( $this->request_end_microtime );
	}

	/**
	 * Initialize tracing for an individual field
	 *
	 * @param mixed                                $source         The source passed down the Resolve Tree
	 * @param array<string,mixed>                  $args           The args for the field
	 * @param \WPGraphQL\AppContext                $context The AppContext passed down the ResolveTree
	 * @param \GraphQL\Type\Definition\ResolveInfo $info The ResolveInfo passed down the ResolveTree
	 *
	 * @return void
	 */
	public function init_field_resolver_trace( $source, array $args, AppContext $context, ResolveInfo $info ) {
		$this->field_trace = [
			'path'           => $info->path,
			'parentType'     => $info->parentType->name,
			'fieldName'      => $info->fieldName,
			'returnType'     => $info->returnType->name ? $info->returnType->name : $info->returnType,
			'startOffset'    => $this->get_start_offset(),
			'startMicrotime' => microtime( true ),
		];
	}

	/**
	 * End the tracing for a resolver
	 *
	 * @return void
	 */
	public function end_field_resolver_trace() {
		if ( ! empty( $this->field_trace ) ) {
			$this->field_trace['duration'] = $this->get_field_resolver_duration();
			$sanitized_trace               = $this->sanitize_resolver_trace( $this->field_trace );
			$this->trace_logs[]            = $sanitized_trace;
		}

		// reset the field trace
		$this->field_trace = [];
	}

	/**
	 * Given a resolver start time, returns the duration of a resolver
	 *
	 * @return float|int
	 */
	public function get_field_resolver_duration() {
		return ( microtime( true ) - $this->field_trace['startMicrotime'] ) * 1000000;
	}

	/**
	 * Get the offset between the start of the request and now
	 *
	 * @return float|int
	 */
	public function get_start_offset() {
		return ( microtime( true ) - $this->request_start_microtime ) * 1000000;
	}

	/**
	 * Given a trace, sanitizes the values and returns the sanitized_trace
	 *
	 * @param array<string,mixed> $trace
	 *
	 * @return array<string,mixed>
	 */
	public function sanitize_resolver_trace( array $trace ) {
		$sanitized_trace                = [];
		$sanitized_trace['path']        = ! empty( $trace['path'] ) && is_array( $trace['path'] ) ? array_map(
			[
				$this,
				'sanitize_trace_resolver_path',
			],
			$trace['path']
		) : [];
		$sanitized_trace['parentType']  = ! empty( $trace['parentType'] ) ? esc_html( $trace['parentType'] ) : '';
		$sanitized_trace['fieldName']   = ! empty( $trace['fieldName'] ) ? esc_html( $trace['fieldName'] ) : '';
		$sanitized_trace['returnType']  = ! empty( $trace['returnType'] ) ? esc_html( $trace['returnType'] ) : '';
		$sanitized_trace['startOffset'] = ! empty( $trace['startOffset'] ) ? absint( $trace['startOffset'] ) : '';
		$sanitized_trace['duration']    = ! empty( $trace['duration'] ) ? absint( $trace['duration'] ) : '';

		return $sanitized_trace;
	}

	/**
	 * Given input from a Resolver Path, this sanitizes the input for output in the trace
	 *
	 * @param mixed $input The input to sanitize
	 *
	 * @return int|string|null
	 */
	public static function sanitize_trace_resolver_path( $input ) {
		$sanitized_input = null;
		if ( is_numeric( $input ) ) {
			$sanitized_input = absint( $input );
		} else {
			$sanitized_input = esc_html( $input );
		}

		return $sanitized_input;
	}

	/**
	 * Formats a timestamp to be RFC 3339 compliant
	 *
	 * @see https://github.com/apollographql/apollo-tracing
	 *
	 * @param mixed|string|float|int $time The timestamp to format
	 *
	 * @return float
	 */
	public function format_timestamp( $time ) {
		$time_as_float = sprintf( '%.4f', $time );
		$timestamp     = \DateTime::createFromFormat( 'U.u', $time_as_float );

		return ! empty( $timestamp ) ? (float) $timestamp->format( 'Y-m-d\TH:i:s.uP' ) : (float) 0;
	}

	/**
	 * Filter the headers that WPGraphQL returns to include headers that indicate the WPGraphQL
	 * server supports Apollo Tracing and Credentials
	 *
	 * @param string[] $headers The headers to return
	 *
	 * @return string[]
	 */
	public function return_tracing_headers( array $headers ) {
		$headers[] = 'X-Insights-Include-Tracing';
		$headers[] = 'X-Apollo-Tracing';
		$headers[] = 'Credentials';

		return $headers;
	}

	/**
	 * Filter the results of the GraphQL Response to include the Query Log
	 *
	 * @param mixed|array<string,mixed>|object $response       The response of the GraphQL Request
	 *
	 * @return mixed $response
	 */
	public function add_tracing_to_response_extensions( $response ) {

		// Get the trace
		$trace = $this->get_trace();

		// If a specific capability is set for tracing and the requesting user
		// doesn't have the capability, return the unmodified response
		if ( ! $this->user_can_see_trace_data() ) {
			return $response;
		}

		if ( is_array( $response ) ) {
			$response['extensions']['tracing'] = $trace;
		} elseif ( is_object( $response ) ) {
			// @phpstan-ignore-next-line
			$response->extensions['tracing'] = $trace;
		}

		return $response;
	}

	/**
	 * Returns the request duration calculated from the start and end times
	 *
	 * @return float|int
	 */
	public function get_request_duration() {
		return ( $this->request_end_microtime - $this->request_start_microtime ) * 1000000;
	}

	/**
	 * Determine if the requesting user can see trace data
	 */
	public function user_can_see_trace_data(): bool {
		$can_see = false;

		// If logs are disabled, user cannot see logs
		if ( ! $this->tracing_enabled ) {
			$can_see = false;
		} elseif ( 'any' === $this->tracing_user_role ) {
			// If "any" is the selected role, anyone can see the logs
			$can_see = true;
		} else {
			// Get the current users roles
			$user = wp_get_current_user();

			// If the user doesn't have roles or the selected role isn't one the user has, the user cannot see roles.
			if ( in_array( $this->tracing_user_role, $user->roles, true ) ) {
				$can_see = true;
			}
		}

		/**
		 * Filter whether the logs can be seen in the request results or not
		 *
		 * @param bool $can_see Whether the requester can see the logs or not
		 */
		return apply_filters( 'graphql_user_can_see_trace_data', $can_see );
	}

	/**
	 * Get the trace to add to the response
	 *
	 * @return array<string,mixed>
	 */
	public function get_trace(): array {

		// Compile the trace to return with the GraphQL Response
		$trace = [
			'version'   => absint( $this->trace_spec_version ),
			'startTime' => (float) $this->request_start_microtime,
			'endTime'   => (float) $this->request_end_microtime,
			'duration'  => absint( $this->get_request_duration() ),
			'execution' => [
				'resolvers' => $this->trace_logs,
			],
		];

		/**
		 * Filter the trace
		 *
		 * @param array<string,mixed>      $trace     The trace to return
		 * @param \WPGraphQL\Utils\Tracing $instance The Tracing class instance
		 */
		return apply_filters( 'graphql_tracing_response', $trace, $this );
	}
}


// File: wp-graphql\src\Utils\Utils.php
<?php

namespace WPGraphQL\Utils;

use GraphQLRelay\Relay;

class Utils {

	/**
	 * Given a GraphQL Query string, return a hash
	 *
	 * @param string $query The Query String to hash
	 *
	 * @return string|null
	 */
	public static function get_query_id( string $query ) {

		/**
		 * Filter the hash algorithm to allow different algorithms.
		 *
		 * @string $algorithm Default is sha256. Possible values are those that work with the PHP hash() function. See: https://www.php.net/manual/en/function.hash-algos.php
		 */
		$hash_algorithm = apply_filters( 'graphql_query_id_hash_algorithm', 'sha256' );

		try {
			$query_ast = \GraphQL\Language\Parser::parse( $query );
			$query     = \GraphQL\Language\Printer::doPrint( $query_ast );
			return hash( $hash_algorithm, $query );
		} catch ( \Throwable $exception ) {
			return null;
		}
	}

	/**
	 * Maps new input query args and sanitizes the input
	 *
	 * @param mixed|mixed[]|string $args The raw query args from the GraphQL query
	 * @param mixed|mixed[]|string $map  The mapping of where each of the args should go
	 * @param string[]             $skip Fields to skipped and not be added to the output array.
	 *
	 * @return array<string,mixed>
	 * @since  0.5.0
	 */
	public static function map_input( $args, $map, $skip = [] ) {
		if ( ! is_array( $args ) || ! is_array( $map ) ) {
			return [];
		}

		$query_args = [];

		foreach ( $args as $arg => $value ) {
			if ( [] !== $skip && in_array( $arg, $skip, true ) ) {
				continue;
			}

			if ( is_array( $value ) && ! empty( $value ) ) {
				$value = array_map(
					static function ( $value ) {
						if ( is_string( $value ) ) {
							$value = sanitize_text_field( $value );
						}

						return $value;
					},
					$value
				);
			} elseif ( is_string( $value ) ) {
				$value = sanitize_text_field( $value );
			}

			if ( array_key_exists( $arg, $map ) ) {
				$query_args[ $map[ $arg ] ] = $value;
			} else {
				$query_args[ $arg ] = $value;
			}
		}

		return $query_args;
	}

	/**
	 * Checks the post_date_gmt or modified_gmt and prepare any post or
	 * modified date for single post output.
	 *
	 * @param string            $date_gmt GMT publication time.
	 * @param mixed|string|null $date Optional. Local publication time. Default null.
	 *
	 * @return string|null ISO8601/RFC3339 formatted datetime.
	 * @since 4.7.0
	 */
	public static function prepare_date_response( string $date_gmt, $date = null ) {
		// Use the date if passed.
		if ( isset( $date ) ) {
			return mysql_to_rfc3339( $date );
		}
		// Return null if $date_gmt is empty/zeros.
		if ( '0000-00-00 00:00:00' === $date_gmt ) {
			return null;
		}

		// Return the formatted datetime.
		return mysql_to_rfc3339( $date_gmt );
	}

	/**
	 * Format a GraphQL name according to the GraphQL spec.
	 *
	 * Per the GraphQL spec, characters in names are limited to Latin ASCII letter, digits, or underscores.
	 *
	 * @see http://spec.graphql.org/draft/#sec-Names
	 *
	 * @param string $name The name to format.
	 * @param string $replacement The replacement character for invalid characters. Defaults to '_'.
	 * @param string $regex The regex to use to match invalid characters. Defaults to '/[^A-Za-z0-9_]/i'.
	 *
	 * @since v1.17.0
	 */
	public static function format_graphql_name( string $name, string $replacement = '_', string $regex = '/[^A-Za-z0-9_]/i' ): string {
		if ( empty( $name ) ) {
			return '';
		}

		/**
		 * Filter to manually format a GraphQL name according to custom rules.
		 *
		 * If anything other than null is returned, the result will be used for the name instead of the standard regex.
		 *
		 * Useful for providing custom transliteration rules that will convert non ASCII characters to ASCII.
		 *
		 * @param string|null $formatted_name The name to format. If not null, the result will be returned as the formatted name.
		 * @param string $original_name       The name to format.
		 * @param string $replacement         The replacement character for invalid characters. Defaults to '_'.
		 * @param string $regex               The regex to use to match invalid characters. Defaults to '/[^A-Za-z0-9_]/i'.
		 *
		 * @return string|null
		 */
		$pre_format_name = apply_filters( 'graphql_pre_format_name', null, $name, $replacement, $regex );

		// Check whether the filter is being used (correctly).
		if ( ! empty( $pre_format_name ) && is_string( $pre_format_name ) ) {
			// Don't trust the filter to return a formatted string.
			$name = trim( sanitize_text_field( $pre_format_name ) );
		} else {
			// Throw a warning if someone is using the filter incorrectly.
			if ( null !== $pre_format_name ) {
				graphql_debug(
					esc_html__( 'The `graphql_pre_format_name` filter must return a string or null.', 'wp-graphql' ),
					[
						'type'          => 'INVALID_GRAPHQL_NAME',
						'original_name' => esc_html( $name ),
					]
				);
			}

			// Remove all non-alphanumeric characters.
			$name = preg_replace( $regex, $replacement, $name );
		}

		if ( empty( $name ) ) {
			return '';
		}

		// Replace multiple consecutive leading underscores with a single underscore, since those are reserved.
		$name = preg_replace( '/^_+/', '_', trim( $name ) );

		return ! empty( $name ) ? $name : '';
	}

	/**
	 * Given a field name, formats it for GraphQL
	 *
	 * @param string $field_name         The field name to format
	 * @param bool   $allow_underscores  Whether the field should be formatted with underscores allowed. Default false.
	 */
	public static function format_field_name( string $field_name, bool $allow_underscores = false ): string {
		// Bail if empty.
		if ( empty( $field_name ) ) {
			return '';
		}

		$formatted_field_name = graphql_format_name( $field_name, '_', '/[^a-zA-Z0-9 -]/' );

		// If the formatted name is empty, we want to return the original value so it displays in the error.
		if ( empty( $formatted_field_name ) ) {
			return $field_name;
		}

		// underscores are allowed by GraphQL, but WPGraphQL has historically
		// stripped them when formatting field names.
		// The $allow_underscores argument allows functions to opt-in to allowing underscores
		if ( true !== $allow_underscores ) {
			// uppercase words separated by an underscore, then replace the underscores with a space
			$formatted_field_name = lcfirst( str_replace( '_', ' ', ucwords( $formatted_field_name, '_' ) ) );
		}

		// uppercase words separated by a dash, then replace the dashes with a space
		$formatted_field_name = lcfirst( str_replace( '-', ' ', ucwords( $formatted_field_name, '-' ) ) );

		// uppercace words separated by a space, and replace spaces with no space
		$formatted_field_name = lcfirst( str_replace( ' ', '', ucwords( $formatted_field_name, ' ' ) ) );

		// Field names should be lcfirst.
		return lcfirst( $formatted_field_name );
	}

	/**
	 * Given a type name, formats it for GraphQL
	 *
	 * @param string $type_name The type name to format
	 *
	 * @return string
	 */
	public static function format_type_name( $type_name ) {
		return ucfirst( self::format_field_name( $type_name ) );
	}

	/**
	 * Returns a GraphQL type name for a given WordPress template name.
	 *
	 * If the template name has no ASCII characters, the file name will be used instead.
	 *
	 * @param string $name The template name.
	 * @param string $file The file name.
	 * @return string The formatted type name. If the name is empty, an empty string will be returned.
	 */
	public static function format_type_name_for_wp_template( string $name, string $file ): string {
		$name = ucwords( $name );
		// Strip out not ASCII characters.
		$name = graphql_format_name( $name, '', '/[^\w]/' );

		// If replaced_name is empty, use the file name.
		if ( empty( $name ) ) {
			$file_parts    = explode( '.', $file );
			$file_name     = ! empty( $file_parts[0] ) ? self::format_type_name( $file_parts[0] ) : '';
			$replaced_name = ! empty( $file_name ) ? graphql_format_name( $file_name, '', '/[^\w]/' ) : '';

			$name = ! empty( $replaced_name ) ? $replaced_name : $name;
		}

		// If the name is still empty, we don't have a valid type.
		if ( empty( $name ) ) {
			return '';
		}

		// Maybe prefix the name with "Template_".
		if ( preg_match( '/^\d/', $name ) || false === strpos( strtolower( $name ), 'template' ) ) {
			$name = 'Template_' . $name;
		}

		return $name;
	}

	/**
	 * Helper function that defines the allowed HTML to use on the Settings pages
	 *
	 * @return array<string,array<string,mixed>>
	 */
	public static function get_allowed_wp_kses_html() {
		$allowed_atts = [
			'align'      => [],
			'class'      => [],
			'type'       => [],
			'id'         => [],
			'dir'        => [],
			'lang'       => [],
			'style'      => [],
			'xml:lang'   => [],
			'src'        => [],
			'alt'        => [],
			'href'       => [],
			'rel'        => [],
			'rev'        => [],
			'target'     => [],
			'novalidate' => [],
			'value'      => [],
			'name'       => [],
			'tabindex'   => [],
			'action'     => [],
			'method'     => [],
			'for'        => [],
			'width'      => [],
			'height'     => [],
			'data'       => [],
			'title'      => [],
			'checked'    => [],
			'disabled'   => [],
			'selected'   => [],
		];

		return [
			'form'     => $allowed_atts,
			'label'    => $allowed_atts,
			'input'    => $allowed_atts,
			'textarea' => $allowed_atts,
			'iframe'   => $allowed_atts,
			'script'   => $allowed_atts,
			'select'   => $allowed_atts,
			'option'   => $allowed_atts,
			'style'    => $allowed_atts,
			'strong'   => $allowed_atts,
			'small'    => $allowed_atts,
			'table'    => $allowed_atts,
			'span'     => $allowed_atts,
			'abbr'     => $allowed_atts,
			'code'     => $allowed_atts,
			'pre'      => $allowed_atts,
			'div'      => $allowed_atts,
			'img'      => $allowed_atts,
			'h1'       => $allowed_atts,
			'h2'       => $allowed_atts,
			'h3'       => $allowed_atts,
			'h4'       => $allowed_atts,
			'h5'       => $allowed_atts,
			'h6'       => $allowed_atts,
			'ol'       => $allowed_atts,
			'ul'       => $allowed_atts,
			'li'       => $allowed_atts,
			'em'       => $allowed_atts,
			'hr'       => $allowed_atts,
			'br'       => $allowed_atts,
			'tr'       => $allowed_atts,
			'td'       => $allowed_atts,
			'p'        => $allowed_atts,
			'a'        => $allowed_atts,
			'b'        => $allowed_atts,
			'i'        => $allowed_atts,
		];
	}

	/**
	 * Helper function to get the WordPress database ID from a GraphQL ID type input.
	 *
	 * Returns false if not a valid ID.
	 *
	 * @param int|string $id The ID from the input args. Can be either the database ID (as either a string or int) or the global Relay ID.
	 *
	 * @return int|false
	 */
	public static function get_database_id_from_id( $id ) {
		// If we already have the database ID, send it back as an integer.
		if ( is_numeric( $id ) ) {
			return absint( $id );
		}

		$id_parts = Relay::fromGlobalId( $id );

		return ! empty( $id_parts['id'] ) && is_numeric( $id_parts['id'] ) ? absint( $id_parts['id'] ) : false;
	}

	/**
	 * Get the node type from the ID
	 *
	 * @param int|string $id The encoded Node ID.
	 *
	 * @return ?string
	 */
	public static function get_node_type_from_id( $id ) {
		if ( is_numeric( $id ) ) {
			return null;
		}

		$id_parts = Relay::fromGlobalId( $id );
		return $id_parts['type'] ?: null;
	}

	/**
	 * Given a WP Post or post ID, this method attempts to resolve a preview post ID.
	 *
	 * @param int|\WP_Post $post The WP Post object or Post ID
	 *
	 * @return int A preview post ID if one exists, the current post ID if one doesn't exist.
	 * @since 1.18.0
	 */
	public static function get_post_preview_id( $post ): int {
		$post_id = is_object( $post ) ? $post->ID : $post;

		$revisions = wp_get_post_revisions(
			$post_id,
			[
				'posts_per_page' => 1,
				'fields'         => 'ids',
				'check_enabled'  => false,
			]
		);

		$post_id = ! empty( $revisions ) ? array_values( $revisions )[0] : $post_id;

		return is_object( $post_id ) ? (int) $post_id->ID : (int) $post_id;
	}
}


// File: wp-graphql\vendor\autoload.php
<?php

// autoload.php @generated by Composer

if (PHP_VERSION_ID < 50600) {
    if (!headers_sent()) {
        header('HTTP/1.1 500 Internal Server Error');
    }
    $err = 'Composer 2.3.0 dropped support for autoloading on PHP <5.6 and you are running '.PHP_VERSION.', please upgrade PHP or use Composer 2.2 LTS via "composer self-update --2.2". Aborting.'.PHP_EOL;
    if (!ini_get('display_errors')) {
        if (PHP_SAPI === 'cli' || PHP_SAPI === 'phpdbg') {
            fwrite(STDERR, $err);
        } elseif (!headers_sent()) {
            echo $err;
        }
    }
    trigger_error(
        $err,
        E_USER_ERROR
    );
}

require_once __DIR__ . '/composer/autoload_real.php';

return ComposerAutoloaderInit1a3f5842150c900c52f8026a66f17617::getLoader();


// File: wp-graphql\vendor\appsero\client\src\Client.php
<?php
namespace Appsero;

/**
 * Appsero Client
 *
 * This class is necessary to set project data
 */
class Client {

    /**
     * The client version
     *
     * @var string
     */
    public $version = '1.2.0';

    /**
     * Hash identifier of the plugin
     *
     * @var string
     */
    public $hash;

    /**
     * Name of the plugin
     *
     * @var string
     */
    public $name;

    /**
     * The plugin/theme file path
     * @example .../wp-content/plugins/test-slug/test-slug.php
     *
     * @var string
     */
    public $file;

    /**
     * Main plugin file
     * @example test-slug/test-slug.php
     *
     * @var string
     */
    public $basename;

    /**
     * Slug of the plugin
     * @example test-slug
     *
     * @var string
     */
    public $slug;

    /**
     * The project version
     *
     * @var string
     */
    public $project_version;

    /**
     * The project type
     *
     * @var string
     */
    public $type;

    /**
     * textdomain
     *
     * @var string
     */
    public $textdomain;

    /**
     * The Object of Insights Class
     *
     * @var object
     */
    private $insights;

    /**
     * The Object of Updater Class
     *
     * @var object
     */
    private $updater;

    /**
     * The Object of License Class
     *
     * @var object
     */
    private $license;

	/**
     * Initialize the class
     *
     * @param string  $hash hash of the plugin
     * @param string  $name readable name of the plugin
     * @param string  $file main plugin file path
     */
    public function __construct( $hash, $name, $file ) {
        $this->hash = $hash;
        $this->name = $name;
        $this->file = $file;

        $this->set_basename_and_slug();
    }

    /**
     * Initialize insights class
     *
     * @return Appsero\Insights
     */
    public function insights() {

        if ( ! class_exists( __NAMESPACE__ . '\Insights') ) {
            require_once __DIR__ . '/Insights.php';
        }

        // if already instantiated, return the cached one
        if ( $this->insights ) {
            return $this->insights;
        }

        $this->insights = new Insights( $this );

        return $this->insights;
    }

    /**
     * Initialize plugin/theme updater
     *
     * @return Appsero\Updater
     */
    public function updater() {

        if ( ! class_exists( __NAMESPACE__ . '\Updater') ) {
            require_once __DIR__ . '/Updater.php';
        }

        // if already instantiated, return the cached one
        if ( $this->updater ) {
            return $this->updater;
        }

        $this->updater = new Updater( $this );

        return $this->updater;
    }

    /**
     * Initialize license checker
     *
     * @return Appsero\License
     */
    public function license() {

        if ( ! class_exists( __NAMESPACE__ . '\License') ) {
            require_once __DIR__ . '/License.php';
        }

        // if already instantiated, return the cached one
        if ( $this->license ) {
            return $this->license;
        }

        $this->license = new License( $this );

        return $this->license;
    }

    /**
     * API Endpoint
     *
     * @return string
     */
    public function endpoint() {
        $endpoint = apply_filters( 'appsero_endpoint', 'https://api.appsero.com' );

        return trailingslashit( $endpoint );
    }

    /**
     * Set project basename, slug and version
     *
     * @return void
     */
    protected function set_basename_and_slug() {

        if ( strpos( $this->file, WP_CONTENT_DIR . '/themes/' ) === false ) {
            $this->basename = plugin_basename( $this->file );

            list( $this->slug, $mainfile) = explode( '/', $this->basename );

            require_once ABSPATH . 'wp-admin/includes/plugin.php';

            $plugin_data = get_plugin_data( $this->file );

            $this->project_version = $plugin_data['Version'];
            $this->type = 'plugin';
        } else {
            $this->basename = str_replace( WP_CONTENT_DIR . '/themes/', '', $this->file );

            list( $this->slug, $mainfile) = explode( '/', $this->basename );

            $theme = wp_get_theme( $this->slug );

            $this->project_version = $theme->version;
            $this->type = 'theme';
        }

        $this->textdomain = $this->slug;
    }

    /**
     * Send request to remote endpoint
     *
     * @param  array  $params
     * @param  string $route
     *
     * @return array|WP_Error   Array of results including HTTP headers or WP_Error if the request failed.
     */
    public function send_request( $params, $route, $blocking = false ) {
        $url = $this->endpoint() . $route;

        $headers = array(
            'user-agent' => 'Appsero/' . md5( esc_url( home_url() ) ) . ';',
            'Accept'     => 'application/json',
        );

        $response = wp_remote_post( $url, array(
            'method'      => 'POST',
            'timeout'     => 30,
            'redirection' => 5,
            'httpversion' => '1.0',
            'blocking'    => $blocking,
            'headers'     => $headers,
            'body'        => array_merge( $params, array( 'client' => $this->version ) ),
            'cookies'     => array()
        ) );

        return $response;
    }

    /**
     * Check if the current server is localhost
     *
     * @return boolean
     */
    public function is_local_server() {
        $is_local = in_array( $_SERVER['REMOTE_ADDR'], array( '127.0.0.1', '::1' ) );

        return apply_filters( 'appsero_is_local', $is_local );
    }

    /**
     * Translate function _e()
     */
    public function _etrans( $text ) {
        call_user_func( '_e', $text, $this->textdomain );
    }

    /**
     * Translate function __()
     */
    public function __trans( $text ) {
        return call_user_func( '__', $text, $this->textdomain );
    }

    /**
     * Set project textdomain
     */
    public function set_textdomain( $textdomain ) {
        $this->textdomain = $textdomain;
    }
}


// File: wp-graphql\vendor\appsero\client\src\Insights.php
<?php
namespace Appsero;

/**
 * Appsero Insights
 *
 * This is a tracker class to track plugin usage based on if the customer has opted in.
 * No personal information is being tracked by this class, only general settings, active plugins, environment details
 * and admin email.
 */
class Insights {

    /**
     * The notice text
     *
     * @var string
     */
    public $notice;

    /**
     * Wheather to the notice or not
     *
     * @var boolean
     */
    protected $show_notice = true;

    /**
     * If extra data needs to be sent
     *
     * @var array
     */
    protected $extra_data = array();

    /**
     * AppSero\Client
     *
     * @var object
     */
    protected $client;

    /**
     * @var boolean
     */
    private $plugin_data = false;


    /**
     * Initialize the class
     *
     * @param      $client
     * @param null $name
     * @param null $file
     */
    public function __construct( $client, $name = null, $file = null ) {

        if ( is_string( $client ) && ! empty( $name ) && ! empty( $file ) ) {
            $client = new Client( $client, $name, $file );
        }

        if ( is_object( $client ) && is_a( $client, 'Appsero\Client' ) ) {
            $this->client = $client;
        }
    }

    /**
     * Don't show the notice
     *
     * @return \self
     */
    public function hide_notice() {
        $this->show_notice = false;

        return $this;
    }

    /**
     * Add plugin data if needed
     *
     * @return \self
     */
    public function add_plugin_data() {
        $this->plugin_data = true;

        return $this;
    }

    /**
     * Add extra data if needed
     *
     * @param array $data
     *
     * @return \self
     */
    public function add_extra( $data = array() ) {
        $this->extra_data = $data;

        return $this;
    }

    /**
     * Set custom notice text
     *
     * @param  string $text
     *
     * @return \self
     */
    public function notice($text='' ) {
        $this->notice = $text;

        return $this;
    }

    /**
     * Initialize insights
     *
     * @return void
     */
    public function init() {
        if ( $this->client->type == 'plugin' ) {
            $this->init_plugin();
        } else if ( $this->client->type == 'theme' ) {
            $this->init_theme();
        }
    }

    /**
     * Initialize theme hooks
     *
     * @return void
     */
    public function init_theme() {
        $this->init_common();

        add_action( 'switch_theme', array( $this, 'deactivation_cleanup' ) );
        add_action( 'switch_theme', array( $this, 'theme_deactivated' ), 12, 3 );
    }

    /**
     * Initialize plugin hooks
     *
     * @return void
     */
    public function init_plugin() {
        // plugin deactivate popup
        if ( ! $this->is_local_server() ) {
            add_filter( 'plugin_action_links_' . $this->client->basename, array( $this, 'plugin_action_links' ) );
            add_action( 'admin_footer', array( $this, 'deactivate_scripts' ) );
        }

        $this->init_common();

        register_activation_hook( $this->client->file, array( $this, 'activate_plugin' ) );
        register_deactivation_hook( $this->client->file, array( $this, 'deactivation_cleanup' ) );
    }

    /**
     * Initialize common hooks
     *
     * @return void
     */
    protected function init_common() {

        if ( $this->show_notice ) {
            // tracking notice
            add_action( 'admin_notices', array( $this, 'admin_notice' ) );
        }

        add_action( 'admin_init', array( $this, 'handle_optin_optout' ) );

        // uninstall reason
        add_action( 'wp_ajax_' . $this->client->slug . '_submit-uninstall-reason', array( $this, 'uninstall_reason_submission' ) );

        // cron events
        add_filter( 'cron_schedules', array( $this, 'add_weekly_schedule' ) );
        add_action( $this->client->slug . '_tracker_send_event', array( $this, 'send_tracking_data' ) );
        // add_action( 'admin_init', array( $this, 'send_tracking_data' ) ); // test
    }

    /**
     * Send tracking data to AppSero server
     *
     * @param  boolean  $override
     *
     * @return void
     */
    public function send_tracking_data( $override = false ) {
        if ( ! $this->tracking_allowed() && ! $override ) {
            return;
        }

        // Send a maximum of once per week
        $last_send = $this->get_last_send();

        if ( $last_send && $last_send > strtotime( '-1 week' ) ) {
            return;
        }

        $tracking_data = $this->get_tracking_data();

        $response = $this->client->send_request( $tracking_data, 'track' );

        update_option( $this->client->slug . '_tracking_last_send', time() );
    }

    /**
     * Get the tracking data points
     *
     * @return array
     */
    protected function get_tracking_data() {
        $all_plugins = $this->get_all_plugins();

        $users = get_users( array(
            'role'    => 'administrator',
            'orderby' => 'ID',
            'order'   => 'ASC',
            'number'  => 1,
            'paged'   => 1,
        ) );

        $admin_user =  ( is_array( $users ) && ! empty( $users ) ) ? $users[0] : false;
        $first_name = $last_name = '';

        if ( $admin_user ) {
            $first_name = $admin_user->first_name ? $admin_user->first_name : $admin_user->display_name;
            $last_name  = $admin_user->last_name;
        }

        $data = array(
            'url'              => esc_url( home_url() ),
            'site'             => $this->get_site_name(),
            'admin_email'      => get_option( 'admin_email' ),
            'first_name'       => $first_name,
            'last_name'        => $last_name,
            'hash'             => $this->client->hash,
            'server'           => $this->get_server_info(),
            'wp'               => $this->get_wp_info(),
            'users'            => $this->get_user_counts(),
            'active_plugins'   => count( $all_plugins['active_plugins'] ),
            'inactive_plugins' => count( $all_plugins['inactive_plugins'] ),
            'ip_address'       => $this->get_user_ip_address(),
            'project_version'  => $this->client->project_version,
            'tracking_skipped' => false,
            'is_local'         => $this->is_local_server(),
        );

        // Add Plugins
        if ($this->plugin_data) {
            
            $plugins_data = array();

            foreach ($all_plugins['active_plugins'] as $slug => $plugin) {
                $slug = strstr($slug, '/', true);
                if (! $slug) {
                    continue;
                }

                $plugins_data[ $slug ] = array(
                    'name' => isset($plugin['name']) ? $plugin['name'] : '',
                    'version' => isset($plugin['version']) ? $plugin['version'] : '',
                );
            }

            if (array_key_exists($this->client->slug, $plugins_data)) {
                unset($plugins_data[$this->client->slug]);
            }
            
            $data['plugins'] = $plugins_data;
        }

        // Add metadata
        if ( $extra = $this->get_extra_data() ) {
            $data['extra'] = $extra;
        }

        // Check this has previously skipped tracking
        $skipped = get_option( $this->client->slug . '_tracking_skipped' );

        if ( $skipped === 'yes' ) {
            delete_option( $this->client->slug . '_tracking_skipped' );

            $data['tracking_skipped'] = true;
        }

        return apply_filters( $this->client->slug . '_tracker_data', $data );
    }

    /**
     * If a child class wants to send extra data
     *
     * @return mixed
     */
    protected function get_extra_data() {
        if ( is_callable( $this->extra_data ) ) {
            return call_user_func( $this->extra_data );
        }

        if ( is_array( $this->extra_data ) ) {
            return $this->extra_data;
        }

        return array();
    }

    /**
     * Explain the user which data we collect
     *
     * @return array
     */
    protected function data_we_collect() {
        $data = array(
            'Server environment details (php, mysql, server, WordPress versions)',
            'Number of users in your site',
            'Site language',
            'Number of active and inactive plugins',
            'Site name and URL',
            'Your name and email address',
        );

        if ($this->plugin_data) { 
            array_splice($data, 4, 0, ["active plugins' name"]);
        }

        return $data;
    }

    /**
     * Check if the user has opted into tracking
     *
     * @return bool
     */
    public function tracking_allowed() {
        $allow_tracking = get_option( $this->client->slug . '_allow_tracking', 'no' );

        return $allow_tracking == 'yes';
    }

    /**
     * Get the last time a tracking was sent
     *
     * @return false|string
     */
    private function get_last_send() {
        return get_option( $this->client->slug . '_tracking_last_send', false );
    }

    /**
     * Check if the notice has been dismissed or enabled
     *
     * @return boolean
     */
    public function notice_dismissed() {
        $hide_notice = get_option( $this->client->slug . '_tracking_notice', null );

        if ( 'hide' == $hide_notice ) {
            return true;
        }

        return false;
    }

    /**
     * Check if the current server is localhost
     *
     * @return boolean
     */
    private function is_local_server() {

        $host       = isset( $_SERVER['HTTP_HOST'] ) ? $_SERVER['HTTP_HOST'] : 'localhost';
        $ip         = isset( $_SERVER['SERVER_ADDR'] ) ? $_SERVER['SERVER_ADDR'] : '127.0.0.1';
        $is_local   = false;

        if( in_array( $ip,array( '127.0.0.1', '::1' ) )
            || ! strpos( $host, '.' )
            || in_array( strrchr( $host, '.' ), array( '.test', '.testing', '.local', '.localhost', '.localdomain' ) )
        ) {
            $is_local = true;
        }

        return apply_filters( 'appsero_is_local', $is_local );
    }

    /**
     * Schedule the event weekly
     *
     * @return void
     */
    private function schedule_event() {
        $hook_name = $this->client->slug . '_tracker_send_event';

        if ( ! wp_next_scheduled( $hook_name ) ) {
            wp_schedule_event( time(), 'weekly', $hook_name );
        }
    }

    /**
     * Clear any scheduled hook
     *
     * @return void
     */
    private function clear_schedule_event() {
        wp_clear_scheduled_hook( $this->client->slug . '_tracker_send_event' );
    }

    /**
     * Display the admin notice to users that have not opted-in or out
     *
     * @return void
     */
    public function admin_notice() {

        if ( $this->notice_dismissed() ) {
            return;
        }

        if ( $this->tracking_allowed() ) {
            return;
        }

        if ( ! current_user_can( 'manage_options' ) ) {
            return;
        }

        // don't show tracking if a local server
        if ( $this->is_local_server() ) {
            return;
        }

        $optin_url  = add_query_arg( $this->client->slug . '_tracker_optin', 'true' );
        $optout_url = add_query_arg( $this->client->slug . '_tracker_optout', 'true' );

        if ( empty( $this->notice ) ) {
            $notice = sprintf( $this->client->__trans( 'Want to help make <strong>%1$s</strong> even more awesome? Allow %1$s to collect non-sensitive diagnostic data and usage information.' ), $this->client->name );
        } else {
            $notice = $this->notice;
        }

        $policy_url = 'https://' . 'appsero.com/privacy-policy/';

        $notice .= ' (<a class="' . $this->client->slug . '-insights-data-we-collect" href="#">' . $this->client->__trans( 'what we collect' ) . '</a>)';
        $notice .= '<p class="description" style="display:none;">' . implode( ', ', $this->data_we_collect() ) . '. No sensitive data is tracked. ';
        $notice .= 'We are using Appsero to collect your data. <a href="' . $policy_url . '" target="_blank">Learn more</a> about how Appsero collects and handle your data.</p>';

        echo '<div class="updated"><p>';
            echo $notice;
            echo '</p><p class="submit">';
            echo '&nbsp;<a href="' . esc_url( $optin_url ) . '" class="button-primary button-large">' . $this->client->__trans( 'Allow' ) . '</a>';
            echo '&nbsp;<a href="' . esc_url( $optout_url ) . '" class="button-secondary button-large">' . $this->client->__trans( 'No thanks' ) . '</a>';
        echo '</p></div>';

        echo "<script type='text/javascript'>jQuery('." . $this->client->slug . "-insights-data-we-collect').on('click', function(e) {
                e.preventDefault();
                jQuery(this).parents('.updated').find('p.description').slideToggle('fast');
            });
            </script>
        ";
    }

    /**
     * handle the optin/optout
     *
     * @return void
     */
    public function handle_optin_optout() {

        if ( isset( $_GET[ $this->client->slug . '_tracker_optin' ] ) && $_GET[ $this->client->slug . '_tracker_optin' ] == 'true' ) {
            $this->optin();

            wp_redirect( remove_query_arg( $this->client->slug . '_tracker_optin' ) );
            exit;
        }

        if ( isset( $_GET[ $this->client->slug . '_tracker_optout' ] ) && $_GET[ $this->client->slug . '_tracker_optout' ] == 'true' ) {
            $this->optout();

            wp_redirect( remove_query_arg( $this->client->slug . '_tracker_optout' ) );
            exit;
        }
    }

    /**
     * Tracking optin
     *
     * @return void
     */
    public function optin() {
        update_option( $this->client->slug . '_allow_tracking', 'yes' );
        update_option( $this->client->slug . '_tracking_notice', 'hide' );

        $this->clear_schedule_event();
        $this->schedule_event();
        $this->send_tracking_data();
    }

    /**
     * Optout from tracking
     *
     * @return void
     */
    public function optout() {
        update_option( $this->client->slug . '_allow_tracking', 'no' );
        update_option( $this->client->slug . '_tracking_notice', 'hide' );

        $this->send_tracking_skipped_request();

        $this->clear_schedule_event();
    }

    /**
     * Get the number of post counts
     *
     * @param  string  $post_type
     *
     * @return integer
     */
    public function get_post_count( $post_type ) {
        global $wpdb;

        return (int) $wpdb->get_var( "SELECT count(ID) FROM $wpdb->posts WHERE post_type = '$post_type' and post_status = 'publish'");
    }

    /**
     * Get server related info.
     *
     * @return array
     */
    private static function get_server_info() {
        global $wpdb;

        $server_data = array();

        if ( isset( $_SERVER['SERVER_SOFTWARE'] ) && ! empty( $_SERVER['SERVER_SOFTWARE'] ) ) {
            $server_data['software'] = $_SERVER['SERVER_SOFTWARE'];
        }

        if ( function_exists( 'phpversion' ) ) {
            $server_data['php_version'] = phpversion();
        }

        $server_data['mysql_version']        = $wpdb->db_version();

        $server_data['php_max_upload_size']  = size_format( wp_max_upload_size() );
        $server_data['php_default_timezone'] = date_default_timezone_get();
        $server_data['php_soap']             = class_exists( 'SoapClient' ) ? 'Yes' : 'No';
        $server_data['php_fsockopen']        = function_exists( 'fsockopen' ) ? 'Yes' : 'No';
        $server_data['php_curl']             = function_exists( 'curl_init' ) ? 'Yes' : 'No';

        return $server_data;
    }

    /**
     * Get WordPress related data.
     *
     * @return array
     */
    private function get_wp_info() {
        $wp_data = array();

        $wp_data['memory_limit'] = WP_MEMORY_LIMIT;
        $wp_data['debug_mode']   = ( defined('WP_DEBUG') && WP_DEBUG ) ? 'Yes' : 'No';
        $wp_data['locale']       = get_locale();
        $wp_data['version']      = get_bloginfo( 'version' );
        $wp_data['multisite']    = is_multisite() ? 'Yes' : 'No';
        $wp_data['theme_slug']   = get_stylesheet();

        $theme = wp_get_theme( $wp_data['theme_slug'] );

        $wp_data['theme_name']    = $theme->get( 'Name' );
        $wp_data['theme_version'] = $theme->get( 'Version' );
        $wp_data['theme_uri']     = $theme->get( 'ThemeURI' );
        $wp_data['theme_author']  = $theme->get( 'Author' );

        return $wp_data;
    }

    /**
     * Get the list of active and inactive plugins
     *
     * @return array
     */
    private function get_all_plugins() {
        // Ensure get_plugins function is loaded
        if ( ! function_exists( 'get_plugins' ) ) {
            include ABSPATH . '/wp-admin/includes/plugin.php';
        }

        $plugins             = get_plugins();
        $active_plugins_keys = get_option( 'active_plugins', array() );
        $active_plugins      = array();

        foreach ( $plugins as $k => $v ) {
            // Take care of formatting the data how we want it.
            $formatted = array();
            $formatted['name'] = strip_tags( $v['Name'] );

            if ( isset( $v['Version'] ) ) {
                $formatted['version'] = strip_tags( $v['Version'] );
            }

            if ( isset( $v['Author'] ) ) {
                $formatted['author'] = strip_tags( $v['Author'] );
            }

            if ( isset( $v['Network'] ) ) {
                $formatted['network'] = strip_tags( $v['Network'] );
            }

            if ( isset( $v['PluginURI'] ) ) {
                $formatted['plugin_uri'] = strip_tags( $v['PluginURI'] );
            }

            if ( in_array( $k, $active_plugins_keys ) ) {
                // Remove active plugins from list so we can show active and inactive separately
                unset( $plugins[$k] );
                $active_plugins[$k] = $formatted;
            } else {
                $plugins[$k] = $formatted;
            }
        }

        return array( 'active_plugins' => $active_plugins, 'inactive_plugins' => $plugins );
    }

    /**
     * Get user totals based on user role.
     *
     * @return array
     */
    public function get_user_counts() {
        $user_count          = array();
        $user_count_data     = count_users();
        $user_count['total'] = $user_count_data['total_users'];

        // Get user count based on user role
        foreach ( $user_count_data['avail_roles'] as $role => $count ) {
            if ( ! $count ) {
                continue;
            }

            $user_count[ $role ] = $count;
        }

        return $user_count;
    }

    /**
     * Add weekly cron schedule
     *
     * @param array  $schedules
     *
     * @return array
     */
    public function add_weekly_schedule( $schedules ) {

        $schedules['weekly'] = array(
            'interval' => DAY_IN_SECONDS * 7,
            'display'  => 'Once Weekly',
        );

        return $schedules;
    }

    /**
     * Plugin activation hook
     *
     * @return void
     */
    public function activate_plugin() {
        $allowed = get_option( $this->client->slug . '_allow_tracking', 'no' );

        // if it wasn't allowed before, do nothing
        if ( 'yes' !== $allowed ) {
            return;
        }

        // re-schedule and delete the last sent time so we could force send again
        $hook_name = $this->client->slug . '_tracker_send_event';
        if ( ! wp_next_scheduled( $hook_name ) ) {
            wp_schedule_event( time(), 'weekly', $hook_name );
        }

        delete_option( $this->client->slug . '_tracking_last_send' );

        $this->send_tracking_data( true );
    }

    /**
     * Clear our options upon deactivation
     *
     * @return void
     */
    public function deactivation_cleanup() {
        $this->clear_schedule_event();

        if ( 'theme' == $this->client->type ) {
            delete_option( $this->client->slug . '_tracking_last_send' );
            delete_option( $this->client->slug . '_allow_tracking' );
        }

        delete_option( $this->client->slug . '_tracking_notice' );
    }

    /**
     * Hook into action links and modify the deactivate link
     *
     * @param  array  $links
     *
     * @return array
     */
    public function plugin_action_links( $links ) {

        if ( array_key_exists( 'deactivate', $links ) ) {
            $links['deactivate'] = str_replace( '<a', '<a class="' . $this->client->slug . '-deactivate-link"', $links['deactivate'] );
        }

        return $links;
    }

    /**
     * Plugin uninstall reasons
     *
     * @return array
     */
    private function get_uninstall_reasons() {
        $reasons = array(
			array(
				'id'          => 'could-not-understand',
				'text'        => $this->client->__trans( "Couldn't understand" ),
				'placeholder' => $this->client->__trans( 'Would you like us to assist you?' ),
                'icon'        => '<svg xmlns="http://www.w3.org/2000/svg" width="23" height="23" viewBox="0 0 23 23"><g fill="none"><g fill="#3B86FF"><path d="M11.5 0C17.9 0 23 5.1 23 11.5 23 17.9 17.9 23 11.5 23 10.6 23 9.6 22.9 8.8 22.7L8.8 22.6C9.3 22.5 9.7 22.3 10 21.9 10.3 21.6 10.4 21.3 10.4 20.9 10.8 21 11.1 21 11.5 21 16.7 21 21 16.7 21 11.5 21 6.3 16.7 2 11.5 2 6.3 2 2 6.3 2 11.5 2 13 2.3 14.3 2.9 15.6 2.7 16 2.4 16.3 2.2 16.8L2.1 17.1 2.1 17.3C2 17.5 2 17.7 2 18 0.7 16.1 0 13.9 0 11.5 0 5.1 5.1 0 11.5 0ZM6 13.6C6 13.7 6.1 13.8 6.1 13.9 6.3 14.5 6.2 15.7 6.1 16.4 6.1 16.6 6 16.9 6 17.1 6 17.1 6.1 17.1 6.1 17.1 7.1 16.9 8.2 16 9.3 15.5 9.8 15.2 10.4 15 10.9 15 11.2 15 11.4 15 11.6 15.2 11.9 15.4 12.1 16 11.6 16.4 11.5 16.5 11.3 16.6 11.1 16.7 10.5 17 9.9 17.4 9.3 17.7 9 17.9 9 18.1 9.1 18.5 9.2 18.9 9.3 19.4 9.3 19.8 9.4 20.3 9.3 20.8 9 21.2 8.8 21.5 8.5 21.6 8.1 21.7 7.9 21.8 7.6 21.9 7.3 21.9L6.5 22C6.3 22 6 21.9 5.8 21.9 5 21.8 4.4 21.5 3.9 20.9 3.3 20.4 3.1 19.6 3 18.8L3 18.5C3 18.2 3 17.9 3.1 17.7L3.1 17.6C3.2 17.1 3.5 16.7 3.7 16.3 4 15.9 4.2 15.4 4.3 15 4.4 14.6 4.4 14.5 4.6 14.2 4.6 13.9 4.7 13.7 4.9 13.6 5.2 13.2 5.7 13.2 6 13.6ZM11.7 11.2C13.1 11.2 14.3 11.7 15.2 12.9 15.3 13 15.4 13.1 15.4 13.2 15.4 13.4 15.3 13.8 15.2 13.8 15 13.9 14.9 13.8 14.8 13.7 14.6 13.5 14.4 13.2 14.1 13.1 13.5 12.6 12.8 12.3 12 12.2 10.7 12.1 9.5 12.3 8.4 12.8 8.3 12.8 8.2 12.8 8.1 12.8 7.9 12.8 7.8 12.4 7.8 12.2 7.7 12.1 7.8 11.9 8 11.8 8.4 11.7 8.8 11.5 9.2 11.4 10 11.2 10.9 11.1 11.7 11.2ZM16.3 5.9C17.3 5.9 18 6.6 18 7.6 18 8.5 17.3 9.3 16.3 9.3 15.4 9.3 14.7 8.5 14.7 7.6 14.7 6.6 15.4 5.9 16.3 5.9ZM8.3 5C9.2 5 9.9 5.8 9.9 6.7 9.9 7.7 9.2 8.4 8.2 8.4 7.3 8.4 6.6 7.7 6.6 6.7 6.6 5.8 7.3 5 8.3 5Z"/></g></g></svg>'
			),
			array(
				'id'          => 'found-better-plugin',
				'text'        => $this->client->__trans( 'Found a better plugin' ),
				'placeholder' => $this->client->__trans( 'Which plugin?' ),
                'icon'        => '<svg xmlns="http://www.w3.org/2000/svg" width="23" height="23" viewBox="0 0 23 23"><g fill="none"><g fill="#3B86FF"><path d="M17.1 14L22.4 19.3C23.2 20.2 23.2 21.5 22.4 22.4 21.5 23.2 20.2 23.2 19.3 22.4L19.3 22.4 14 17.1C15.3 16.3 16.3 15.3 17.1 14L17.1 14ZM8.6 0C13.4 0 17.3 3.9 17.3 8.6 17.3 13.4 13.4 17.2 8.6 17.2 3.9 17.2 0 13.4 0 8.6 0 3.9 3.9 0 8.6 0ZM8.6 2.2C5.1 2.2 2.2 5.1 2.2 8.6 2.2 12.2 5.1 15.1 8.6 15.1 12.2 15.1 15.1 12.2 15.1 8.6 15.1 5.1 12.2 2.2 8.6 2.2ZM8.6 3.6L8.6 5C6.6 5 5 6.6 5 8.6L5 8.6 3.6 8.6C3.6 5.9 5.9 3.6 8.6 3.6L8.6 3.6Z"/></g></g></svg>',
			),
			array(
				'id'          => 'not-have-that-feature',
				'text'        => $this->client->__trans( "Missing a specific feature" ),
				'placeholder' => $this->client->__trans( 'Could you tell us more about that feature?' ),
                'icon'        => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="17" viewBox="0 0 24 17"><g fill="none"><g fill="#3B86FF"><path d="M19.4 0C19.7 0.6 19.8 1.3 19.8 2 19.8 3.2 19.4 4.4 18.5 5.3 17.6 6.2 16.5 6.7 15.2 6.7 15.2 6.7 15.2 6.7 15.2 6.7 14 6.7 12.9 6.2 12 5.3 11.2 4.4 10.7 3.3 10.7 2 10.7 1.3 10.8 0.6 11.1 0L7.6 0 7 0 6.5 0 6.5 5.7C6.3 5.6 5.9 5.3 5.6 5.1 5 4.6 4.3 4.3 3.5 4.3 3.5 4.3 3.5 4.3 3.4 4.3 1.6 4.4 0 5.9 0 7.9 0 8.6 0.2 9.2 0.5 9.7 1.1 10.8 2.2 11.5 3.5 11.5 4.3 11.5 5 11.2 5.6 10.8 6 10.5 6.3 10.3 6.5 10.2L6.5 10.2 6.5 17 6.5 17 7 17 7.6 17 22.5 17C23.3 17 24 16.3 24 15.5L24 0 19.4 0Z"/></g></g></svg>',
			),
			array(
				'id'          => 'is-not-working',
				'text'        => $this->client->__trans( 'Not working' ),
				'placeholder' => $this->client->__trans( 'Could you tell us a bit more whats not working?' ),
                'icon'        => '<svg xmlns="http://www.w3.org/2000/svg" width="23" height="23" viewBox="0 0 23 23"><g fill="none"><g fill="#3B86FF"><path d="M11.5 0C17.9 0 23 5.1 23 11.5 23 17.9 17.9 23 11.5 23 5.1 23 0 17.9 0 11.5 0 5.1 5.1 0 11.5 0ZM11.8 14.4C11.2 14.4 10.7 14.8 10.7 15.4 10.7 16 11.2 16.4 11.8 16.4 12.4 16.4 12.8 16 12.8 15.4 12.8 14.8 12.4 14.4 11.8 14.4ZM12 7C10.1 7 9.1 8.1 9 9.6L10.5 9.6C10.5 8.8 11.1 8.3 11.9 8.3 12.7 8.3 13.2 8.8 13.2 9.5 13.2 10.1 13 10.4 12.2 10.9 11.3 11.4 10.9 12 11 12.9L11 13.4 12.5 13.4 12.5 13C12.5 12.4 12.7 12.1 13.5 11.6 14.4 11.1 14.9 10.4 14.9 9.4 14.9 8 13.7 7 12 7Z"/></g></g></svg>',
			),
			array(
				'id'          => 'looking-for-other',
				'text'        => $this->client->__trans( "Not what I was looking" ),
				'placeholder' => $this->client->__trans( 'Could you tell us a bit more?' ),
                'icon'        => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="17" viewBox="0 0 24 17"><g fill="none"><g fill="#3B86FF"><path d="M23.5 9C23.5 9 23.5 8.9 23.5 8.9 23.5 8.9 23.5 8.9 23.5 8.9 23.4 8.6 23.2 8.3 23 8 22.2 6.5 20.6 3.7 19.8 2.6 18.8 1.3 17.7 0 16.1 0 15.7 0 15.3 0.1 14.9 0.2 13.8 0.6 12.6 1.2 12.3 2.7L11.7 2.7C11.4 1.2 10.2 0.6 9.1 0.2 8.7 0.1 8.3 0 7.9 0 6.3 0 5.2 1.3 4.2 2.6 3.4 3.7 1.8 6.5 1 8 0.8 8.3 0.6 8.6 0.5 8.9 0.5 8.9 0.5 8.9 0.5 8.9 0.5 8.9 0.5 9 0.5 9 0.2 9.7 0 10.5 0 11.3 0 14.4 2.5 17 5.5 17 7.3 17 8.8 16.1 9.8 14.8L14.2 14.8C15.2 16.1 16.7 17 18.5 17 21.5 17 24 14.4 24 11.3 24 10.5 23.8 9.7 23.5 9ZM5.5 15C3.6 15 2 13.2 2 11 2 8.8 3.6 7 5.5 7 7.4 7 9 8.8 9 11 9 13.2 7.4 15 5.5 15ZM18.5 15C16.6 15 15 13.2 15 11 15 8.8 16.6 7 18.5 7 20.4 7 22 8.8 22 11 22 13.2 20.4 15 18.5 15Z"/></g></g></svg>',
			),
			array(
				'id'          => 'did-not-work-as-expected',
				'text'        => $this->client->__trans( "Didn't work as expected" ),
				'placeholder' => $this->client->__trans( 'What did you expect?' ),
                'icon'        => '<svg xmlns="http://www.w3.org/2000/svg" width="23" height="23" viewBox="0 0 23 23"><g fill="none"><g fill="#3B86FF"><path d="M11.5 0C17.9 0 23 5.1 23 11.5 23 17.9 17.9 23 11.5 23 5.1 23 0 17.9 0 11.5 0 5.1 5.1 0 11.5 0ZM11.5 2C6.3 2 2 6.3 2 11.5 2 16.7 6.3 21 11.5 21 16.7 21 21 16.7 21 11.5 21 6.3 16.7 2 11.5 2ZM12.5 12.9L12.7 5 10.2 5 10.5 12.9 12.5 12.9ZM11.5 17.4C12.4 17.4 13 16.8 13 15.9 13 15 12.4 14.4 11.5 14.4 10.6 14.4 10 15 10 15.9 10 16.8 10.6 17.4 11.5 17.4Z"/></g></g></svg>',
			),
			array(
				'id'          => 'other',
				'text'        => $this->client->__trans( 'Others' ),
				'placeholder' => $this->client->__trans( 'Could you tell us a bit more?' ),
                'icon'        => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="23" viewBox="0 0 24 6"><g fill="none"><g fill="#3B86FF"><path d="M3 0C4.7 0 6 1.3 6 3 6 4.7 4.7 6 3 6 1.3 6 0 4.7 0 3 0 1.3 1.3 0 3 0ZM12 0C13.7 0 15 1.3 15 3 15 4.7 13.7 6 12 6 10.3 6 9 4.7 9 3 9 1.3 10.3 0 12 0ZM21 0C22.7 0 24 1.3 24 3 24 4.7 22.7 6 21 6 19.3 6 18 4.7 18 3 18 1.3 19.3 0 21 0Z"/></g></g></svg>',
			),
		);

        return $reasons;
    }

    /**
     * Plugin deactivation uninstall reason submission
     *
     * @return void
     */
    public function uninstall_reason_submission() {

        if ( ! isset( $_POST['reason_id'] ) ) {
            wp_send_json_error();
        }

        if ( ! wp_verify_nonce( $_POST['nonce'], 'appsero-security-nonce' ) ) {
            wp_send_json_error( 'Nonce verification failed' );
        }

        $data                = $this->get_tracking_data();
        $data['reason_id']   = sanitize_text_field( $_POST['reason_id'] );
        $data['reason_info'] = isset( $_REQUEST['reason_info'] ) ? trim( stripslashes( $_REQUEST['reason_info'] ) ) : '';

        $this->client->send_request( $data, 'deactivate' );

        wp_send_json_success();
    }

    /**
     * Handle the plugin deactivation feedback
     *
     * @return void
     */
    public function deactivate_scripts() {
        global $pagenow;

        if ( 'plugins.php' != $pagenow ) {
            return;
        }

        $this->deactivation_modal_styles();
        $reasons = $this->get_uninstall_reasons();
        $custom_reasons = apply_filters( 'appsero_custom_deactivation_reasons', array() );
        ?>

        <div class="wd-dr-modal" id="<?php echo $this->client->slug; ?>-wd-dr-modal">
            <div class="wd-dr-modal-wrap">
                <div class="wd-dr-modal-header">
                    <h3><?php $this->client->_etrans( 'Goodbyes are always hard. If you have a moment, please let us know how we can improve.' ); ?></h3>
                </div>

                <div class="wd-dr-modal-body">
                    <ul class="wd-de-reasons">
                        <?php foreach ( $reasons as $reason ) { ?>
                            <li data-placeholder="<?php echo esc_attr( $reason['placeholder'] ); ?>">
                                <label>
                                    <input type="radio" name="selected-reason" value="<?php echo $reason['id']; ?>">
                                    <div class="wd-de-reason-icon"><?php echo $reason['icon']; ?></div>
                                    <div class="wd-de-reason-text"><?php echo $reason['text']; ?></div>
                                </label>
                            </li>
                        <?php } ?>
                    </ul>
                    <?php if ( $custom_reasons && is_array( $custom_reasons ) ) : ?>
                    <ul class="wd-de-reasons wd-de-others-reasons">
                        <?php foreach ( $custom_reasons as $reason ) { ?>
                            <li data-placeholder="<?php echo esc_attr( $reason['placeholder'] ); ?>" data-customreason="true">
                                <label>
                                    <input type="radio" name="selected-reason" value="<?php echo $reason['id']; ?>">
                                    <div class="wd-de-reason-icon"><?php echo $reason['icon']; ?></div>
                                    <div class="wd-de-reason-text"><?php echo $reason['text']; ?></div>
                                </label>
                            </li>
                        <?php } ?>
                    </ul>
                    <?php endif; ?>
                    <div class="wd-dr-modal-reason-input"><textarea></textarea></div>
                    <p class="wd-dr-modal-reasons-bottom">
                       <?php
                       echo sprintf(
	                       $this->client->__trans( 'We share your data with <a href="%1$s" target="_blank">Appsero</a> to troubleshoot problems &amp; make product improvements. <a href="%2$s" target="_blank">Learn more</a> about how Appsero handles your data.'),
	                       esc_url( 'https://appsero.com/' ),
                           esc_url( 'https://appsero.com/privacy-policy' )
                       );
                       ?>
                    </p>
                </div>

                <div class="wd-dr-modal-footer">
                    <a href="#" class="dont-bother-me wd-dr-button-secondary"><?php $this->client->_etrans( "Skip & Deactivate" ); ?></a>
                    <button class="wd-dr-button-secondary wd-dr-cancel-modal"><?php $this->client->_etrans( 'Cancel' ); ?></button>
                    <button class="wd-dr-submit-modal"><?php $this->client->_etrans( 'Submit & Deactivate' ); ?></button>
                </div>
            </div>
        </div>

        <script type="text/javascript">
            (function($) {
                $(function() {
                    var modal = $( '#<?php echo $this->client->slug; ?>-wd-dr-modal' );
                    var deactivateLink = '';

                    // Open modal
                    $( '#the-list' ).on('click', 'a.<?php echo $this->client->slug; ?>-deactivate-link', function(e) {
                        e.preventDefault();

                        modal.addClass('modal-active');
                        deactivateLink = $(this).attr('href');
                        modal.find('a.dont-bother-me').attr('href', deactivateLink).css('float', 'left');
                    });

                    // Close modal; Cancel
                    modal.on('click', 'button.wd-dr-cancel-modal', function(e) {
                        e.preventDefault();
                        modal.removeClass('modal-active');
                    });

                    // Reason change
                    modal.on('click', 'input[type="radio"]', function () {
                        var parent = $(this).parents('li');
                        var isCustomReason = parent.data('customreason');
                        var inputValue = $(this).val();

                        if ( isCustomReason ) {
                            $('ul.wd-de-reasons.wd-de-others-reasons li').removeClass('wd-de-reason-selected');
                        } else {
                            $('ul.wd-de-reasons li').removeClass('wd-de-reason-selected');

                            if ( "other" != inputValue ) {
                                $('ul.wd-de-reasons.wd-de-others-reasons').css('display', 'none');
                            }
                        }

                        // Show if has custom reasons
                        if ( "other" == inputValue ) {
                            $('ul.wd-de-reasons.wd-de-others-reasons').css('display', 'flex');
                        }

                        parent.addClass('wd-de-reason-selected');
                        $('.wd-dr-modal-reason-input').show();

                        $('.wd-dr-modal-reason-input textarea').attr('placeholder', parent.data('placeholder')).focus();
                    });

                    // Submit response
                    modal.on('click', 'button.wd-dr-submit-modal', function(e) {
                        e.preventDefault();

                        var button = $(this);

                        if ( button.hasClass('disabled') ) {
                            return;
                        }

                        var $radio = $( 'input[type="radio"]:checked', modal );
                        var $input = $('.wd-dr-modal-reason-input textarea');

                        $.ajax({
                            url: ajaxurl,
                            type: 'POST',
                            data: {
                                nonce: '<?php echo wp_create_nonce( 'appsero-security-nonce' ); ?>',
                                action: '<?php echo $this->client->slug; ?>_submit-uninstall-reason',
                                reason_id: ( 0 === $radio.length ) ? 'none' : $radio.val(),
                                reason_info: ( 0 !== $input.length ) ? $input.val().trim() : ''
                            },
                            beforeSend: function() {
                                button.addClass('disabled');
                                button.text('Processing...');
                            },
                            complete: function() {
                                window.location.href = deactivateLink;
                            }
                        });
                    });
                });
            }(jQuery));
        </script>

        <?php
    }

    /**
     * Run after theme deactivated
     * @param  string $new_name
     * @param  object $new_theme
     * @param  object $old_theme
     * @return void
     */
    public function theme_deactivated( $new_name, $new_theme, $old_theme ) {
        // Make sure this is appsero theme
        if ( $old_theme->get_template() == $this->client->slug ) {
            $this->client->send_request( $this->get_tracking_data(), 'deactivate' );
        }
    }

    /**
     * Get user IP Address
     */
    private function get_user_ip_address() {
        $response = wp_remote_get( 'https://icanhazip.com/' );

        if ( is_wp_error( $response ) ) {
            return '';
        }

        $ip = trim( wp_remote_retrieve_body( $response ) );

        if ( ! filter_var( $ip, FILTER_VALIDATE_IP ) ) {
            return '';
        }

        return $ip;
    }

    /**
     * Get site name
     */
    private function get_site_name() {
        $site_name = get_bloginfo( 'name' );

        if ( empty( $site_name ) ) {
            $site_name = get_bloginfo( 'description' );
            $site_name = wp_trim_words( $site_name, 3, '' );
        }

        if ( empty( $site_name ) ) {
            $site_name = esc_url( home_url() );
        }

        return $site_name;
    }

    /**
     * Send request to appsero if user skip to send tracking data
     */
    private function send_tracking_skipped_request() {
        $skipped = get_option( $this->client->slug . '_tracking_skipped' );

        $data = array(
            'hash'               => $this->client->hash,
            'previously_skipped' => false,
        );

        if ( $skipped === 'yes' ) {
            $data['previously_skipped'] = true;
        } else {
            update_option( $this->client->slug . '_tracking_skipped', 'yes' );
        }

        $this->client->send_request( $data, 'tracking-skipped' );
    }

    /**
     * Deactivation modal styles
     */
    private function deactivation_modal_styles() {
        ?>
        <style type="text/css">
            .wd-dr-modal {
                position: fixed;
                z-index: 99999;
                top: 0;
                right: 0;
                bottom: 0;
                left: 0;
                background: rgba(0,0,0,0.5);
                display: none;
                box-sizing: border-box;
                overflow: scroll;
            }
            .wd-dr-modal * {
                box-sizing: border-box;
            }
            .wd-dr-modal.modal-active {
                display: block;
            }
            .wd-dr-modal-wrap {
                max-width: 870px;
                width: 100%;
                position: relative;
                margin: 10% auto;
                background: #fff;
            }
            .wd-dr-modal-header {
                border-bottom: 1px solid #E8E8E8;
                padding: 20px 20px 18px 20px;
            }
            .wd-dr-modal-header h3 {
                line-height: 1.8;
                margin: 0;
                color: #4A5568;
            }
            .wd-dr-modal-body {
                padding: 5px 20px 20px 20px;
            }
            .wd-dr-modal-body .reason-input {
                margin-top: 5px;
                margin-left: 20px;
            }
            .wd-dr-modal-footer {
                border-top: 1px solid #E8E8E8;
                padding: 20px;
                text-align: right;
            }
            .wd-dr-modal-reasons-bottom {
                margin: 0;
            }
            ul.wd-de-reasons {
                display: flex;
                margin: 0 -5px 0 -5px;
                padding: 15px 0 20px 0;
            }
            ul.wd-de-reasons.wd-de-others-reasons {
                padding-top: 0;
                display: none;
            }
            ul.wd-de-reasons li {
                padding: 0 5px;
                margin: 0;
                width: 14.26%;
            }
            ul.wd-de-reasons label {
                position: relative;
                border: 1px solid #E8E8E8;
                border-radius: 4px;
                display: block;
                text-align: center;
                height: 100%;
                padding: 15px 3px 8px 3px;
            }
            ul.wd-de-reasons label:after {
                width: 0;
                height: 0;
                border-left: 8px solid transparent;
                border-right: 8px solid transparent;
                border-top: 10px solid #3B86FF;
                position: absolute;
                left: 50%;
                top: 100%;
                margin-left: -8px;
            }
            ul.wd-de-reasons label input[type="radio"] {
                position: absolute;
                left: 0;
                right: 0;
                visibility: hidden;
            }
            .wd-de-reason-text {
                color: #4A5568;
                font-size: 13px;
            }
            .wd-de-reason-icon {
                margin-bottom: 7px;
            }
            ul.wd-de-reasons li.wd-de-reason-selected label {
                background-color: #3B86FF;
                border-color: #3B86FF;
            }
            li.wd-de-reason-selected .wd-de-reason-icon svg,
            li.wd-de-reason-selected .wd-de-reason-icon svg g {
                fill: #fff;
            }
            li.wd-de-reason-selected .wd-de-reason-text {
                color: #fff;
            }
            ul.wd-de-reasons li.wd-de-reason-selected label:after {
                content: "";
            }
            .wd-dr-modal-reason-input {
                margin-bottom: 15px;
                display: none;
            }
            .wd-dr-modal-reason-input textarea {
                background: #FAFAFA;
                border: 1px solid #287EB8;
                border-radius: 4px;
                width: 100%;
                height: 100px;
                color: #524242;
                font-size: 13px;
                line-height: 1.4;
                padding: 11px 15px;
                resize: none;
            }
            .wd-dr-modal-reason-input textarea:focus {
                outline: 0 none;
                box-shadow: 0 0 0;
            }
            .wd-dr-button-secondary, .wd-dr-button-secondary:hover {
                border: 1px solid #EBEBEB;
                border-radius: 3px;
                font-size: 13px;
                line-height: 1.5;
                color: #718096;
                padding: 5px 12px;
                cursor: pointer;
                background-color: transparent;
                text-decoration: none;
            }
            .wd-dr-submit-modal, .wd-dr-submit-modal:hover {
                border: 1px solid #3B86FF;
                background-color: #3B86FF;
                border-radius: 3px;
                font-size: 13px;
                line-height: 1.5;
                color: #fff;
                padding: 5px 12px;
                cursor: pointer;
                margin-left: 4px;
            }
        </style>
        <?php
    }

}


// File: wp-graphql\vendor\appsero\client\src\License.php
<?php

namespace Appsero;

/**
 * Appsero License Checker
 *
 * This class will check, active and deactive license
 */
class License {

    /**
     * AppSero\Client
     *
     * @var object
     */
    protected $client;

    /**
     * Arguments of create menu
     *
     * @var array
     */
    protected $menu_args;

    /**
     * `option_name` of `wp_options` table
     *
     * @var string
     */
    protected $option_key;

    /**
     * Error message of HTTP request
     *
     * @var string
     */
    public $error;

    /**
     * Success message on form submit
     *
     * @var string
     */
    public $success;

    /**
     * Corn schedule hook name
     *
     * @var string
     */
    protected $schedule_hook;

    /**
     * Set value for valid licnese
     *
     * @var bool
     */
    private $is_valid_licnese = null;

    /**
     * Initialize the class
     *
     * @param Appsero\Client
     */
    public function __construct( Client $client ) {
        $this->client = $client;

        $this->option_key = 'appsero_' . md5( $this->client->slug ) . '_manage_license';

        $this->schedule_hook = $this->client->slug . '_license_check_event';

        // Creating WP Ajax Endpoint to refresh license remotely
        add_action( "wp_ajax_appsero_refresh_license_" . $this->client->hash, array( $this, 'refresh_license_api' ) );

        // Run hook to check license status daily
        add_action( $this->schedule_hook, array( $this, 'check_license_status' ) );

        // Active/Deactive corn schedule
        $this->run_schedule();
    }

    /**
     * Set the license option key.
     *
     * If someone wants to override the default generated key.
     *
     * @param string $key
     *
     * @since 1.3.0
     *
     * @return License
     */
    public function set_option_key( $key ) {
        $this->option_key = $key;

        return $this;
    }

    /**
     * Get the license key
     *
     * @since 1.3.0
     *
     * @return string|null
     */
    public function get_license() {
        return get_option( $this->option_key, null );
    }

    /**
     * Check license
     *
     * @return bool
     */
    public function check( $license_key ) {
        $route    = 'public/license/' . $this->client->hash . '/check';

        return $this->send_request( $license_key, $route );
    }

    /**
     * Active a license
     *
     * @return bool
     */
    public function activate( $license_key ) {
        $route    = 'public/license/' . $this->client->hash . '/activate';

        return $this->send_request( $license_key, $route );
    }

    /**
     * Deactivate a license
     *
     * @return bool
     */
    public function deactivate( $license_key ) {
        $route    = 'public/license/' . $this->client->hash . '/deactivate';

        return $this->send_request( $license_key, $route );
    }

    /**
     * Send common request
     *
     * @param $license_key
     * @param $route
     *
     * @return array
     */
    protected function send_request( $license_key, $route ) {
        $params = array(
            'license_key' => $license_key,
            'url'         => esc_url( home_url() ),
            'is_local'    => $this->client->is_local_server(),
        );

        $response = $this->client->send_request( $params, $route, true );

        if ( is_wp_error( $response ) ) {
            return array(
                'success' => false,
                'error'   => $response->get_error_message()
            );
        }

        $response = json_decode( wp_remote_retrieve_body( $response ), true );

        if ( empty( $response ) || isset( $response['exception'] )) {
            return array(
                'success' => false,
                'error'   => $this->client->__trans( 'Unknown error occurred, Please try again.' ),
            );
        }

        if ( isset( $response['errors'] ) && isset( $response['errors']['license_key'] ) ) {
            $response = array(
                'success' => false,
                'error'   => $response['errors']['license_key'][0]
            );
        }

        return $response;
    }

    /**
     * License Refresh Endpoint
     */
    public function refresh_license_api() {
        $this->check_license_status();

        return wp_send_json(
            array(
                'message' => 'License refreshed successfully.'
            ),
            200
        );
    }

    /**
     * Add settings page for license
     *
     * @param array $args
     *
     * @return void
     */
    public function add_settings_page( $args = array() ) {
        $defaults = array(
            'type'        => 'menu', // Can be: menu, options, submenu
            'page_title'  => 'Manage License',
            'menu_title'  => 'Manage License',
            'capability'  => 'manage_options',
            'menu_slug'   => $this->client->slug . '-manage-license',
            'icon_url'    => '',
            'position'    => null,
            'parent_slug' => '',
        );

        $this->menu_args = wp_parse_args( $args, $defaults );

        add_action( 'admin_menu', array( $this, 'admin_menu' ), 99 );
    }

    /**
     * Admin Menu hook
     *
     * @return void
     */
    public function admin_menu() {
        switch ( $this->menu_args['type'] ) {
            case 'menu':
                $this->create_menu_page();
                break;

            case 'submenu':
                $this->create_submenu_page();
                break;

            case 'options':
                $this->create_options_page();
                break;
        }
    }

    /**
     * License menu output
     */
    public function menu_output() {
        if ( isset( $_POST['submit'] ) ) {
            $this->license_form_submit( $_POST );
        }

        $license = $this->get_license();
        $action  = ( $license && isset( $license['status'] ) && 'activate' == $license['status'] ) ? 'deactive' : 'active';
        $this->licenses_style();
        ?>

        <div class="wrap appsero-license-settings-wrapper">
            <h1>License Settings</h1>

            <?php
                $this->show_license_page_notices();
                do_action( 'before_appsero_license_section' );
            ?>

            <div class="appsero-license-settings appsero-license-section">
                <?php $this->show_license_page_card_header( $license ); ?>

                <div class="appsero-license-details">
                    <p>
                        <?php printf( $this->client->__trans( 'Activate <strong>%s</strong> by your license key to get professional support and automatic update from your WordPress dashboard.' ), $this->client->name ); ?>
                    </p>
                    <form method="post" action="<?php $this->form_action_url(); ?>" novalidate="novalidate" spellcheck="false">
                        <input type="hidden" name="_action" value="<?php echo $action; ?>">
                        <input type="hidden" name="_nonce" value="<?php echo wp_create_nonce( $this->client->name ); ?>">
                        <div class="license-input-fields">
                            <div class="license-input-key">
                                <svg enable-background="new 0 0 512 512" version="1.1" viewBox="0 0 512 512" xml:space="preserve" xmlns="http://www.w3.org/2000/svg">
                                    <path d="m463.75 48.251c-64.336-64.336-169.01-64.335-233.35 1e-3 -43.945 43.945-59.209 108.71-40.181 167.46l-185.82 185.82c-2.813 2.813-4.395 6.621-4.395 10.606v84.858c0 8.291 6.709 15 15 15h84.858c3.984 0 7.793-1.582 10.605-4.395l21.211-21.226c3.237-3.237 4.819-7.778 4.292-12.334l-2.637-22.793 31.582-2.974c7.178-0.674 12.847-6.343 13.521-13.521l2.974-31.582 22.793 2.651c4.233 0.571 8.496-0.85 11.704-3.691 3.193-2.856 5.024-6.929 5.024-11.206v-27.929h27.422c3.984 0 7.793-1.582 10.605-4.395l38.467-37.958c58.74 19.043 122.38 4.929 166.33-39.046 64.336-64.335 64.336-169.01 0-233.35zm-42.435 106.07c-17.549 17.549-46.084 17.549-63.633 0s-17.549-46.084 0-63.633 46.084-17.549 63.633 0 17.548 46.084 0 63.633z"/>
                                </svg>
                                <input type="text" value="<?php echo $this->get_input_license_value( $action, $license ); ?>"
                                    placeholder="<?php echo esc_attr( $this->client->__trans( 'Enter your license key to activate' ) ); ?>" name="license_key"
                                    <?php echo ( 'deactive' == $action ) ? 'readonly="readonly"' : ''; ?>
                                />
                            </div>
                            <button type="submit" name="submit" class="<?php echo 'deactive' == $action ? 'deactive-button' : ''; ?>">
                                <?php echo $action == 'active' ? $this->client->__trans( 'Activate License' ) : $this->client->__trans( 'Deactivate License' ); ?>
                            </button>
                        </div>
                    </form>

                    <?php
                        if ( 'deactive' == $action && isset( $license['remaining'] ) ) {
                            $this->show_active_license_info( $license );
                        } ?>
                </div>
            </div> <!-- /.appsero-license-settings -->

            <?php do_action( 'after_appsero_license_section' ); ?>
        </div>
        <?php
    }

    /**
     * License form submit
     */
    public function license_form_submit( $form ) {
        if ( ! isset( $form['_nonce'], $form['_action'] ) ) {
            $this->error = $this->client->__trans( 'Please add all information' );

            return;
        }

        if ( ! wp_verify_nonce( $form['_nonce'], $this->client->name ) ) {
            $this->error = $this->client->__trans( "You don't have permission to manage license." );

            return;
        }

        switch ( $form['_action'] ) {
            case 'active':
                $this->active_client_license( $form );
                break;

            case 'deactive':
                $this->deactive_client_license( $form );
                break;

            case 'refresh':
                $this->refresh_client_license( $form );
                break;
        }
    }

    /**
     * Check license status on schedule
     */
    public function check_license_status() {
        $license = $this->get_license();

        if ( isset( $license['key'] ) && ! empty( $license['key'] ) ) {
            $response = $this->check( $license['key'] );

            if ( isset( $response['success'] ) && $response['success'] ) {
                $license['status']           = 'activate';
                $license['remaining']        = $response['remaining'];
                $license['activation_limit'] = $response['activation_limit'];
                $license['expiry_days']      = $response['expiry_days'];
                $license['title']            = $response['title'];
                $license['source_id']        = $response['source_identifier'];
                $license['recurring']        = $response['recurring'];
            } else {
                $license['status']      = 'deactivate';
                $license['expiry_days'] = 0;
            }

            update_option( $this->option_key, $license, false );
        }
    }

    /**
     * Check this is a valid license
     */
    public function is_valid() {
        if ( null !== $this->is_valid_licnese ) {
            return $this->is_valid_licnese;
        }

        $license = $this->get_license();

        if ( ! empty( $license['key'] ) && isset( $license['status'] ) && $license['status'] == 'activate' ) {
            $this->is_valid_licnese = true;
        } else {
            $this->is_valid_licnese = false;
        }

        return $this->is_valid_licnese;
    }

    /**
     * Check this is a valid license
     */
    public function is_valid_by( $option, $value ) {
        $license = $this->get_license();

        if ( ! empty( $license['key'] ) && isset( $license['status'] ) && $license['status'] == 'activate' ) {
            if ( isset( $license[ $option ] ) && $license[ $option ] == $value ) {
                return true;
            }
        }

        return false;
    }

    /**
     * Styles for licenses page
     */
    private function licenses_style() {
        ?>
        <style type="text/css">
            .appsero-license-section {
                width: 100%;
                max-width: 1100px;
                min-height: 1px;
                box-sizing: border-box;
            }
            .appsero-license-settings {
                background-color: #fff;
                box-shadow: 0px 3px 10px rgba(16, 16, 16, 0.05);
            }
            .appsero-license-settings * {
                box-sizing: border-box;
            }
            .appsero-license-title {
                background-color: #F8FAFB;
                border-bottom: 2px solid #EAEAEA;
                display: flex;
                align-items: center;
                padding: 10px 20px;
            }
            .appsero-license-title svg {
                width: 30px;
                height: 30px;
                fill: #0082BF;
            }
            .appsero-license-title span {
                font-size: 17px;
                color: #444444;
                margin-left: 10px;
            }
            .appsero-license-details {
                padding: 20px;
            }
            .appsero-license-details p {
                font-size: 15px;
                margin: 0 0 20px 0;
            }
            .license-input-key {
                position: relative;
                flex: 0 0 72%;
                max-width: 72%;
            }
            .license-input-key input {
                background-color: #F9F9F9;
                padding: 10px 15px 10px 48px;
                border: 1px solid #E8E5E5;
                border-radius: 3px;
                height: 45px;
                font-size: 16px;
                color: #71777D;
                width: 100%;
                box-shadow: 0 0 0 transparent;
            }
            .license-input-key input:focus {
                outline: 0 none;
                border: 1px solid #E8E5E5;
                box-shadow: 0 0 0 transparent;
            }
            .license-input-key svg {
                width: 22px;
                height: 22px;
                fill: #0082BF;
                position: absolute;
                left: 14px;
                top: 13px;
            }
            .license-input-fields {
                display: flex;
                justify-content: space-between;
                margin-bottom: 30px;
                max-width: 850px;
                width: 100%;
            }
            .license-input-fields button {
                color: #fff;
                font-size: 17px;
                padding: 8px;
                height: 46px;
                background-color: #0082BF;
                border-radius: 3px;
                cursor: pointer;
                flex: 0 0 25%;
                max-width: 25%;
                border: 1px solid #0082BF;
            }
            .license-input-fields button.deactive-button {
                background-color: #E40055;
                border-color: #E40055;
            }
            .license-input-fields button:focus {
                outline: 0 none;
            }
            .active-license-info {
                display: flex;
            }
            .single-license-info {
                min-width: 220px;
                flex: 0 0 30%;
            }
            .single-license-info h3 {
                font-size: 18px;
                margin: 0 0 12px 0;
            }
            .single-license-info p {
                margin: 0;
                color: #00C000;
            }
            .single-license-info p.occupied {
                color: #E40055;
            }
            .appsero-license-right-form {
                margin-left: auto;
            }
            .appsero-license-refresh-button {
                padding: 6px 10px 4px 10px;
                border: 1px solid #0082BF;
                border-radius: 3px;
                margin-left: auto;
                background-color: #0082BF;
                color: #fff;
                cursor: pointer;
            }
            .appsero-license-refresh-button .dashicons {
                color: #fff;
                margin-left: 0;
            }
        </style>
        <?php
    }

    /**
     * Show active license information
     */
    private function show_active_license_info( $license ) {
        ?>
        <div class="active-license-info">
            <div class="single-license-info">
                <h3><?php $this->client->_etrans( 'Activations Remaining' ); ?></h3>
                <?php if ( empty( $license['activation_limit'] ) ) { ?>
                    <p><?php $this->client->_etrans( 'Unlimited' ); ?></p>
                <?php } else { ?>
                    <p class="<?php echo $license['remaining'] ? '' : 'occupied'; ?>">
                        <?php printf( $this->client->__trans( '%1$d out of %2$d' ), $license['remaining'], $license['activation_limit'] ); ?>
                    </p>
                <?php } ?>
            </div>
            <div class="single-license-info">
                <h3><?php $this->client->_etrans( 'Expires in' ); ?></h3>
                <?php
                    if ( false !== $license['expiry_days'] ) {
                        $occupied = $license['expiry_days'] > 21 ? '' : 'occupied';
                        echo '<p class="' . $occupied . '">' . $license['expiry_days'] . ' days</p>';
                    } else {
                        echo '<p>' . $this->client->__trans( 'Never' ) . '</p>';
                    } ?>
            </div>
        </div>
        <?php
    }

    /**
     * Show license settings page notices
     */
    private function show_license_page_notices() {
        if ( ! empty( $this->error ) ) {
            ?>
            <div class="notice notice-error is-dismissible appsero-license-section">
                <p><?php echo $this->error; ?></p>
            </div>
        <?php
        }

        if ( ! empty( $this->success ) ) {
            ?>
            <div class="notice notice-success is-dismissible appsero-license-section">
                <p><?php echo $this->success; ?></p>
            </div>
        <?php
        }
        echo '<br />';
    }

    /**
     * Card header
     */
    private function show_license_page_card_header( $license ) {
        ?>
        <div class="appsero-license-title">
            <svg enable-background="new 0 0 299.995 299.995" version="1.1" viewBox="0 0 300 300" xml:space="preserve" xmlns="http://www.w3.org/2000/svg">
                <path d="m150 161.48c-8.613 0-15.598 6.982-15.598 15.598 0 5.776 3.149 10.807 7.817 13.505v17.341h15.562v-17.341c4.668-2.697 7.817-7.729 7.817-13.505 0-8.616-6.984-15.598-15.598-15.598z"/>
                <path d="m150 85.849c-13.111 0-23.775 10.665-23.775 23.775v25.319h47.548v-25.319c-1e-3 -13.108-10.665-23.775-23.773-23.775z"/>
                <path d="m150 1e-3c-82.839 0-150 67.158-150 150 0 82.837 67.156 150 150 150s150-67.161 150-150c0-82.839-67.161-150-150-150zm46.09 227.12h-92.173c-9.734 0-17.626-7.892-17.626-17.629v-56.919c0-8.491 6.007-15.582 14.003-17.25v-25.697c0-27.409 22.3-49.711 49.711-49.711 27.409 0 49.709 22.3 49.709 49.711v25.697c7.993 1.673 14 8.759 14 17.25v56.919h2e-3c0 9.736-7.892 17.629-17.626 17.629z"/>
            </svg>
            <span><?php echo $this->client->__trans( 'Activate License' ); ?></span>

            <?php if ( $license && $license['key'] ) : ?>
            <form method="post" class="appsero-license-right-form" action="<?php $this->form_action_url(); ?>" novalidate="novalidate" spellcheck="false">
                <input type="hidden" name="_action" value="refresh">
                <input type="hidden" name="_nonce" value="<?php echo wp_create_nonce( $this->client->name ); ?>">
                <button type="submit" name="submit" class="appsero-license-refresh-button">
                    <span class="dashicons dashicons-update"></span>
                    <?php echo $this->client->__trans( 'Refresh License' ); ?>
                </button>
            </form>
            <?php endif; ?>

        </div>
        <?php
    }

    /**
     * Active client license
     */
    private function active_client_license( $form ) {
        if ( empty( $form['license_key'] ) ) {
            $this->error = $this->client->__trans( 'The license key field is required.' );

            return;
        }

        $license_key = sanitize_text_field( $form['license_key'] );
        $response    = $this->activate( $license_key );

        if ( ! $response['success'] ) {
            $this->error = $response['error'] ? $response['error'] : $this->client->__trans( 'Unknown error occurred.' );

            return;
        }

        $data = array(
            'key'              => $license_key,
            'status'           => 'activate',
            'remaining'        => $response['remaining'],
            'activation_limit' => $response['activation_limit'],
            'expiry_days'      => $response['expiry_days'],
            'title'            => $response['title'],
            'source_id'        => $response['source_identifier'],
            'recurring'        => $response['recurring'],
        );

        update_option( $this->option_key, $data, false );

        $this->success = $this->client->__trans( 'License activated successfully.' );
    }

    /**
     * Deactive client license
     */
    private function deactive_client_license( $form ) {
        $license = $this->get_license();

        if ( empty( $license['key'] ) ) {
            $this->error = $this->client->__trans( 'License key not found.' );

            return;
        }

        $response = $this->deactivate( $license['key'] );

        $data = array(
            'key'    => '',
            'status' => 'deactivate',
        );

        update_option( $this->option_key, $data, false );

        if ( ! $response['success'] ) {
            $this->error = $response['error'] ? $response['error'] : $this->client->__trans( 'Unknown error occurred.' );

            return;
        }

        $this->success = $this->client->__trans( 'License deactivated successfully.' );
    }

    /**
     * Refresh Client License
     */
    private function refresh_client_license( $form = null ) {
        $license = $this->get_license();

        if( !$license || ! isset( $license['key'] ) || empty( $license['key'] ) ) {
            $this->error = $this->client->__trans( "License key not found" );
            return;
        }

        $this->check_license_status();

        $this->success = $this->client->__trans( 'License refreshed successfully.' );
    }

    /**
     * Add license menu page
     */
    private function create_menu_page() {
        call_user_func(
            'add_' . 'menu' . '_page',
            $this->menu_args['page_title'],
            $this->menu_args['menu_title'],
            $this->menu_args['capability'],
            $this->menu_args['menu_slug'],
            array( $this, 'menu_output' ),
            $this->menu_args['icon_url'],
            $this->menu_args['position']
        );
    }

    /**
     * Add submenu page
     */
    private function create_submenu_page() {
        call_user_func(
            'add_' . 'submenu' . '_page',
            $this->menu_args['parent_slug'],
            $this->menu_args['page_title'],
            $this->menu_args['menu_title'],
            $this->menu_args['capability'],
            $this->menu_args['menu_slug'],
            array( $this, 'menu_output' ),
            $this->menu_args['position']
        );
    }

    /**
     * Add submenu page
     */
    private function create_options_page() {
        call_user_func(
            'add_' . 'options' . '_page',
            $this->menu_args['page_title'],
            $this->menu_args['menu_title'],
            $this->menu_args['capability'],
            $this->menu_args['menu_slug'],
            array( $this, 'menu_output' ),
            $this->menu_args['position']
        );
    }

    /**
     * Schedule daily sicense checker event
     */
    public function schedule_cron_event() {
        if ( ! wp_next_scheduled( $this->schedule_hook ) ) {
            wp_schedule_event( time(), 'daily', $this->schedule_hook );

            wp_schedule_single_event( time() + 20, $this->schedule_hook );
        }
    }

    /**
     * Clear any scheduled hook
     */
    public function clear_scheduler() {
        wp_clear_scheduled_hook( $this->schedule_hook );
    }

    /**
     * Enable/Disable schedule
     */
    private function run_schedule() {
        switch ( $this->client->type ) {
            case 'plugin':
                register_activation_hook( $this->client->file, array( $this, 'schedule_cron_event' ) );
                register_deactivation_hook( $this->client->file, array( $this, 'clear_scheduler' ) );
                break;

            case 'theme':
                add_action( 'after_switch_theme', array( $this, 'schedule_cron_event' ) );
                add_action( 'switch_theme', array( $this, 'clear_scheduler' ) );
                break;
        }
    }

    /**
     * Form action URL
     */
    private function form_action_url() {
        $url = add_query_arg(
            $_GET,
            admin_url( basename( $_SERVER['SCRIPT_NAME'] ) )
        );

        echo apply_filters( 'appsero_client_license_form_action', $url );
    }

    /**
     * Get input license key
     *
     * @param  $action
     *
     * @return $license
     */
    private function get_input_license_value( $action, $license ) {
        if ( 'active' == $action ) {
            return isset( $license['key'] ) ? $license['key'] : '';
        }

        if ( 'deactive' == $action ) {
            $key_length = strlen( $license['key'] );

            return str_pad(
                substr( $license['key'], 0, $key_length / 2 ), $key_length, '*'
            );
        }

        return '';
    }
}


// File: wp-graphql\vendor\appsero\client\src\Updater.php
<?php
namespace Appsero;

/**
 * Appsero Updater
 *
 * This class will show new updates project
 */
class Updater {

    /**
     * Appsero\Client
     *
     * @var object
     */
    protected $client;

    /**
     * Initialize the class
     *
     * @param Appsero\Client
     */
    public function __construct( Client $client ) {

        $this->client    = $client;
        $this->cache_key = 'appsero_' . md5( $this->client->slug ) . '_version_info';

        // Run hooks.
        if ( $this->client->type == 'plugin' ) {
            $this->run_plugin_hooks();
        } elseif ( $this->client->type == 'theme' ) {
            $this->run_theme_hooks();
        }
    }

    /**
     * Set up WordPress filter to hooks to get update.
     *
     * @return void
     */
    public function run_plugin_hooks() {
        add_filter( 'pre_set_site_transient_update_plugins', array( $this, 'check_plugin_update' ) );
        add_filter( 'plugins_api', array( $this, 'plugins_api_filter' ), 10, 3 );
    }

    /**
     * Set up WordPress filter to hooks to get update.
     *
     * @return void
     */
    public function run_theme_hooks() {
        add_filter( 'pre_set_site_transient_update_themes', array( $this, 'check_theme_update' ) );
    }

    /**
     * Check for Update for this specific project
     */
    public function check_plugin_update( $transient_data ) {
        global $pagenow;

        if ( ! is_object( $transient_data ) ) {
            $transient_data = new \stdClass;
        }

        if ( 'plugins.php' == $pagenow && is_multisite() ) {
            return $transient_data;
        }

        if ( ! empty( $transient_data->response ) && ! empty( $transient_data->response[ $this->client->basename ] ) ) {
            return $transient_data;
        }

        $version_info = $this->get_version_info();

        if ( false !== $version_info && is_object( $version_info ) && isset( $version_info->new_version ) ) {

            unset( $version_info->sections );

            // If new version available then set to `response`
            if ( version_compare( $this->client->project_version, $version_info->new_version, '<' ) ) {
                $transient_data->response[ $this->client->basename ] = $version_info;
            } else {
                // If new version is not available then set to `no_update`
                $transient_data->no_update[ $this->client->basename ] = $version_info;
            }

            $transient_data->last_checked = time();
            $transient_data->checked[ $this->client->basename ] = $this->client->project_version;
        }

        return $transient_data;
    }

    /**
     * Get version info from database
     *
     * @return Object or Boolean
     */
    private function get_cached_version_info() {
        global $pagenow;

        // If updater page then fetch from API now
        if ( 'update-core.php' == $pagenow ) {
            return false; // Force to fetch data
        }

        $value = get_transient( $this->cache_key );

        if( ! $value && ! isset( $value->name ) ) {
            return false; // Cache is expired
        }

        // We need to turn the icons into an array
        if ( isset( $value->icons ) ) {
            $value->icons = (array) $value->icons;
        }

        // We need to turn the banners into an array
        if ( isset( $value->banners ) ) {
            $value->banners = (array) $value->banners;
        }

        if ( isset( $value->sections ) ) {
            $value->sections = (array) $value->sections;
        }

        return $value;
    }

    /**
     * Set version info to database
     */
    private function set_cached_version_info( $value ) {
        if ( ! $value ) {
            return;
        }

        set_transient( $this->cache_key, $value, 3 * HOUR_IN_SECONDS );
    }

    /**
     * Get plugin info from Appsero
     */
    private function get_project_latest_version() {

        $license = $this->client->license()->get_license();

        $params = array(
            'version'     => $this->client->project_version,
            'name'        => $this->client->name,
            'slug'        => $this->client->slug,
            'basename'    => $this->client->basename,
            'license_key' => ! empty( $license ) && isset( $license['key'] ) ? $license['key'] : '',
        );

        $route = 'update/' . $this->client->hash . '/check';

        $response = $this->client->send_request( $params, $route, true );

        if ( is_wp_error( $response ) ) {
            return false;
        }

        $response = json_decode( wp_remote_retrieve_body( $response ) );

        if ( ! isset( $response->slug ) ) {
            return false;
        }

        if ( isset( $response->icons ) ) {
            $response->icons = (array) $response->icons;
        }

        if ( isset( $response->banners ) ) {
            $response->banners = (array) $response->banners;
        }

        if ( isset( $response->sections ) ) {
            $response->sections = (array) $response->sections;
        }

        return $response;
    }

    /**
     * Updates information on the "View version x.x details" page with custom data.
     *
     * @param mixed   $data
     * @param string  $action
     * @param object  $args
     *
     * @return object $data
     */
    public function plugins_api_filter( $data, $action = '', $args = null ) {

        if ( $action != 'plugin_information' ) {
            return $data;
        }

        if ( ! isset( $args->slug ) || ( $args->slug != $this->client->slug ) ) {
            return $data;
        }

        return $this->get_version_info();
    }

    /**
     * Check theme upate
     */
    public function check_theme_update( $transient_data ) {
        global $pagenow;

        if ( ! is_object( $transient_data ) ) {
            $transient_data = new \stdClass;
        }

        if ( 'themes.php' == $pagenow && is_multisite() ) {
            return $transient_data;
        }

        if ( ! empty( $transient_data->response ) && ! empty( $transient_data->response[ $this->client->slug ] ) ) {
            return $transient_data;
        }

        $version_info = $this->get_version_info();

        if ( false !== $version_info && is_object( $version_info ) && isset( $version_info->new_version ) ) {

            // If new version available then set to `response`
            if ( version_compare( $this->client->project_version, $version_info->new_version, '<' ) ) {
                $transient_data->response[ $this->client->slug ] = (array) $version_info;
            } else {
                // If new version is not available then set to `no_update`
                $transient_data->no_update[ $this->client->slug ] = (array) $version_info;
            }

            $transient_data->last_checked = time();
            $transient_data->checked[ $this->client->slug ] = $this->client->project_version;
        }

        return $transient_data;
    }

    /**
     * Get version information
     */
    private function get_version_info() {
        $version_info = $this->get_cached_version_info();

        if ( false === $version_info ) {
            $version_info = $this->get_project_latest_version();
            $this->set_cached_version_info( $version_info );
        }

        return $version_info;
    }

}


// File: wp-graphql\vendor\composer\autoload_classmap.php
<?php

// autoload_classmap.php @generated by Composer

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
    'Appsero\\Client' => $vendorDir . '/appsero/client/src/Client.php',
    'Appsero\\Insights' => $vendorDir . '/appsero/client/src/Insights.php',
    'Appsero\\License' => $vendorDir . '/appsero/client/src/License.php',
    'Appsero\\Updater' => $vendorDir . '/appsero/client/src/Updater.php',
    'Composer\\InstalledVersions' => $vendorDir . '/composer/InstalledVersions.php',
    'GraphQLRelay\\Connection\\ArrayConnection' => $vendorDir . '/ivome/graphql-relay-php/src/Connection/ArrayConnection.php',
    'GraphQLRelay\\Connection\\Connection' => $vendorDir . '/ivome/graphql-relay-php/src/Connection/Connection.php',
    'GraphQLRelay\\Mutation\\Mutation' => $vendorDir . '/ivome/graphql-relay-php/src/Mutation/Mutation.php',
    'GraphQLRelay\\Node\\Node' => $vendorDir . '/ivome/graphql-relay-php/src/Node/Node.php',
    'GraphQLRelay\\Node\\Plural' => $vendorDir . '/ivome/graphql-relay-php/src/Node/Plural.php',
    'GraphQLRelay\\Relay' => $vendorDir . '/ivome/graphql-relay-php/src/Relay.php',
    'GraphQL\\Deferred' => $vendorDir . '/webonyx/graphql-php/src/Deferred.php',
    'GraphQL\\Error\\ClientAware' => $vendorDir . '/webonyx/graphql-php/src/Error/ClientAware.php',
    'GraphQL\\Error\\DebugFlag' => $vendorDir . '/webonyx/graphql-php/src/Error/DebugFlag.php',
    'GraphQL\\Error\\Error' => $vendorDir . '/webonyx/graphql-php/src/Error/Error.php',
    'GraphQL\\Error\\FormattedError' => $vendorDir . '/webonyx/graphql-php/src/Error/FormattedError.php',
    'GraphQL\\Error\\InvariantViolation' => $vendorDir . '/webonyx/graphql-php/src/Error/InvariantViolation.php',
    'GraphQL\\Error\\SyntaxError' => $vendorDir . '/webonyx/graphql-php/src/Error/SyntaxError.php',
    'GraphQL\\Error\\UserError' => $vendorDir . '/webonyx/graphql-php/src/Error/UserError.php',
    'GraphQL\\Error\\Warning' => $vendorDir . '/webonyx/graphql-php/src/Error/Warning.php',
    'GraphQL\\Exception\\InvalidArgument' => $vendorDir . '/webonyx/graphql-php/src/Exception/InvalidArgument.php',
    'GraphQL\\Executor\\ExecutionContext' => $vendorDir . '/webonyx/graphql-php/src/Executor/ExecutionContext.php',
    'GraphQL\\Executor\\ExecutionResult' => $vendorDir . '/webonyx/graphql-php/src/Executor/ExecutionResult.php',
    'GraphQL\\Executor\\Executor' => $vendorDir . '/webonyx/graphql-php/src/Executor/Executor.php',
    'GraphQL\\Executor\\ExecutorImplementation' => $vendorDir . '/webonyx/graphql-php/src/Executor/ExecutorImplementation.php',
    'GraphQL\\Executor\\Promise\\Adapter\\AmpPromiseAdapter' => $vendorDir . '/webonyx/graphql-php/src/Executor/Promise/Adapter/AmpPromiseAdapter.php',
    'GraphQL\\Executor\\Promise\\Adapter\\ReactPromiseAdapter' => $vendorDir . '/webonyx/graphql-php/src/Executor/Promise/Adapter/ReactPromiseAdapter.php',
    'GraphQL\\Executor\\Promise\\Adapter\\SyncPromise' => $vendorDir . '/webonyx/graphql-php/src/Executor/Promise/Adapter/SyncPromise.php',
    'GraphQL\\Executor\\Promise\\Adapter\\SyncPromiseAdapter' => $vendorDir . '/webonyx/graphql-php/src/Executor/Promise/Adapter/SyncPromiseAdapter.php',
    'GraphQL\\Executor\\Promise\\Promise' => $vendorDir . '/webonyx/graphql-php/src/Executor/Promise/Promise.php',
    'GraphQL\\Executor\\Promise\\PromiseAdapter' => $vendorDir . '/webonyx/graphql-php/src/Executor/Promise/PromiseAdapter.php',
    'GraphQL\\Executor\\ReferenceExecutor' => $vendorDir . '/webonyx/graphql-php/src/Executor/ReferenceExecutor.php',
    'GraphQL\\Executor\\Values' => $vendorDir . '/webonyx/graphql-php/src/Executor/Values.php',
    'GraphQL\\Experimental\\Executor\\Collector' => $vendorDir . '/webonyx/graphql-php/src/Experimental/Executor/Collector.php',
    'GraphQL\\Experimental\\Executor\\CoroutineContext' => $vendorDir . '/webonyx/graphql-php/src/Experimental/Executor/CoroutineContext.php',
    'GraphQL\\Experimental\\Executor\\CoroutineContextShared' => $vendorDir . '/webonyx/graphql-php/src/Experimental/Executor/CoroutineContextShared.php',
    'GraphQL\\Experimental\\Executor\\CoroutineExecutor' => $vendorDir . '/webonyx/graphql-php/src/Experimental/Executor/CoroutineExecutor.php',
    'GraphQL\\Experimental\\Executor\\Runtime' => $vendorDir . '/webonyx/graphql-php/src/Experimental/Executor/Runtime.php',
    'GraphQL\\Experimental\\Executor\\Strand' => $vendorDir . '/webonyx/graphql-php/src/Experimental/Executor/Strand.php',
    'GraphQL\\GraphQL' => $vendorDir . '/webonyx/graphql-php/src/GraphQL.php',
    'GraphQL\\Language\\AST\\ArgumentNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/ArgumentNode.php',
    'GraphQL\\Language\\AST\\BooleanValueNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/BooleanValueNode.php',
    'GraphQL\\Language\\AST\\DefinitionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/DefinitionNode.php',
    'GraphQL\\Language\\AST\\DirectiveDefinitionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/DirectiveDefinitionNode.php',
    'GraphQL\\Language\\AST\\DirectiveNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/DirectiveNode.php',
    'GraphQL\\Language\\AST\\DocumentNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/DocumentNode.php',
    'GraphQL\\Language\\AST\\EnumTypeDefinitionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/EnumTypeDefinitionNode.php',
    'GraphQL\\Language\\AST\\EnumTypeExtensionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/EnumTypeExtensionNode.php',
    'GraphQL\\Language\\AST\\EnumValueDefinitionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/EnumValueDefinitionNode.php',
    'GraphQL\\Language\\AST\\EnumValueNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/EnumValueNode.php',
    'GraphQL\\Language\\AST\\ExecutableDefinitionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/ExecutableDefinitionNode.php',
    'GraphQL\\Language\\AST\\FieldDefinitionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/FieldDefinitionNode.php',
    'GraphQL\\Language\\AST\\FieldNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/FieldNode.php',
    'GraphQL\\Language\\AST\\FloatValueNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/FloatValueNode.php',
    'GraphQL\\Language\\AST\\FragmentDefinitionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/FragmentDefinitionNode.php',
    'GraphQL\\Language\\AST\\FragmentSpreadNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/FragmentSpreadNode.php',
    'GraphQL\\Language\\AST\\HasSelectionSet' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/HasSelectionSet.php',
    'GraphQL\\Language\\AST\\InlineFragmentNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/InlineFragmentNode.php',
    'GraphQL\\Language\\AST\\InputObjectTypeDefinitionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/InputObjectTypeDefinitionNode.php',
    'GraphQL\\Language\\AST\\InputObjectTypeExtensionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/InputObjectTypeExtensionNode.php',
    'GraphQL\\Language\\AST\\InputValueDefinitionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/InputValueDefinitionNode.php',
    'GraphQL\\Language\\AST\\IntValueNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/IntValueNode.php',
    'GraphQL\\Language\\AST\\InterfaceTypeDefinitionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/InterfaceTypeDefinitionNode.php',
    'GraphQL\\Language\\AST\\InterfaceTypeExtensionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/InterfaceTypeExtensionNode.php',
    'GraphQL\\Language\\AST\\ListTypeNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/ListTypeNode.php',
    'GraphQL\\Language\\AST\\ListValueNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/ListValueNode.php',
    'GraphQL\\Language\\AST\\Location' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/Location.php',
    'GraphQL\\Language\\AST\\NameNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/NameNode.php',
    'GraphQL\\Language\\AST\\NamedTypeNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/NamedTypeNode.php',
    'GraphQL\\Language\\AST\\Node' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/Node.php',
    'GraphQL\\Language\\AST\\NodeKind' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/NodeKind.php',
    'GraphQL\\Language\\AST\\NodeList' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/NodeList.php',
    'GraphQL\\Language\\AST\\NonNullTypeNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/NonNullTypeNode.php',
    'GraphQL\\Language\\AST\\NullValueNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/NullValueNode.php',
    'GraphQL\\Language\\AST\\ObjectFieldNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/ObjectFieldNode.php',
    'GraphQL\\Language\\AST\\ObjectTypeDefinitionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/ObjectTypeDefinitionNode.php',
    'GraphQL\\Language\\AST\\ObjectTypeExtensionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/ObjectTypeExtensionNode.php',
    'GraphQL\\Language\\AST\\ObjectValueNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/ObjectValueNode.php',
    'GraphQL\\Language\\AST\\OperationDefinitionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/OperationDefinitionNode.php',
    'GraphQL\\Language\\AST\\OperationTypeDefinitionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/OperationTypeDefinitionNode.php',
    'GraphQL\\Language\\AST\\ScalarTypeDefinitionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/ScalarTypeDefinitionNode.php',
    'GraphQL\\Language\\AST\\ScalarTypeExtensionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/ScalarTypeExtensionNode.php',
    'GraphQL\\Language\\AST\\SchemaDefinitionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/SchemaDefinitionNode.php',
    'GraphQL\\Language\\AST\\SchemaTypeExtensionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/SchemaTypeExtensionNode.php',
    'GraphQL\\Language\\AST\\SelectionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/SelectionNode.php',
    'GraphQL\\Language\\AST\\SelectionSetNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/SelectionSetNode.php',
    'GraphQL\\Language\\AST\\StringValueNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/StringValueNode.php',
    'GraphQL\\Language\\AST\\TypeDefinitionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/TypeDefinitionNode.php',
    'GraphQL\\Language\\AST\\TypeExtensionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/TypeExtensionNode.php',
    'GraphQL\\Language\\AST\\TypeNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/TypeNode.php',
    'GraphQL\\Language\\AST\\TypeSystemDefinitionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/TypeSystemDefinitionNode.php',
    'GraphQL\\Language\\AST\\UnionTypeDefinitionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/UnionTypeDefinitionNode.php',
    'GraphQL\\Language\\AST\\UnionTypeExtensionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/UnionTypeExtensionNode.php',
    'GraphQL\\Language\\AST\\ValueNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/ValueNode.php',
    'GraphQL\\Language\\AST\\VariableDefinitionNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/VariableDefinitionNode.php',
    'GraphQL\\Language\\AST\\VariableNode' => $vendorDir . '/webonyx/graphql-php/src/Language/AST/VariableNode.php',
    'GraphQL\\Language\\DirectiveLocation' => $vendorDir . '/webonyx/graphql-php/src/Language/DirectiveLocation.php',
    'GraphQL\\Language\\Lexer' => $vendorDir . '/webonyx/graphql-php/src/Language/Lexer.php',
    'GraphQL\\Language\\Parser' => $vendorDir . '/webonyx/graphql-php/src/Language/Parser.php',
    'GraphQL\\Language\\Printer' => $vendorDir . '/webonyx/graphql-php/src/Language/Printer.php',
    'GraphQL\\Language\\Source' => $vendorDir . '/webonyx/graphql-php/src/Language/Source.php',
    'GraphQL\\Language\\SourceLocation' => $vendorDir . '/webonyx/graphql-php/src/Language/SourceLocation.php',
    'GraphQL\\Language\\Token' => $vendorDir . '/webonyx/graphql-php/src/Language/Token.php',
    'GraphQL\\Language\\Visitor' => $vendorDir . '/webonyx/graphql-php/src/Language/Visitor.php',
    'GraphQL\\Language\\VisitorOperation' => $vendorDir . '/webonyx/graphql-php/src/Language/VisitorOperation.php',
    'GraphQL\\Server\\Helper' => $vendorDir . '/webonyx/graphql-php/src/Server/Helper.php',
    'GraphQL\\Server\\OperationParams' => $vendorDir . '/webonyx/graphql-php/src/Server/OperationParams.php',
    'GraphQL\\Server\\RequestError' => $vendorDir . '/webonyx/graphql-php/src/Server/RequestError.php',
    'GraphQL\\Server\\ServerConfig' => $vendorDir . '/webonyx/graphql-php/src/Server/ServerConfig.php',
    'GraphQL\\Server\\StandardServer' => $vendorDir . '/webonyx/graphql-php/src/Server/StandardServer.php',
    'GraphQL\\Type\\Definition\\AbstractType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/AbstractType.php',
    'GraphQL\\Type\\Definition\\BooleanType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/BooleanType.php',
    'GraphQL\\Type\\Definition\\CompositeType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/CompositeType.php',
    'GraphQL\\Type\\Definition\\CustomScalarType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/CustomScalarType.php',
    'GraphQL\\Type\\Definition\\Directive' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/Directive.php',
    'GraphQL\\Type\\Definition\\EnumType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/EnumType.php',
    'GraphQL\\Type\\Definition\\EnumValueDefinition' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/EnumValueDefinition.php',
    'GraphQL\\Type\\Definition\\FieldArgument' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/FieldArgument.php',
    'GraphQL\\Type\\Definition\\FieldDefinition' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/FieldDefinition.php',
    'GraphQL\\Type\\Definition\\FloatType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/FloatType.php',
    'GraphQL\\Type\\Definition\\HasFieldsType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/HasFieldsType.php',
    'GraphQL\\Type\\Definition\\IDType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/IDType.php',
    'GraphQL\\Type\\Definition\\ImplementingType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/ImplementingType.php',
    'GraphQL\\Type\\Definition\\InputObjectField' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/InputObjectField.php',
    'GraphQL\\Type\\Definition\\InputObjectType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/InputObjectType.php',
    'GraphQL\\Type\\Definition\\InputType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/InputType.php',
    'GraphQL\\Type\\Definition\\IntType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/IntType.php',
    'GraphQL\\Type\\Definition\\InterfaceType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/InterfaceType.php',
    'GraphQL\\Type\\Definition\\LeafType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/LeafType.php',
    'GraphQL\\Type\\Definition\\ListOfType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/ListOfType.php',
    'GraphQL\\Type\\Definition\\NamedType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/NamedType.php',
    'GraphQL\\Type\\Definition\\NonNull' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/NonNull.php',
    'GraphQL\\Type\\Definition\\NullableType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/NullableType.php',
    'GraphQL\\Type\\Definition\\ObjectType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/ObjectType.php',
    'GraphQL\\Type\\Definition\\OutputType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/OutputType.php',
    'GraphQL\\Type\\Definition\\QueryPlan' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/QueryPlan.php',
    'GraphQL\\Type\\Definition\\ResolveInfo' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/ResolveInfo.php',
    'GraphQL\\Type\\Definition\\ScalarType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/ScalarType.php',
    'GraphQL\\Type\\Definition\\StringType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/StringType.php',
    'GraphQL\\Type\\Definition\\Type' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/Type.php',
    'GraphQL\\Type\\Definition\\TypeWithFields' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/TypeWithFields.php',
    'GraphQL\\Type\\Definition\\UnionType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/UnionType.php',
    'GraphQL\\Type\\Definition\\UnmodifiedType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/UnmodifiedType.php',
    'GraphQL\\Type\\Definition\\UnresolvedFieldDefinition' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/UnresolvedFieldDefinition.php',
    'GraphQL\\Type\\Definition\\WrappingType' => $vendorDir . '/webonyx/graphql-php/src/Type/Definition/WrappingType.php',
    'GraphQL\\Type\\Introspection' => $vendorDir . '/webonyx/graphql-php/src/Type/Introspection.php',
    'GraphQL\\Type\\Schema' => $vendorDir . '/webonyx/graphql-php/src/Type/Schema.php',
    'GraphQL\\Type\\SchemaConfig' => $vendorDir . '/webonyx/graphql-php/src/Type/SchemaConfig.php',
    'GraphQL\\Type\\SchemaValidationContext' => $vendorDir . '/webonyx/graphql-php/src/Type/SchemaValidationContext.php',
    'GraphQL\\Type\\TypeKind' => $vendorDir . '/webonyx/graphql-php/src/Type/TypeKind.php',
    'GraphQL\\Type\\Validation\\InputObjectCircularRefs' => $vendorDir . '/webonyx/graphql-php/src/Type/Validation/InputObjectCircularRefs.php',
    'GraphQL\\Utils\\AST' => $vendorDir . '/webonyx/graphql-php/src/Utils/AST.php',
    'GraphQL\\Utils\\ASTDefinitionBuilder' => $vendorDir . '/webonyx/graphql-php/src/Utils/ASTDefinitionBuilder.php',
    'GraphQL\\Utils\\BlockString' => $vendorDir . '/webonyx/graphql-php/src/Utils/BlockString.php',
    'GraphQL\\Utils\\BreakingChangesFinder' => $vendorDir . '/webonyx/graphql-php/src/Utils/BreakingChangesFinder.php',
    'GraphQL\\Utils\\BuildClientSchema' => $vendorDir . '/webonyx/graphql-php/src/Utils/BuildClientSchema.php',
    'GraphQL\\Utils\\BuildSchema' => $vendorDir . '/webonyx/graphql-php/src/Utils/BuildSchema.php',
    'GraphQL\\Utils\\InterfaceImplementations' => $vendorDir . '/webonyx/graphql-php/src/Utils/InterfaceImplementations.php',
    'GraphQL\\Utils\\MixedStore' => $vendorDir . '/webonyx/graphql-php/src/Utils/MixedStore.php',
    'GraphQL\\Utils\\PairSet' => $vendorDir . '/webonyx/graphql-php/src/Utils/PairSet.php',
    'GraphQL\\Utils\\SchemaExtender' => $vendorDir . '/webonyx/graphql-php/src/Utils/SchemaExtender.php',
    'GraphQL\\Utils\\SchemaPrinter' => $vendorDir . '/webonyx/graphql-php/src/Utils/SchemaPrinter.php',
    'GraphQL\\Utils\\TypeComparators' => $vendorDir . '/webonyx/graphql-php/src/Utils/TypeComparators.php',
    'GraphQL\\Utils\\TypeInfo' => $vendorDir . '/webonyx/graphql-php/src/Utils/TypeInfo.php',
    'GraphQL\\Utils\\Utils' => $vendorDir . '/webonyx/graphql-php/src/Utils/Utils.php',
    'GraphQL\\Utils\\Value' => $vendorDir . '/webonyx/graphql-php/src/Utils/Value.php',
    'GraphQL\\Validator\\ASTValidationContext' => $vendorDir . '/webonyx/graphql-php/src/Validator/ASTValidationContext.php',
    'GraphQL\\Validator\\DocumentValidator' => $vendorDir . '/webonyx/graphql-php/src/Validator/DocumentValidator.php',
    'GraphQL\\Validator\\Rules\\CustomValidationRule' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/CustomValidationRule.php',
    'GraphQL\\Validator\\Rules\\DisableIntrospection' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/DisableIntrospection.php',
    'GraphQL\\Validator\\Rules\\ExecutableDefinitions' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/ExecutableDefinitions.php',
    'GraphQL\\Validator\\Rules\\FieldsOnCorrectType' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/FieldsOnCorrectType.php',
    'GraphQL\\Validator\\Rules\\FragmentsOnCompositeTypes' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/FragmentsOnCompositeTypes.php',
    'GraphQL\\Validator\\Rules\\KnownArgumentNames' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/KnownArgumentNames.php',
    'GraphQL\\Validator\\Rules\\KnownArgumentNamesOnDirectives' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/KnownArgumentNamesOnDirectives.php',
    'GraphQL\\Validator\\Rules\\KnownDirectives' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/KnownDirectives.php',
    'GraphQL\\Validator\\Rules\\KnownFragmentNames' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/KnownFragmentNames.php',
    'GraphQL\\Validator\\Rules\\KnownTypeNames' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/KnownTypeNames.php',
    'GraphQL\\Validator\\Rules\\LoneAnonymousOperation' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/LoneAnonymousOperation.php',
    'GraphQL\\Validator\\Rules\\LoneSchemaDefinition' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/LoneSchemaDefinition.php',
    'GraphQL\\Validator\\Rules\\NoFragmentCycles' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/NoFragmentCycles.php',
    'GraphQL\\Validator\\Rules\\NoUndefinedVariables' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/NoUndefinedVariables.php',
    'GraphQL\\Validator\\Rules\\NoUnusedFragments' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/NoUnusedFragments.php',
    'GraphQL\\Validator\\Rules\\NoUnusedVariables' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/NoUnusedVariables.php',
    'GraphQL\\Validator\\Rules\\OverlappingFieldsCanBeMerged' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/OverlappingFieldsCanBeMerged.php',
    'GraphQL\\Validator\\Rules\\PossibleFragmentSpreads' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/PossibleFragmentSpreads.php',
    'GraphQL\\Validator\\Rules\\ProvidedRequiredArguments' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/ProvidedRequiredArguments.php',
    'GraphQL\\Validator\\Rules\\ProvidedRequiredArgumentsOnDirectives' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/ProvidedRequiredArgumentsOnDirectives.php',
    'GraphQL\\Validator\\Rules\\QueryComplexity' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/QueryComplexity.php',
    'GraphQL\\Validator\\Rules\\QueryDepth' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/QueryDepth.php',
    'GraphQL\\Validator\\Rules\\QuerySecurityRule' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/QuerySecurityRule.php',
    'GraphQL\\Validator\\Rules\\ScalarLeafs' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/ScalarLeafs.php',
    'GraphQL\\Validator\\Rules\\SingleFieldSubscription' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/SingleFieldSubscription.php',
    'GraphQL\\Validator\\Rules\\UniqueArgumentNames' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/UniqueArgumentNames.php',
    'GraphQL\\Validator\\Rules\\UniqueDirectivesPerLocation' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/UniqueDirectivesPerLocation.php',
    'GraphQL\\Validator\\Rules\\UniqueFragmentNames' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/UniqueFragmentNames.php',
    'GraphQL\\Validator\\Rules\\UniqueInputFieldNames' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/UniqueInputFieldNames.php',
    'GraphQL\\Validator\\Rules\\UniqueOperationNames' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/UniqueOperationNames.php',
    'GraphQL\\Validator\\Rules\\UniqueVariableNames' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/UniqueVariableNames.php',
    'GraphQL\\Validator\\Rules\\ValidationRule' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/ValidationRule.php',
    'GraphQL\\Validator\\Rules\\ValuesOfCorrectType' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/ValuesOfCorrectType.php',
    'GraphQL\\Validator\\Rules\\VariablesAreInputTypes' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/VariablesAreInputTypes.php',
    'GraphQL\\Validator\\Rules\\VariablesInAllowedPosition' => $vendorDir . '/webonyx/graphql-php/src/Validator/Rules/VariablesInAllowedPosition.php',
    'GraphQL\\Validator\\SDLValidationContext' => $vendorDir . '/webonyx/graphql-php/src/Validator/SDLValidationContext.php',
    'GraphQL\\Validator\\ValidationContext' => $vendorDir . '/webonyx/graphql-php/src/Validator/ValidationContext.php',
    'WPGraphQL\\Admin\\Admin' => $baseDir . '/src/Admin/Admin.php',
    'WPGraphQL\\Admin\\AdminNotices' => $baseDir . '/src/Admin/AdminNotices.php',
    'WPGraphQL\\Admin\\GraphiQL\\GraphiQL' => $baseDir . '/src/Admin/GraphiQL/GraphiQL.php',
    'WPGraphQL\\Admin\\Settings\\Settings' => $baseDir . '/src/Admin/Settings/Settings.php',
    'WPGraphQL\\Admin\\Settings\\SettingsRegistry' => $baseDir . '/src/Admin/Settings/SettingsRegistry.php',
    'WPGraphQL\\AppContext' => $baseDir . '/src/AppContext.php',
    'WPGraphQL\\Connection\\Comments' => $baseDir . '/src/Connection/Comments.php',
    'WPGraphQL\\Connection\\MenuItems' => $baseDir . '/src/Connection/MenuItems.php',
    'WPGraphQL\\Connection\\PostObjects' => $baseDir . '/src/Connection/PostObjects.php',
    'WPGraphQL\\Connection\\Taxonomies' => $baseDir . '/src/Connection/Taxonomies.php',
    'WPGraphQL\\Connection\\TermObjects' => $baseDir . '/src/Connection/TermObjects.php',
    'WPGraphQL\\Connection\\Users' => $baseDir . '/src/Connection/Users.php',
    'WPGraphQL\\Data\\CommentMutation' => $baseDir . '/src/Data/CommentMutation.php',
    'WPGraphQL\\Data\\Config' => $baseDir . '/src/Data/Config.php',
    'WPGraphQL\\Data\\Connection\\AbstractConnectionResolver' => $baseDir . '/src/Data/Connection/AbstractConnectionResolver.php',
    'WPGraphQL\\Data\\Connection\\CommentConnectionResolver' => $baseDir . '/src/Data/Connection/CommentConnectionResolver.php',
    'WPGraphQL\\Data\\Connection\\ContentTypeConnectionResolver' => $baseDir . '/src/Data/Connection/ContentTypeConnectionResolver.php',
    'WPGraphQL\\Data\\Connection\\EnqueuedScriptsConnectionResolver' => $baseDir . '/src/Data/Connection/EnqueuedScriptsConnectionResolver.php',
    'WPGraphQL\\Data\\Connection\\EnqueuedStylesheetConnectionResolver' => $baseDir . '/src/Data/Connection/EnqueuedStylesheetConnectionResolver.php',
    'WPGraphQL\\Data\\Connection\\MenuConnectionResolver' => $baseDir . '/src/Data/Connection/MenuConnectionResolver.php',
    'WPGraphQL\\Data\\Connection\\MenuItemConnectionResolver' => $baseDir . '/src/Data/Connection/MenuItemConnectionResolver.php',
    'WPGraphQL\\Data\\Connection\\PluginConnectionResolver' => $baseDir . '/src/Data/Connection/PluginConnectionResolver.php',
    'WPGraphQL\\Data\\Connection\\PostObjectConnectionResolver' => $baseDir . '/src/Data/Connection/PostObjectConnectionResolver.php',
    'WPGraphQL\\Data\\Connection\\TaxonomyConnectionResolver' => $baseDir . '/src/Data/Connection/TaxonomyConnectionResolver.php',
    'WPGraphQL\\Data\\Connection\\TermObjectConnectionResolver' => $baseDir . '/src/Data/Connection/TermObjectConnectionResolver.php',
    'WPGraphQL\\Data\\Connection\\ThemeConnectionResolver' => $baseDir . '/src/Data/Connection/ThemeConnectionResolver.php',
    'WPGraphQL\\Data\\Connection\\UserConnectionResolver' => $baseDir . '/src/Data/Connection/UserConnectionResolver.php',
    'WPGraphQL\\Data\\Connection\\UserRoleConnectionResolver' => $baseDir . '/src/Data/Connection/UserRoleConnectionResolver.php',
    'WPGraphQL\\Data\\Cursor\\AbstractCursor' => $baseDir . '/src/Data/Cursor/AbstractCursor.php',
    'WPGraphQL\\Data\\Cursor\\CommentObjectCursor' => $baseDir . '/src/Data/Cursor/CommentObjectCursor.php',
    'WPGraphQL\\Data\\Cursor\\CursorBuilder' => $baseDir . '/src/Data/Cursor/CursorBuilder.php',
    'WPGraphQL\\Data\\Cursor\\PostObjectCursor' => $baseDir . '/src/Data/Cursor/PostObjectCursor.php',
    'WPGraphQL\\Data\\Cursor\\TermObjectCursor' => $baseDir . '/src/Data/Cursor/TermObjectCursor.php',
    'WPGraphQL\\Data\\Cursor\\UserCursor' => $baseDir . '/src/Data/Cursor/UserCursor.php',
    'WPGraphQL\\Data\\DataSource' => $baseDir . '/src/Data/DataSource.php',
    'WPGraphQL\\Data\\Loader\\AbstractDataLoader' => $baseDir . '/src/Data/Loader/AbstractDataLoader.php',
    'WPGraphQL\\Data\\Loader\\CommentAuthorLoader' => $baseDir . '/src/Data/Loader/CommentAuthorLoader.php',
    'WPGraphQL\\Data\\Loader\\CommentLoader' => $baseDir . '/src/Data/Loader/CommentLoader.php',
    'WPGraphQL\\Data\\Loader\\EnqueuedScriptLoader' => $baseDir . '/src/Data/Loader/EnqueuedScriptLoader.php',
    'WPGraphQL\\Data\\Loader\\EnqueuedStylesheetLoader' => $baseDir . '/src/Data/Loader/EnqueuedStylesheetLoader.php',
    'WPGraphQL\\Data\\Loader\\PluginLoader' => $baseDir . '/src/Data/Loader/PluginLoader.php',
    'WPGraphQL\\Data\\Loader\\PostObjectLoader' => $baseDir . '/src/Data/Loader/PostObjectLoader.php',
    'WPGraphQL\\Data\\Loader\\PostTypeLoader' => $baseDir . '/src/Data/Loader/PostTypeLoader.php',
    'WPGraphQL\\Data\\Loader\\TaxonomyLoader' => $baseDir . '/src/Data/Loader/TaxonomyLoader.php',
    'WPGraphQL\\Data\\Loader\\TermObjectLoader' => $baseDir . '/src/Data/Loader/TermObjectLoader.php',
    'WPGraphQL\\Data\\Loader\\ThemeLoader' => $baseDir . '/src/Data/Loader/ThemeLoader.php',
    'WPGraphQL\\Data\\Loader\\UserLoader' => $baseDir . '/src/Data/Loader/UserLoader.php',
    'WPGraphQL\\Data\\Loader\\UserRoleLoader' => $baseDir . '/src/Data/Loader/UserRoleLoader.php',
    'WPGraphQL\\Data\\MediaItemMutation' => $baseDir . '/src/Data/MediaItemMutation.php',
    'WPGraphQL\\Data\\NodeResolver' => $baseDir . '/src/Data/NodeResolver.php',
    'WPGraphQL\\Data\\PostObjectMutation' => $baseDir . '/src/Data/PostObjectMutation.php',
    'WPGraphQL\\Data\\TermObjectMutation' => $baseDir . '/src/Data/TermObjectMutation.php',
    'WPGraphQL\\Data\\UserMutation' => $baseDir . '/src/Data/UserMutation.php',
    'WPGraphQL\\Model\\Avatar' => $baseDir . '/src/Model/Avatar.php',
    'WPGraphQL\\Model\\Comment' => $baseDir . '/src/Model/Comment.php',
    'WPGraphQL\\Model\\CommentAuthor' => $baseDir . '/src/Model/CommentAuthor.php',
    'WPGraphQL\\Model\\Menu' => $baseDir . '/src/Model/Menu.php',
    'WPGraphQL\\Model\\MenuItem' => $baseDir . '/src/Model/MenuItem.php',
    'WPGraphQL\\Model\\Model' => $baseDir . '/src/Model/Model.php',
    'WPGraphQL\\Model\\Plugin' => $baseDir . '/src/Model/Plugin.php',
    'WPGraphQL\\Model\\Post' => $baseDir . '/src/Model/Post.php',
    'WPGraphQL\\Model\\PostType' => $baseDir . '/src/Model/PostType.php',
    'WPGraphQL\\Model\\Taxonomy' => $baseDir . '/src/Model/Taxonomy.php',
    'WPGraphQL\\Model\\Term' => $baseDir . '/src/Model/Term.php',
    'WPGraphQL\\Model\\Theme' => $baseDir . '/src/Model/Theme.php',
    'WPGraphQL\\Model\\User' => $baseDir . '/src/Model/User.php',
    'WPGraphQL\\Model\\UserRole' => $baseDir . '/src/Model/UserRole.php',
    'WPGraphQL\\Mutation\\CommentCreate' => $baseDir . '/src/Mutation/CommentCreate.php',
    'WPGraphQL\\Mutation\\CommentDelete' => $baseDir . '/src/Mutation/CommentDelete.php',
    'WPGraphQL\\Mutation\\CommentRestore' => $baseDir . '/src/Mutation/CommentRestore.php',
    'WPGraphQL\\Mutation\\CommentUpdate' => $baseDir . '/src/Mutation/CommentUpdate.php',
    'WPGraphQL\\Mutation\\MediaItemCreate' => $baseDir . '/src/Mutation/MediaItemCreate.php',
    'WPGraphQL\\Mutation\\MediaItemDelete' => $baseDir . '/src/Mutation/MediaItemDelete.php',
    'WPGraphQL\\Mutation\\MediaItemUpdate' => $baseDir . '/src/Mutation/MediaItemUpdate.php',
    'WPGraphQL\\Mutation\\PostObjectCreate' => $baseDir . '/src/Mutation/PostObjectCreate.php',
    'WPGraphQL\\Mutation\\PostObjectDelete' => $baseDir . '/src/Mutation/PostObjectDelete.php',
    'WPGraphQL\\Mutation\\PostObjectUpdate' => $baseDir . '/src/Mutation/PostObjectUpdate.php',
    'WPGraphQL\\Mutation\\ResetUserPassword' => $baseDir . '/src/Mutation/ResetUserPassword.php',
    'WPGraphQL\\Mutation\\SendPasswordResetEmail' => $baseDir . '/src/Mutation/SendPasswordResetEmail.php',
    'WPGraphQL\\Mutation\\TermObjectCreate' => $baseDir . '/src/Mutation/TermObjectCreate.php',
    'WPGraphQL\\Mutation\\TermObjectDelete' => $baseDir . '/src/Mutation/TermObjectDelete.php',
    'WPGraphQL\\Mutation\\TermObjectUpdate' => $baseDir . '/src/Mutation/TermObjectUpdate.php',
    'WPGraphQL\\Mutation\\UpdateSettings' => $baseDir . '/src/Mutation/UpdateSettings.php',
    'WPGraphQL\\Mutation\\UserCreate' => $baseDir . '/src/Mutation/UserCreate.php',
    'WPGraphQL\\Mutation\\UserDelete' => $baseDir . '/src/Mutation/UserDelete.php',
    'WPGraphQL\\Mutation\\UserRegister' => $baseDir . '/src/Mutation/UserRegister.php',
    'WPGraphQL\\Mutation\\UserUpdate' => $baseDir . '/src/Mutation/UserUpdate.php',
    'WPGraphQL\\Registry\\SchemaRegistry' => $baseDir . '/src/Registry/SchemaRegistry.php',
    'WPGraphQL\\Registry\\TypeRegistry' => $baseDir . '/src/Registry/TypeRegistry.php',
    'WPGraphQL\\Registry\\Utils\\PostObject' => $baseDir . '/src/Registry/Utils/PostObject.php',
    'WPGraphQL\\Registry\\Utils\\TermObject' => $baseDir . '/src/Registry/Utils/TermObject.php',
    'WPGraphQL\\Request' => $baseDir . '/src/Request.php',
    'WPGraphQL\\Router' => $baseDir . '/src/Router.php',
    'WPGraphQL\\Server\\ValidationRules\\DisableIntrospection' => $baseDir . '/src/Server/ValidationRules/DisableIntrospection.php',
    'WPGraphQL\\Server\\ValidationRules\\QueryDepth' => $baseDir . '/src/Server/ValidationRules/QueryDepth.php',
    'WPGraphQL\\Server\\ValidationRules\\RequireAuthentication' => $baseDir . '/src/Server/ValidationRules/RequireAuthentication.php',
    'WPGraphQL\\Server\\WPHelper' => $baseDir . '/src/Server/WPHelper.php',
    'WPGraphQL\\Type\\Connection\\Comments' => $baseDir . '/src/Type/Connection/Comments.php',
    'WPGraphQL\\Type\\Connection\\MenuItems' => $baseDir . '/src/Type/Connection/MenuItems.php',
    'WPGraphQL\\Type\\Connection\\PostObjects' => $baseDir . '/src/Type/Connection/PostObjects.php',
    'WPGraphQL\\Type\\Connection\\Taxonomies' => $baseDir . '/src/Type/Connection/Taxonomies.php',
    'WPGraphQL\\Type\\Connection\\TermObjects' => $baseDir . '/src/Type/Connection/TermObjects.php',
    'WPGraphQL\\Type\\Connection\\Users' => $baseDir . '/src/Type/Connection/Users.php',
    'WPGraphQL\\Type\\Enum\\AvatarRatingEnum' => $baseDir . '/src/Type/Enum/AvatarRatingEnum.php',
    'WPGraphQL\\Type\\Enum\\CommentNodeIdTypeEnum' => $baseDir . '/src/Type/Enum/CommentNodeIdTypeEnum.php',
    'WPGraphQL\\Type\\Enum\\CommentStatusEnum' => $baseDir . '/src/Type/Enum/CommentStatusEnum.php',
    'WPGraphQL\\Type\\Enum\\CommentsConnectionOrderbyEnum' => $baseDir . '/src/Type/Enum/CommentsConnectionOrderbyEnum.php',
    'WPGraphQL\\Type\\Enum\\ContentNodeIdTypeEnum' => $baseDir . '/src/Type/Enum/ContentNodeIdTypeEnum.php',
    'WPGraphQL\\Type\\Enum\\ContentTypeEnum' => $baseDir . '/src/Type/Enum/ContentTypeEnum.php',
    'WPGraphQL\\Type\\Enum\\ContentTypeIdTypeEnum' => $baseDir . '/src/Type/Enum/ContentTypeIdTypeEnum.php',
    'WPGraphQL\\Type\\Enum\\MediaItemSizeEnum' => $baseDir . '/src/Type/Enum/MediaItemSizeEnum.php',
    'WPGraphQL\\Type\\Enum\\MediaItemStatusEnum' => $baseDir . '/src/Type/Enum/MediaItemStatusEnum.php',
    'WPGraphQL\\Type\\Enum\\MenuItemNodeIdTypeEnum' => $baseDir . '/src/Type/Enum/MenuItemNodeIdTypeEnum.php',
    'WPGraphQL\\Type\\Enum\\MenuLocationEnum' => $baseDir . '/src/Type/Enum/MenuLocationEnum.php',
    'WPGraphQL\\Type\\Enum\\MenuNodeIdTypeEnum' => $baseDir . '/src/Type/Enum/MenuNodeIdTypeEnum.php',
    'WPGraphQL\\Type\\Enum\\MimeTypeEnum' => $baseDir . '/src/Type/Enum/MimeTypeEnum.php',
    'WPGraphQL\\Type\\Enum\\OrderEnum' => $baseDir . '/src/Type/Enum/OrderEnum.php',
    'WPGraphQL\\Type\\Enum\\PluginStatusEnum' => $baseDir . '/src/Type/Enum/PluginStatusEnum.php',
    'WPGraphQL\\Type\\Enum\\PostObjectFieldFormatEnum' => $baseDir . '/src/Type/Enum/PostObjectFieldFormatEnum.php',
    'WPGraphQL\\Type\\Enum\\PostObjectsConnectionDateColumnEnum' => $baseDir . '/src/Type/Enum/PostObjectsConnectionDateColumnEnum.php',
    'WPGraphQL\\Type\\Enum\\PostObjectsConnectionOrderbyEnum' => $baseDir . '/src/Type/Enum/PostObjectsConnectionOrderbyEnum.php',
    'WPGraphQL\\Type\\Enum\\PostStatusEnum' => $baseDir . '/src/Type/Enum/PostStatusEnum.php',
    'WPGraphQL\\Type\\Enum\\RelationEnum' => $baseDir . '/src/Type/Enum/RelationEnum.php',
    'WPGraphQL\\Type\\Enum\\ScriptLoadingStrategyEnum' => $baseDir . '/src/Type/Enum/ScriptLoadingStrategyEnum.php',
    'WPGraphQL\\Type\\Enum\\TaxonomyEnum' => $baseDir . '/src/Type/Enum/TaxonomyEnum.php',
    'WPGraphQL\\Type\\Enum\\TaxonomyIdTypeEnum' => $baseDir . '/src/Type/Enum/TaxonomyIdTypeEnum.php',
    'WPGraphQL\\Type\\Enum\\TermNodeIdTypeEnum' => $baseDir . '/src/Type/Enum/TermNodeIdTypeEnum.php',
    'WPGraphQL\\Type\\Enum\\TermObjectsConnectionOrderbyEnum' => $baseDir . '/src/Type/Enum/TermObjectsConnectionOrderbyEnum.php',
    'WPGraphQL\\Type\\Enum\\TimezoneEnum' => $baseDir . '/src/Type/Enum/TimezoneEnum.php',
    'WPGraphQL\\Type\\Enum\\UserNodeIdTypeEnum' => $baseDir . '/src/Type/Enum/UserNodeIdTypeEnum.php',
    'WPGraphQL\\Type\\Enum\\UserRoleEnum' => $baseDir . '/src/Type/Enum/UserRoleEnum.php',
    'WPGraphQL\\Type\\Enum\\UsersConnectionOrderbyEnum' => $baseDir . '/src/Type/Enum/UsersConnectionOrderbyEnum.php',
    'WPGraphQL\\Type\\Enum\\UsersConnectionSearchColumnEnum' => $baseDir . '/src/Type/Enum/UsersConnectionSearchColumnEnum.php',
    'WPGraphQL\\Type\\Input\\DateInput' => $baseDir . '/src/Type/Input/DateInput.php',
    'WPGraphQL\\Type\\Input\\DateQueryInput' => $baseDir . '/src/Type/Input/DateQueryInput.php',
    'WPGraphQL\\Type\\Input\\PostObjectsConnectionOrderbyInput' => $baseDir . '/src/Type/Input/PostObjectsConnectionOrderbyInput.php',
    'WPGraphQL\\Type\\Input\\UsersConnectionOrderbyInput' => $baseDir . '/src/Type/Input/UsersConnectionOrderbyInput.php',
    'WPGraphQL\\Type\\InterfaceType\\Commenter' => $baseDir . '/src/Type/InterfaceType/Commenter.php',
    'WPGraphQL\\Type\\InterfaceType\\Connection' => $baseDir . '/src/Type/InterfaceType/Connection.php',
    'WPGraphQL\\Type\\InterfaceType\\ContentNode' => $baseDir . '/src/Type/InterfaceType/ContentNode.php',
    'WPGraphQL\\Type\\InterfaceType\\ContentTemplate' => $baseDir . '/src/Type/InterfaceType/ContentTemplate.php',
    'WPGraphQL\\Type\\InterfaceType\\DatabaseIdentifier' => $baseDir . '/src/Type/InterfaceType/DatabaseIdentifier.php',
    'WPGraphQL\\Type\\InterfaceType\\Edge' => $baseDir . '/src/Type/InterfaceType/Edge.php',
    'WPGraphQL\\Type\\InterfaceType\\EnqueuedAsset' => $baseDir . '/src/Type/InterfaceType/EnqueuedAsset.php',
    'WPGraphQL\\Type\\InterfaceType\\HierarchicalContentNode' => $baseDir . '/src/Type/InterfaceType/HierarchicalContentNode.php',
    'WPGraphQL\\Type\\InterfaceType\\HierarchicalNode' => $baseDir . '/src/Type/InterfaceType/HierarchicalNode.php',
    'WPGraphQL\\Type\\InterfaceType\\HierarchicalTermNode' => $baseDir . '/src/Type/InterfaceType/HierarchicalTermNode.php',
    'WPGraphQL\\Type\\InterfaceType\\MenuItemLinkable' => $baseDir . '/src/Type/InterfaceType/MenuItemLinkable.php',
    'WPGraphQL\\Type\\InterfaceType\\Node' => $baseDir . '/src/Type/InterfaceType/Node.php',
    'WPGraphQL\\Type\\InterfaceType\\NodeWithAuthor' => $baseDir . '/src/Type/InterfaceType/NodeWithAuthor.php',
    'WPGraphQL\\Type\\InterfaceType\\NodeWithComments' => $baseDir . '/src/Type/InterfaceType/NodeWithComments.php',
    'WPGraphQL\\Type\\InterfaceType\\NodeWithContentEditor' => $baseDir . '/src/Type/InterfaceType/NodeWithContentEditor.php',
    'WPGraphQL\\Type\\InterfaceType\\NodeWithExcerpt' => $baseDir . '/src/Type/InterfaceType/NodeWithExcerpt.php',
    'WPGraphQL\\Type\\InterfaceType\\NodeWithFeaturedImage' => $baseDir . '/src/Type/InterfaceType/NodeWithFeaturedImage.php',
    'WPGraphQL\\Type\\InterfaceType\\NodeWithPageAttributes' => $baseDir . '/src/Type/InterfaceType/NodeWithPageAttributes.php',
    'WPGraphQL\\Type\\InterfaceType\\NodeWithRevisions' => $baseDir . '/src/Type/InterfaceType/NodeWithRevisions.php',
    'WPGraphQL\\Type\\InterfaceType\\NodeWithTemplate' => $baseDir . '/src/Type/InterfaceType/NodeWithTemplate.php',
    'WPGraphQL\\Type\\InterfaceType\\NodeWithTitle' => $baseDir . '/src/Type/InterfaceType/NodeWithTitle.php',
    'WPGraphQL\\Type\\InterfaceType\\NodeWithTrackbacks' => $baseDir . '/src/Type/InterfaceType/NodeWithTrackbacks.php',
    'WPGraphQL\\Type\\InterfaceType\\OneToOneConnection' => $baseDir . '/src/Type/InterfaceType/OneToOneConnection.php',
    'WPGraphQL\\Type\\InterfaceType\\PageInfo' => $baseDir . '/src/Type/InterfaceType/PageInfo.php',
    'WPGraphQL\\Type\\InterfaceType\\Previewable' => $baseDir . '/src/Type/InterfaceType/Previewable.php',
    'WPGraphQL\\Type\\InterfaceType\\TermNode' => $baseDir . '/src/Type/InterfaceType/TermNode.php',
    'WPGraphQL\\Type\\InterfaceType\\UniformResourceIdentifiable' => $baseDir . '/src/Type/InterfaceType/UniformResourceIdentifiable.php',
    'WPGraphQL\\Type\\ObjectType\\Avatar' => $baseDir . '/src/Type/ObjectType/Avatar.php',
    'WPGraphQL\\Type\\ObjectType\\Comment' => $baseDir . '/src/Type/ObjectType/Comment.php',
    'WPGraphQL\\Type\\ObjectType\\CommentAuthor' => $baseDir . '/src/Type/ObjectType/CommentAuthor.php',
    'WPGraphQL\\Type\\ObjectType\\ContentType' => $baseDir . '/src/Type/ObjectType/ContentType.php',
    'WPGraphQL\\Type\\ObjectType\\EnqueuedScript' => $baseDir . '/src/Type/ObjectType/EnqueuedScript.php',
    'WPGraphQL\\Type\\ObjectType\\EnqueuedStylesheet' => $baseDir . '/src/Type/ObjectType/EnqueuedStylesheet.php',
    'WPGraphQL\\Type\\ObjectType\\MediaDetails' => $baseDir . '/src/Type/ObjectType/MediaDetails.php',
    'WPGraphQL\\Type\\ObjectType\\MediaItemMeta' => $baseDir . '/src/Type/ObjectType/MediaItemMeta.php',
    'WPGraphQL\\Type\\ObjectType\\MediaSize' => $baseDir . '/src/Type/ObjectType/MediaSize.php',
    'WPGraphQL\\Type\\ObjectType\\Menu' => $baseDir . '/src/Type/ObjectType/Menu.php',
    'WPGraphQL\\Type\\ObjectType\\MenuItem' => $baseDir . '/src/Type/ObjectType/MenuItem.php',
    'WPGraphQL\\Type\\ObjectType\\Plugin' => $baseDir . '/src/Type/ObjectType/Plugin.php',
    'WPGraphQL\\Type\\ObjectType\\PostObject' => $baseDir . '/src/Type/ObjectType/PostObject.php',
    'WPGraphQL\\Type\\ObjectType\\PostTypeLabelDetails' => $baseDir . '/src/Type/ObjectType/PostTypeLabelDetails.php',
    'WPGraphQL\\Type\\ObjectType\\RootMutation' => $baseDir . '/src/Type/ObjectType/RootMutation.php',
    'WPGraphQL\\Type\\ObjectType\\RootQuery' => $baseDir . '/src/Type/ObjectType/RootQuery.php',
    'WPGraphQL\\Type\\ObjectType\\SettingGroup' => $baseDir . '/src/Type/ObjectType/SettingGroup.php',
    'WPGraphQL\\Type\\ObjectType\\Settings' => $baseDir . '/src/Type/ObjectType/Settings.php',
    'WPGraphQL\\Type\\ObjectType\\Taxonomy' => $baseDir . '/src/Type/ObjectType/Taxonomy.php',
    'WPGraphQL\\Type\\ObjectType\\TermObject' => $baseDir . '/src/Type/ObjectType/TermObject.php',
    'WPGraphQL\\Type\\ObjectType\\Theme' => $baseDir . '/src/Type/ObjectType/Theme.php',
    'WPGraphQL\\Type\\ObjectType\\User' => $baseDir . '/src/Type/ObjectType/User.php',
    'WPGraphQL\\Type\\ObjectType\\UserRole' => $baseDir . '/src/Type/ObjectType/UserRole.php',
    'WPGraphQL\\Type\\Union\\MenuItemObjectUnion' => $baseDir . '/src/Type/Union/MenuItemObjectUnion.php',
    'WPGraphQL\\Type\\Union\\PostObjectUnion' => $baseDir . '/src/Type/Union/PostObjectUnion.php',
    'WPGraphQL\\Type\\Union\\TermObjectUnion' => $baseDir . '/src/Type/Union/TermObjectUnion.php',
    'WPGraphQL\\Type\\WPConnectionType' => $baseDir . '/src/Type/WPConnectionType.php',
    'WPGraphQL\\Type\\WPEnumType' => $baseDir . '/src/Type/WPEnumType.php',
    'WPGraphQL\\Type\\WPInputObjectType' => $baseDir . '/src/Type/WPInputObjectType.php',
    'WPGraphQL\\Type\\WPInterfaceTrait' => $baseDir . '/src/Type/WPInterfaceTrait.php',
    'WPGraphQL\\Type\\WPInterfaceType' => $baseDir . '/src/Type/WPInterfaceType.php',
    'WPGraphQL\\Type\\WPMutationType' => $baseDir . '/src/Type/WPMutationType.php',
    'WPGraphQL\\Type\\WPObjectType' => $baseDir . '/src/Type/WPObjectType.php',
    'WPGraphQL\\Type\\WPScalar' => $baseDir . '/src/Type/WPScalar.php',
    'WPGraphQL\\Type\\WPUnionType' => $baseDir . '/src/Type/WPUnionType.php',
    'WPGraphQL\\Types' => $baseDir . '/src/Types.php',
    'WPGraphQL\\Utils\\DebugLog' => $baseDir . '/src/Utils/DebugLog.php',
    'WPGraphQL\\Utils\\InstrumentSchema' => $baseDir . '/src/Utils/InstrumentSchema.php',
    'WPGraphQL\\Utils\\Preview' => $baseDir . '/src/Utils/Preview.php',
    'WPGraphQL\\Utils\\QueryAnalyzer' => $baseDir . '/src/Utils/QueryAnalyzer.php',
    'WPGraphQL\\Utils\\QueryLog' => $baseDir . '/src/Utils/QueryLog.php',
    'WPGraphQL\\Utils\\Tracing' => $baseDir . '/src/Utils/Tracing.php',
    'WPGraphQL\\Utils\\Utils' => $baseDir . '/src/Utils/Utils.php',
    'WPGraphQL\\WPSchema' => $baseDir . '/src/WPSchema.php',
);


// File: wp-graphql\vendor\composer\autoload_namespaces.php
<?php

// autoload_namespaces.php @generated by Composer

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
);


// File: wp-graphql\vendor\composer\autoload_psr4.php
<?php

// autoload_psr4.php @generated by Composer

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
    'WPGraphQL\\' => array($baseDir . '/src'),
    'GraphQL\\' => array($vendorDir . '/webonyx/graphql-php/src'),
    'Appsero\\' => array($vendorDir . '/appsero/client/src'),
);


// File: wp-graphql\vendor\composer\autoload_real.php
<?php

// autoload_real.php @generated by Composer

class ComposerAutoloaderInit1a3f5842150c900c52f8026a66f17617
{
    private static $loader;

    public static function loadClassLoader($class)
    {
        if ('Composer\Autoload\ClassLoader' === $class) {
            require __DIR__ . '/ClassLoader.php';
        }
    }

    /**
     * @return \Composer\Autoload\ClassLoader
     */
    public static function getLoader()
    {
        if (null !== self::$loader) {
            return self::$loader;
        }

        require __DIR__ . '/platform_check.php';

        spl_autoload_register(array('ComposerAutoloaderInit1a3f5842150c900c52f8026a66f17617', 'loadClassLoader'), true, true);
        self::$loader = $loader = new \Composer\Autoload\ClassLoader(\dirname(__DIR__));
        spl_autoload_unregister(array('ComposerAutoloaderInit1a3f5842150c900c52f8026a66f17617', 'loadClassLoader'));

        require __DIR__ . '/autoload_static.php';
        call_user_func(\Composer\Autoload\ComposerStaticInit1a3f5842150c900c52f8026a66f17617::getInitializer($loader));

        $loader->register(true);

        return $loader;
    }
}


// File: wp-graphql\vendor\composer\autoload_static.php
<?php

// autoload_static.php @generated by Composer

namespace Composer\Autoload;

class ComposerStaticInit1a3f5842150c900c52f8026a66f17617
{
    public static $prefixLengthsPsr4 = array (
        'W' => 
        array (
            'WPGraphQL\\' => 10,
        ),
        'G' => 
        array (
            'GraphQL\\' => 8,
        ),
        'A' => 
        array (
            'Appsero\\' => 8,
        ),
    );

    public static $prefixDirsPsr4 = array (
        'WPGraphQL\\' => 
        array (
            0 => __DIR__ . '/../..' . '/src',
        ),
        'GraphQL\\' => 
        array (
            0 => __DIR__ . '/..' . '/webonyx/graphql-php/src',
        ),
        'Appsero\\' => 
        array (
            0 => __DIR__ . '/..' . '/appsero/client/src',
        ),
    );

    public static $classMap = array (
        'Appsero\\Client' => __DIR__ . '/..' . '/appsero/client/src/Client.php',
        'Appsero\\Insights' => __DIR__ . '/..' . '/appsero/client/src/Insights.php',
        'Appsero\\License' => __DIR__ . '/..' . '/appsero/client/src/License.php',
        'Appsero\\Updater' => __DIR__ . '/..' . '/appsero/client/src/Updater.php',
        'Composer\\InstalledVersions' => __DIR__ . '/..' . '/composer/InstalledVersions.php',
        'GraphQLRelay\\Connection\\ArrayConnection' => __DIR__ . '/..' . '/ivome/graphql-relay-php/src/Connection/ArrayConnection.php',
        'GraphQLRelay\\Connection\\Connection' => __DIR__ . '/..' . '/ivome/graphql-relay-php/src/Connection/Connection.php',
        'GraphQLRelay\\Mutation\\Mutation' => __DIR__ . '/..' . '/ivome/graphql-relay-php/src/Mutation/Mutation.php',
        'GraphQLRelay\\Node\\Node' => __DIR__ . '/..' . '/ivome/graphql-relay-php/src/Node/Node.php',
        'GraphQLRelay\\Node\\Plural' => __DIR__ . '/..' . '/ivome/graphql-relay-php/src/Node/Plural.php',
        'GraphQLRelay\\Relay' => __DIR__ . '/..' . '/ivome/graphql-relay-php/src/Relay.php',
        'GraphQL\\Deferred' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Deferred.php',
        'GraphQL\\Error\\ClientAware' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Error/ClientAware.php',
        'GraphQL\\Error\\DebugFlag' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Error/DebugFlag.php',
        'GraphQL\\Error\\Error' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Error/Error.php',
        'GraphQL\\Error\\FormattedError' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Error/FormattedError.php',
        'GraphQL\\Error\\InvariantViolation' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Error/InvariantViolation.php',
        'GraphQL\\Error\\SyntaxError' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Error/SyntaxError.php',
        'GraphQL\\Error\\UserError' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Error/UserError.php',
        'GraphQL\\Error\\Warning' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Error/Warning.php',
        'GraphQL\\Exception\\InvalidArgument' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Exception/InvalidArgument.php',
        'GraphQL\\Executor\\ExecutionContext' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Executor/ExecutionContext.php',
        'GraphQL\\Executor\\ExecutionResult' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Executor/ExecutionResult.php',
        'GraphQL\\Executor\\Executor' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Executor/Executor.php',
        'GraphQL\\Executor\\ExecutorImplementation' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Executor/ExecutorImplementation.php',
        'GraphQL\\Executor\\Promise\\Adapter\\AmpPromiseAdapter' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Executor/Promise/Adapter/AmpPromiseAdapter.php',
        'GraphQL\\Executor\\Promise\\Adapter\\ReactPromiseAdapter' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Executor/Promise/Adapter/ReactPromiseAdapter.php',
        'GraphQL\\Executor\\Promise\\Adapter\\SyncPromise' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Executor/Promise/Adapter/SyncPromise.php',
        'GraphQL\\Executor\\Promise\\Adapter\\SyncPromiseAdapter' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Executor/Promise/Adapter/SyncPromiseAdapter.php',
        'GraphQL\\Executor\\Promise\\Promise' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Executor/Promise/Promise.php',
        'GraphQL\\Executor\\Promise\\PromiseAdapter' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Executor/Promise/PromiseAdapter.php',
        'GraphQL\\Executor\\ReferenceExecutor' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Executor/ReferenceExecutor.php',
        'GraphQL\\Executor\\Values' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Executor/Values.php',
        'GraphQL\\Experimental\\Executor\\Collector' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Experimental/Executor/Collector.php',
        'GraphQL\\Experimental\\Executor\\CoroutineContext' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Experimental/Executor/CoroutineContext.php',
        'GraphQL\\Experimental\\Executor\\CoroutineContextShared' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Experimental/Executor/CoroutineContextShared.php',
        'GraphQL\\Experimental\\Executor\\CoroutineExecutor' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Experimental/Executor/CoroutineExecutor.php',
        'GraphQL\\Experimental\\Executor\\Runtime' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Experimental/Executor/Runtime.php',
        'GraphQL\\Experimental\\Executor\\Strand' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Experimental/Executor/Strand.php',
        'GraphQL\\GraphQL' => __DIR__ . '/..' . '/webonyx/graphql-php/src/GraphQL.php',
        'GraphQL\\Language\\AST\\ArgumentNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/ArgumentNode.php',
        'GraphQL\\Language\\AST\\BooleanValueNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/BooleanValueNode.php',
        'GraphQL\\Language\\AST\\DefinitionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/DefinitionNode.php',
        'GraphQL\\Language\\AST\\DirectiveDefinitionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/DirectiveDefinitionNode.php',
        'GraphQL\\Language\\AST\\DirectiveNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/DirectiveNode.php',
        'GraphQL\\Language\\AST\\DocumentNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/DocumentNode.php',
        'GraphQL\\Language\\AST\\EnumTypeDefinitionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/EnumTypeDefinitionNode.php',
        'GraphQL\\Language\\AST\\EnumTypeExtensionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/EnumTypeExtensionNode.php',
        'GraphQL\\Language\\AST\\EnumValueDefinitionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/EnumValueDefinitionNode.php',
        'GraphQL\\Language\\AST\\EnumValueNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/EnumValueNode.php',
        'GraphQL\\Language\\AST\\ExecutableDefinitionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/ExecutableDefinitionNode.php',
        'GraphQL\\Language\\AST\\FieldDefinitionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/FieldDefinitionNode.php',
        'GraphQL\\Language\\AST\\FieldNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/FieldNode.php',
        'GraphQL\\Language\\AST\\FloatValueNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/FloatValueNode.php',
        'GraphQL\\Language\\AST\\FragmentDefinitionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/FragmentDefinitionNode.php',
        'GraphQL\\Language\\AST\\FragmentSpreadNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/FragmentSpreadNode.php',
        'GraphQL\\Language\\AST\\HasSelectionSet' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/HasSelectionSet.php',
        'GraphQL\\Language\\AST\\InlineFragmentNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/InlineFragmentNode.php',
        'GraphQL\\Language\\AST\\InputObjectTypeDefinitionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/InputObjectTypeDefinitionNode.php',
        'GraphQL\\Language\\AST\\InputObjectTypeExtensionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/InputObjectTypeExtensionNode.php',
        'GraphQL\\Language\\AST\\InputValueDefinitionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/InputValueDefinitionNode.php',
        'GraphQL\\Language\\AST\\IntValueNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/IntValueNode.php',
        'GraphQL\\Language\\AST\\InterfaceTypeDefinitionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/InterfaceTypeDefinitionNode.php',
        'GraphQL\\Language\\AST\\InterfaceTypeExtensionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/InterfaceTypeExtensionNode.php',
        'GraphQL\\Language\\AST\\ListTypeNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/ListTypeNode.php',
        'GraphQL\\Language\\AST\\ListValueNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/ListValueNode.php',
        'GraphQL\\Language\\AST\\Location' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/Location.php',
        'GraphQL\\Language\\AST\\NameNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/NameNode.php',
        'GraphQL\\Language\\AST\\NamedTypeNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/NamedTypeNode.php',
        'GraphQL\\Language\\AST\\Node' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/Node.php',
        'GraphQL\\Language\\AST\\NodeKind' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/NodeKind.php',
        'GraphQL\\Language\\AST\\NodeList' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/NodeList.php',
        'GraphQL\\Language\\AST\\NonNullTypeNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/NonNullTypeNode.php',
        'GraphQL\\Language\\AST\\NullValueNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/NullValueNode.php',
        'GraphQL\\Language\\AST\\ObjectFieldNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/ObjectFieldNode.php',
        'GraphQL\\Language\\AST\\ObjectTypeDefinitionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/ObjectTypeDefinitionNode.php',
        'GraphQL\\Language\\AST\\ObjectTypeExtensionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/ObjectTypeExtensionNode.php',
        'GraphQL\\Language\\AST\\ObjectValueNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/ObjectValueNode.php',
        'GraphQL\\Language\\AST\\OperationDefinitionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/OperationDefinitionNode.php',
        'GraphQL\\Language\\AST\\OperationTypeDefinitionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/OperationTypeDefinitionNode.php',
        'GraphQL\\Language\\AST\\ScalarTypeDefinitionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/ScalarTypeDefinitionNode.php',
        'GraphQL\\Language\\AST\\ScalarTypeExtensionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/ScalarTypeExtensionNode.php',
        'GraphQL\\Language\\AST\\SchemaDefinitionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/SchemaDefinitionNode.php',
        'GraphQL\\Language\\AST\\SchemaTypeExtensionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/SchemaTypeExtensionNode.php',
        'GraphQL\\Language\\AST\\SelectionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/SelectionNode.php',
        'GraphQL\\Language\\AST\\SelectionSetNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/SelectionSetNode.php',
        'GraphQL\\Language\\AST\\StringValueNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/StringValueNode.php',
        'GraphQL\\Language\\AST\\TypeDefinitionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/TypeDefinitionNode.php',
        'GraphQL\\Language\\AST\\TypeExtensionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/TypeExtensionNode.php',
        'GraphQL\\Language\\AST\\TypeNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/TypeNode.php',
        'GraphQL\\Language\\AST\\TypeSystemDefinitionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/TypeSystemDefinitionNode.php',
        'GraphQL\\Language\\AST\\UnionTypeDefinitionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/UnionTypeDefinitionNode.php',
        'GraphQL\\Language\\AST\\UnionTypeExtensionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/UnionTypeExtensionNode.php',
        'GraphQL\\Language\\AST\\ValueNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/ValueNode.php',
        'GraphQL\\Language\\AST\\VariableDefinitionNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/VariableDefinitionNode.php',
        'GraphQL\\Language\\AST\\VariableNode' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/AST/VariableNode.php',
        'GraphQL\\Language\\DirectiveLocation' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/DirectiveLocation.php',
        'GraphQL\\Language\\Lexer' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/Lexer.php',
        'GraphQL\\Language\\Parser' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/Parser.php',
        'GraphQL\\Language\\Printer' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/Printer.php',
        'GraphQL\\Language\\Source' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/Source.php',
        'GraphQL\\Language\\SourceLocation' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/SourceLocation.php',
        'GraphQL\\Language\\Token' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/Token.php',
        'GraphQL\\Language\\Visitor' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/Visitor.php',
        'GraphQL\\Language\\VisitorOperation' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Language/VisitorOperation.php',
        'GraphQL\\Server\\Helper' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Server/Helper.php',
        'GraphQL\\Server\\OperationParams' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Server/OperationParams.php',
        'GraphQL\\Server\\RequestError' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Server/RequestError.php',
        'GraphQL\\Server\\ServerConfig' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Server/ServerConfig.php',
        'GraphQL\\Server\\StandardServer' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Server/StandardServer.php',
        'GraphQL\\Type\\Definition\\AbstractType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/AbstractType.php',
        'GraphQL\\Type\\Definition\\BooleanType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/BooleanType.php',
        'GraphQL\\Type\\Definition\\CompositeType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/CompositeType.php',
        'GraphQL\\Type\\Definition\\CustomScalarType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/CustomScalarType.php',
        'GraphQL\\Type\\Definition\\Directive' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/Directive.php',
        'GraphQL\\Type\\Definition\\EnumType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/EnumType.php',
        'GraphQL\\Type\\Definition\\EnumValueDefinition' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/EnumValueDefinition.php',
        'GraphQL\\Type\\Definition\\FieldArgument' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/FieldArgument.php',
        'GraphQL\\Type\\Definition\\FieldDefinition' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/FieldDefinition.php',
        'GraphQL\\Type\\Definition\\FloatType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/FloatType.php',
        'GraphQL\\Type\\Definition\\HasFieldsType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/HasFieldsType.php',
        'GraphQL\\Type\\Definition\\IDType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/IDType.php',
        'GraphQL\\Type\\Definition\\ImplementingType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/ImplementingType.php',
        'GraphQL\\Type\\Definition\\InputObjectField' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/InputObjectField.php',
        'GraphQL\\Type\\Definition\\InputObjectType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/InputObjectType.php',
        'GraphQL\\Type\\Definition\\InputType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/InputType.php',
        'GraphQL\\Type\\Definition\\IntType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/IntType.php',
        'GraphQL\\Type\\Definition\\InterfaceType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/InterfaceType.php',
        'GraphQL\\Type\\Definition\\LeafType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/LeafType.php',
        'GraphQL\\Type\\Definition\\ListOfType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/ListOfType.php',
        'GraphQL\\Type\\Definition\\NamedType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/NamedType.php',
        'GraphQL\\Type\\Definition\\NonNull' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/NonNull.php',
        'GraphQL\\Type\\Definition\\NullableType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/NullableType.php',
        'GraphQL\\Type\\Definition\\ObjectType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/ObjectType.php',
        'GraphQL\\Type\\Definition\\OutputType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/OutputType.php',
        'GraphQL\\Type\\Definition\\QueryPlan' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/QueryPlan.php',
        'GraphQL\\Type\\Definition\\ResolveInfo' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/ResolveInfo.php',
        'GraphQL\\Type\\Definition\\ScalarType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/ScalarType.php',
        'GraphQL\\Type\\Definition\\StringType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/StringType.php',
        'GraphQL\\Type\\Definition\\Type' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/Type.php',
        'GraphQL\\Type\\Definition\\TypeWithFields' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/TypeWithFields.php',
        'GraphQL\\Type\\Definition\\UnionType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/UnionType.php',
        'GraphQL\\Type\\Definition\\UnmodifiedType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/UnmodifiedType.php',
        'GraphQL\\Type\\Definition\\UnresolvedFieldDefinition' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/UnresolvedFieldDefinition.php',
        'GraphQL\\Type\\Definition\\WrappingType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Definition/WrappingType.php',
        'GraphQL\\Type\\Introspection' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Introspection.php',
        'GraphQL\\Type\\Schema' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Schema.php',
        'GraphQL\\Type\\SchemaConfig' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/SchemaConfig.php',
        'GraphQL\\Type\\SchemaValidationContext' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/SchemaValidationContext.php',
        'GraphQL\\Type\\TypeKind' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/TypeKind.php',
        'GraphQL\\Type\\Validation\\InputObjectCircularRefs' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Type/Validation/InputObjectCircularRefs.php',
        'GraphQL\\Utils\\AST' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Utils/AST.php',
        'GraphQL\\Utils\\ASTDefinitionBuilder' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Utils/ASTDefinitionBuilder.php',
        'GraphQL\\Utils\\BlockString' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Utils/BlockString.php',
        'GraphQL\\Utils\\BreakingChangesFinder' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Utils/BreakingChangesFinder.php',
        'GraphQL\\Utils\\BuildClientSchema' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Utils/BuildClientSchema.php',
        'GraphQL\\Utils\\BuildSchema' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Utils/BuildSchema.php',
        'GraphQL\\Utils\\InterfaceImplementations' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Utils/InterfaceImplementations.php',
        'GraphQL\\Utils\\MixedStore' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Utils/MixedStore.php',
        'GraphQL\\Utils\\PairSet' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Utils/PairSet.php',
        'GraphQL\\Utils\\SchemaExtender' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Utils/SchemaExtender.php',
        'GraphQL\\Utils\\SchemaPrinter' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Utils/SchemaPrinter.php',
        'GraphQL\\Utils\\TypeComparators' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Utils/TypeComparators.php',
        'GraphQL\\Utils\\TypeInfo' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Utils/TypeInfo.php',
        'GraphQL\\Utils\\Utils' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Utils/Utils.php',
        'GraphQL\\Utils\\Value' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Utils/Value.php',
        'GraphQL\\Validator\\ASTValidationContext' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/ASTValidationContext.php',
        'GraphQL\\Validator\\DocumentValidator' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/DocumentValidator.php',
        'GraphQL\\Validator\\Rules\\CustomValidationRule' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/CustomValidationRule.php',
        'GraphQL\\Validator\\Rules\\DisableIntrospection' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/DisableIntrospection.php',
        'GraphQL\\Validator\\Rules\\ExecutableDefinitions' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/ExecutableDefinitions.php',
        'GraphQL\\Validator\\Rules\\FieldsOnCorrectType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/FieldsOnCorrectType.php',
        'GraphQL\\Validator\\Rules\\FragmentsOnCompositeTypes' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/FragmentsOnCompositeTypes.php',
        'GraphQL\\Validator\\Rules\\KnownArgumentNames' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/KnownArgumentNames.php',
        'GraphQL\\Validator\\Rules\\KnownArgumentNamesOnDirectives' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/KnownArgumentNamesOnDirectives.php',
        'GraphQL\\Validator\\Rules\\KnownDirectives' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/KnownDirectives.php',
        'GraphQL\\Validator\\Rules\\KnownFragmentNames' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/KnownFragmentNames.php',
        'GraphQL\\Validator\\Rules\\KnownTypeNames' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/KnownTypeNames.php',
        'GraphQL\\Validator\\Rules\\LoneAnonymousOperation' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/LoneAnonymousOperation.php',
        'GraphQL\\Validator\\Rules\\LoneSchemaDefinition' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/LoneSchemaDefinition.php',
        'GraphQL\\Validator\\Rules\\NoFragmentCycles' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/NoFragmentCycles.php',
        'GraphQL\\Validator\\Rules\\NoUndefinedVariables' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/NoUndefinedVariables.php',
        'GraphQL\\Validator\\Rules\\NoUnusedFragments' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/NoUnusedFragments.php',
        'GraphQL\\Validator\\Rules\\NoUnusedVariables' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/NoUnusedVariables.php',
        'GraphQL\\Validator\\Rules\\OverlappingFieldsCanBeMerged' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/OverlappingFieldsCanBeMerged.php',
        'GraphQL\\Validator\\Rules\\PossibleFragmentSpreads' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/PossibleFragmentSpreads.php',
        'GraphQL\\Validator\\Rules\\ProvidedRequiredArguments' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/ProvidedRequiredArguments.php',
        'GraphQL\\Validator\\Rules\\ProvidedRequiredArgumentsOnDirectives' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/ProvidedRequiredArgumentsOnDirectives.php',
        'GraphQL\\Validator\\Rules\\QueryComplexity' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/QueryComplexity.php',
        'GraphQL\\Validator\\Rules\\QueryDepth' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/QueryDepth.php',
        'GraphQL\\Validator\\Rules\\QuerySecurityRule' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/QuerySecurityRule.php',
        'GraphQL\\Validator\\Rules\\ScalarLeafs' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/ScalarLeafs.php',
        'GraphQL\\Validator\\Rules\\SingleFieldSubscription' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/SingleFieldSubscription.php',
        'GraphQL\\Validator\\Rules\\UniqueArgumentNames' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/UniqueArgumentNames.php',
        'GraphQL\\Validator\\Rules\\UniqueDirectivesPerLocation' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/UniqueDirectivesPerLocation.php',
        'GraphQL\\Validator\\Rules\\UniqueFragmentNames' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/UniqueFragmentNames.php',
        'GraphQL\\Validator\\Rules\\UniqueInputFieldNames' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/UniqueInputFieldNames.php',
        'GraphQL\\Validator\\Rules\\UniqueOperationNames' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/UniqueOperationNames.php',
        'GraphQL\\Validator\\Rules\\UniqueVariableNames' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/UniqueVariableNames.php',
        'GraphQL\\Validator\\Rules\\ValidationRule' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/ValidationRule.php',
        'GraphQL\\Validator\\Rules\\ValuesOfCorrectType' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/ValuesOfCorrectType.php',
        'GraphQL\\Validator\\Rules\\VariablesAreInputTypes' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/VariablesAreInputTypes.php',
        'GraphQL\\Validator\\Rules\\VariablesInAllowedPosition' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/Rules/VariablesInAllowedPosition.php',
        'GraphQL\\Validator\\SDLValidationContext' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/SDLValidationContext.php',
        'GraphQL\\Validator\\ValidationContext' => __DIR__ . '/..' . '/webonyx/graphql-php/src/Validator/ValidationContext.php',
        'WPGraphQL\\Admin\\Admin' => __DIR__ . '/../..' . '/src/Admin/Admin.php',
        'WPGraphQL\\Admin\\AdminNotices' => __DIR__ . '/../..' . '/src/Admin/AdminNotices.php',
        'WPGraphQL\\Admin\\GraphiQL\\GraphiQL' => __DIR__ . '/../..' . '/src/Admin/GraphiQL/GraphiQL.php',
        'WPGraphQL\\Admin\\Settings\\Settings' => __DIR__ . '/../..' . '/src/Admin/Settings/Settings.php',
        'WPGraphQL\\Admin\\Settings\\SettingsRegistry' => __DIR__ . '/../..' . '/src/Admin/Settings/SettingsRegistry.php',
        'WPGraphQL\\AppContext' => __DIR__ . '/../..' . '/src/AppContext.php',
        'WPGraphQL\\Connection\\Comments' => __DIR__ . '/../..' . '/src/Connection/Comments.php',
        'WPGraphQL\\Connection\\MenuItems' => __DIR__ . '/../..' . '/src/Connection/MenuItems.php',
        'WPGraphQL\\Connection\\PostObjects' => __DIR__ . '/../..' . '/src/Connection/PostObjects.php',
        'WPGraphQL\\Connection\\Taxonomies' => __DIR__ . '/../..' . '/src/Connection/Taxonomies.php',
        'WPGraphQL\\Connection\\TermObjects' => __DIR__ . '/../..' . '/src/Connection/TermObjects.php',
        'WPGraphQL\\Connection\\Users' => __DIR__ . '/../..' . '/src/Connection/Users.php',
        'WPGraphQL\\Data\\CommentMutation' => __DIR__ . '/../..' . '/src/Data/CommentMutation.php',
        'WPGraphQL\\Data\\Config' => __DIR__ . '/../..' . '/src/Data/Config.php',
        'WPGraphQL\\Data\\Connection\\AbstractConnectionResolver' => __DIR__ . '/../..' . '/src/Data/Connection/AbstractConnectionResolver.php',
        'WPGraphQL\\Data\\Connection\\CommentConnectionResolver' => __DIR__ . '/../..' . '/src/Data/Connection/CommentConnectionResolver.php',
        'WPGraphQL\\Data\\Connection\\ContentTypeConnectionResolver' => __DIR__ . '/../..' . '/src/Data/Connection/ContentTypeConnectionResolver.php',
        'WPGraphQL\\Data\\Connection\\EnqueuedScriptsConnectionResolver' => __DIR__ . '/../..' . '/src/Data/Connection/EnqueuedScriptsConnectionResolver.php',
        'WPGraphQL\\Data\\Connection\\EnqueuedStylesheetConnectionResolver' => __DIR__ . '/../..' . '/src/Data/Connection/EnqueuedStylesheetConnectionResolver.php',
        'WPGraphQL\\Data\\Connection\\MenuConnectionResolver' => __DIR__ . '/../..' . '/src/Data/Connection/MenuConnectionResolver.php',
        'WPGraphQL\\Data\\Connection\\MenuItemConnectionResolver' => __DIR__ . '/../..' . '/src/Data/Connection/MenuItemConnectionResolver.php',
        'WPGraphQL\\Data\\Connection\\PluginConnectionResolver' => __DIR__ . '/../..' . '/src/Data/Connection/PluginConnectionResolver.php',
        'WPGraphQL\\Data\\Connection\\PostObjectConnectionResolver' => __DIR__ . '/../..' . '/src/Data/Connection/PostObjectConnectionResolver.php',
        'WPGraphQL\\Data\\Connection\\TaxonomyConnectionResolver' => __DIR__ . '/../..' . '/src/Data/Connection/TaxonomyConnectionResolver.php',
        'WPGraphQL\\Data\\Connection\\TermObjectConnectionResolver' => __DIR__ . '/../..' . '/src/Data/Connection/TermObjectConnectionResolver.php',
        'WPGraphQL\\Data\\Connection\\ThemeConnectionResolver' => __DIR__ . '/../..' . '/src/Data/Connection/ThemeConnectionResolver.php',
        'WPGraphQL\\Data\\Connection\\UserConnectionResolver' => __DIR__ . '/../..' . '/src/Data/Connection/UserConnectionResolver.php',
        'WPGraphQL\\Data\\Connection\\UserRoleConnectionResolver' => __DIR__ . '/../..' . '/src/Data/Connection/UserRoleConnectionResolver.php',
        'WPGraphQL\\Data\\Cursor\\AbstractCursor' => __DIR__ . '/../..' . '/src/Data/Cursor/AbstractCursor.php',
        'WPGraphQL\\Data\\Cursor\\CommentObjectCursor' => __DIR__ . '/../..' . '/src/Data/Cursor/CommentObjectCursor.php',
        'WPGraphQL\\Data\\Cursor\\CursorBuilder' => __DIR__ . '/../..' . '/src/Data/Cursor/CursorBuilder.php',
        'WPGraphQL\\Data\\Cursor\\PostObjectCursor' => __DIR__ . '/../..' . '/src/Data/Cursor/PostObjectCursor.php',
        'WPGraphQL\\Data\\Cursor\\TermObjectCursor' => __DIR__ . '/../..' . '/src/Data/Cursor/TermObjectCursor.php',
        'WPGraphQL\\Data\\Cursor\\UserCursor' => __DIR__ . '/../..' . '/src/Data/Cursor/UserCursor.php',
        'WPGraphQL\\Data\\DataSource' => __DIR__ . '/../..' . '/src/Data/DataSource.php',
        'WPGraphQL\\Data\\Loader\\AbstractDataLoader' => __DIR__ . '/../..' . '/src/Data/Loader/AbstractDataLoader.php',
        'WPGraphQL\\Data\\Loader\\CommentAuthorLoader' => __DIR__ . '/../..' . '/src/Data/Loader/CommentAuthorLoader.php',
        'WPGraphQL\\Data\\Loader\\CommentLoader' => __DIR__ . '/../..' . '/src/Data/Loader/CommentLoader.php',
        'WPGraphQL\\Data\\Loader\\EnqueuedScriptLoader' => __DIR__ . '/../..' . '/src/Data/Loader/EnqueuedScriptLoader.php',
        'WPGraphQL\\Data\\Loader\\EnqueuedStylesheetLoader' => __DIR__ . '/../..' . '/src/Data/Loader/EnqueuedStylesheetLoader.php',
        'WPGraphQL\\Data\\Loader\\PluginLoader' => __DIR__ . '/../..' . '/src/Data/Loader/PluginLoader.php',
        'WPGraphQL\\Data\\Loader\\PostObjectLoader' => __DIR__ . '/../..' . '/src/Data/Loader/PostObjectLoader.php',
        'WPGraphQL\\Data\\Loader\\PostTypeLoader' => __DIR__ . '/../..' . '/src/Data/Loader/PostTypeLoader.php',
        'WPGraphQL\\Data\\Loader\\TaxonomyLoader' => __DIR__ . '/../..' . '/src/Data/Loader/TaxonomyLoader.php',
        'WPGraphQL\\Data\\Loader\\TermObjectLoader' => __DIR__ . '/../..' . '/src/Data/Loader/TermObjectLoader.php',
        'WPGraphQL\\Data\\Loader\\ThemeLoader' => __DIR__ . '/../..' . '/src/Data/Loader/ThemeLoader.php',
        'WPGraphQL\\Data\\Loader\\UserLoader' => __DIR__ . '/../..' . '/src/Data/Loader/UserLoader.php',
        'WPGraphQL\\Data\\Loader\\UserRoleLoader' => __DIR__ . '/../..' . '/src/Data/Loader/UserRoleLoader.php',
        'WPGraphQL\\Data\\MediaItemMutation' => __DIR__ . '/../..' . '/src/Data/MediaItemMutation.php',
        'WPGraphQL\\Data\\NodeResolver' => __DIR__ . '/../..' . '/src/Data/NodeResolver.php',
        'WPGraphQL\\Data\\PostObjectMutation' => __DIR__ . '/../..' . '/src/Data/PostObjectMutation.php',
        'WPGraphQL\\Data\\TermObjectMutation' => __DIR__ . '/../..' . '/src/Data/TermObjectMutation.php',
        'WPGraphQL\\Data\\UserMutation' => __DIR__ . '/../..' . '/src/Data/UserMutation.php',
        'WPGraphQL\\Model\\Avatar' => __DIR__ . '/../..' . '/src/Model/Avatar.php',
        'WPGraphQL\\Model\\Comment' => __DIR__ . '/../..' . '/src/Model/Comment.php',
        'WPGraphQL\\Model\\CommentAuthor' => __DIR__ . '/../..' . '/src/Model/CommentAuthor.php',
        'WPGraphQL\\Model\\Menu' => __DIR__ . '/../..' . '/src/Model/Menu.php',
        'WPGraphQL\\Model\\MenuItem' => __DIR__ . '/../..' . '/src/Model/MenuItem.php',
        'WPGraphQL\\Model\\Model' => __DIR__ . '/../..' . '/src/Model/Model.php',
        'WPGraphQL\\Model\\Plugin' => __DIR__ . '/../..' . '/src/Model/Plugin.php',
        'WPGraphQL\\Model\\Post' => __DIR__ . '/../..' . '/src/Model/Post.php',
        'WPGraphQL\\Model\\PostType' => __DIR__ . '/../..' . '/src/Model/PostType.php',
        'WPGraphQL\\Model\\Taxonomy' => __DIR__ . '/../..' . '/src/Model/Taxonomy.php',
        'WPGraphQL\\Model\\Term' => __DIR__ . '/../..' . '/src/Model/Term.php',
        'WPGraphQL\\Model\\Theme' => __DIR__ . '/../..' . '/src/Model/Theme.php',
        'WPGraphQL\\Model\\User' => __DIR__ . '/../..' . '/src/Model/User.php',
        'WPGraphQL\\Model\\UserRole' => __DIR__ . '/../..' . '/src/Model/UserRole.php',
        'WPGraphQL\\Mutation\\CommentCreate' => __DIR__ . '/../..' . '/src/Mutation/CommentCreate.php',
        'WPGraphQL\\Mutation\\CommentDelete' => __DIR__ . '/../..' . '/src/Mutation/CommentDelete.php',
        'WPGraphQL\\Mutation\\CommentRestore' => __DIR__ . '/../..' . '/src/Mutation/CommentRestore.php',
        'WPGraphQL\\Mutation\\CommentUpdate' => __DIR__ . '/../..' . '/src/Mutation/CommentUpdate.php',
        'WPGraphQL\\Mutation\\MediaItemCreate' => __DIR__ . '/../..' . '/src/Mutation/MediaItemCreate.php',
        'WPGraphQL\\Mutation\\MediaItemDelete' => __DIR__ . '/../..' . '/src/Mutation/MediaItemDelete.php',
        'WPGraphQL\\Mutation\\MediaItemUpdate' => __DIR__ . '/../..' . '/src/Mutation/MediaItemUpdate.php',
        'WPGraphQL\\Mutation\\PostObjectCreate' => __DIR__ . '/../..' . '/src/Mutation/PostObjectCreate.php',
        'WPGraphQL\\Mutation\\PostObjectDelete' => __DIR__ . '/../..' . '/src/Mutation/PostObjectDelete.php',
        'WPGraphQL\\Mutation\\PostObjectUpdate' => __DIR__ . '/../..' . '/src/Mutation/PostObjectUpdate.php',
        'WPGraphQL\\Mutation\\ResetUserPassword' => __DIR__ . '/../..' . '/src/Mutation/ResetUserPassword.php',
        'WPGraphQL\\Mutation\\SendPasswordResetEmail' => __DIR__ . '/../..' . '/src/Mutation/SendPasswordResetEmail.php',
        'WPGraphQL\\Mutation\\TermObjectCreate' => __DIR__ . '/../..' . '/src/Mutation/TermObjectCreate.php',
        'WPGraphQL\\Mutation\\TermObjectDelete' => __DIR__ . '/../..' . '/src/Mutation/TermObjectDelete.php',
        'WPGraphQL\\Mutation\\TermObjectUpdate' => __DIR__ . '/../..' . '/src/Mutation/TermObjectUpdate.php',
        'WPGraphQL\\Mutation\\UpdateSettings' => __DIR__ . '/../..' . '/src/Mutation/UpdateSettings.php',
        'WPGraphQL\\Mutation\\UserCreate' => __DIR__ . '/../..' . '/src/Mutation/UserCreate.php',
        'WPGraphQL\\Mutation\\UserDelete' => __DIR__ . '/../..' . '/src/Mutation/UserDelete.php',
        'WPGraphQL\\Mutation\\UserRegister' => __DIR__ . '/../..' . '/src/Mutation/UserRegister.php',
        'WPGraphQL\\Mutation\\UserUpdate' => __DIR__ . '/../..' . '/src/Mutation/UserUpdate.php',
        'WPGraphQL\\Registry\\SchemaRegistry' => __DIR__ . '/../..' . '/src/Registry/SchemaRegistry.php',
        'WPGraphQL\\Registry\\TypeRegistry' => __DIR__ . '/../..' . '/src/Registry/TypeRegistry.php',
        'WPGraphQL\\Registry\\Utils\\PostObject' => __DIR__ . '/../..' . '/src/Registry/Utils/PostObject.php',
        'WPGraphQL\\Registry\\Utils\\TermObject' => __DIR__ . '/../..' . '/src/Registry/Utils/TermObject.php',
        'WPGraphQL\\Request' => __DIR__ . '/../..' . '/src/Request.php',
        'WPGraphQL\\Router' => __DIR__ . '/../..' . '/src/Router.php',
        'WPGraphQL\\Server\\ValidationRules\\DisableIntrospection' => __DIR__ . '/../..' . '/src/Server/ValidationRules/DisableIntrospection.php',
        'WPGraphQL\\Server\\ValidationRules\\QueryDepth' => __DIR__ . '/../..' . '/src/Server/ValidationRules/QueryDepth.php',
        'WPGraphQL\\Server\\ValidationRules\\RequireAuthentication' => __DIR__ . '/../..' . '/src/Server/ValidationRules/RequireAuthentication.php',
        'WPGraphQL\\Server\\WPHelper' => __DIR__ . '/../..' . '/src/Server/WPHelper.php',
        'WPGraphQL\\Type\\Connection\\Comments' => __DIR__ . '/../..' . '/src/Type/Connection/Comments.php',
        'WPGraphQL\\Type\\Connection\\MenuItems' => __DIR__ . '/../..' . '/src/Type/Connection/MenuItems.php',
        'WPGraphQL\\Type\\Connection\\PostObjects' => __DIR__ . '/../..' . '/src/Type/Connection/PostObjects.php',
        'WPGraphQL\\Type\\Connection\\Taxonomies' => __DIR__ . '/../..' . '/src/Type/Connection/Taxonomies.php',
        'WPGraphQL\\Type\\Connection\\TermObjects' => __DIR__ . '/../..' . '/src/Type/Connection/TermObjects.php',
        'WPGraphQL\\Type\\Connection\\Users' => __DIR__ . '/../..' . '/src/Type/Connection/Users.php',
        'WPGraphQL\\Type\\Enum\\AvatarRatingEnum' => __DIR__ . '/../..' . '/src/Type/Enum/AvatarRatingEnum.php',
        'WPGraphQL\\Type\\Enum\\CommentNodeIdTypeEnum' => __DIR__ . '/../..' . '/src/Type/Enum/CommentNodeIdTypeEnum.php',
        'WPGraphQL\\Type\\Enum\\CommentStatusEnum' => __DIR__ . '/../..' . '/src/Type/Enum/CommentStatusEnum.php',
        'WPGraphQL\\Type\\Enum\\CommentsConnectionOrderbyEnum' => __DIR__ . '/../..' . '/src/Type/Enum/CommentsConnectionOrderbyEnum.php',
        'WPGraphQL\\Type\\Enum\\ContentNodeIdTypeEnum' => __DIR__ . '/../..' . '/src/Type/Enum/ContentNodeIdTypeEnum.php',
        'WPGraphQL\\Type\\Enum\\ContentTypeEnum' => __DIR__ . '/../..' . '/src/Type/Enum/ContentTypeEnum.php',
        'WPGraphQL\\Type\\Enum\\ContentTypeIdTypeEnum' => __DIR__ . '/../..' . '/src/Type/Enum/ContentTypeIdTypeEnum.php',
        'WPGraphQL\\Type\\Enum\\MediaItemSizeEnum' => __DIR__ . '/../..' . '/src/Type/Enum/MediaItemSizeEnum.php',
        'WPGraphQL\\Type\\Enum\\MediaItemStatusEnum' => __DIR__ . '/../..' . '/src/Type/Enum/MediaItemStatusEnum.php',
        'WPGraphQL\\Type\\Enum\\MenuItemNodeIdTypeEnum' => __DIR__ . '/../..' . '/src/Type/Enum/MenuItemNodeIdTypeEnum.php',
        'WPGraphQL\\Type\\Enum\\MenuLocationEnum' => __DIR__ . '/../..' . '/src/Type/Enum/MenuLocationEnum.php',
        'WPGraphQL\\Type\\Enum\\MenuNodeIdTypeEnum' => __DIR__ . '/../..' . '/src/Type/Enum/MenuNodeIdTypeEnum.php',
        'WPGraphQL\\Type\\Enum\\MimeTypeEnum' => __DIR__ . '/../..' . '/src/Type/Enum/MimeTypeEnum.php',
        'WPGraphQL\\Type\\Enum\\OrderEnum' => __DIR__ . '/../..' . '/src/Type/Enum/OrderEnum.php',
        'WPGraphQL\\Type\\Enum\\PluginStatusEnum' => __DIR__ . '/../..' . '/src/Type/Enum/PluginStatusEnum.php',
        'WPGraphQL\\Type\\Enum\\PostObjectFieldFormatEnum' => __DIR__ . '/../..' . '/src/Type/Enum/PostObjectFieldFormatEnum.php',
        'WPGraphQL\\Type\\Enum\\PostObjectsConnectionDateColumnEnum' => __DIR__ . '/../..' . '/src/Type/Enum/PostObjectsConnectionDateColumnEnum.php',
        'WPGraphQL\\Type\\Enum\\PostObjectsConnectionOrderbyEnum' => __DIR__ . '/../..' . '/src/Type/Enum/PostObjectsConnectionOrderbyEnum.php',
        'WPGraphQL\\Type\\Enum\\PostStatusEnum' => __DIR__ . '/../..' . '/src/Type/Enum/PostStatusEnum.php',
        'WPGraphQL\\Type\\Enum\\RelationEnum' => __DIR__ . '/../..' . '/src/Type/Enum/RelationEnum.php',
        'WPGraphQL\\Type\\Enum\\ScriptLoadingStrategyEnum' => __DIR__ . '/../..' . '/src/Type/Enum/ScriptLoadingStrategyEnum.php',
        'WPGraphQL\\Type\\Enum\\TaxonomyEnum' => __DIR__ . '/../..' . '/src/Type/Enum/TaxonomyEnum.php',
        'WPGraphQL\\Type\\Enum\\TaxonomyIdTypeEnum' => __DIR__ . '/../..' . '/src/Type/Enum/TaxonomyIdTypeEnum.php',
        'WPGraphQL\\Type\\Enum\\TermNodeIdTypeEnum' => __DIR__ . '/../..' . '/src/Type/Enum/TermNodeIdTypeEnum.php',
        'WPGraphQL\\Type\\Enum\\TermObjectsConnectionOrderbyEnum' => __DIR__ . '/../..' . '/src/Type/Enum/TermObjectsConnectionOrderbyEnum.php',
        'WPGraphQL\\Type\\Enum\\TimezoneEnum' => __DIR__ . '/../..' . '/src/Type/Enum/TimezoneEnum.php',
        'WPGraphQL\\Type\\Enum\\UserNodeIdTypeEnum' => __DIR__ . '/../..' . '/src/Type/Enum/UserNodeIdTypeEnum.php',
        'WPGraphQL\\Type\\Enum\\UserRoleEnum' => __DIR__ . '/../..' . '/src/Type/Enum/UserRoleEnum.php',
        'WPGraphQL\\Type\\Enum\\UsersConnectionOrderbyEnum' => __DIR__ . '/../..' . '/src/Type/Enum/UsersConnectionOrderbyEnum.php',
        'WPGraphQL\\Type\\Enum\\UsersConnectionSearchColumnEnum' => __DIR__ . '/../..' . '/src/Type/Enum/UsersConnectionSearchColumnEnum.php',
        'WPGraphQL\\Type\\Input\\DateInput' => __DIR__ . '/../..' . '/src/Type/Input/DateInput.php',
        'WPGraphQL\\Type\\Input\\DateQueryInput' => __DIR__ . '/../..' . '/src/Type/Input/DateQueryInput.php',
        'WPGraphQL\\Type\\Input\\PostObjectsConnectionOrderbyInput' => __DIR__ . '/../..' . '/src/Type/Input/PostObjectsConnectionOrderbyInput.php',
        'WPGraphQL\\Type\\Input\\UsersConnectionOrderbyInput' => __DIR__ . '/../..' . '/src/Type/Input/UsersConnectionOrderbyInput.php',
        'WPGraphQL\\Type\\InterfaceType\\Commenter' => __DIR__ . '/../..' . '/src/Type/InterfaceType/Commenter.php',
        'WPGraphQL\\Type\\InterfaceType\\Connection' => __DIR__ . '/../..' . '/src/Type/InterfaceType/Connection.php',
        'WPGraphQL\\Type\\InterfaceType\\ContentNode' => __DIR__ . '/../..' . '/src/Type/InterfaceType/ContentNode.php',
        'WPGraphQL\\Type\\InterfaceType\\ContentTemplate' => __DIR__ . '/../..' . '/src/Type/InterfaceType/ContentTemplate.php',
        'WPGraphQL\\Type\\InterfaceType\\DatabaseIdentifier' => __DIR__ . '/../..' . '/src/Type/InterfaceType/DatabaseIdentifier.php',
        'WPGraphQL\\Type\\InterfaceType\\Edge' => __DIR__ . '/../..' . '/src/Type/InterfaceType/Edge.php',
        'WPGraphQL\\Type\\InterfaceType\\EnqueuedAsset' => __DIR__ . '/../..' . '/src/Type/InterfaceType/EnqueuedAsset.php',
        'WPGraphQL\\Type\\InterfaceType\\HierarchicalContentNode' => __DIR__ . '/../..' . '/src/Type/InterfaceType/HierarchicalContentNode.php',
        'WPGraphQL\\Type\\InterfaceType\\HierarchicalNode' => __DIR__ . '/../..' . '/src/Type/InterfaceType/HierarchicalNode.php',
        'WPGraphQL\\Type\\InterfaceType\\HierarchicalTermNode' => __DIR__ . '/../..' . '/src/Type/InterfaceType/HierarchicalTermNode.php',
        'WPGraphQL\\Type\\InterfaceType\\MenuItemLinkable' => __DIR__ . '/../..' . '/src/Type/InterfaceType/MenuItemLinkable.php',
        'WPGraphQL\\Type\\InterfaceType\\Node' => __DIR__ . '/../..' . '/src/Type/InterfaceType/Node.php',
        'WPGraphQL\\Type\\InterfaceType\\NodeWithAuthor' => __DIR__ . '/../..' . '/src/Type/InterfaceType/NodeWithAuthor.php',
        'WPGraphQL\\Type\\InterfaceType\\NodeWithComments' => __DIR__ . '/../..' . '/src/Type/InterfaceType/NodeWithComments.php',
        'WPGraphQL\\Type\\InterfaceType\\NodeWithContentEditor' => __DIR__ . '/../..' . '/src/Type/InterfaceType/NodeWithContentEditor.php',
        'WPGraphQL\\Type\\InterfaceType\\NodeWithExcerpt' => __DIR__ . '/../..' . '/src/Type/InterfaceType/NodeWithExcerpt.php',
        'WPGraphQL\\Type\\InterfaceType\\NodeWithFeaturedImage' => __DIR__ . '/../..' . '/src/Type/InterfaceType/NodeWithFeaturedImage.php',
        'WPGraphQL\\Type\\InterfaceType\\NodeWithPageAttributes' => __DIR__ . '/../..' . '/src/Type/InterfaceType/NodeWithPageAttributes.php',
        'WPGraphQL\\Type\\InterfaceType\\NodeWithRevisions' => __DIR__ . '/../..' . '/src/Type/InterfaceType/NodeWithRevisions.php',
        'WPGraphQL\\Type\\InterfaceType\\NodeWithTemplate' => __DIR__ . '/../..' . '/src/Type/InterfaceType/NodeWithTemplate.php',
        'WPGraphQL\\Type\\InterfaceType\\NodeWithTitle' => __DIR__ . '/../..' . '/src/Type/InterfaceType/NodeWithTitle.php',
        'WPGraphQL\\Type\\InterfaceType\\NodeWithTrackbacks' => __DIR__ . '/../..' . '/src/Type/InterfaceType/NodeWithTrackbacks.php',
        'WPGraphQL\\Type\\InterfaceType\\OneToOneConnection' => __DIR__ . '/../..' . '/src/Type/InterfaceType/OneToOneConnection.php',
        'WPGraphQL\\Type\\InterfaceType\\PageInfo' => __DIR__ . '/../..' . '/src/Type/InterfaceType/PageInfo.php',
        'WPGraphQL\\Type\\InterfaceType\\Previewable' => __DIR__ . '/../..' . '/src/Type/InterfaceType/Previewable.php',
        'WPGraphQL\\Type\\InterfaceType\\TermNode' => __DIR__ . '/../..' . '/src/Type/InterfaceType/TermNode.php',
        'WPGraphQL\\Type\\InterfaceType\\UniformResourceIdentifiable' => __DIR__ . '/../..' . '/src/Type/InterfaceType/UniformResourceIdentifiable.php',
        'WPGraphQL\\Type\\ObjectType\\Avatar' => __DIR__ . '/../..' . '/src/Type/ObjectType/Avatar.php',
        'WPGraphQL\\Type\\ObjectType\\Comment' => __DIR__ . '/../..' . '/src/Type/ObjectType/Comment.php',
        'WPGraphQL\\Type\\ObjectType\\CommentAuthor' => __DIR__ . '/../..' . '/src/Type/ObjectType/CommentAuthor.php',
        'WPGraphQL\\Type\\ObjectType\\ContentType' => __DIR__ . '/../..' . '/src/Type/ObjectType/ContentType.php',
        'WPGraphQL\\Type\\ObjectType\\EnqueuedScript' => __DIR__ . '/../..' . '/src/Type/ObjectType/EnqueuedScript.php',
        'WPGraphQL\\Type\\ObjectType\\EnqueuedStylesheet' => __DIR__ . '/../..' . '/src/Type/ObjectType/EnqueuedStylesheet.php',
        'WPGraphQL\\Type\\ObjectType\\MediaDetails' => __DIR__ . '/../..' . '/src/Type/ObjectType/MediaDetails.php',
        'WPGraphQL\\Type\\ObjectType\\MediaItemMeta' => __DIR__ . '/../..' . '/src/Type/ObjectType/MediaItemMeta.php',
        'WPGraphQL\\Type\\ObjectType\\MediaSize' => __DIR__ . '/../..' . '/src/Type/ObjectType/MediaSize.php',
        'WPGraphQL\\Type\\ObjectType\\Menu' => __DIR__ . '/../..' . '/src/Type/ObjectType/Menu.php',
        'WPGraphQL\\Type\\ObjectType\\MenuItem' => __DIR__ . '/../..' . '/src/Type/ObjectType/MenuItem.php',
        'WPGraphQL\\Type\\ObjectType\\Plugin' => __DIR__ . '/../..' . '/src/Type/ObjectType/Plugin.php',
        'WPGraphQL\\Type\\ObjectType\\PostObject' => __DIR__ . '/../..' . '/src/Type/ObjectType/PostObject.php',
        'WPGraphQL\\Type\\ObjectType\\PostTypeLabelDetails' => __DIR__ . '/../..' . '/src/Type/ObjectType/PostTypeLabelDetails.php',
        'WPGraphQL\\Type\\ObjectType\\RootMutation' => __DIR__ . '/../..' . '/src/Type/ObjectType/RootMutation.php',
        'WPGraphQL\\Type\\ObjectType\\RootQuery' => __DIR__ . '/../..' . '/src/Type/ObjectType/RootQuery.php',
        'WPGraphQL\\Type\\ObjectType\\SettingGroup' => __DIR__ . '/../..' . '/src/Type/ObjectType/SettingGroup.php',
        'WPGraphQL\\Type\\ObjectType\\Settings' => __DIR__ . '/../..' . '/src/Type/ObjectType/Settings.php',
        'WPGraphQL\\Type\\ObjectType\\Taxonomy' => __DIR__ . '/../..' . '/src/Type/ObjectType/Taxonomy.php',
        'WPGraphQL\\Type\\ObjectType\\TermObject' => __DIR__ . '/../..' . '/src/Type/ObjectType/TermObject.php',
        'WPGraphQL\\Type\\ObjectType\\Theme' => __DIR__ . '/../..' . '/src/Type/ObjectType/Theme.php',
        'WPGraphQL\\Type\\ObjectType\\User' => __DIR__ . '/../..' . '/src/Type/ObjectType/User.php',
        'WPGraphQL\\Type\\ObjectType\\UserRole' => __DIR__ . '/../..' . '/src/Type/ObjectType/UserRole.php',
        'WPGraphQL\\Type\\Union\\MenuItemObjectUnion' => __DIR__ . '/../..' . '/src/Type/Union/MenuItemObjectUnion.php',
        'WPGraphQL\\Type\\Union\\PostObjectUnion' => __DIR__ . '/../..' . '/src/Type/Union/PostObjectUnion.php',
        'WPGraphQL\\Type\\Union\\TermObjectUnion' => __DIR__ . '/../..' . '/src/Type/Union/TermObjectUnion.php',
        'WPGraphQL\\Type\\WPConnectionType' => __DIR__ . '/../..' . '/src/Type/WPConnectionType.php',
        'WPGraphQL\\Type\\WPEnumType' => __DIR__ . '/../..' . '/src/Type/WPEnumType.php',
        'WPGraphQL\\Type\\WPInputObjectType' => __DIR__ . '/../..' . '/src/Type/WPInputObjectType.php',
        'WPGraphQL\\Type\\WPInterfaceTrait' => __DIR__ . '/../..' . '/src/Type/WPInterfaceTrait.php',
        'WPGraphQL\\Type\\WPInterfaceType' => __DIR__ . '/../..' . '/src/Type/WPInterfaceType.php',
        'WPGraphQL\\Type\\WPMutationType' => __DIR__ . '/../..' . '/src/Type/WPMutationType.php',
        'WPGraphQL\\Type\\WPObjectType' => __DIR__ . '/../..' . '/src/Type/WPObjectType.php',
        'WPGraphQL\\Type\\WPScalar' => __DIR__ . '/../..' . '/src/Type/WPScalar.php',
        'WPGraphQL\\Type\\WPUnionType' => __DIR__ . '/../..' . '/src/Type/WPUnionType.php',
        'WPGraphQL\\Types' => __DIR__ . '/../..' . '/src/Types.php',
        'WPGraphQL\\Utils\\DebugLog' => __DIR__ . '/../..' . '/src/Utils/DebugLog.php',
        'WPGraphQL\\Utils\\InstrumentSchema' => __DIR__ . '/../..' . '/src/Utils/InstrumentSchema.php',
        'WPGraphQL\\Utils\\Preview' => __DIR__ . '/../..' . '/src/Utils/Preview.php',
        'WPGraphQL\\Utils\\QueryAnalyzer' => __DIR__ . '/../..' . '/src/Utils/QueryAnalyzer.php',
        'WPGraphQL\\Utils\\QueryLog' => __DIR__ . '/../..' . '/src/Utils/QueryLog.php',
        'WPGraphQL\\Utils\\Tracing' => __DIR__ . '/../..' . '/src/Utils/Tracing.php',
        'WPGraphQL\\Utils\\Utils' => __DIR__ . '/../..' . '/src/Utils/Utils.php',
        'WPGraphQL\\WPSchema' => __DIR__ . '/../..' . '/src/WPSchema.php',
    );

    public static function getInitializer(ClassLoader $loader)
    {
        return \Closure::bind(function () use ($loader) {
            $loader->prefixLengthsPsr4 = ComposerStaticInit1a3f5842150c900c52f8026a66f17617::$prefixLengthsPsr4;
            $loader->prefixDirsPsr4 = ComposerStaticInit1a3f5842150c900c52f8026a66f17617::$prefixDirsPsr4;
            $loader->classMap = ComposerStaticInit1a3f5842150c900c52f8026a66f17617::$classMap;

        }, null, ClassLoader::class);
    }
}


// File: wp-graphql\vendor\composer\ClassLoader.php
<?php

/*
 * This file is part of Composer.
 *
 * (c) Nils Adermann <naderman@naderman.de>
 *     Jordi Boggiano <j.boggiano@seld.be>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Composer\Autoload;

/**
 * ClassLoader implements a PSR-0, PSR-4 and classmap class loader.
 *
 *     $loader = new \Composer\Autoload\ClassLoader();
 *
 *     // register classes with namespaces
 *     $loader->add('Symfony\Component', __DIR__.'/component');
 *     $loader->add('Symfony',           __DIR__.'/framework');
 *
 *     // activate the autoloader
 *     $loader->register();
 *
 *     // to enable searching the include path (eg. for PEAR packages)
 *     $loader->setUseIncludePath(true);
 *
 * In this example, if you try to use a class in the Symfony\Component
 * namespace or one of its children (Symfony\Component\Console for instance),
 * the autoloader will first look for the class under the component/
 * directory, and it will then fallback to the framework/ directory if not
 * found before giving up.
 *
 * This class is loosely based on the Symfony UniversalClassLoader.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 * @author Jordi Boggiano <j.boggiano@seld.be>
 * @see    https://www.php-fig.org/psr/psr-0/
 * @see    https://www.php-fig.org/psr/psr-4/
 */
class ClassLoader
{
    /** @var \Closure(string):void */
    private static $includeFile;

    /** @var string|null */
    private $vendorDir;

    // PSR-4
    /**
     * @var array<string, array<string, int>>
     */
    private $prefixLengthsPsr4 = array();
    /**
     * @var array<string, list<string>>
     */
    private $prefixDirsPsr4 = array();
    /**
     * @var list<string>
     */
    private $fallbackDirsPsr4 = array();

    // PSR-0
    /**
     * List of PSR-0 prefixes
     *
     * Structured as array('F (first letter)' => array('Foo\Bar (full prefix)' => array('path', 'path2')))
     *
     * @var array<string, array<string, list<string>>>
     */
    private $prefixesPsr0 = array();
    /**
     * @var list<string>
     */
    private $fallbackDirsPsr0 = array();

    /** @var bool */
    private $useIncludePath = false;

    /**
     * @var array<string, string>
     */
    private $classMap = array();

    /** @var bool */
    private $classMapAuthoritative = false;

    /**
     * @var array<string, bool>
     */
    private $missingClasses = array();

    /** @var string|null */
    private $apcuPrefix;

    /**
     * @var array<string, self>
     */
    private static $registeredLoaders = array();

    /**
     * @param string|null $vendorDir
     */
    public function __construct($vendorDir = null)
    {
        $this->vendorDir = $vendorDir;
        self::initializeIncludeClosure();
    }

    /**
     * @return array<string, list<string>>
     */
    public function getPrefixes()
    {
        if (!empty($this->prefixesPsr0)) {
            return call_user_func_array('array_merge', array_values($this->prefixesPsr0));
        }

        return array();
    }

    /**
     * @return array<string, list<string>>
     */
    public function getPrefixesPsr4()
    {
        return $this->prefixDirsPsr4;
    }

    /**
     * @return list<string>
     */
    public function getFallbackDirs()
    {
        return $this->fallbackDirsPsr0;
    }

    /**
     * @return list<string>
     */
    public function getFallbackDirsPsr4()
    {
        return $this->fallbackDirsPsr4;
    }

    /**
     * @return array<string, string> Array of classname => path
     */
    public function getClassMap()
    {
        return $this->classMap;
    }

    /**
     * @param array<string, string> $classMap Class to filename map
     *
     * @return void
     */
    public function addClassMap(array $classMap)
    {
        if ($this->classMap) {
            $this->classMap = array_merge($this->classMap, $classMap);
        } else {
            $this->classMap = $classMap;
        }
    }

    /**
     * Registers a set of PSR-0 directories for a given prefix, either
     * appending or prepending to the ones previously set for this prefix.
     *
     * @param string              $prefix  The prefix
     * @param list<string>|string $paths   The PSR-0 root directories
     * @param bool                $prepend Whether to prepend the directories
     *
     * @return void
     */
    public function add($prefix, $paths, $prepend = false)
    {
        $paths = (array) $paths;
        if (!$prefix) {
            if ($prepend) {
                $this->fallbackDirsPsr0 = array_merge(
                    $paths,
                    $this->fallbackDirsPsr0
                );
            } else {
                $this->fallbackDirsPsr0 = array_merge(
                    $this->fallbackDirsPsr0,
                    $paths
                );
            }

            return;
        }

        $first = $prefix[0];
        if (!isset($this->prefixesPsr0[$first][$prefix])) {
            $this->prefixesPsr0[$first][$prefix] = $paths;

            return;
        }
        if ($prepend) {
            $this->prefixesPsr0[$first][$prefix] = array_merge(
                $paths,
                $this->prefixesPsr0[$first][$prefix]
            );
        } else {
            $this->prefixesPsr0[$first][$prefix] = array_merge(
                $this->prefixesPsr0[$first][$prefix],
                $paths
            );
        }
    }

    /**
     * Registers a set of PSR-4 directories for a given namespace, either
     * appending or prepending to the ones previously set for this namespace.
     *
     * @param string              $prefix  The prefix/namespace, with trailing '\\'
     * @param list<string>|string $paths   The PSR-4 base directories
     * @param bool                $prepend Whether to prepend the directories
     *
     * @throws \InvalidArgumentException
     *
     * @return void
     */
    public function addPsr4($prefix, $paths, $prepend = false)
    {
        $paths = (array) $paths;
        if (!$prefix) {
            // Register directories for the root namespace.
            if ($prepend) {
                $this->fallbackDirsPsr4 = array_merge(
                    $paths,
                    $this->fallbackDirsPsr4
                );
            } else {
                $this->fallbackDirsPsr4 = array_merge(
                    $this->fallbackDirsPsr4,
                    $paths
                );
            }
        } elseif (!isset($this->prefixDirsPsr4[$prefix])) {
            // Register directories for a new namespace.
            $length = strlen($prefix);
            if ('\\' !== $prefix[$length - 1]) {
                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
            }
            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
            $this->prefixDirsPsr4[$prefix] = $paths;
        } elseif ($prepend) {
            // Prepend directories for an already registered namespace.
            $this->prefixDirsPsr4[$prefix] = array_merge(
                $paths,
                $this->prefixDirsPsr4[$prefix]
            );
        } else {
            // Append directories for an already registered namespace.
            $this->prefixDirsPsr4[$prefix] = array_merge(
                $this->prefixDirsPsr4[$prefix],
                $paths
            );
        }
    }

    /**
     * Registers a set of PSR-0 directories for a given prefix,
     * replacing any others previously set for this prefix.
     *
     * @param string              $prefix The prefix
     * @param list<string>|string $paths  The PSR-0 base directories
     *
     * @return void
     */
    public function set($prefix, $paths)
    {
        if (!$prefix) {
            $this->fallbackDirsPsr0 = (array) $paths;
        } else {
            $this->prefixesPsr0[$prefix[0]][$prefix] = (array) $paths;
        }
    }

    /**
     * Registers a set of PSR-4 directories for a given namespace,
     * replacing any others previously set for this namespace.
     *
     * @param string              $prefix The prefix/namespace, with trailing '\\'
     * @param list<string>|string $paths  The PSR-4 base directories
     *
     * @throws \InvalidArgumentException
     *
     * @return void
     */
    public function setPsr4($prefix, $paths)
    {
        if (!$prefix) {
            $this->fallbackDirsPsr4 = (array) $paths;
        } else {
            $length = strlen($prefix);
            if ('\\' !== $prefix[$length - 1]) {
                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
            }
            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
            $this->prefixDirsPsr4[$prefix] = (array) $paths;
        }
    }

    /**
     * Turns on searching the include path for class files.
     *
     * @param bool $useIncludePath
     *
     * @return void
     */
    public function setUseIncludePath($useIncludePath)
    {
        $this->useIncludePath = $useIncludePath;
    }

    /**
     * Can be used to check if the autoloader uses the include path to check
     * for classes.
     *
     * @return bool
     */
    public function getUseIncludePath()
    {
        return $this->useIncludePath;
    }

    /**
     * Turns off searching the prefix and fallback directories for classes
     * that have not been registered with the class map.
     *
     * @param bool $classMapAuthoritative
     *
     * @return void
     */
    public function setClassMapAuthoritative($classMapAuthoritative)
    {
        $this->classMapAuthoritative = $classMapAuthoritative;
    }

    /**
     * Should class lookup fail if not found in the current class map?
     *
     * @return bool
     */
    public function isClassMapAuthoritative()
    {
        return $this->classMapAuthoritative;
    }

    /**
     * APCu prefix to use to cache found/not-found classes, if the extension is enabled.
     *
     * @param string|null $apcuPrefix
     *
     * @return void
     */
    public function setApcuPrefix($apcuPrefix)
    {
        $this->apcuPrefix = function_exists('apcu_fetch') && filter_var(ini_get('apc.enabled'), FILTER_VALIDATE_BOOLEAN) ? $apcuPrefix : null;
    }

    /**
     * The APCu prefix in use, or null if APCu caching is not enabled.
     *
     * @return string|null
     */
    public function getApcuPrefix()
    {
        return $this->apcuPrefix;
    }

    /**
     * Registers this instance as an autoloader.
     *
     * @param bool $prepend Whether to prepend the autoloader or not
     *
     * @return void
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);

        if (null === $this->vendorDir) {
            return;
        }

        if ($prepend) {
            self::$registeredLoaders = array($this->vendorDir => $this) + self::$registeredLoaders;
        } else {
            unset(self::$registeredLoaders[$this->vendorDir]);
            self::$registeredLoaders[$this->vendorDir] = $this;
        }
    }

    /**
     * Unregisters this instance as an autoloader.
     *
     * @return void
     */
    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));

        if (null !== $this->vendorDir) {
            unset(self::$registeredLoaders[$this->vendorDir]);
        }
    }

    /**
     * Loads the given class or interface.
     *
     * @param  string    $class The name of the class
     * @return true|null True if loaded, null otherwise
     */
    public function loadClass($class)
    {
        if ($file = $this->findFile($class)) {
            $includeFile = self::$includeFile;
            $includeFile($file);

            return true;
        }

        return null;
    }

    /**
     * Finds the path to the file where the class is defined.
     *
     * @param string $class The name of the class
     *
     * @return string|false The path if found, false otherwise
     */
    public function findFile($class)
    {
        // class map lookup
        if (isset($this->classMap[$class])) {
            return $this->classMap[$class];
        }
        if ($this->classMapAuthoritative || isset($this->missingClasses[$class])) {
            return false;
        }
        if (null !== $this->apcuPrefix) {
            $file = apcu_fetch($this->apcuPrefix.$class, $hit);
            if ($hit) {
                return $file;
            }
        }

        $file = $this->findFileWithExtension($class, '.php');

        // Search for Hack files if we are running on HHVM
        if (false === $file && defined('HHVM_VERSION')) {
            $file = $this->findFileWithExtension($class, '.hh');
        }

        if (null !== $this->apcuPrefix) {
            apcu_add($this->apcuPrefix.$class, $file);
        }

        if (false === $file) {
            // Remember that this class does not exist.
            $this->missingClasses[$class] = true;
        }

        return $file;
    }

    /**
     * Returns the currently registered loaders keyed by their corresponding vendor directories.
     *
     * @return array<string, self>
     */
    public static function getRegisteredLoaders()
    {
        return self::$registeredLoaders;
    }

    /**
     * @param  string       $class
     * @param  string       $ext
     * @return string|false
     */
    private function findFileWithExtension($class, $ext)
    {
        // PSR-4 lookup
        $logicalPathPsr4 = strtr($class, '\\', DIRECTORY_SEPARATOR) . $ext;

        $first = $class[0];
        if (isset($this->prefixLengthsPsr4[$first])) {
            $subPath = $class;
            while (false !== $lastPos = strrpos($subPath, '\\')) {
                $subPath = substr($subPath, 0, $lastPos);
                $search = $subPath . '\\';
                if (isset($this->prefixDirsPsr4[$search])) {
                    $pathEnd = DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $lastPos + 1);
                    foreach ($this->prefixDirsPsr4[$search] as $dir) {
                        if (file_exists($file = $dir . $pathEnd)) {
                            return $file;
                        }
                    }
                }
            }
        }

        // PSR-4 fallback dirs
        foreach ($this->fallbackDirsPsr4 as $dir) {
            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {
                return $file;
            }
        }

        // PSR-0 lookup
        if (false !== $pos = strrpos($class, '\\')) {
            // namespaced class name
            $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1)
                . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);
        } else {
            // PEAR-like class name
            $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;
        }

        if (isset($this->prefixesPsr0[$first])) {
            foreach ($this->prefixesPsr0[$first] as $prefix => $dirs) {
                if (0 === strpos($class, $prefix)) {
                    foreach ($dirs as $dir) {
                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                            return $file;
                        }
                    }
                }
            }
        }

        // PSR-0 fallback dirs
        foreach ($this->fallbackDirsPsr0 as $dir) {
            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                return $file;
            }
        }

        // PSR-0 include paths.
        if ($this->useIncludePath && $file = stream_resolve_include_path($logicalPathPsr0)) {
            return $file;
        }

        return false;
    }

    /**
     * @return void
     */
    private static function initializeIncludeClosure()
    {
        if (self::$includeFile !== null) {
            return;
        }

        /**
         * Scope isolated include.
         *
         * Prevents access to $this/self from included files.
         *
         * @param  string $file
         * @return void
         */
        self::$includeFile = \Closure::bind(static function($file) {
            include $file;
        }, null, null);
    }
}


// File: wp-graphql\vendor\composer\installed.php
<?php return array(
    'root' => array(
        'name' => 'wp-graphql/wp-graphql',
        'pretty_version' => 'v1.26.0',
        'version' => '1.26.0.0',
        'reference' => 'b28890708cc5b05995cbf4693faec6624e49a905',
        'type' => 'wordpress-plugin',
        'install_path' => __DIR__ . '/../../',
        'aliases' => array(),
        'dev' => false,
    ),
    'versions' => array(
        'appsero/client' => array(
            'pretty_version' => 'v1.2.1',
            'version' => '1.2.1.0',
            'reference' => 'd110c537f4ca92ac7f3398eee67cc6bdf506a4fb',
            'type' => 'library',
            'install_path' => __DIR__ . '/../appsero/client',
            'aliases' => array(),
            'dev_requirement' => false,
        ),
        'ivome/graphql-relay-php' => array(
            'pretty_version' => 'v0.7.0',
            'version' => '0.7.0.0',
            'reference' => '06bd176103618d896197d85d04a3a17c91e39698',
            'type' => 'library',
            'install_path' => __DIR__ . '/../ivome/graphql-relay-php',
            'aliases' => array(),
            'dev_requirement' => false,
        ),
        'webonyx/graphql-php' => array(
            'pretty_version' => 'v14.11.10',
            'version' => '14.11.10.0',
            'reference' => 'd9c2fdebc6aa01d831bc2969da00e8588cffef19',
            'type' => 'library',
            'install_path' => __DIR__ . '/../webonyx/graphql-php',
            'aliases' => array(),
            'dev_requirement' => false,
        ),
        'wp-graphql/wp-graphql' => array(
            'pretty_version' => 'v1.26.0',
            'version' => '1.26.0.0',
            'reference' => 'b28890708cc5b05995cbf4693faec6624e49a905',
            'type' => 'wordpress-plugin',
            'install_path' => __DIR__ . '/../../',
            'aliases' => array(),
            'dev_requirement' => false,
        ),
    ),
);


// File: wp-graphql\vendor\composer\InstalledVersions.php
<?php

/*
 * This file is part of Composer.
 *
 * (c) Nils Adermann <naderman@naderman.de>
 *     Jordi Boggiano <j.boggiano@seld.be>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Composer;

use Composer\Autoload\ClassLoader;
use Composer\Semver\VersionParser;

/**
 * This class is copied in every Composer installed project and available to all
 *
 * See also https://getcomposer.org/doc/07-runtime.md#installed-versions
 *
 * To require its presence, you can require `composer-runtime-api ^2.0`
 *
 * @final
 */
class InstalledVersions
{
    /**
     * @var mixed[]|null
     * @psalm-var array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}|array{}|null
     */
    private static $installed;

    /**
     * @var bool|null
     */
    private static $canGetVendors;

    /**
     * @var array[]
     * @psalm-var array<string, array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}>
     */
    private static $installedByVendor = array();

    /**
     * Returns a list of all package names which are present, either by being installed, replaced or provided
     *
     * @return string[]
     * @psalm-return list<string>
     */
    public static function getInstalledPackages()
    {
        $packages = array();
        foreach (self::getInstalled() as $installed) {
            $packages[] = array_keys($installed['versions']);
        }

        if (1 === \count($packages)) {
            return $packages[0];
        }

        return array_keys(array_flip(\call_user_func_array('array_merge', $packages)));
    }

    /**
     * Returns a list of all package names with a specific type e.g. 'library'
     *
     * @param  string   $type
     * @return string[]
     * @psalm-return list<string>
     */
    public static function getInstalledPackagesByType($type)
    {
        $packagesByType = array();

        foreach (self::getInstalled() as $installed) {
            foreach ($installed['versions'] as $name => $package) {
                if (isset($package['type']) && $package['type'] === $type) {
                    $packagesByType[] = $name;
                }
            }
        }

        return $packagesByType;
    }

    /**
     * Checks whether the given package is installed
     *
     * This also returns true if the package name is provided or replaced by another package
     *
     * @param  string $packageName
     * @param  bool   $includeDevRequirements
     * @return bool
     */
    public static function isInstalled($packageName, $includeDevRequirements = true)
    {
        foreach (self::getInstalled() as $installed) {
            if (isset($installed['versions'][$packageName])) {
                return $includeDevRequirements || !isset($installed['versions'][$packageName]['dev_requirement']) || $installed['versions'][$packageName]['dev_requirement'] === false;
            }
        }

        return false;
    }

    /**
     * Checks whether the given package satisfies a version constraint
     *
     * e.g. If you want to know whether version 2.3+ of package foo/bar is installed, you would call:
     *
     *   Composer\InstalledVersions::satisfies(new VersionParser, 'foo/bar', '^2.3')
     *
     * @param  VersionParser $parser      Install composer/semver to have access to this class and functionality
     * @param  string        $packageName
     * @param  string|null   $constraint  A version constraint to check for, if you pass one you have to make sure composer/semver is required by your package
     * @return bool
     */
    public static function satisfies(VersionParser $parser, $packageName, $constraint)
    {
        $constraint = $parser->parseConstraints((string) $constraint);
        $provided = $parser->parseConstraints(self::getVersionRanges($packageName));

        return $provided->matches($constraint);
    }

    /**
     * Returns a version constraint representing all the range(s) which are installed for a given package
     *
     * It is easier to use this via isInstalled() with the $constraint argument if you need to check
     * whether a given version of a package is installed, and not just whether it exists
     *
     * @param  string $packageName
     * @return string Version constraint usable with composer/semver
     */
    public static function getVersionRanges($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            $ranges = array();
            if (isset($installed['versions'][$packageName]['pretty_version'])) {
                $ranges[] = $installed['versions'][$packageName]['pretty_version'];
            }
            if (array_key_exists('aliases', $installed['versions'][$packageName])) {
                $ranges = array_merge($ranges, $installed['versions'][$packageName]['aliases']);
            }
            if (array_key_exists('replaced', $installed['versions'][$packageName])) {
                $ranges = array_merge($ranges, $installed['versions'][$packageName]['replaced']);
            }
            if (array_key_exists('provided', $installed['versions'][$packageName])) {
                $ranges = array_merge($ranges, $installed['versions'][$packageName]['provided']);
            }

            return implode(' || ', $ranges);
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as version, use satisfies or getVersionRanges if you need to know if a given version is present
     */
    public static function getVersion($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            if (!isset($installed['versions'][$packageName]['version'])) {
                return null;
            }

            return $installed['versions'][$packageName]['version'];
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as version, use satisfies or getVersionRanges if you need to know if a given version is present
     */
    public static function getPrettyVersion($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            if (!isset($installed['versions'][$packageName]['pretty_version'])) {
                return null;
            }

            return $installed['versions'][$packageName]['pretty_version'];
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as reference
     */
    public static function getReference($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            if (!isset($installed['versions'][$packageName]['reference'])) {
                return null;
            }

            return $installed['versions'][$packageName]['reference'];
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as install path. Packages of type metapackages also have a null install path.
     */
    public static function getInstallPath($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            return isset($installed['versions'][$packageName]['install_path']) ? $installed['versions'][$packageName]['install_path'] : null;
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @return array
     * @psalm-return array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}
     */
    public static function getRootPackage()
    {
        $installed = self::getInstalled();

        return $installed[0]['root'];
    }

    /**
     * Returns the raw installed.php data for custom implementations
     *
     * @deprecated Use getAllRawData() instead which returns all datasets for all autoloaders present in the process. getRawData only returns the first dataset loaded, which may not be what you expect.
     * @return array[]
     * @psalm-return array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}
     */
    public static function getRawData()
    {
        @trigger_error('getRawData only returns the first dataset loaded, which may not be what you expect. Use getAllRawData() instead which returns all datasets for all autoloaders present in the process.', E_USER_DEPRECATED);

        if (null === self::$installed) {
            // only require the installed.php file if this file is loaded from its dumped location,
            // and not from its source location in the composer/composer package, see https://github.com/composer/composer/issues/9937
            if (substr(__DIR__, -8, 1) !== 'C') {
                self::$installed = include __DIR__ . '/installed.php';
            } else {
                self::$installed = array();
            }
        }

        return self::$installed;
    }

    /**
     * Returns the raw data of all installed.php which are currently loaded for custom implementations
     *
     * @return array[]
     * @psalm-return list<array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}>
     */
    public static function getAllRawData()
    {
        return self::getInstalled();
    }

    /**
     * Lets you reload the static array from another file
     *
     * This is only useful for complex integrations in which a project needs to use
     * this class but then also needs to execute another project's autoloader in process,
     * and wants to ensure both projects have access to their version of installed.php.
     *
     * A typical case would be PHPUnit, where it would need to make sure it reads all
     * the data it needs from this class, then call reload() with
     * `require $CWD/vendor/composer/installed.php` (or similar) as input to make sure
     * the project in which it runs can then also use this class safely, without
     * interference between PHPUnit's dependencies and the project's dependencies.
     *
     * @param  array[] $data A vendor/composer/installed.php data set
     * @return void
     *
     * @psalm-param array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>} $data
     */
    public static function reload($data)
    {
        self::$installed = $data;
        self::$installedByVendor = array();
    }

    /**
     * @return array[]
     * @psalm-return list<array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}>
     */
    private static function getInstalled()
    {
        if (null === self::$canGetVendors) {
            self::$canGetVendors = method_exists('Composer\Autoload\ClassLoader', 'getRegisteredLoaders');
        }

        $installed = array();

        if (self::$canGetVendors) {
            foreach (ClassLoader::getRegisteredLoaders() as $vendorDir => $loader) {
                if (isset(self::$installedByVendor[$vendorDir])) {
                    $installed[] = self::$installedByVendor[$vendorDir];
                } elseif (is_file($vendorDir.'/composer/installed.php')) {
                    /** @var array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>} $required */
                    $required = require $vendorDir.'/composer/installed.php';
                    $installed[] = self::$installedByVendor[$vendorDir] = $required;
                    if (null === self::$installed && strtr($vendorDir.'/composer', '\\', '/') === strtr(__DIR__, '\\', '/')) {
                        self::$installed = $installed[count($installed) - 1];
                    }
                }
            }
        }

        if (null === self::$installed) {
            // only require the installed.php file if this file is loaded from its dumped location,
            // and not from its source location in the composer/composer package, see https://github.com/composer/composer/issues/9937
            if (substr(__DIR__, -8, 1) !== 'C') {
                /** @var array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>} $required */
                $required = require __DIR__ . '/installed.php';
                self::$installed = $required;
            } else {
                self::$installed = array();
            }
        }

        if (self::$installed !== array()) {
            $installed[] = self::$installed;
        }

        return $installed;
    }
}


// File: wp-graphql\vendor\composer\platform_check.php
<?php

// platform_check.php @generated by Composer

$issues = array();

if (!(PHP_VERSION_ID >= 70100)) {
    $issues[] = 'Your Composer dependencies require a PHP version ">= 7.1.0". You are running ' . PHP_VERSION . '.';
}

if ($issues) {
    if (!headers_sent()) {
        header('HTTP/1.1 500 Internal Server Error');
    }
    if (!ini_get('display_errors')) {
        if (PHP_SAPI === 'cli' || PHP_SAPI === 'phpdbg') {
            fwrite(STDERR, 'Composer detected issues in your platform:' . PHP_EOL.PHP_EOL . implode(PHP_EOL, $issues) . PHP_EOL.PHP_EOL);
        } elseif (!headers_sent()) {
            echo 'Composer detected issues in your platform:' . PHP_EOL.PHP_EOL . str_replace('You are running '.PHP_VERSION.'.', '', implode(PHP_EOL, $issues)) . PHP_EOL.PHP_EOL;
        }
    }
    trigger_error(
        'Composer detected issues in your platform: ' . implode(' ', $issues),
        E_USER_ERROR
    );
}


// File: wp-graphql\vendor\ivome\graphql-relay-php\src\Relay.php
<?php
/**
 * @author: Ivo Meißner
 * Date: 23.02.16
 * Time: 15:21
 */

namespace GraphQLRelay;


use GraphQL\Type\Definition\ObjectType;
use GraphQLRelay\Connection\ArrayConnection;
use GraphQLRelay\Connection\Connection;
use GraphQLRelay\Mutation\Mutation;
use GraphQLRelay\Node\Node;

class Relay {
    /**
     * Returns a GraphQLFieldConfigArgumentMap appropriate to include on a field
     * whose return type is a connection type with forward pagination.
     *
     * @return array
     */
    public static function forwardConnectionArgs()
    {
        return Connection::forwardConnectionArgs();
    }

    /**
     * Returns a GraphQLFieldConfigArgumentMap appropriate to include on a field
     * whose return type is a connection type with backward pagination.
     *
     * @return array
     */
    public static function backwardConnectionArgs()
    {
        return Connection::backwardConnectionArgs();
    }

    /**
     * Returns a GraphQLFieldConfigArgumentMap appropriate to include on a field
     * whose return type is a connection type with bidirectional pagination.
     *
     * @return array
     */
    public static function connectionArgs()
    {
        return Connection::connectionArgs();
    }

    /**
     * Returns a GraphQLObjectType for a connection and its edge with the given name,
     * and whose nodes are of the specified type.
     *
     * @param array $config
     * @return array
     */
    public static function connectionDefinitions(array $config)
    {
        return Connection::connectionDefinitions($config);
    }

    /**
     * Returns a GraphQLObjectType for a connection with the given name,
     * and whose nodes are of the specified type.
     *
     * @param array $config
     * @return ObjectType
     */
    public static function connectionType(array $config)
    {
        return Connection::createConnectionType($config);
    }

    /**
     * Returns a GraphQLObjectType for a edge with the given name,
     * and whose nodes are of the specified type.
     *
     * @param array $config
     * @return ObjectType
     */
    public static function edgeType(array $config)
    {
        return Connection::createEdgeType($config);
    }

    /**
     * A simple function that accepts an array and connection arguments, and returns
     * a connection object for use in GraphQL. It uses array offsets as pagination,
     * so pagination will only work if the array is static.
     * @param array $data
     * @param $args
     *
     * @return array
     */
    public static function connectionFromArray(array $data, $args)
    {
        return ArrayConnection::connectionFromArray($data, $args);
    }

    /**
     * Given a slice (subset) of an array, returns a connection object for use in
     * GraphQL.
     *
     * This function is similar to `connectionFromArray`, but is intended for use
     * cases where you know the cardinality of the connection, consider it too large
     * to materialize the entire array, and instead wish pass in a slice of the
     * total result large enough to cover the range specified in `args`.
     *
     * @param array $arraySlice
     * @param $args
     * @param $meta
     * @return array
     */
    public static function connectionFromArraySlice(array $arraySlice, $args, $meta)
    {
        return ArrayConnection::connectionFromArraySlice($arraySlice, $args, $meta);
    }

    /**
     * Return the cursor associated with an object in an array.
     *
     * @param array $data
     * @param $object
     * @return null|string
     */
    public static function cursorForObjectInConnection(array $data, $object)
    {
        return ArrayConnection::cursorForObjectInConnection($data, $object);
    }

    /**
     * Returns a GraphQLFieldConfig for the mutation described by the
     * provided MutationConfig.
     *
     * A description of a mutation consumable by mutationWithClientMutationId
     * to create a GraphQLFieldConfig for that mutation.
     *
     * The inputFields and outputFields should not include `clientMutationId`,
     * as this will be provided automatically.
     *
     * An input object will be created containing the input fields, and an
     * object will be created containing the output fields.
     *
     * mutateAndGetPayload will receive an Object with a key for each
     * input field, and it should return an Object with a key for each
     * output field. It may return synchronously, or return a Promise.
     *
     * type MutationConfig = {
     *   name: string,
     *   inputFields: InputObjectConfigFieldMap,
     *   outputFields: GraphQLFieldConfigMap,
     *   mutateAndGetPayload: mutationFn,
     * }
     *
     * @param array $config
     * @return array
     */
    public static function mutationWithClientMutationId(array $config)
    {
        return Mutation::mutationWithClientMutationId($config);
    }


    /**
     * Given a function to map from an ID to an underlying object, and a function
     * to map from an underlying object to the concrete GraphQLObjectType it
     * corresponds to, constructs a `Node` interface that objects can implement,
     * and a field config for a `node` root field.
     *
     * If the typeResolver is omitted, object resolution on the interface will be
     * handled with the `isTypeOf` method on object types, as with any GraphQL
     * interface without a provided `resolveType` method.
     *
     * @param callable $idFetcher
     * @param callable $typeResolver
     * @return array
     */
    public static function nodeDefinitions(callable $idFetcher, callable $typeResolver = null) {
        return Node::nodeDefinitions($idFetcher, $typeResolver);
    }

    /**
     * Takes a type name and an ID specific to that type name, and returns a
     * "global ID" that is unique among all types.
     *
     * @param string $type
     * @param string $id
     * @return string
     */
    public static function toGlobalId($type, $id) {
        return Node::toGlobalId($type, $id);
    }

    /**
     * Takes the "global ID" created by self::toGlobalId, and returns the type name and ID
     * used to create it.
     *
     * @param $globalId
     * @return array
     */
    public static function fromGlobalId($globalId) {
        return Node::fromGlobalId($globalId);
    }

    /**
     * Creates the configuration for an id field on a node, using `self::toGlobalId` to
     * construct the ID from the provided typename. The type-specific ID is fetched
     * by calling idFetcher on the object, or if not provided, by accessing the `id`
     * property on the object.
     *
     * @param string|null $typeName
     * @param callable|null $idFetcher
     * @return array
     */
    public static function globalIdField($typeName = null, callable $idFetcher = null) {
        return Node::globalIdField($typeName, $idFetcher);
    }
}


// File: wp-graphql\vendor\ivome\graphql-relay-php\src\Connection\ArrayConnection.php
<?php
/**
 * @author: Ivo Meißner
 * Date: 22.02.16
 * Time: 18:54
 */

namespace GraphQLRelay\Connection;


class ArrayConnection
{
    const PREFIX = 'arrayconnection:';

    /**
     * Creates the cursor string from an offset.
     */
    public static function offsetToCursor($offset)
    {
        return base64_encode(self::PREFIX . $offset);
    }

    /**
     * Rederives the offset from the cursor string.
     */
    public static function cursorToOffset($cursor)
    {
        $offset = substr(base64_decode($cursor), strlen(self::PREFIX));
        if (is_numeric($offset)){
            return intval($offset);
        } else {
            return null;
        }
    }

    /**
     * Given an optional cursor and a default offset, returns the offset
     * to use; if the cursor contains a valid offset, that will be used,
     * otherwise it will be the default.
     */
    public static function getOffsetWithDefault($cursor, $defaultOffset)
    {
        if ($cursor == null){
            return $defaultOffset;
        }
        $offset = self::cursorToOffset($cursor);
        return $offset !== null ? $offset: $defaultOffset;
    }

    /**
     * A simple function that accepts an array and connection arguments, and returns
     * a connection object for use in GraphQL. It uses array offsets as pagination,
     * so pagination will only work if the array is static.
     * @param array $data
     * @param $args
     *
     * @return array
     */
    public static function connectionFromArray(array $data, $args)
    {
        return self::connectionFromArraySlice($data, $args, [
            'sliceStart' => 0,
            'arrayLength' => count($data)
        ]);
    }

    /**
     * Given a slice (subset) of an array, returns a connection object for use in
     * GraphQL.
     *
     * This function is similar to `connectionFromArray`, but is intended for use
     * cases where you know the cardinality of the connection, consider it too large
     * to materialize the entire array, and instead wish pass in a slice of the
     * total result large enough to cover the range specified in `args`.
     *
     * @return array
     */
    public static function connectionFromArraySlice(array $arraySlice, $args, $meta)
    {
        $after = self::getArrayValueSafe($args, 'after');
        $before = self::getArrayValueSafe($args, 'before');
        $first = self::getArrayValueSafe($args, 'first');
        $last = self::getArrayValueSafe($args, 'last');
        $sliceStart = self::getArrayValueSafe($meta, 'sliceStart');
        $arrayLength = self::getArrayValueSafe($meta, 'arrayLength');
        $sliceEnd = $sliceStart + count($arraySlice);
        $beforeOffset = self::getOffsetWithDefault($before, $arrayLength);
        $afterOffset = self::getOffsetWithDefault($after, -1);

        $startOffset = max([
            $sliceStart - 1,
            $afterOffset,
            -1
        ]) + 1;

        $endOffset = min([
            $sliceEnd,
            $beforeOffset,
            $arrayLength
        ]);
        if ($first !== null) {
            $endOffset = min([
                $endOffset,
                $startOffset + $first
            ]);
        }

        if ($last !== null) {
            $startOffset = max([
                $startOffset,
                $endOffset - $last
            ]);
        }

        $slice = array_slice($arraySlice,
            max($startOffset - $sliceStart, 0),
            count($arraySlice) - ($sliceEnd - $endOffset) - max($startOffset - $sliceStart, 0)
        );

        $edges = array_map(function($item, $index) use ($startOffset) {
            return [
                'cursor' => self::offsetToCursor($startOffset + $index),
                'node' => $item
            ];
        }, $slice, array_keys($slice));

        $firstEdge = $edges ? $edges[0] : null;
        $lastEdge = $edges ? $edges[count($edges) - 1] : null;
        $lowerBound = $after ? ($afterOffset + 1) : 0;
        $upperBound = $before ? ($beforeOffset) : $arrayLength;

        return [
            'edges' => $edges,
            'pageInfo' => [
                'startCursor' => $firstEdge ? $firstEdge['cursor'] : null,
                'endCursor' => $lastEdge ? $lastEdge['cursor'] : null,
                'hasPreviousPage' => $last !== null ? $startOffset > $lowerBound : false,
                'hasNextPage' => $first !== null ? $endOffset < $upperBound : false
            ]
        ];
    }

    /**
     * Return the cursor associated with an object in an array.
     *
     * @param array $data
     * @param $object
     * @return null|string
     */
    public static function cursorForObjectInConnection(array $data, $object)
    {
        $offset = -1;
        for ($i = 0; $i < count($data); $i++) {
            if ($data[$i] == $object){
                $offset = $i;
                break;
            }
        }

        if ($offset === -1) {
            return null;
        }

        return self::offsetToCursor($offset);
    }

    /**
     * Returns the value for the given array key, NULL, if it does not exist
     *
     * @param array $array
     * @param string $key
     * @return mixed
     */
    protected static function getArrayValueSafe(array $array, $key)
    {
        return array_key_exists($key, $array) ? $array[$key] : null;
    }
}


// File: wp-graphql\vendor\ivome\graphql-relay-php\src\Connection\Connection.php
<?php
/**
 * @author: Ivo Meißner
 * Date: 22.02.16
 * Time: 17:15
 */

namespace GraphQLRelay\Connection;

use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\Type;

class Connection {
    /**
     * @var ObjectType
     */
    protected static $pageInfoType;

    /**
     * Returns a GraphQLFieldConfigArgumentMap appropriate to include on a field
     * whose return type is a connection type with forward pagination.
     *
     * @return array
     */
    public static function forwardConnectionArgs()
    {
        return [
            'after' => [
                'type' => Type::string()
            ],
            'first' => [
                'type' => Type::int()
            ]
        ];
    }

    /**
     * Returns a GraphQLFieldConfigArgumentMap appropriate to include on a field
     * whose return type is a connection type with backward pagination.
     *
     * @return array
     */
    public static function backwardConnectionArgs()
    {
        return [
            'before' => [
                'type' => Type::string()
            ],
            'last' => [
                'type' => Type::int()
            ]
        ];
    }

    /**
     * Returns a GraphQLFieldConfigArgumentMap appropriate to include on a field
     * whose return type is a connection type with bidirectional pagination.
     *
     * @return array
     */
    public static function connectionArgs()
    {
        return array_merge(
            self::forwardConnectionArgs(),
            self::backwardConnectionArgs()
        );
    }

    /**
     * Returns a GraphQLObjectType for a connection with the given name,
     * and whose nodes are of the specified type.
     */
    public static function connectionDefinitions(array $config)
    {
        return [
            'edgeType' => self::createEdgeType($config),
            'connectionType' => self::createConnectionType($config)
        ];
    }

    /**
     * Returns a GraphQLObjectType for a connection with the given name,
     * and whose nodes are of the specified type.
     *
     * @return ObjectType
     */
    public static function createConnectionType(array $config)
    {
        if (!array_key_exists('nodeType', $config)){
            throw new \InvalidArgumentException('Connection config needs to have at least a node definition');
        }
        $nodeType = $config['nodeType'];
        $name = array_key_exists('name', $config) ? $config['name'] : $nodeType->name;
        $connectionFields = array_key_exists('connectionFields', $config) ? $config['connectionFields'] : [];
        $edgeType = array_key_exists('edgeType', $config) ? $config['edgeType'] : null;

        $connectionType = new ObjectType([
            'name' => $name . 'Connection',
            'description' => 'A connection to a list of items.',
            'fields' => function() use ($edgeType, $connectionFields, $config) {
                return array_merge([
                    'pageInfo' => [
                        'type' => Type::nonNull(self::pageInfoType()),
                        'description' => 'Information to aid in pagination.'
                    ],
                    'edges' => [
                        'type' => Type::listOf($edgeType ?: self::createEdgeType($config)),
                        'description' => 'Information to aid in pagination'
                    ]
                ], self::resolveMaybeThunk($connectionFields));
            }
        ]);

        return $connectionType;
    }

    /**
     * Returns a GraphQLObjectType for an edge with the given name,
     * and whose nodes are of the specified type.
     *
     * @param array $config
     * @return ObjectType
     */
    public static function createEdgeType(array $config)
    {
        if (!array_key_exists('nodeType', $config)){
            throw new \InvalidArgumentException('Edge config needs to have at least a node definition');
        }
        $nodeType = $config['nodeType'];
        $name = array_key_exists('name', $config) ? $config['name'] : $nodeType->name;
        $edgeFields = array_key_exists('edgeFields', $config) ? $config['edgeFields'] : [];
        $resolveNode = array_key_exists('resolveNode', $config) ? $config['resolveNode'] : null;
        $resolveCursor = array_key_exists('resolveCursor', $config) ? $config['resolveCursor'] : null;

        $edgeType = new ObjectType(array_merge([
            'name' => $name . 'Edge',
            'description' => 'An edge in a connection',
            'fields' => function() use ($nodeType, $resolveNode, $resolveCursor, $edgeFields) {
                return array_merge([
                    'node' => [
                        'type' => $nodeType,
                        'resolve' => $resolveNode,
                        'description' => 'The item at the end of the edge'
                    ],
                    'cursor' => [
                        'type' => Type::nonNull(Type::string()),
                        'resolve' => $resolveCursor,
                        'description' => 'A cursor for use in pagination'
                    ]
                ], self::resolveMaybeThunk($edgeFields));
            }
        ]));

        return $edgeType;
    }

    /**
     * The common page info type used by all connections.
     *
     * @return ObjectType
     */
    public static function pageInfoType()
    {
        if (self::$pageInfoType === null){
            self::$pageInfoType = new ObjectType([
                'name' => 'PageInfo',
                'description' => 'Information about pagination in a connection.',
                'fields' => [
                    'hasNextPage' => [
                        'type' => Type::nonNull(Type::boolean()),
                        'description' => 'When paginating forwards, are there more items?'
                    ],
                    'hasPreviousPage' => [
                        'type' => Type::nonNull(Type::boolean()),
                        'description' => 'When paginating backwards, are there more items?'
                    ],
                    'startCursor' => [
                        'type' => Type::string(),
                        'description' => 'When paginating backwards, the cursor to continue.'
                    ],
                    'endCursor' => [
                        'type' => Type::string(),
                        'description' => 'When paginating forwards, the cursor to continue.'
                    ]
                ]
            ]);
        }
        return self::$pageInfoType;
    }

    protected static function resolveMaybeThunk ($thinkOrThunk)
    {
        return is_callable($thinkOrThunk) ? call_user_func($thinkOrThunk) : $thinkOrThunk;
    }
}


// File: wp-graphql\vendor\ivome\graphql-relay-php\src\Mutation\Mutation.php
<?php
/**
 * @author: Ivo Meißner
 * Date: 23.02.16
 * Time: 12:02
 */

namespace GraphQLRelay\Mutation;


use GraphQL\Type\Definition\InputObjectType;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\ResolveInfo;
use GraphQL\Type\Definition\Type;

class Mutation {
    /**
     * Returns a GraphQLFieldConfig for the mutation described by the
     * provided MutationConfig.
     *
     * A description of a mutation consumable by mutationWithClientMutationId
     * to create a GraphQLFieldConfig for that mutation.
     *
     * The inputFields and outputFields should not include `clientMutationId`,
     * as this will be provided automatically.
     *
     * An input object will be created containing the input fields, and an
     * object will be created containing the output fields.
     *
     * mutateAndGetPayload will receive an Object with a key for each
     * input field, and it should return an Object with a key for each
     * output field. It may return synchronously, or return a Promise.
     *
     * type MutationConfig = {
     *   name: string,
     *   description?: string,
     *   deprecationReason?: string,
     *   inputFields: InputObjectConfigFieldMap,
     *   outputFields: GraphQLFieldConfigMap,
     *   mutateAndGetPayload: mutationFn,
     * }
     */
    public static function mutationWithClientMutationId(array $config)
    {
        $name = self::getArrayValue($config, 'name');
        $inputFields = self::getArrayValue($config, 'inputFields');
        $outputFields = self::getArrayValue($config, 'outputFields');
        $mutateAndGetPayload = self::getArrayValue($config, 'mutateAndGetPayload');

        $augmentedInputFields = function() use ($inputFields) {
            $inputFieldsResolved = self::resolveMaybeThunk($inputFields);
            return array_merge($inputFieldsResolved !== null ? $inputFieldsResolved : [], [
                'clientMutationId' => [
                    'type' => Type::string()
                ]
            ]);
        };

        $augmentedOutputFields = function () use ($outputFields) {
            $outputFieldsResolved = self::resolveMaybeThunk($outputFields);
            return array_merge($outputFieldsResolved !== null ? $outputFieldsResolved : [], [
                'clientMutationId' => [
                    'type' => Type::string()
                ]
            ]);
        };

        $outputType = new ObjectType([
            'name' => $name . 'Payload',
            'fields' => $augmentedOutputFields
        ]);

        $inputType = new InputObjectType([
            'name' => $name . 'Input',
            'fields' => $augmentedInputFields
        ]);

        $definition = [
            'type' => $outputType,
            'args' => [
                'input' => [
                    'type' => Type::nonNull($inputType)
                ]
            ],
            'resolve' => function ($query, $args, $context, ResolveInfo $info) use ($mutateAndGetPayload) {
                $payload = call_user_func($mutateAndGetPayload, $args['input'], $context, $info);
                $payload['clientMutationId'] = isset($args['input']['clientMutationId']) ? $args['input']['clientMutationId'] : null;
                return $payload;
            }
        ];
	    if (array_key_exists('description', $config)){
		    $definition['description'] = $config['description'];
	    }
	    if (array_key_exists('deprecationReason', $config)){
		    $definition['deprecationReason'] = $config['deprecationReason'];
	    }
        return $definition;
    }

    /**
     * Returns the value for the given array key, NULL, if it does not exist
     *
     * @param array $array
     * @param string $key
     * @return mixed
     */
    protected static function getArrayValue(array $array, $key)
    {
        if (array_key_exists($key, $array)){
            return $array[$key];
        } else {
            throw new \InvalidArgumentException('The config value for "' . $key . '" is required, but missing in MutationConfig."');
        }
    }

    protected static function resolveMaybeThunk($thinkOrThunk)
    {
        return is_callable($thinkOrThunk) ? call_user_func($thinkOrThunk) : $thinkOrThunk;
    }
}

// File: wp-graphql\vendor\ivome\graphql-relay-php\src\Node\Node.php
<?php
/**
 * @author: Ivo Meißner
 * Date: 22.02.16
 * Time: 12:45
 */

namespace GraphQLRelay\Node;

use GraphQL\Type\Definition\InterfaceType;
use GraphQL\Type\Definition\Type;

const GLOBAL_ID_DELIMITER = ':';

class Node {

    /**
     * Given a function to map from an ID to an underlying object, and a function
     * to map from an underlying object to the concrete GraphQLObjectType it
     * corresponds to, constructs a `Node` interface that objects can implement,
     * and a field config for a `node` root field.
     *
     * If the typeResolver is omitted, object resolution on the interface will be
     * handled with the `isTypeOf` method on object types, as with any GraphQL
     * interface without a provided `resolveType` method.
     *
     * @param callable $idFetcher
     * @param callable $typeResolver
     * @return array
     */
    public static function nodeDefinitions(callable $idFetcher, callable $typeResolver = null) {
        $nodeInterface = new InterfaceType([
            'name' => 'Node',
            'description' => 'An object with an ID',
            'fields' => [
                'id' => [
                    'type' => Type::nonNull(Type::id()),
                    'description' => 'The id of the object',
                ]
            ],
            'resolveType' => $typeResolver
        ]);

        $nodeField = [
            'name' => 'node',
            'description' => 'Fetches an object given its ID',
            'type' => $nodeInterface,
            'args' => [
                'id' => [
                    'type' => Type::nonNull(Type::id()),
                    'description' => 'The ID of an object'
                ]
            ],
            'resolve' => function ($obj, $args, $context, $info) use ($idFetcher) {
                return $idFetcher($args['id'], $context, $info);
            }
        ];

        return [
            'nodeInterface' => $nodeInterface,
            'nodeField' => $nodeField
        ];
    }

    /**
     * Takes a type name and an ID specific to that type name, and returns a
     * "global ID" that is unique among all types.
     *
     * @param string $type
     * @param string $id
     * @return string
     */
    public static function toGlobalId($type, $id) {
        return base64_encode($type . GLOBAL_ID_DELIMITER . $id);
    }

    /**
     * Takes the "global ID" created by self::toGlobalId, and returns the type name and ID
     * used to create it.
     *
     * @param $globalId
     * @return array
     */
    public static function fromGlobalId($globalId) {
        $unbasedGlobalId = base64_decode($globalId);
        $delimiterPos = strpos($unbasedGlobalId, GLOBAL_ID_DELIMITER);
        return [
            'type' => substr($unbasedGlobalId, 0, $delimiterPos),
            'id' => substr($unbasedGlobalId, $delimiterPos + 1)
        ];
    }

    /**
     * Creates the configuration for an id field on a node, using `self::toGlobalId` to
     * construct the ID from the provided typename. The type-specific ID is fetched
     * by calling idFetcher on the object, or if not provided, by accessing the `id`
     * property on the object.
     *
     * @param string|null $typeName
     * @param callable|null $idFetcher
     * @return array
     */
    public static function globalIdField($typeName = null, callable $idFetcher = null) {
        return [
            'name' => 'id',
            'description' => 'The ID of an object',
            'type' => Type::nonNull(Type::id()),
            'resolve' => function($obj, $args, $context, $info) use ($typeName, $idFetcher) {
                return self::toGlobalId(
                    $typeName !== null ? $typeName : $info->parentType->name,
                    $idFetcher ? $idFetcher($obj, $info) : $obj['id']
                );
            }
        ];
    }

}


// File: wp-graphql\vendor\ivome\graphql-relay-php\src\Node\Plural.php
<?php
/**
 * @author: Ivo Meißner
 * Date: 29.02.16
 * Time: 16:17
 */

namespace GraphQLRelay\Node;


use GraphQL\Type\Definition\ResolveInfo;
use GraphQL\Type\Definition\Type;

class Plural {
    /**
     * Returns configuration for Plural identifying root field
     *
     * type PluralIdentifyingRootFieldConfig = {
     *       argName: string,
     *       inputType: GraphQLInputType,
     *       outputType: GraphQLOutputType,
     *       resolveSingleInput: (input: any, info: GraphQLResolveInfo) => ?any,
     *       description?: ?string,
     * };
     *
     * @param array $config
     * @return array
     */
    public static function pluralIdentifyingRootField(array $config)
    {
        $inputArgs = [];
        $argName = self::getArrayValue($config, 'argName');
        $inputArgs[$argName] = [
            'type' => Type::nonNull(
                Type::listOf(
                    Type::nonNull(self::getArrayValue($config, 'inputType'))
                )
            )
        ];

        return [
            'description' => isset($config['description']) ? $config['description'] : null,
            'type' => Type::listOf(self::getArrayValue($config, 'outputType')),
            'args' => $inputArgs,
            'resolve' => function ($obj, $args, $context, ResolveInfo $info) use ($argName, $config) {
                $inputs = $args[$argName];
                return array_map(function($input) use ($config, $context, $info) {
                    return call_user_func(self::getArrayValue($config, 'resolveSingleInput'), $input, $context, $info);
                }, $inputs);
            }
        ];
    }

    /**
     * Returns the value for the given array key, NULL, if it does not exist
     *
     * @param array $array
     * @param string $key
     * @return mixed
     */
    protected static function getArrayValue(array $array, $key)
    {
        if (array_key_exists($key, $array)){
            return $array[$key];
        } else {
            throw new \InvalidArgumentException('The config value for "' . $key . '" is required, but missing in PluralIdentifyingRootFieldConfig."');
        }
    }
}

// File: wp-graphql\vendor\ivome\graphql-relay-php\tests\RelayTest.php
<?php
/**
 * @author: Ivo Meißner
 * Date: 29.02.16
 * Time: 17:01
 */

namespace GraphQLRelay\tests;

use GraphQL\Type\Definition\ObjectType;
use GraphQLRelay\Connection\Connection;
use GraphQLRelay\Relay;
use PHPUnit\Framework\TestCase;

class RelayTest extends TestCase
{
    public function testForwardConnectionArgs()
    {
        $this->assertEquals(
            Connection::forwardConnectionArgs(),
            Relay::forwardConnectionArgs()
        );
    }

    public function testBackwardConnectionArgs()
    {
        $this->assertEquals(
            Connection::backwardConnectionArgs(),
            Relay::backwardConnectionArgs()
        );
    }

    public function testConnectionArgs()
    {
        $this->assertEquals(
            Connection::connectionArgs(),
            Relay::connectionArgs()
        );
    }

    public function testConnectionDefinitions()
    {
        $nodeType = new ObjectType(['name' => 'test']);
        $config = ['nodeType' => $nodeType];

        $this->assertEquals(
            Connection::connectionDefinitions($config),
            Relay::connectionDefinitions($config)
        );
    }

    public function testConnectionType()
    {
        $nodeType = new ObjectType(['name' => 'test']);
        $config = ['nodeType' => $nodeType];

        $this->assertEquals(
            Connection::createConnectionType($config),
            Relay::connectionType($config)
        );
    }

    public function testEdgeType()
    {
        $nodeType = new ObjectType(['name' => 'test']);
        $config = ['nodeType' => $nodeType];

        $this->assertEquals(
            Connection::createEdgeType($config),
            Relay::edgeType($config)
        );
    }
}


// File: wp-graphql\vendor\ivome\graphql-relay-php\tests\StarWarsConnectionTest.php
<?php
/**
 * @author: Ivo Meißner
 * Date: 29.02.16
 * Time: 12:18
 */

namespace GraphQLRelay\tests;


use GraphQL\GraphQL;
use PHPUnit\Framework\TestCase;

class StarWarsConnectionTest extends TestCase
{
    public function testFetchesTheFirstShipOfTheRebels()
    {
        $query = 'query RebelsShipsQuery {
            rebels {
              name,
              ships(first: 1) {
                edges {
                  node {
                    name
                  }
                }
              }
            }
          }';

        $expected = array (
            'rebels' =>
                array (
                    'name' => 'Alliance to Restore the Republic',
                    'ships' =>
                        array (
                            'edges' =>
                                array (
                                    0 =>
                                        array (
                                            'node' =>
                                                array (
                                                    'name' => 'X-Wing',
                                                ),
                                        ),
                                ),
                        ),
                ),
        );

        $this->assertValidQuery($query, $expected);
    }

    public function testFetchesTheFirstTwoShipsOfTheRebelsWithACursor()
    {
        $query = 'query MoreRebelShipsQuery {
            rebels {
              name,
              ships(first: 2) {
                edges {
                  cursor,
                  node {
                    name
                  }
                }
              }
            }
          }';

        $expected = array (
            'rebels' =>
                array (
                    'name' => 'Alliance to Restore the Republic',
                    'ships' =>
                        array (
                            'edges' =>
                                array (
                                    0 =>
                                        array (
                                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjA=',
                                            'node' =>
                                                array (
                                                    'name' => 'X-Wing',
                                                ),
                                        ),
                                    1 =>
                                        array (
                                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                                            'node' =>
                                                array (
                                                    'name' => 'Y-Wing',
                                                ),
                                        ),
                                ),
                        ),
                ),
        );

        $this->assertValidQuery($query, $expected);
    }

    public function testFetchesTheNextThreeShipsOfTHeRebelsWithACursor()
    {
        $query = 'query EndOfRebelShipsQuery {
            rebels {
              name,
              ships(first: 3 after: "YXJyYXljb25uZWN0aW9uOjE=") {
                edges {
                  cursor,
                  node {
                    name
                  }
                }
              }
            }
          }';

        $expected = array (
            'rebels' =>
                array (
                    'name' => 'Alliance to Restore the Republic',
                    'ships' =>
                        array (
                            'edges' =>
                                array (
                                    0 =>
                                        array (
                                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                                            'node' =>
                                                array (
                                                    'name' => 'A-Wing',
                                                ),
                                        ),
                                    1 =>
                                        array (
                                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                                            'node' =>
                                                array (
                                                    'name' => 'Millennium Falcon',
                                                ),
                                        ),
                                    2 =>
                                        array (
                                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjQ=',
                                            'node' =>
                                                array (
                                                    'name' => 'Home One',
                                                ),
                                        ),
                                ),
                        ),
                ),
        );

        $this->assertValidQuery($query, $expected);
    }

    public function testFetchesNoShipsOfTheRebelsAtTheEndOfConnection()
    {
        $query = 'query RebelsQuery {
            rebels {
              name,
              ships(first: 3 after: "YXJyYXljb25uZWN0aW9uOjQ=") {
                edges {
                  cursor,
                  node {
                    name
                  }
                }
              }
            }
          }';

        $expected = array (
            'rebels' =>
                array (
                    'name' => 'Alliance to Restore the Republic',
                    'ships' =>
                        array (
                            'edges' =>
                                array (
                                ),
                        ),
                ),
        );

        $this->assertValidQuery($query, $expected);
    }

    public function testIdentifiesTheEndOfTheList()
    {
        $query = 'query EndOfRebelShipsQuery {
            rebels {
              name,
              originalShips: ships(first: 2) {
                edges {
                  node {
                    name
                  }
                }
                pageInfo {
                  hasNextPage
                }
              }
              moreShips: ships(first: 3 after: "YXJyYXljb25uZWN0aW9uOjE=") {
                edges {
                  node {
                    name
                  }
                }
                pageInfo {
                  hasNextPage
                }
              }
            }
          }';
        $expected = array (
            'rebels' =>
                array (
                    'name' => 'Alliance to Restore the Republic',
                    'originalShips' =>
                        array (
                            'edges' =>
                                array (
                                    0 =>
                                        array (
                                            'node' =>
                                                array (
                                                    'name' => 'X-Wing',
                                                ),
                                        ),
                                    1 =>
                                        array (
                                            'node' =>
                                                array (
                                                    'name' => 'Y-Wing',
                                                ),
                                        ),
                                ),
                            'pageInfo' =>
                                array (
                                    'hasNextPage' => true,
                                ),
                        ),
                    'moreShips' =>
                        array (
                            'edges' =>
                                array (
                                    0 =>
                                        array (
                                            'node' =>
                                                array (
                                                    'name' => 'A-Wing',
                                                ),
                                        ),
                                    1 =>
                                        array (
                                            'node' =>
                                                array (
                                                    'name' => 'Millennium Falcon',
                                                ),
                                        ),
                                    2 =>
                                        array (
                                            'node' =>
                                                array (
                                                    'name' => 'Home One',
                                                ),
                                        ),
                                ),
                            'pageInfo' =>
                                array (
                                    'hasNextPage' => false,
                                ),
                        ),
                ),
        );

        $this->assertValidQuery($query, $expected);
    }

    /**
     * Helper function to test a query and the expected response.
     */
    private function assertValidQuery($query, $expected)
    {
        $result = GraphQL::executeQuery(StarWarsSchema::getSchema(), $query)->toArray();

        $this->assertEquals(['data' => $expected], $result);
    }
}

// File: wp-graphql\vendor\ivome\graphql-relay-php\tests\StarWarsData.php
<?php
/**
 * @author: Ivo Meißner
 * Date: 29.02.16
 * Time: 08:34
 */

namespace GraphQLRelay\tests;


class StarWarsData {
    protected static $xwing = [
        'id' => '1',
        'name' => 'X-Wing'
    ];

    protected static $ywing = [
        'id' => '2',
        'name' => 'Y-Wing'
    ];

    protected static $awing = [
        'id' => '3',
        'name' => 'A-Wing'
    ];

    protected static $falcon = [
        'id' => '4',
        'name' => 'Millennium Falcon'
    ];

    protected static $homeOne = [
        'id' => '5',
        'name' => 'Home One'
    ];

    protected static $tieFighter = [
        'id' => '6',
        'name' => 'TIE Fighter'
    ];

    protected static $tieInterceptor = [
        'id' => '7',
        'name' => 'TIE Interceptor'
    ];

    protected static $executor = [
        'id' => '8',
        'name' => 'TIE Interceptor'
    ];

    protected static $rebels = [
        'id' => '1',
        'name' => 'Alliance to Restore the Republic',
        'ships' => ['1', '2', '3', '4', '5']
    ];

    protected static $empire = [
        'id' => '2',
        'name' => 'Galactic Empire',
        'ships' => ['6', '7', '8']
    ];

    protected static $nextShip = 9;

    protected static $data;

    /**
     * Returns the data object
     *
     * @return array $array
     */
    protected static function getData()
    {
        if (self::$data === null) {
            self::$data = [
                'Faction' => [
                    '1' => self::$rebels,
                    '2' => self::$empire
                ],
                'Ship' => [
                    '1' => self::$xwing,
                    '2' => self::$ywing,
                    '3' => self::$awing,
                    '4' => self::$falcon,
                    '5' => self::$homeOne,
                    '6' => self::$tieFighter,
                    '7' => self::$tieInterceptor,
                    '8' => self::$executor
                ]
            ];
        }
        return self::$data;
    }

    /**
     * @param $shipName
     * @param $factionId
     * @return array
     */
    public static function createShip($shipName, $factionId)
    {
        $data = self::getData();

        $newShip = [
            'id' => (string) self::$nextShip++,
            'name' => $shipName
        ];
        $data['Ship'][$newShip['id']] = $newShip;
        $data['Faction'][$factionId]['ships'][] = $newShip['id'];

        // Save
        self::$data = $data;

        return $newShip;
    }

    public static function getShip($id)
    {
        $data = self::getData();
        return $data['Ship'][$id];
    }

    public static function getFaction($id)
    {
        $data = self::getData();
        return $data['Faction'][$id];
    }

    public static function getRebels()
    {
        return self::$rebels;
    }

    public static function getEmpire()
    {
        return self::$empire;
    }
}

// File: wp-graphql\vendor\ivome\graphql-relay-php\tests\StarWarsMutationTest.php
<?php
/**
 * @author: Ivo Meißner
 * Date: 29.02.16
 * Time: 12:11
 */

namespace GraphQLRelay\tests;


use GraphQL\GraphQL;
use PHPUnit\Framework\TestCase;

class StarWarsMutationTest extends TestCase
{
    public function testMutatesTheDataSet()
    {
        $mutation = 'mutation AddBWingQuery($input: IntroduceShipInput!) {
            introduceShip(input: $input) {
              ship {
                id
                name
              }
              faction {
                name
              }
              clientMutationId
            }
          }';

        $params = array (
            'input' =>
                array (
                    'shipName' => 'B-Wing',
                    'factionId' => '1',
                    'clientMutationId' => 'abcde',
                ),
        );

        $expected = array (
            'introduceShip' =>
                array (
                    'ship' =>
                        array (
                            'id' => 'U2hpcDo5',
                            'name' => 'B-Wing',
                        ),
                    'faction' =>
                        array (
                            'name' => 'Alliance to Restore the Republic',
                        ),
                    'clientMutationId' => 'abcde',
                ),
        );

        $result = GraphQL::executeQuery(StarWarsSchema::getSchema(), $mutation, null, null, $params)->toArray();

        $this->assertEquals(['data' => $expected], $result);
    }
}

// File: wp-graphql\vendor\ivome\graphql-relay-php\tests\StarWarsObjectIdentificationTest.php
<?php
/**
 * @author: Ivo Meißner
 * Date: 29.02.16
 * Time: 11:23
 */

namespace GraphQLRelay\tests;


use GraphQL\GraphQL;
use PHPUnit\Framework\TestCase;

class StarWarsObjectIdentificationTest extends TestCase
{
    public function testFetchesTheIDAndNameOfTheRebels()
    {
        $query = 'query RebelsQuery {
            rebels {
              id
              name
            }
          }';

        $expected = array (
            'rebels' =>
                array (
                    'id' => 'RmFjdGlvbjox',
                    'name' => 'Alliance to Restore the Republic',
                ),
        );

        $this->assertValidQuery($query, $expected);
    }

    public function testRefetchesTheRebels()
    {
        $query = 'query RebelsRefetchQuery {
            node(id: "RmFjdGlvbjox") {
              id
              ... on Faction {
                name
              }
            }
          }';

        $expected = array (
            'node' =>
                array (
                    'id' => 'RmFjdGlvbjox',
                    'name' => 'Alliance to Restore the Republic',
                ),
        );

        $this->assertValidQuery($query, $expected);
    }

    public function testFetchesTheIDAndNameOfTheEmpire()
    {
        $query = 'query EmpireQuery {
            empire {
              id
              name
            }
          }';

        $expected = array (
            'empire' =>
                array (
                    'id' => 'RmFjdGlvbjoy',
                    'name' => 'Galactic Empire',
                ),
        );

        $this->assertValidQuery($query, $expected);
    }

    public function testRefetchesTheEmpire()
    {
        $query = 'query EmpireRefetchQuery {
            node(id: "RmFjdGlvbjoy") {
              id
              ... on Faction {
                name
              }
            }
          }';

        $expected = array (
            'node' =>
                array (
                    'id' => 'RmFjdGlvbjoy',
                    'name' => 'Galactic Empire',
                ),
        );

        $this->assertValidQuery($query, $expected);
    }

    public function testRefetchesTheXWing()
    {
        $query = 'query XWingRefetchQuery {
            node(id: "U2hpcDox") {
              id
              ... on Ship {
                name
              }
            }
          }';

        $expected = array (
            'node' =>
                array (
                    'id' => 'U2hpcDox',
                    'name' => 'X-Wing',
                ),
        );

        $this->assertValidQuery($query, $expected);
    }

    /**
     * Helper function to test a query and the expected response.
     */
    private function assertValidQuery($query, $expected)
    {
        $result = GraphQL::executeQuery(StarWarsSchema::getSchema(), $query)->toArray();

        $this->assertEquals(['data' => $expected], $result);
    }
}

// File: wp-graphql\vendor\ivome\graphql-relay-php\tests\StarWarsSchema.php
<?php
/**
 * @author: Ivo Meißner
 * Date: 29.02.16
 * Time: 10:17
 */

namespace GraphQLRelay\tests;


use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Schema;
use GraphQLRelay\Relay;

class StarWarsSchema {
    protected static $shipConnection;
    protected static $factionType;
    protected static $shipType;
    protected static $nodeDefinition;
    protected static $shipMutation;

    /**
     * This is a basic end-to-end test, designed to demonstrate the various
     * capabilities of a Relay-compliant GraphQL server.
     *
     * It is recommended that readers of this test be familiar with
     * the end-to-end test in GraphQL.js first, as this test skips
     * over the basics covered there in favor of illustrating the
     * key aspects of the Relay spec that this test is designed to illustrate.
     *
     * We will create a GraphQL schema that describes the major
     * factions and ships in the original Star Wars trilogy.
     *
     * NOTE: This may contain spoilers for the original Star
     * Wars trilogy.
     */

    /**
     * Using our shorthand to describe type systems, the type system for our
     * example will be the following:
     *
     * interface Node {
     *   id: ID!
     * }
     *
     * type Faction : Node {
     *   id: ID!
     *   name: String
     *   ships: ShipConnection
     * }
     *
     * type Ship : Node {
     *   id: ID!
     *   name: String
     * }
     *
     * type ShipConnection {
     *   edges: [ShipEdge]
     *   pageInfo: PageInfo!
     * }
     *
     * type ShipEdge {
     *   cursor: String!
     *   node: Ship
     * }
     *
     * type PageInfo {
     *   hasNextPage: Boolean!
     *   hasPreviousPage: Boolean!
     *   startCursor: String
     *   endCursor: String
     * }
     *
     * type Query {
     *   rebels: Faction
     *   empire: Faction
     *   node(id: ID!): Node
     * }
     *
     * input IntroduceShipInput {
     *   clientMutationId: string!
     *   shipName: string!
     *   factionId: ID!
     * }
     *
     * input IntroduceShipPayload {
     *   clientMutationId: string!
     *   ship: Ship
     *   faction: Faction
     * }
     *
     * type Mutation {
     *   introduceShip(input IntroduceShipInput!): IntroduceShipPayload
     * }
     */

    /**
     * We get the node interface and field from the relay library.
     *
     * The first method is the way we resolve an ID to its object. The second is the
     * way we resolve an object that implements node to its type.
     */
    protected static function getNodeDefinition()
    {
        if (self::$nodeDefinition === null){
            $nodeDefinition = Relay::nodeDefinitions(
                // The ID fetcher definition
                function ($globalId) {
                    $idComponents = Relay::fromGlobalId($globalId);
                    if ($idComponents['type'] === 'Faction'){
                        return StarWarsData::getFaction($idComponents['id']);
                    } else if ($idComponents['type'] === 'Ship'){
                        return StarWarsData::getShip($idComponents['id']);
                    } else {
                        return null;
                    }
                },
                // Type resolver
                function ($object) {
                    return isset($object['ships']) ? self::getFactionType() : self::getShipType();
                }
            );
            self::$nodeDefinition = $nodeDefinition;
        }

        return self::$nodeDefinition;
    }

    /**
     * We define our basic ship type.
     *
     * This implements the following type system shorthand:
     *   type Ship : Node {
     *     id: String!
     *     name: String
     *   }
     *
     * @return ObjectType
     */
    protected static function getShipType()
    {
        if (self::$shipType === null){
            $nodeDefinition = self::getNodeDefinition();

            $shipType = new ObjectType([
                'name' => 'Ship',
                'description' => 'A ship in the Star Wars saga',
                'fields' => function() {
                    return [
                        'id' => Relay::globalIdField(),
                        'name' => [
                            'type' => Type::string(),
                            'description' => 'The name of the ship.'
                        ]
                    ];
                },
                'interfaces' => [$nodeDefinition['nodeInterface']]
            ]);
            self::$shipType = $shipType;
        }
        return self::$shipType;
    }

    /**
     * We define our faction type, which implements the node interface.
     *
     * This implements the following type system shorthand:
     *   type Faction : Node {
     *     id: String!
     *     name: String
     *     ships: ShipConnection
     *   }
     *
     * @return ObjectType
     */
    protected static function getFactionType()
    {
        if (self::$factionType === null){
            $shipConnection = self::getShipConnection();
            $nodeDefinition = self::getNodeDefinition();

            $factionType = new ObjectType([
                'name' => 'Faction',
                'description' => 'A faction in the Star Wars saga',
                'fields' => function() use ($shipConnection) {
                    return [
                        'id' => Relay::globalIdField(),
                        'name' => [
                            'type' => Type::string(),
                            'description' => 'The name of the faction.'
                        ],
                        'ships' => [
                            'type' => $shipConnection['connectionType'],
                            'description' => 'The ships used by the faction.',
                            'args' => Relay::connectionArgs(),
                            'resolve' => function($faction, $args) {
                                // Map IDs from faction back to ships
                                $data = array_map(function($id) {
                                    return StarWarsData::getShip($id);
                                }, $faction['ships']);
                                return Relay::connectionFromArray($data, $args);
                            }
                        ]
                    ];
                },
                'interfaces' => [$nodeDefinition['nodeInterface']]
            ]);

            self::$factionType = $factionType;
        }

        return self::$factionType;
    }

    /**
     * We define a connection between a faction and its ships.
     *
     * connectionType implements the following type system shorthand:
     *   type ShipConnection {
     *     edges: [ShipEdge]
     *     pageInfo: PageInfo!
     *   }
     *
     * connectionType has an edges field - a list of edgeTypes that implement the
     * following type system shorthand:
     *   type ShipEdge {
     *     cursor: String!
     *     node: Ship
     *   }
     */
    protected static function getShipConnection()
    {
        if (self::$shipConnection === null){
            $shipType = self::getShipType();
            $shipConnection = Relay::connectionDefinitions([
                'nodeType' => $shipType
            ]);

            self::$shipConnection = $shipConnection;
        }

        return self::$shipConnection;
    }

    /**
     * This will return a GraphQLFieldConfig for our ship
     * mutation.
     *
     * It creates these two types implicitly:
     *   input IntroduceShipInput {
     *     clientMutationId: string!
     *     shipName: string!
     *     factionId: ID!
     *   }
     *
     *   input IntroduceShipPayload {
     *     clientMutationId: string!
     *     ship: Ship
     *     faction: Faction
     *   }
     */
    public static function getShipMutation()
    {
        if (self::$shipMutation === null){
            $shipType = self::getShipType();
            $factionType = self::getFactionType();

            $shipMutation = Relay::mutationWithClientMutationId([
                'name' => 'IntroduceShip',
                'inputFields' => [
                    'shipName' => [
                        'type' => Type::nonNull(Type::string())
                    ],
                    'factionId' => [
                        'type' => Type::nonNull(Type::id())
                    ]
                ],
                'outputFields' => [
                    'ship' => [
                        'type' => $shipType,
                        'resolve' => function ($payload) {
                            return StarWarsData::getShip($payload['shipId']);
                        }
                    ],
                    'faction' => [
                        'type' => $factionType,
                        'resolve' => function ($payload) {
                            return StarWarsData::getFaction($payload['factionId']);
                        }
                    ]
                ],
                'mutateAndGetPayload' => function ($input) {
                    $newShip = StarWarsData::createShip($input['shipName'], $input['factionId']);
                    return [
                        'shipId' => $newShip['id'],
                        'factionId' => $input['factionId']
                    ];
                }
            ]);
            self::$shipMutation = $shipMutation;
        }

        return self::$shipMutation;
    }

    /**
     * Returns the complete schema for StarWars tests
     *
     * @return Schema
     */
    public static function getSchema()
    {
        $factionType = self::getFactionType();
        $nodeDefinition = self::getNodeDefinition();
        $shipMutation = self::getShipMutation();

        /**
         * This is the type that will be the root of our query, and the
         * entry point into our schema.
         *
         * This implements the following type system shorthand:
         *   type Query {
         *     rebels: Faction
         *     empire: Faction
         *     node(id: String!): Node
         *   }
         */
        $queryType = new ObjectType([
            'name' => 'Query',
            'fields' => function () use ($factionType, $nodeDefinition) {
                return [
                    'rebels' => [
                        'type' => $factionType,
                        'resolve' => function (){
                            return StarWarsData::getRebels();
                        }
                    ],
                    'empire' => [
                        'type' => $factionType,
                        'resolve' => function () {
                            return StarWarsData::getEmpire();
                        }
                    ],
                    'node' => $nodeDefinition['nodeField']
                ];
            },
        ]);

        /**
         * This is the type that will be the root of our mutations, and the
         * entry point into performing writes in our schema.
         *
         * This implements the following type system shorthand:
         *   type Mutation {
         *     introduceShip(input IntroduceShipInput!): IntroduceShipPayload
         *   }
         */
        $mutationType = new ObjectType([
            'name' => 'Mutation',
            'fields' => function () use ($shipMutation) {
                return [
                    'introduceShip' => $shipMutation
                ];
            }
        ]);

        /**
         * Finally, we construct our schema (whose starting query type is the query
         * type we defined above) and export it.
         */
        $schema = new Schema([
            'query' => $queryType,
            'mutation' => $mutationType
        ]);

        return $schema;
    }
}

// File: wp-graphql\vendor\ivome\graphql-relay-php\tests\Connection\ArrayConnectionTest.php
<?php
/**
 * @author: Ivo Meißner
 * Date: 23.02.16
 * Time: 17:04
 */

namespace GraphQLRelay\Tests\Connection;

use GraphQLRelay\Connection\ArrayConnection;
use PHPUnit\Framework\TestCase;

class ArrayConnectionTest extends TestCase
{
    protected $letters = ['A', 'B', 'C', 'D', 'E'];

    public function testReturnsAllElementsWithoutFilters()
    {
        $connection = ArrayConnection::connectionFromArray($this->letters, []);

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'A',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjA=',
                        ),
                    1 =>
                        array (
                            'node' => 'B',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                        ),
                    2 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                    3 =>
                        array (
                            'node' => 'D',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                        ),
                    4 =>
                        array (
                            'node' => 'E',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjQ=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjA=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjQ=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => false,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testRespectsASmallerFirst()
    {
        $connection = ArrayConnection::connectionFromArray($this->letters, ['first' => 2]);

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'A',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjA=',
                        ),
                    1 =>
                        array (
                            'node' => 'B',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjA=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => true,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testRespectsAnOverlyLargeFirst()
    {
        $connection = ArrayConnection::connectionFromArray($this->letters, ['first' => 10]);

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'A',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjA=',
                        ),
                    1 =>
                        array (
                            'node' => 'B',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                        ),
                    2 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                    3 =>
                        array (
                            'node' => 'D',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                        ),
                    4 =>
                        array (
                            'node' => 'E',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjQ=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjA=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjQ=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => false,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testRespectsASmallerLast()
    {
        $connection = ArrayConnection::connectionFromArray($this->letters, ['last' => 2]);

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'D',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                        ),
                    1 =>
                        array (
                            'node' => 'E',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjQ=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjQ=',
                    'hasPreviousPage' => true,
                    'hasNextPage' => false,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testRespectsAnOverlyLargeLast()
    {
        $connection = ArrayConnection::connectionFromArray($this->letters, ['last' => 10]);

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'A',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjA=',
                        ),
                    1 =>
                        array (
                            'node' => 'B',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                        ),
                    2 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                    3 =>
                        array (
                            'node' => 'D',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                        ),
                    4 =>
                        array (
                            'node' => 'E',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjQ=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjA=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjQ=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => false,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testRespectsFirstAndAfter()
    {
        $connection = ArrayConnection::connectionFromArray($this->letters, ['first' => 2, 'after' => 'YXJyYXljb25uZWN0aW9uOjE=']);

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                    1 =>
                        array (
                            'node' => 'D',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => true,
                ),
        );

        $this->assertEquals($connection, $expected);
    }

    public function testRespectsFirstAndAfterWithLongFirst()
    {
        $connection = ArrayConnection::connectionFromArray($this->letters, ['first' => 10, 'after' => 'YXJyYXljb25uZWN0aW9uOjE=']);

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                    1 =>
                        array (
                            'node' => 'D',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                        ),
                    2 =>
                        array (
                            'node' => 'E',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjQ=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjQ=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => false,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testRespectsLastAndBefore()
    {
        $connection = ArrayConnection::connectionFromArray($this->letters, [
            'last' => 2,
            'before' => 'YXJyYXljb25uZWN0aW9uOjM='
        ]);

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'B',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                        ),
                    1 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                    'hasPreviousPage' => true,
                    'hasNextPage' => false,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testRespectsLastAndBeforeWithLongLast()
    {
        $connection = ArrayConnection::connectionFromArray($this->letters, [
            'last' => 10,
            'before' => 'YXJyYXljb25uZWN0aW9uOjM='
        ]);

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'A',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjA=',
                        ),
                    1 =>
                        array (
                            'node' => 'B',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                        ),
                    2 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjA=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => false,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testRespectsFirstAndAfterAndBeforeTooFew()
    {
        $connection = ArrayConnection::connectionFromArray($this->letters, [
            'first' => 2,
            'after' => 'YXJyYXljb25uZWN0aW9uOjA=',
            'before' => 'YXJyYXljb25uZWN0aW9uOjQ='
        ]);

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'B',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                        ),
                    1 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => true,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testRespectsFirstAndAfterAndBeforeTooMany()
    {
        $connection = ArrayConnection::connectionFromArray($this->letters, [
            'first' => 3,
            'after' => 'YXJyYXljb25uZWN0aW9uOjA=',
            'before' => 'YXJyYXljb25uZWN0aW9uOjQ='
        ]);

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'B',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                        ),
                    1 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                    2 =>
                        array (
                            'node' => 'D',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => false,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testRespectsFirstAndAfterAndBeforeExactlyRight()
    {
        $connection = ArrayConnection::connectionFromArray($this->letters, [
            'first' => 3,
            'after' => 'YXJyYXljb25uZWN0aW9uOjA=',
            'before' => 'YXJyYXljb25uZWN0aW9uOjQ='
        ]);

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'B',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                        ),
                    1 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                    2 =>
                        array (
                            'node' => 'D',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => false,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testRespectsLastAndAfterAndBeforeTooFew()
    {
        $connection = ArrayConnection::connectionFromArray($this->letters, [
            'last' => 2,
            'after' => 'YXJyYXljb25uZWN0aW9uOjA=',
            'before' => 'YXJyYXljb25uZWN0aW9uOjQ='
        ]);

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                    1 =>
                        array (
                            'node' => 'D',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                    'hasPreviousPage' => true,
                    'hasNextPage' => false,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testRespectsLastAndAfterAndBeforeTooMany()
    {
        $connection = ArrayConnection::connectionFromArray($this->letters, [
            'last' => 4,
            'after' => 'YXJyYXljb25uZWN0aW9uOjA=',
            'before' => 'YXJyYXljb25uZWN0aW9uOjQ='
        ]);

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'B',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                        ),
                    1 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                    2 =>
                        array (
                            'node' => 'D',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => false,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testRespectsLastAndAfterAndBeforeExactlyRight()
    {
        $connection = ArrayConnection::connectionFromArray($this->letters, [
            'last' => 3,
            'after' => 'YXJyYXljb25uZWN0aW9uOjA=',
            'before' => 'YXJyYXljb25uZWN0aW9uOjQ='
        ]);

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'B',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                        ),
                    1 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                    2 =>
                        array (
                            'node' => 'D',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => false,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testReturnsNoElementsIfFirstIs0()
    {
        $connection = ArrayConnection::connectionFromArray($this->letters, [
            'first' => 0
        ]);

        $expected = array (
            'edges' =>
                array (
                ),
            'pageInfo' =>
                array (
                    'startCursor' => NULL,
                    'endCursor' => NULL,
                    'hasPreviousPage' => false,
                    'hasNextPage' => true,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testReturnsAllElementsIfCursorsAreInvalid()
    {
        $connection = ArrayConnection::connectionFromArray($this->letters, [
            'before' => 'invalid',
            'after' => 'invalid'
        ]);

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'A',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjA=',
                        ),
                    1 =>
                        array (
                            'node' => 'B',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                        ),
                    2 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                    3 =>
                        array (
                            'node' => 'D',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                        ),
                    4 =>
                        array (
                            'node' => 'E',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjQ=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjA=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjQ=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => false,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testReturnsAllElementsIfCursorsAreOnTheOutside()
    {
        $connection = ArrayConnection::connectionFromArray($this->letters, [
            'before' => 'YXJyYXljb25uZWN0aW9uOjYK',
            'after' => 'YXJyYXljb25uZWN0aW9uOi0xCg=='
        ]);

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'A',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjA=',
                        ),
                    1 =>
                        array (
                            'node' => 'B',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                        ),
                    2 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                    3 =>
                        array (
                            'node' => 'D',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                        ),
                    4 =>
                        array (
                            'node' => 'E',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjQ=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjA=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjQ=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => false,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testReturnsNoElementsIfCursorsCross()
    {
        $connection = ArrayConnection::connectionFromArray($this->letters, [
            'before' => 'YXJyYXljb25uZWN0aW9uOjI=',
            'after' => 'YXJyYXljb25uZWN0aW9uOjQ='
        ]);

        $expected = array (
            'edges' =>
                array (
                ),
            'pageInfo' =>
                array (
                    'startCursor' => NULL,
                    'endCursor' => NULL,
                    'hasPreviousPage' => false,
                    'hasNextPage' => false,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testReturnsAnEdgeCursorGivenAnArrayAndAMemberObject()
    {
        $cursor = ArrayConnection::cursorForObjectInConnection($this->letters, 'B');

        $this->assertEquals('YXJyYXljb25uZWN0aW9uOjE=', $cursor);
    }

    public function testReturnsNullGivenAnArrayAndANonMemberObject()
    {
        $cursor = ArrayConnection::cursorForObjectInConnection($this->letters, 'F');

        $this->assertEquals(null, $cursor);
    }

    public function testWorksWithAJustRightArraySlice()
    {
        $connection = ArrayConnection::connectionFromArraySlice(
            array_slice($this->letters, 1, 2),
            [
                'first' => 2,
                'after' => 'YXJyYXljb25uZWN0aW9uOjA=',
            ],
            [
                'sliceStart' => 1,
                'arrayLength' => 5
            ]
        );

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'B',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                        ),
                    1 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => true,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testWorksWithAnOversizedArraySliceLeftSide()
    {
        $connection = ArrayConnection::connectionFromArraySlice(
            array_slice($this->letters, 0, 3),
            [
                'first' => 2,
                'after' => 'YXJyYXljb25uZWN0aW9uOjA=',
            ],
            [
                'sliceStart' => 0,
                'arrayLength' => 5
            ]
        );

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'B',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                        ),
                    1 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjE=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => true,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testWorksWithAnOversizedArraySliceRightSide()
    {
        $connection = ArrayConnection::connectionFromArraySlice(
            array_slice($this->letters, 2, 2),
            [
                'first' => 1,
                'after' => 'YXJyYXljb25uZWN0aW9uOjE=',
            ],
            [
                'sliceStart' => 2,
                'arrayLength' => 5
            ]
        );

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => true,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testWorksWithAnOversizedArraySliceBothSides()
    {
        $connection = ArrayConnection::connectionFromArraySlice(
            array_slice($this->letters, 1, 3),
            [
                'first' => 1,
                'after' => 'YXJyYXljb25uZWN0aW9uOjE=',
            ],
            [
                'sliceStart' => 1,
                'arrayLength' => 5
            ]
        );

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => true,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testWorksWithAnUndersizedArraySliceLeftSide()
    {
        $connection = ArrayConnection::connectionFromArraySlice(
            array_slice($this->letters, 3, 2),
            [
                'first' => 3,
                'after' => 'YXJyYXljb25uZWN0aW9uOjE=',
            ],
            [
                'sliceStart' => 3,
                'arrayLength' => 5
            ]
        );

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'D',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                        ),
                    1 =>
                        array (
                            'node' => 'E',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjQ=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjQ=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => false,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testWorksWithAnUndersizedArraySliceRightSide()
    {
        $connection = ArrayConnection::connectionFromArraySlice(
            array_slice($this->letters, 2, 2),
            [
                'first' => 3,
                'after' => 'YXJyYXljb25uZWN0aW9uOjE=',
            ],
            [
                'sliceStart' => 2,
                'arrayLength' => 5
            ]
        );

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'C',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                        ),
                    1 =>
                        array (
                            'node' => 'D',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjI=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => true,
                ),
        );

        $this->assertEquals($expected, $connection);
    }

    public function testWorksWithAnUndersizedArraySliceBothSides()
    {
        $connection = ArrayConnection::connectionFromArraySlice(
            array_slice($this->letters, 3, 1),
            [
                'first' => 3,
                'after' => 'YXJyYXljb25uZWN0aW9uOjE=',
            ],
            [
                'sliceStart' => 3,
                'arrayLength' => 5
            ]
        );

        $expected = array (
            'edges' =>
                array (
                    0 =>
                        array (
                            'node' => 'D',
                            'cursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                        ),
                ),
            'pageInfo' =>
                array (
                    'startCursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                    'endCursor' => 'YXJyYXljb25uZWN0aW9uOjM=',
                    'hasPreviousPage' => false,
                    'hasNextPage' => true,
                ),
        );

        $this->assertEquals($expected, $connection);
    }
}


// File: wp-graphql\vendor\ivome\graphql-relay-php\tests\Connection\ConnectionTest.php
<?php
/**
 * @author: Ivo Meißner
 * Date: 22.02.16
 * Time: 18:35
 */
namespace GraphQLRelay\Tests\Connection;

use GraphQL\GraphQL;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Schema;
use GraphQLRelay\Connection\ArrayConnection;
use GraphQLRelay\Connection\Connection;
use PHPUnit\Framework\TestCase;

class ConnectionTest extends TestCase
{
    /**
     * @var array
     */
    protected $allUsers;

    /**
     * @var \GraphQL\Type\Definition\ObjectType
     */
    protected $userType;

    /**
     * @var array
     */
    protected $friendConnection;

    /**
     * @var array
     */
    protected $userConnection;

    /**
     * @var ObjectType
     */
    protected $queryType;

    /**
     * @var Schema
     */
    protected $schema;

    public function setup(): void
    {
        $this->allUsers = [
            [ 'name' => 'Dan', 'friends' => [1, 2, 3, 4] ],
            [ 'name' => 'Nick', 'friends' => [0, 2, 3, 4] ],
            [ 'name' => 'Lee', 'friends' => [0, 1, 3, 4] ],
            [ 'name' => 'Joe', 'friends' => [0, 1, 2, 4] ],
            [ 'name' => 'Tim', 'friends' => [0, 1, 2, 3] ],
        ];

        $this->userType = new ObjectType([
            'name' => 'User',
            'fields' => function(){
                return [
                    'name' => [
                        'type' => Type::string()
                    ],
                    'friends' => [
                        'type' => $this->friendConnection,
                        'args' => Connection::connectionArgs(),
                        'resolve' => function ($user, $args) {
                            return ArrayConnection::connectionFromArray($user['friends'], $args);
                        }
                    ],
                    'friendsForward' => [
                        'type' => $this->userConnection,
                        'args' => Connection::forwardConnectionArgs(),
                        'resolve' => function ($user, $args) {
                            return ArrayConnection::connectionFromArray($user['friends'], $args);
                        }
                    ],
                    'friendsBackward' => [
                        'type' => $this->userConnection,
                        'args' => Connection::backwardConnectionArgs(),
                        'resolve' => function ($user, $args) {
                            return ArrayConnection::connectionFromArray($user['friends'], $args);
                        }
                    ]
                ];
            }
        ]);

        $this->friendConnection = Connection::connectionDefinitions([
            'name' => 'Friend',
            'nodeType' => $this->userType,
            'resolveNode' => function ($edge) {
                return $this->allUsers[$edge['node']];
            },
            'edgeFields' => function() {
                return [
                    'friendshipTime' => [
                        'type' => Type::string(),
                        'resolve' => function() { return 'Yesterday'; }
                    ]
                ];
            },
            'connectionFields' => function() {
                return [
                    'totalCount' => [
                        'type' => Type::int(),
                        'resolve' => function() {
                            return count($this->allUsers) -1;
                        }
                    ]
                ];
            }
        ])['connectionType'];

        $this->userConnection = Connection::connectionDefinitions([
            'nodeType' => $this->userType,
            'resolveNode' => function ($edge) {
                return $this->allUsers[$edge['node']];
            }
        ])['connectionType'];

        $this->queryType = new ObjectType([
            'name' => 'Query',
            'fields' => function() {
                return [
                    'user' => [
                        'type' => $this->userType,
                        'resolve' => function() {
                            return $this->allUsers[0];
                        }
                    ]
                ];
            }
        ]);

        $this->schema = new Schema([
            'query' => $this->queryType
        ]);
    }

    public function testIncludesConnectionAndEdgeFields()
    {
        $query = 'query FriendsQuery {
            user {
              friends(first: 2) {
                totalCount
                edges {
                  friendshipTime
                  node {
                    name
                  }
                }
              }
            }
          }';

        $expected = [
            'user' => [
                'friends' => [
                    'totalCount' => 4,
                    'edges' => [
                        [
                            'friendshipTime' => 'Yesterday',
                            'node' => [
                                'name' => 'Nick'
                            ]
                        ],
                        [
                            'friendshipTime' => 'Yesterday',
                            'node' => [
                                'name' => 'Lee'
                            ]
                        ]
                    ]
                ]
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    public function testWorksWithForwardConnectionArgs()
    {
        $query = 'query FriendsQuery {
            user {
              friendsForward(first: 2) {
                edges {
                  node {
                    name
                  }
                }
              }
            }
          }';
        $expected = [
            'user' => [
                'friendsForward' => [
                    'edges' => [
                        [
                            'node' => [
                                'name' => 'Nick'
                            ]
                        ],
                        [
                            'node' => [
                                'name' => 'Lee'
                            ]
                        ]
                    ]
                ]
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    public function testWorksWithBackwardConnectionArgs()
    {
        $query = 'query FriendsQuery {
            user {
              friendsBackward(last: 2) {
                edges {
                  node {
                    name
                  }
                }
              }
            }
          }';

        $expected = [
            'user' => [
                'friendsBackward' => [
                    'edges' => [
                        [
                            'node' => [
                                'name' => 'Joe'
                            ]
                        ],
                        [
                            'node' => [
                                'name' => 'Tim'
                            ]
                        ]
                    ]
                ]
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    public function testEdgeTypeThrowsWithoutNodeType() {
    	$this->expectException(\InvalidArgumentException::class);
        Connection::createEdgeType([]);
    }

    public function testConnectionTypeThrowsWithoutNodeType() {
    	$this->expectException(\InvalidArgumentException::class);
        Connection::createConnectionType([]);
    }

    public function testConnectionDefinitionThrowsWithoutNodeType() {
    	$this->expectException(\InvalidArgumentException::class);
        Connection::connectionDefinitions([]);
    }

    /**
     * Helper function to test a query and the expected response.
     */
    protected function assertValidQuery($query, $expected)
    {
        $result = GraphQL::executeQuery($this->schema, $query)->toArray();
        $this->assertEquals(['data' => $expected], $result);
    }
}


// File: wp-graphql\vendor\ivome\graphql-relay-php\tests\Connection\SeparateConnectionTest.php
<?php
/**
 * @author: Ivo Meißner
 * Date: 22.02.16
 * Time: 18:35
 */
namespace GraphQLRelay\Tests\Connection;

use GraphQL\GraphQL;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Schema;
use GraphQLRelay\Connection\ArrayConnection;
use GraphQLRelay\Connection\Connection;
use PHPUnit\Framework\TestCase;

class SeparateConnectionTest extends TestCase
{
    /**
     * @var array
     */
    protected $allUsers;

    /**
     * @var ObjectType
     */
    protected $userType;

    /**
     * @var ObjectType
     */
    protected $friendEdge;

    /**
     * @var ObjectType
     */
    protected $friendConnection;
    
    /**
     * @var ObjectType
     */
    protected $userEdge;

    /**
     * @var ObjectType
     */
    protected $userConnection;

    /**
     * @var ObjectType
     */
    protected $queryType;

    /**
     * @var Schema
     */
    protected $schema;

    public function setup(): void
    {
        $this->allUsers = [
            [ 'name' => 'Dan', 'friends' => [1, 2, 3, 4] ],
            [ 'name' => 'Nick', 'friends' => [0, 2, 3, 4] ],
            [ 'name' => 'Lee', 'friends' => [0, 1, 3, 4] ],
            [ 'name' => 'Joe', 'friends' => [0, 1, 2, 4] ],
            [ 'name' => 'Tim', 'friends' => [0, 1, 2, 3] ],
        ];

        $this->userType = new ObjectType([
            'name' => 'User',
            'fields' => function(){
                return [
                    'name' => [
                        'type' => Type::string()
                    ],
                    'friends' => [
                        'type' => $this->friendConnection,
                        'args' => Connection::connectionArgs(),
                        'resolve' => function ($user, $args) {
                            return ArrayConnection::connectionFromArray($user['friends'], $args);
                        }
                    ],
                    'friendsForward' => [
                        'type' => $this->userConnection,
                        'args' => Connection::forwardConnectionArgs(),
                        'resolve' => function ($user, $args) {
                            return ArrayConnection::connectionFromArray($user['friends'], $args);
                        }
                    ],
                    'friendsBackward' => [
                        'type' => $this->userConnection,
                        'args' => Connection::backwardConnectionArgs(),
                        'resolve' => function ($user, $args) {
                            return ArrayConnection::connectionFromArray($user['friends'], $args);
                        }
                    ]
                ];
            }
        ]);

        $this->friendEdge = Connection::createEdgeType([
            'name' => 'Friend',
            'nodeType' => $this->userType,
            'resolveNode' => function ($edge) {
                return $this->allUsers[$edge['node']];
            },
            'edgeFields' => function() {
                return [
                    'friendshipTime' => [
                        'type' => Type::string(),
                        'resolve' => function() { return 'Yesterday'; }
                    ]
                ];
            }
        ]);

        $this->friendConnection = Connection::createConnectionType([
            'name' => 'Friend',
            'nodeType' => $this->userType,
            'edgeType' => $this->friendEdge,
            'connectionFields' => function() {
                return [
                    'totalCount' => [
                        'type' => Type::int(),
                        'resolve' => function() {
                            return count($this->allUsers) -1;
                        }
                    ]
                ];
            }
        ]);

        $this->userEdge = Connection::createEdgeType([
            'nodeType' => $this->userType,
            'resolveNode' => function ($edge) {
                return $this->allUsers[$edge['node']];
            }
        ]);

        $this->userConnection = Connection::createConnectionType([
            'nodeType' => $this->userType,
            'edgeType' => $this->userEdge
        ]);

        $this->queryType = new ObjectType([
            'name' => 'Query',
            'fields' => function() {
                return [
                    'user' => [
                        'type' => $this->userType,
                        'resolve' => function() {
                            return $this->allUsers[0];
                        }
                    ]
                ];
            }
        ]);

        $this->schema = new Schema([
            'query' => $this->queryType
        ]);
    }

    public function testIncludesConnectionAndEdgeFields()
    {
        $query = 'query FriendsQuery {
            user {
              friends(first: 2) {
                totalCount
                edges {
                  friendshipTime
                  node {
                    name
                  }
                }
              }
            }
          }';

        $expected = [
            'user' => [
                'friends' => [
                    'totalCount' => 4,
                    'edges' => [
                        [
                            'friendshipTime' => 'Yesterday',
                            'node' => [
                                'name' => 'Nick'
                            ]
                        ],
                        [
                            'friendshipTime' => 'Yesterday',
                            'node' => [
                                'name' => 'Lee'
                            ]
                        ]
                    ]
                ]
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    public function testWorksWithForwardConnectionArgs()
    {
        $query = 'query FriendsQuery {
            user {
              friendsForward(first: 2) {
                edges {
                  node {
                    name
                  }
                }
              }
            }
          }';
        $expected = [
            'user' => [
                'friendsForward' => [
                    'edges' => [
                        [
                            'node' => [
                                'name' => 'Nick'
                            ]
                        ],
                        [
                            'node' => [
                                'name' => 'Lee'
                            ]
                        ]
                    ]
                ]
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    public function testWorksWithBackwardConnectionArgs()
    {
        $query = 'query FriendsQuery {
            user {
              friendsBackward(last: 2) {
                edges {
                  node {
                    name
                  }
                }
              }
            }
          }';

        $expected = [
            'user' => [
                'friendsBackward' => [
                    'edges' => [
                        [
                            'node' => [
                                'name' => 'Joe'
                            ]
                        ],
                        [
                            'node' => [
                                'name' => 'Tim'
                            ]
                        ]
                    ]
                ]
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    /**
     * Helper function to test a query and the expected response.
     */
    protected function assertValidQuery($query, $expected)
    {
        $result = GraphQL::executeQuery($this->schema, $query)->toArray();
        $this->assertEquals(['data' => $expected], $result);
    }
}


// File: wp-graphql\vendor\ivome\graphql-relay-php\tests\Mutation\MutationTest.php
<?php
/**
 * @author: Ivo Meißner
 * Date: 23.02.16
 * Time: 12:27
 */
namespace GraphQLRelay\Tests\Mutation;


use GraphQL\GraphQL;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Schema;
use GraphQLRelay\Connection\Connection;
use GraphQLRelay\Mutation\Mutation;
use PHPUnit\Framework\TestCase;

class MutationTest extends TestCase
{
    /**
     * @var ObjectType
     */
    protected $simpleMutation;

	/**
	 * @var ObjectType
	 */
	protected $simpleMutationWithDescription;

	/**
	 * @var ObjectType
	 */
	protected $simpleMutationWithDeprecationReason;

    /**
     * @var ObjectType
     */
    protected $simpleMutationWithThunkFields;

    /**
     * @var ObjectType
     */
    protected $mutation;

    /**
     * @var ObjectType
     */
    protected $edgeMutation;

    /**
     * @var Schema
     */
    protected $schema;

    public function setup(): void
    {
        $this->simpleMutation = Mutation::mutationWithClientMutationId([
            'name' => 'SimpleMutation',
            'inputFields' => [],
            'outputFields' => [
                'result' => [
                    'type' => Type::int()
                ]
            ],
            'mutateAndGetPayload' => function () {
                return ['result' => 1];
            }
        ]);

	    $this->simpleMutationWithDescription = Mutation::mutationWithClientMutationId([
		    'name' => 'SimpleMutationWithDescription',
		    'description' => 'Simple Mutation Description',
		    'inputFields' => [],
		    'outputFields' => [
			    'result' => [
				    'type' => Type::int()
			    ]
		    ],
		    'mutateAndGetPayload' => function () {
			    return ['result' => 1];
		    }
	    ]);

	    $this->simpleMutationWithDeprecationReason = Mutation::mutationWithClientMutationId([
		    'name' => 'SimpleMutationWithDeprecationReason',
		    'inputFields' => [],
		    'outputFields' => [
			    'result' => [
				    'type' => Type::int()
			    ]
		    ],
		    'mutateAndGetPayload' => function () {
			    return ['result' => 1];
		    },
		    'deprecationReason' => 'Just because'
	    ]);

        $this->simpleMutationWithThunkFields = Mutation::mutationWithClientMutationId([
            'name' => 'SimpleMutationWithThunkFields',
            'inputFields' => function() {
                return [
                    'inputData' => [
                        'type' => Type::int()
                    ]
                ];
            },
            'outputFields' => function() {
                return [
                    'result' => [
                        'type' => Type::int()
                    ]
                ];
            },
            'mutateAndGetPayload' => function($inputData) {
                return [
                    'result' => $inputData['inputData']
                ];
            }
        ]);

        $userType = new ObjectType([
           'name' => 'User',
            'fields' => [
                'name' => [
                    'type' => Type::string()
                ]
            ]
        ]);

        $this->edgeMutation = Mutation::mutationWithClientMutationId([
            'name' => 'EdgeMutation',
            'inputFields' => [],
            'outputFields' => [
                'result' => [
                    'type' => Connection::createEdgeType(['nodeType' => $userType ])
                ]
            ],
            'mutateAndGetPayload' => function () {
                return ['result' => ['node' => ['name' => 'Robert'], 'cursor' => 'SWxvdmVHcmFwaFFM']];
            }
        ]);

        $this->mutation = new ObjectType([
            'name' => 'Mutation',
            'fields' => [
                'simpleMutation' => $this->simpleMutation,
	            'simpleMutationWithDescription' => $this->simpleMutationWithDescription,
	            'simpleMutationWithDeprecationReason' => $this->simpleMutationWithDeprecationReason,
                'simpleMutationWithThunkFields' => $this->simpleMutationWithThunkFields,
                'edgeMutation' => $this->edgeMutation
            ]
        ]);

        $this->schema = new Schema([
            'mutation' => $this->mutation,
            'query' => $this->mutation
        ]);
    }

    public function testRequiresAnArgument() {
        $query = 'mutation M {
            simpleMutation {
              result
            }
          }';

        $result = GraphQL::executeQuery($this->schema, $query)->toArray();

        $this->assertEquals(count($result['errors']), 1);
        $this->assertEquals($result['errors'][0]['message'], 'Field "simpleMutation" argument "input" of type "SimpleMutationInput!" is required but not provided.');
    }

    public function testReturnsTheSameClientMutationID()
    {
        $query = 'mutation M {
            simpleMutation(input: {clientMutationId: "abc"}) {
              result
              clientMutationId
            }
          }';

        $expected = [
            'simpleMutation' => [
                'result' => 1,
                'clientMutationId' => 'abc'
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    public function testReturnsNullWithOmittedClientMutationID()
    {
        $query = 'mutation M {
            simpleMutation(input: {}) {
              result
              clientMutationId
            }
          }';

        $expected = [
            'simpleMutation' => [
                'result' => 1,
                'clientMutationId' => null
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    public function testSupportsEdgeAsOutputField()
    {
        $query = 'mutation M {
            edgeMutation(input: {clientMutationId: "abc"}) {
              result {
                  node {
                      name
                  }
                  cursor
              }
              clientMutationId
            }
          }';

        $expected = [
            'edgeMutation' => [
                'result' => [
                    'node' => ['name' => 'Robert'],
                    'cursor' => 'SWxvdmVHcmFwaFFM'
                ],
                'clientMutationId' => 'abc'
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    public function testIntrospection()
    {
        $query = '{
            __type(name: "SimpleMutationInput") {
              name
              kind
              inputFields {
                name
                type {
                  name
                  kind
                  ofType {
                    name
                    kind
                  }
                }
              }
            }
          }';

        $expected = [
            '__type' => [
                'name' => 'SimpleMutationInput',
                'kind' => 'INPUT_OBJECT',
                'inputFields' => [
                    [
                        'name' => 'clientMutationId',
                        'type' => [
                            'name' => 'String',
                            'kind' => 'SCALAR',
                            'ofType' => null
                        ]
                    ]
                ]
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    public function testContainsCorrectPayload() {
        $query = '{
            __type(name: "SimpleMutationPayload") {
              name
              kind
              fields {
                name
                type {
                  name
                  kind
                  ofType {
                    name
                    kind
                  }
                }
              }
            }
          }';

        $expected = [
            '__type' => [
                'name' => 'SimpleMutationPayload',
                'kind' => 'OBJECT',
                'fields' => [
                    [
                        'name' => 'result',
                        'type' => [
                            'name' => 'Int',
                            'kind' => 'SCALAR',
                            'ofType' => null
                        ]
                    ],
                    [
                        'name' => 'clientMutationId',
                        'type' => [
                            'name' => 'String',
                            'kind' => 'SCALAR',
                            'ofType' => null
                        ]
                    ]
                ]
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    public function testContainsCorrectField()
    {
        $query = '{
            __schema {
              mutationType {
                fields {
                  name
                  args {
                    name
                    type {
                      name
                      kind
                      ofType {
                        name
                        kind
                      }
                    }
                  }
                  type {
                    name
                    kind
                  }
                }
              }
            }
          }';

        $expected = [
            '__schema' => [
                'mutationType' => [
                    'fields' => [
                        [
                            'name' => 'simpleMutation',
                            'args' => [
                                [
                                    'name' => 'input',
                                    'type' => [
                                        'name' => null,
                                        'kind' => 'NON_NULL',
                                        'ofType' => [
                                            'name' => 'SimpleMutationInput',
                                            'kind' => 'INPUT_OBJECT'
                                        ]
                                    ],
                                ]
                            ],
                            'type' => [
                                'name' => 'SimpleMutationPayload',
                                'kind' => 'OBJECT',
                            ]
                        ],
	                    [
		                    'name' => 'simpleMutationWithDescription',
		                    'args' => [
			                    [
				                    'name' => 'input',
				                    'type' => [
					                    'name' => null,
					                    'kind' => 'NON_NULL',
					                    'ofType' => [
						                    'name' => 'SimpleMutationWithDescriptionInput',
						                    'kind' => 'INPUT_OBJECT'
					                    ]
				                    ],
			                    ]
		                    ],
		                    'type' => [
			                    'name' => 'SimpleMutationWithDescriptionPayload',
			                    'kind' => 'OBJECT',
		                    ]
	                    ],
                        [
                            'name' => 'simpleMutationWithThunkFields',
                            'args' => [
                                [
                                    'name' => 'input',
                                    'type' => [
                                        'name' => null,
                                        'kind' => 'NON_NULL',
                                        'ofType' => [
                                            'name' => 'SimpleMutationWithThunkFieldsInput',
                                            'kind' => 'INPUT_OBJECT'
                                        ]
                                    ],
                                ]
                            ],
                            'type' => [
                                'name' => 'SimpleMutationWithThunkFieldsPayload',
                                'kind' => 'OBJECT',
                            ]
                        ],
                        [
                            'name' => 'edgeMutation',
                            'args' => [
                                [
                                    'name' => 'input',
                                    'type' => [
                                        'name' => null,
                                        'kind' => 'NON_NULL',
                                        'ofType' => [
                                            'name' => 'EdgeMutationInput',
                                            'kind' => 'INPUT_OBJECT'
                                        ]
                                    ],
                                ]
                            ],
                            'type' => [
                                'name' => 'EdgeMutationPayload',
                                'kind' => 'OBJECT',
                            ]
                        ],
                        /*
                         * Promises not implemented right now
                        [
                            'name' => 'simplePromiseMutation',
                            'args' => [
                                [
                                    'name' => 'input',
                                    'type' => [
                                        'name' => null,
                                        'kind' => 'NON_NULL',
                                        'ofType' => [
                                            'name' => 'SimplePromiseMutationInput',
                                            'kind' => 'INPUT_OBJECT'
                                        ]
                                    ],
                                ]
                            ],
                            'type' => [
                                'name' => 'SimplePromiseMutationPayload',
                                'kind' => 'OBJECT',
                            ]
                        ]*/
                    ]
                ]
            ]
        ];

        $result = GraphQL::executeQuery($this->schema, $query)->toArray();

        $this->assertValidQuery($query, $expected);
    }

	public function testContainsCorrectDescriptions() {
		$query = '{
	        __schema {
	          mutationType {
	            fields {
	              name
	              description
	            }
	          }
	        }
	      }';

		$expected = [
			'__schema' => [
				'mutationType' => [
					'fields' => [
						[
							'name' => 'simpleMutation',
							'description' => null
						],
						[
							'name' => 'simpleMutationWithDescription',
							'description' => 'Simple Mutation Description'
						],
						[
							'name' => 'simpleMutationWithThunkFields',
							'description' => null
						],
						[
							'name' => 'edgeMutation',
							'description' => null
						]
					]
				]
			]
		];

		$this->assertValidQuery($query, $expected);
	}

	public function testContainsCorrectDeprecationReasons() {
		$query = '{
	        __schema {
	          mutationType {
	            fields(includeDeprecated: true) {
	              name
	              isDeprecated
	              deprecationReason
	            }
	          }
	        }
	      }';

		$expected = [
			'__schema' => [
				'mutationType' => [
					'fields' => [
						[
							'name' => 'simpleMutation',
							'isDeprecated' => false,
							'deprecationReason' => null
						],
						[
							'name' => 'simpleMutationWithDescription',
							'isDeprecated' => false,
							'deprecationReason' => null
						],
						[
							'name' => 'simpleMutationWithDeprecationReason',
							'isDeprecated' => true,
							'deprecationReason' => 'Just because',
						],
						[
							'name' => 'simpleMutationWithThunkFields',
							'isDeprecated' => false,
							'deprecationReason' => null
						],
						[
							'name' => 'edgeMutation',
							'isDeprecated' => false,
							'deprecationReason' => null
						]
					]
				]
			]
		];

		$this->assertValidQuery($query, $expected);
	}

    /**
     * Helper function to test a query and the expected response.
     */
    protected function assertValidQuery($query, $expected)
    {
        $this->assertEquals(['data' => $expected], GraphQL::executeQuery($this->schema, $query)->toArray());
    }
}


// File: wp-graphql\vendor\ivome\graphql-relay-php\tests\Node\NodeTest.php
<?php
/**
 * @author: Ivo Meißner
 * Date: 22.02.16
 * Time: 13:14
 */

namespace GraphQLRelay\Tests\Node;


use GraphQL\GraphQL;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\ResolveInfo;
use GraphQL\Type\Schema;
use GraphQL\Type\Definition\Type;
use GraphQLRelay\Node\Node;
use PHPUnit\Framework\TestCase;


class NodeTest extends TestCase {
    /**
     * Node definition, so that it is only created once
     *
     * @var array
     */
    protected static $nodeDefinition;

    /**
     * @var ObjectType
     */
    protected static $userType;

    /**
     * @var ObjectType
     */
    protected static $photoType;

    public function testGetsCorrectIDForUsers() {
        $query = '{
            node(id: "1") {
              id
            }
          }';

        $expected = [
            'node' => [
                'id' => 1
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    public function testGetsCorrectIDForPhotos() {
        $query = '{
            node(id: "4") {
            id
            }
          }';

        $expected = [
            'node' => [
                'id' => 4
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    public function testGetsCorrectNameForUsers() {
        $query = '{
            node(id: "1") {
              id
              ... on User {
                name
              }
            }
          }';

        $expected = [
            'node' => [
                'id' => '1',
                'name' => 'John Doe'
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    public function testGetsCorrectWidthForPhotos() {
        $query = '{
            node(id: "4") {
              id
              ... on Photo {
                width
              }
            }
          }';

        $expected = [
            'node' => [
                'id' => '4',
                'width' => 400
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    public function testGetsCorrectTypeNameForUsers() {
        $query = '{
            node(id: "1") {
              id
              __typename
            }
          }';

        $expected = [
            'node' => [
                'id' => '1',
                '__typename' => 'User'
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    public function testCorrectWidthForPhotos() {
        $query = '{
            node(id: "4") {
              id
              __typename
            }
          }';

        $expected = [
            'node' => [
                'id' => '4',
                '__typename' => 'Photo'
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    public function testIgnoresPhotoFragmentsOnUser() {
        $query = '{
        node(id: "1") {
          id
          ... on Photo {
            width
          }
        }
      }';
        $expected = [
            'node' => [
                'id' => '1'
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    public function testReturnsNullForBadIDs() {
        $query = '{
            node(id: "5") {
              id
            }
          }';

        $expected = [
            'node' => null
        ];

        $this->assertValidQuery($query, $expected);
    }

    public function testHasCorrectNodeInterface() {
        $query = '{
            __type(name: "Node") {
              name
              kind
              fields {
                name
                type {
                  kind
                  ofType {
                    name
                    kind
                  }
                }
              }
            }
          }';

        $expected = [
            '__type' => [
                'name' => 'Node',
                'kind' => 'INTERFACE',
                'fields' => [
                    [
                        'name' => 'id',
                        'type' => [
                            'kind' => 'NON_NULL',
                            'ofType' => [
                                'name' => 'ID',
                                'kind' => 'SCALAR'
                            ]
                        ]
                    ]
                ]
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    public function testHasCorrectNodeRootField() {
        $query = '{
            __schema {
              queryType {
                fields {
                  name
                  type {
                    name
                    kind
                  }
                  args {
                    name
                    type {
                      kind
                      ofType {
                        name
                        kind
                      }
                    }
                  }
                }
              }
            }
          }';

        $expected = [
            '__schema' => [
                'queryType' => [
                    'fields' => [
                        [
                            'name' => 'node',
                            'type' => [
                                'name' => 'Node',
                                'kind' => 'INTERFACE'
                            ],
                            'args' => [
                                [
                                    'name' => 'id',
                                    'type' => [
                                        'kind' => 'NON_NULL',
                                        'ofType' => [
                                            'name' => 'ID',
                                            'kind' => 'SCALAR'
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ]
                ]
            ]
        ];

        $this->assertValidQuery($query, $expected);
    }

    /**
     * Returns test schema
     *
     * @return Schema
     */
    protected function getSchema() {
        return new Schema([
            'query' => $this->getQueryType(),

            // We have to pass the types here manually because graphql-php cannot
            // recognize types that are only available through interfaces
            // https://github.com/webonyx/graphql-php/issues/38
            'types' => [
                self::$userType,
                self::$photoType
            ]
        ]);
    }

    /**
     * Returns test query type
     *
     * @return ObjectType
     */
    protected function getQueryType() {
        $nodeField = $this->getNodeDefinitions();
        return new ObjectType([
            'name' => 'Query',
            'fields' => [
                'node' => $nodeField['nodeField']
            ]
        ]);
    }

    /**
     * Returns node definitions
     *
     * @return array
     */
    protected function getNodeDefinitions() {
        if (!self::$nodeDefinition){
            self::$nodeDefinition = Node::nodeDefinitions(
                function($id, $context, ResolveInfo $info) {
                    $userData = $this->getUserData();
                    if (array_key_exists($id, $userData)){
                        return $userData[$id];
                    } else {
                        $photoData = $this->getPhotoData();
                        if (array_key_exists($id, $photoData)){
                            return $photoData[$id];
                        }
                    }
                },
                function($obj) {
                    if (array_key_exists($obj['id'], $this->getUserData())){
                        return self::$userType;
                    } else {
                        return self::$photoType;
                    }
                }
            );

            self::$userType = new ObjectType([
                'name' => 'User',
                'fields' => [
                    'id' => [
                        'type' => Type::nonNull(Type::id()),
                    ],
                    'name' => [
                        'type' => Type::string()
                    ]
                ],
                'interfaces' => [self::$nodeDefinition['nodeInterface']]
            ]);

            self::$photoType = new ObjectType([
                'name' => 'Photo',
                'fields' => [
                    'id' => [
                        'type' => Type::nonNull(Type::id())
                    ],
                    'width' => [
                        'type' => Type::int()
                    ]
                ],
                'interfaces' => [self::$nodeDefinition['nodeInterface']]
            ]);
        }
        return self::$nodeDefinition;
    }

    /**
     * Returns photo data
     *
     * @return array
     */
    protected function getPhotoData() {
        return  [
            '3' => [
                'id' => 3,
                'width' => 300
            ],
            '4' => [
                'id' => 4,
                'width' => 400
            ]
        ];
    }

    /**
     * Returns user data
     *
     * @return array
     */
    protected function getUserData() {
        return [
            '1' => [
                'id' => 1,
                'name' => 'John Doe'
            ],
            '2' => [
                'id' => 2,
                'name' => 'Jane Smith'
            ]
        ];
    }
    
    /**
     * Helper function to test a query and the expected response.
     */
    private function assertValidQuery($query, $expected)
    {
        $result = GraphQL::executeQuery($this->getSchema(), $query)->toArray();

        $this->assertEquals(['data' => $expected], $result);
    }

}

// File: wp-graphql\vendor\ivome\graphql-relay-php\tests\Node\PluralTest.php
<?php
/**
 * @author: Ivo Meißner
 * Date: 29.02.16
 * Time: 16:35
 */

namespace GraphQLRelay\tests\Node;


use GraphQL\GraphQL;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Schema;
use GraphQLRelay\Node\Plural;
use PHPUnit\Framework\TestCase;

class PluralTest extends TestCase {
    protected static function getSchema()
    {
        $userType = new ObjectType([
            'name' => 'User',
            'fields' => function() {
                return [
                    'username' => [
                        'type' => Type::string()
                    ],
                    'url' => [
                        'type' => Type::string()
                    ]
                ];
            }
        ]);

        $queryType = new ObjectType([
            'name' => 'Query',
            'fields' => function() use ($userType) {
                return [
                    'usernames' => Plural::pluralIdentifyingRootField([
                        'argName' => 'usernames',
                        'description' => 'Map from a username to the user',
                        'inputType' => Type::string(),
                        'outputType' => $userType,
                        'resolveSingleInput' => function ($userName, $context, $info) {
                            return [
                                'username' => $userName,
                                'url' => 'www.facebook.com/' . $userName . '?lang=' . $info->rootValue['lang']
                            ];
                        }
                    ])
                ];
            }
        ]);

        return new Schema([
            'query' => $queryType
        ]);
    }

    public function testAllowsFetching() {
        $query = '{
          usernames(usernames:["dschafer", "leebyron", "schrockn"]) {
            username
            url
          }
        }';

        $expected = array (
            'usernames' =>
                array (
                    0 =>
                        array (
                            'username' => 'dschafer',
                            'url' => 'www.facebook.com/dschafer?lang=en',
                        ),
                    1 =>
                        array (
                            'username' => 'leebyron',
                            'url' => 'www.facebook.com/leebyron?lang=en',
                        ),
                    2 =>
                        array (
                            'username' => 'schrockn',
                            'url' => 'www.facebook.com/schrockn?lang=en',
                        ),
                ),
        );

        $this->assertValidQuery($query, $expected);
    }

    public function testCorrectlyIntrospects()
    {
        $query = '{
          __schema {
            queryType {
              fields {
                name
                args {
                  name
                  type {
                    kind
                    ofType {
                      kind
                      ofType {
                        kind
                        ofType {
                          name
                          kind
                        }
                      }
                    }
                  }
                }
                type {
                  kind
                  ofType {
                    name
                    kind
                  }
                }
              }
            }
          }
        }';
        $expected = array (
            '__schema' =>
                array (
                    'queryType' =>
                        array (
                            'fields' =>
                                array (
                                    0 =>
                                        array (
                                            'name' => 'usernames',
                                            'args' =>
                                                array (
                                                    0 =>
                                                        array (
                                                            'name' => 'usernames',
                                                            'type' =>
                                                                array (
                                                                    'kind' => 'NON_NULL',
                                                                    'ofType' =>
                                                                        array (
                                                                            'kind' => 'LIST',
                                                                            'ofType' =>
                                                                                array (
                                                                                    'kind' => 'NON_NULL',
                                                                                    'ofType' =>
                                                                                        array (
                                                                                            'name' => 'String',
                                                                                            'kind' => 'SCALAR',
                                                                                        ),
                                                                                ),
                                                                        ),
                                                                ),
                                                        ),
                                                ),
                                            'type' =>
                                                array (
                                                    'kind' => 'LIST',
                                                    'ofType' =>
                                                        array (
                                                            'name' => 'User',
                                                            'kind' => 'OBJECT',
                                                        ),
                                                ),
                                        ),
                                ),
                        ),
                ),
        );

        $this->assertValidQuery($query, $expected);
    }

    /**
     * Helper function to test a query and the expected response.
     */
    private function assertValidQuery($query, $expected)
    {
        $result = GraphQL::executeQuery($this->getSchema(), $query, ['lang' => 'en'])->toArray();
        $this->assertEquals(['data' => $expected], $result);
    }
}

// File: wp-graphql\vendor\webonyx\graphql-php\src\Deferred.php
<?php

declare(strict_types=1);

namespace GraphQL;

use GraphQL\Executor\Promise\Adapter\SyncPromise;

class Deferred extends SyncPromise
{
    /**
     * @param callable() : mixed $executor
     */
    public static function create(callable $executor) : self
    {
        return new self($executor);
    }

    /**
     * @param callable() : mixed $executor
     */
    public function __construct(callable $executor)
    {
        parent::__construct($executor);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\GraphQL.php
<?php

declare(strict_types=1);

namespace GraphQL;

use GraphQL\Error\Error;
use GraphQL\Executor\ExecutionResult;
use GraphQL\Executor\Executor;
use GraphQL\Executor\Promise\Adapter\SyncPromiseAdapter;
use GraphQL\Executor\Promise\Promise;
use GraphQL\Executor\Promise\PromiseAdapter;
use GraphQL\Executor\ReferenceExecutor;
use GraphQL\Experimental\Executor\CoroutineExecutor;
use GraphQL\Language\AST\DocumentNode;
use GraphQL\Language\Parser;
use GraphQL\Language\Source;
use GraphQL\Type\Definition\Directive;
use GraphQL\Type\Definition\ScalarType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Schema as SchemaType;
use GraphQL\Validator\DocumentValidator;
use GraphQL\Validator\Rules\QueryComplexity;
use GraphQL\Validator\Rules\ValidationRule;
use function array_values;
use function count;
use function trigger_error;
use const E_USER_DEPRECATED;

/**
 * This is the primary facade for fulfilling GraphQL operations.
 * See [related documentation](executing-queries.md).
 */
class GraphQL
{
    /**
     * Executes graphql query.
     *
     * More sophisticated GraphQL servers, such as those which persist queries,
     * may wish to separate the validation and execution phases to a static time
     * tooling step, and a server runtime step.
     *
     * Available options:
     *
     * schema:
     *    The GraphQL type system to use when validating and executing a query.
     * source:
     *    A GraphQL language formatted string representing the requested operation.
     * rootValue:
     *    The value provided as the first argument to resolver functions on the top
     *    level type (e.g. the query object type).
     * contextValue:
     *    The context value is provided as an argument to resolver functions after
     *    field arguments. It is used to pass shared information useful at any point
     *    during executing this query, for example the currently logged in user and
     *    connections to databases or other services.
     * variableValues:
     *    A mapping of variable name to runtime value to use for all variables
     *    defined in the requestString.
     * operationName:
     *    The name of the operation to use if requestString contains multiple
     *    possible operations. Can be omitted if requestString contains only
     *    one operation.
     * fieldResolver:
     *    A resolver function to use when one is not provided by the schema.
     *    If not provided, the default field resolver is used (which looks for a
     *    value on the source value with the field's name).
     * validationRules:
     *    A set of rules for query validation step. Default value is all available rules.
     *    Empty array would allow to skip query validation (may be convenient for persisted
     *    queries which are validated before persisting and assumed valid during execution)
     *
     * @param string|DocumentNode $source
     * @param mixed               $rootValue
     * @param mixed               $contextValue
     * @param mixed[]|null        $variableValues
     * @param ValidationRule[]    $validationRules
     *
     * @api
     */
    public static function executeQuery(
        SchemaType $schema,
        $source,
        $rootValue = null,
        $contextValue = null,
        $variableValues = null,
        ?string $operationName = null,
        ?callable $fieldResolver = null,
        ?array $validationRules = null
    ) : ExecutionResult {
        $promiseAdapter = new SyncPromiseAdapter();

        $promise = self::promiseToExecute(
            $promiseAdapter,
            $schema,
            $source,
            $rootValue,
            $contextValue,
            $variableValues,
            $operationName,
            $fieldResolver,
            $validationRules
        );

        return $promiseAdapter->wait($promise);
    }

    /**
     * Same as executeQuery(), but requires PromiseAdapter and always returns a Promise.
     * Useful for Async PHP platforms.
     *
     * @param string|DocumentNode   $source
     * @param mixed                 $rootValue
     * @param mixed                 $context
     * @param mixed[]|null          $variableValues
     * @param ValidationRule[]|null $validationRules
     *
     * @api
     */
    public static function promiseToExecute(
        PromiseAdapter $promiseAdapter,
        SchemaType $schema,
        $source,
        $rootValue = null,
        $context = null,
        $variableValues = null,
        ?string $operationName = null,
        ?callable $fieldResolver = null,
        ?array $validationRules = null
    ) : Promise {
        try {
            if ($source instanceof DocumentNode) {
                $documentNode = $source;
            } else {
                $documentNode = Parser::parse(new Source($source ?? '', 'GraphQL'));
            }

            // FIXME
            if (count($validationRules ?? []) === 0) {
                /** @var QueryComplexity $queryComplexity */
                $queryComplexity = DocumentValidator::getRule(QueryComplexity::class);
                $queryComplexity->setRawVariableValues($variableValues);
            } else {
                foreach ($validationRules as $rule) {
                    if (! ($rule instanceof QueryComplexity)) {
                        continue;
                    }

                    $rule->setRawVariableValues($variableValues);
                }
            }

            $validationErrors = DocumentValidator::validate($schema, $documentNode, $validationRules);

            if (count($validationErrors) > 0) {
                return $promiseAdapter->createFulfilled(
                    new ExecutionResult(null, $validationErrors)
                );
            }

            return Executor::promiseToExecute(
                $promiseAdapter,
                $schema,
                $documentNode,
                $rootValue,
                $context,
                $variableValues,
                $operationName,
                $fieldResolver
            );
        } catch (Error $e) {
            return $promiseAdapter->createFulfilled(
                new ExecutionResult(null, [$e])
            );
        }
    }

    /**
     * @deprecated Use executeQuery()->toArray() instead
     *
     * @param string|DocumentNode $source
     * @param mixed               $rootValue
     * @param mixed               $contextValue
     * @param mixed[]|null        $variableValues
     *
     * @return Promise|mixed[]
     *
     * @codeCoverageIgnore
     */
    public static function execute(
        SchemaType $schema,
        $source,
        $rootValue = null,
        $contextValue = null,
        $variableValues = null,
        ?string $operationName = null
    ) {
        trigger_error(
            __METHOD__ . ' is deprecated, use GraphQL::executeQuery()->toArray() as a quick replacement',
            E_USER_DEPRECATED
        );

        $promiseAdapter = Executor::getPromiseAdapter();
        $result         = self::promiseToExecute(
            $promiseAdapter,
            $schema,
            $source,
            $rootValue,
            $contextValue,
            $variableValues,
            $operationName
        );

        if ($promiseAdapter instanceof SyncPromiseAdapter) {
            $result = $promiseAdapter->wait($result)->toArray();
        } else {
            $result = $result->then(static function (ExecutionResult $r) : array {
                return $r->toArray();
            });
        }

        return $result;
    }

    /**
     * @deprecated renamed to executeQuery()
     *
     * @param string|DocumentNode $source
     * @param mixed               $rootValue
     * @param mixed               $contextValue
     * @param mixed[]|null        $variableValues
     *
     * @return ExecutionResult|Promise
     *
     * @codeCoverageIgnore
     */
    public static function executeAndReturnResult(
        SchemaType $schema,
        $source,
        $rootValue = null,
        $contextValue = null,
        $variableValues = null,
        ?string $operationName = null
    ) {
        trigger_error(
            __METHOD__ . ' is deprecated, use GraphQL::executeQuery() as a quick replacement',
            E_USER_DEPRECATED
        );

        $promiseAdapter = Executor::getPromiseAdapter();
        $result         = self::promiseToExecute(
            $promiseAdapter,
            $schema,
            $source,
            $rootValue,
            $contextValue,
            $variableValues,
            $operationName
        );

        if ($promiseAdapter instanceof SyncPromiseAdapter) {
            $result = $promiseAdapter->wait($result);
        }

        return $result;
    }

    /**
     * Returns directives defined in GraphQL spec
     *
     * @return Directive[]
     *
     * @api
     */
    public static function getStandardDirectives() : array
    {
        return array_values(Directive::getInternalDirectives());
    }

    /**
     * Returns types defined in GraphQL spec
     *
     * @return Type[]
     *
     * @api
     */
    public static function getStandardTypes() : array
    {
        return array_values(Type::getStandardTypes());
    }

    /**
     * Replaces standard types with types from this list (matching by name)
     * Standard types not listed here remain untouched.
     *
     * @param array<string, ScalarType> $types
     *
     * @api
     */
    public static function overrideStandardTypes(array $types)
    {
        Type::overrideStandardTypes($types);
    }

    /**
     * Returns standard validation rules implementing GraphQL spec
     *
     * @return ValidationRule[]
     *
     * @api
     */
    public static function getStandardValidationRules() : array
    {
        return array_values(DocumentValidator::defaultRules());
    }

    /**
     * Set default resolver implementation
     *
     * @api
     */
    public static function setDefaultFieldResolver(callable $fn) : void
    {
        Executor::setDefaultFieldResolver($fn);
    }

    public static function setPromiseAdapter(?PromiseAdapter $promiseAdapter = null) : void
    {
        Executor::setPromiseAdapter($promiseAdapter);
    }

    /**
     * Experimental: Switch to the new executor
     */
    public static function useExperimentalExecutor()
    {
        trigger_error(
            'Experimental Executor is deprecated and will be removed in the next major version',
            E_USER_DEPRECATED
        );
        Executor::setImplementationFactory([CoroutineExecutor::class, 'create']);
    }

    /**
     * Experimental: Switch back to the default executor
     */
    public static function useReferenceExecutor()
    {
        Executor::setImplementationFactory([ReferenceExecutor::class, 'create']);
    }

    /**
     * Returns directives defined in GraphQL spec
     *
     * @deprecated Renamed to getStandardDirectives
     *
     * @return Directive[]
     *
     * @codeCoverageIgnore
     */
    public static function getInternalDirectives() : array
    {
        return self::getStandardDirectives();
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Error\ClientAware.php
<?php

declare(strict_types=1);

namespace GraphQL\Error;

/**
 * This interface is used for [default error formatting](error-handling.md).
 *
 * Only errors implementing this interface (and returning true from `isClientSafe()`)
 * will be formatted with original error message.
 *
 * All other errors will be formatted with generic "Internal server error".
 */
interface ClientAware
{
    /**
     * Returns true when exception message is safe to be displayed to a client.
     *
     * @return bool
     *
     * @api
     */
    public function isClientSafe();

    /**
     * Returns string describing a category of the error.
     *
     * Value "graphql" is reserved for errors produced by query parsing or validation, do not use it.
     *
     * @return string
     *
     * @api
     */
    public function getCategory();
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Error\DebugFlag.php
<?php

declare(strict_types=1);

namespace GraphQL\Error;

/**
 * Collection of flags for [error debugging](error-handling.md#debugging-tools).
 */
final class DebugFlag
{
    public const NONE                        = 0;
    public const INCLUDE_DEBUG_MESSAGE       = 1;
    public const INCLUDE_TRACE               = 2;
    public const RETHROW_INTERNAL_EXCEPTIONS = 4;
    public const RETHROW_UNSAFE_EXCEPTIONS   = 8;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Error\Error.php
<?php

declare(strict_types=1);

namespace GraphQL\Error;

use Exception;
use GraphQL\Language\AST\Node;
use GraphQL\Language\Source;
use GraphQL\Language\SourceLocation;
use GraphQL\Utils\Utils;
use JsonSerializable;
use ReturnTypeWillChange;
use Throwable;
use Traversable;
use function array_filter;
use function array_map;
use function array_values;
use function count;
use function is_array;
use function iterator_to_array;

/**
 * Describes an Error found during the parse, validate, or
 * execute phases of performing a GraphQL operation. In addition to a message
 * and stack trace, it also includes information about the locations in a
 * GraphQL document and/or execution result that correspond to the Error.
 *
 * When the error was caused by an exception thrown in resolver, original exception
 * is available via `getPrevious()`.
 *
 * Also read related docs on [error handling](error-handling.md)
 *
 * Class extends standard PHP `\Exception`, so all standard methods of base `\Exception` class
 * are available in addition to those listed below.
 */
class Error extends Exception implements JsonSerializable, ClientAware
{
    const CATEGORY_GRAPHQL  = 'graphql';
    const CATEGORY_INTERNAL = 'internal';

    /**
     * Lazily initialized.
     *
     * @var SourceLocation[]
     */
    private $locations;

    /**
     * An array describing the JSON-path into the execution response which
     * corresponds to this error. Only included for errors during execution.
     *
     * @var mixed[]|null
     */
    public $path;

    /**
     * An array of GraphQL AST Nodes corresponding to this error.
     *
     * @var Node[]|null
     */
    public $nodes;

    /**
     * The source GraphQL document for the first location of this error.
     *
     * Note that if this Error represents more than one node, the source may not
     * represent nodes after the first node.
     *
     * @var Source|null
     */
    private $source;

    /** @var int[] */
    private $positions;

    /** @var bool */
    private $isClientSafe;

    /** @var string */
    protected $category;

    /** @var mixed[]|null */
    protected $extensions;

    /**
     * @param string                       $message
     * @param Node|Node[]|Traversable|null $nodes
     * @param mixed[]                      $positions
     * @param mixed[]|null                 $path
     * @param Throwable                    $previous
     * @param mixed[]                      $extensions
     */
    public function __construct(
        $message = '',
        $nodes = null,
        ?Source $source = null,
        array $positions = [],
        $path = null,
        $previous = null,
        array $extensions = []
    ) {
        parent::__construct($message, 0, $previous);

        // Compute list of blame nodes.
        if ($nodes instanceof Traversable) {
            $nodes = iterator_to_array($nodes);
        } elseif ($nodes !== null && ! is_array($nodes)) {
            $nodes = [$nodes];
        }

        $this->nodes      = $nodes;
        $this->source     = $source;
        $this->positions  = $positions;
        $this->path       = $path;
        $this->extensions = count($extensions) > 0 ? $extensions : (
        $previous instanceof self
            ? $previous->extensions
            : []
        );

        if ($previous instanceof ClientAware) {
            $this->isClientSafe = $previous->isClientSafe();
            $cat                = $previous->getCategory();
            $this->category     = $cat === '' || $cat === null  ? self::CATEGORY_INTERNAL: $cat;
        } elseif ($previous !== null) {
            $this->isClientSafe = false;
            $this->category     = self::CATEGORY_INTERNAL;
        } else {
            $this->isClientSafe = true;
            $this->category     = self::CATEGORY_GRAPHQL;
        }
    }

    /**
     * Given an arbitrary Error, presumably thrown while attempting to execute a
     * GraphQL operation, produce a new GraphQLError aware of the location in the
     * document responsible for the original Error.
     *
     * @param mixed        $error
     * @param Node[]|null  $nodes
     * @param mixed[]|null $path
     *
     * @return Error
     */
    public static function createLocatedError($error, $nodes = null, $path = null)
    {
        if ($error instanceof self) {
            if ($error->path !== null && $error->nodes !== null && count($error->nodes) !== 0) {
                return $error;
            }

            $nodes = $nodes ?? $error->nodes;
            $path  = $path ?? $error->path;
        }

        $source        = null;
        $originalError = null;
        $positions     = [];
        $extensions    = [];

        if ($error instanceof self) {
            $message       = $error->getMessage();
            $originalError = $error;
            $nodes         = $error->nodes ?? $nodes;
            $source        = $error->source;
            $positions     = $error->positions;
            $extensions    = $error->extensions;
        } elseif ($error instanceof Throwable) {
            $message       = $error->getMessage();
            $originalError = $error;
        } else {
            $message = (string) $error;
        }

        return new static(
            $message === '' || $message === null ? 'An unknown error occurred.' : $message,
            $nodes,
            $source,
            $positions,
            $path,
            $originalError,
            $extensions
        );
    }

    /**
     * @return mixed[]
     */
    public static function formatError(Error $error)
    {
        return $error->toSerializableArray();
    }

    /**
     * @inheritdoc
     */
    public function isClientSafe()
    {
        return $this->isClientSafe;
    }

    /**
     * @inheritdoc
     */
    public function getCategory()
    {
        return $this->category;
    }

    public function getSource() : ?Source
    {
        if ($this->source === null) {
            if (isset($this->nodes[0]) && $this->nodes[0]->loc !== null) {
                $this->source = $this->nodes[0]->loc->source;
            }
        }

        return $this->source;
    }

    /**
     * @return int[]
     */
    public function getPositions() : array
    {
        if (count($this->positions) === 0 && count($this->nodes ?? []) > 0) {
            $positions = array_map(
                static function ($node) : ?int {
                    return isset($node->loc) ? $node->loc->start : null;
                },
                $this->nodes
            );

            $positions = array_filter(
                $positions,
                static function ($p) : bool {
                    return $p !== null;
                }
            );

            $this->positions = array_values($positions);
        }

        return $this->positions;
    }

    /**
     * An array of locations within the source GraphQL document which correspond to this error.
     *
     * Each entry has information about `line` and `column` within source GraphQL document:
     * $location->line;
     * $location->column;
     *
     * Errors during validation often contain multiple locations, for example to
     * point out to field mentioned in multiple fragments. Errors during execution include a
     * single location, the field which produced the error.
     *
     * @return SourceLocation[]
     *
     * @api
     */
    public function getLocations() : array
    {
        if (! isset($this->locations)) {
            $positions = $this->getPositions();
            $source    = $this->getSource();
            $nodes     = $this->nodes;

            if ($source !== null && count($positions) !== 0) {
                $this->locations = array_map(
                    static function ($pos) use ($source) : SourceLocation {
                        return $source->getLocation($pos);
                    },
                    $positions
                );
            } elseif ($nodes !== null && count($nodes) !== 0) {
                $locations       = array_filter(
                    array_map(
                        static function ($node) : ?SourceLocation {
                            if (isset($node->loc->source)) {
                                return $node->loc->source->getLocation($node->loc->start);
                            }

                            return null;
                        },
                        $nodes
                    )
                );
                $this->locations = array_values($locations);
            } else {
                $this->locations = [];
            }
        }

        return $this->locations;
    }

    /**
     * @return Node[]|null
     */
    public function getNodes()
    {
        return $this->nodes;
    }

    /**
     * Returns an array describing the path from the root value to the field which produced this error.
     * Only included for execution errors.
     *
     * @return mixed[]|null
     *
     * @api
     */
    public function getPath()
    {
        return $this->path;
    }

    /**
     * @return mixed[]
     */
    public function getExtensions()
    {
        return $this->extensions;
    }

    /**
     * Returns array representation of error suitable for serialization
     *
     * @deprecated Use FormattedError::createFromException() instead
     *
     * @return mixed[]
     *
     * @codeCoverageIgnore
     */
    public function toSerializableArray()
    {
        $arr = [
            'message' => $this->getMessage(),
        ];

        $locations = Utils::map(
            $this->getLocations(),
            static function (SourceLocation $loc) : array {
                return $loc->toSerializableArray();
            }
        );

        if (count($locations) > 0) {
            $arr['locations'] = $locations;
        }
        if (count($this->path ?? []) > 0) {
            $arr['path'] = $this->path;
        }
        if (count($this->extensions ?? []) > 0) {
            $arr['extensions'] = $this->extensions;
        }

        return $arr;
    }

    /**
     * Specify data which should be serialized to JSON
     *
     * @link http://php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed data which can be serialized by <b>json_encode</b>,
     * which is a value of any type other than a resource.
     */
    #[ReturnTypeWillChange]
    public function jsonSerialize()
    {
        return $this->toSerializableArray();
    }

    /**
     * @return string
     */
    public function __toString()
    {
        return FormattedError::printError($this);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Error\FormattedError.php
<?php

declare(strict_types=1);

namespace GraphQL\Error;

use Countable;
use ErrorException;
use GraphQL\Language\AST\Node;
use GraphQL\Language\Source;
use GraphQL\Language\SourceLocation;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Definition\WrappingType;
use GraphQL\Utils\Utils;
use Throwable;
use function addcslashes;
use function array_filter;
use function array_intersect_key;
use function array_map;
use function array_merge;
use function array_shift;
use function count;
use function get_class;
use function gettype;
use function implode;
use function is_array;
use function is_bool;
use function is_object;
use function is_scalar;
use function is_string;
use function mb_strlen;
use function preg_split;
use function sprintf;
use function str_repeat;
use function strlen;

/**
 * This class is used for [default error formatting](error-handling.md).
 * It converts PHP exceptions to [spec-compliant errors](https://facebook.github.io/graphql/#sec-Errors)
 * and provides tools for error debugging.
 */
class FormattedError
{
    /** @var string */
    private static $internalErrorMessage = 'Internal server error';

    /**
     * Set default error message for internal errors formatted using createFormattedError().
     * This value can be overridden by passing 3rd argument to `createFormattedError()`.
     *
     * @param string $msg
     *
     * @api
     */
    public static function setInternalErrorMessage($msg)
    {
        self::$internalErrorMessage = $msg;
    }

    /**
     * Prints a GraphQLError to a string, representing useful location information
     * about the error's position in the source.
     *
     * @return string
     */
    public static function printError(Error $error)
    {
        $printedLocations = [];
        if (count($error->nodes ?? []) !== 0) {
            /** @var Node $node */
            foreach ($error->nodes as $node) {
                if ($node->loc === null) {
                    continue;
                }

                if ($node->loc->source === null) {
                    continue;
                }

                $printedLocations[] = self::highlightSourceAtLocation(
                    $node->loc->source,
                    $node->loc->source->getLocation($node->loc->start)
                );
            }
        } elseif ($error->getSource() !== null && count($error->getLocations()) !== 0) {
            $source = $error->getSource();
            foreach (($error->getLocations() ?? []) as $location) {
                $printedLocations[] = self::highlightSourceAtLocation($source, $location);
            }
        }

        return count($printedLocations) === 0
            ? $error->getMessage()
            : implode("\n\n", array_merge([$error->getMessage()], $printedLocations)) . "\n";
    }

    /**
     * Render a helpful description of the location of the error in the GraphQL
     * Source document.
     *
     * @return string
     */
    private static function highlightSourceAtLocation(Source $source, SourceLocation $location)
    {
        $line          = $location->line;
        $lineOffset    = $source->locationOffset->line - 1;
        $columnOffset  = self::getColumnOffset($source, $location);
        $contextLine   = $line + $lineOffset;
        $contextColumn = $location->column + $columnOffset;
        $prevLineNum   = (string) ($contextLine - 1);
        $lineNum       = (string) $contextLine;
        $nextLineNum   = (string) ($contextLine + 1);
        $padLen        = strlen($nextLineNum);
        $lines         = preg_split('/\r\n|[\n\r]/', $source->body);

        $lines[0] = self::whitespace($source->locationOffset->column - 1) . $lines[0];

        $outputLines = [
            sprintf('%s (%s:%s)', $source->name, $contextLine, $contextColumn),
            $line >= 2 ? (self::lpad($padLen, $prevLineNum) . ': ' . $lines[$line - 2]) : null,
            self::lpad($padLen, $lineNum) . ': ' . $lines[$line - 1],
            self::whitespace(2 + $padLen + $contextColumn - 1) . '^',
            $line < count($lines) ? self::lpad($padLen, $nextLineNum) . ': ' . $lines[$line] : null,
        ];

        return implode("\n", array_filter($outputLines));
    }

    /**
     * @return int
     */
    private static function getColumnOffset(Source $source, SourceLocation $location)
    {
        return $location->line === 1 ? $source->locationOffset->column - 1 : 0;
    }

    /**
     * @param int $len
     *
     * @return string
     */
    private static function whitespace($len)
    {
        return str_repeat(' ', $len);
    }

    /**
     * @param int $len
     *
     * @return string
     */
    private static function lpad($len, $str)
    {
        return self::whitespace($len - mb_strlen($str)) . $str;
    }

    /**
     * Standard GraphQL error formatter. Converts any exception to array
     * conforming to GraphQL spec.
     *
     * This method only exposes exception message when exception implements ClientAware interface
     * (or when debug flags are passed).
     *
     * For a list of available debug flags @see \GraphQL\Error\DebugFlag constants.
     *
     * @param string $internalErrorMessage
     *
     * @return mixed[]
     *
     * @throws Throwable
     *
     * @api
     */
    public static function createFromException(Throwable $exception, int $debug = DebugFlag::NONE, $internalErrorMessage = null) : array
    {
        $internalErrorMessage = $internalErrorMessage ?? self::$internalErrorMessage;

        if ($exception instanceof ClientAware) {
            $formattedError = [
                'message'  => $exception->isClientSafe() ? $exception->getMessage() : $internalErrorMessage,
                'extensions' => [
                    'category' => $exception->getCategory(),
                ],
            ];
        } else {
            $formattedError = [
                'message'  => $internalErrorMessage,
                'extensions' => [
                    'category' => Error::CATEGORY_INTERNAL,
                ],
            ];
        }

        if ($exception instanceof Error) {
            $locations = Utils::map(
                $exception->getLocations(),
                static function (SourceLocation $loc) : array {
                    return $loc->toSerializableArray();
                }
            );
            if (count($locations) > 0) {
                $formattedError['locations'] = $locations;
            }

            if (count($exception->path ?? []) > 0) {
                $formattedError['path'] = $exception->path;
            }
            if (count($exception->getExtensions() ?? []) > 0) {
                $formattedError['extensions'] = $exception->getExtensions() + $formattedError['extensions'];
            }
        }

        if ($debug !== DebugFlag::NONE) {
            $formattedError = self::addDebugEntries($formattedError, $exception, $debug);
        }

        return $formattedError;
    }

    /**
     * Decorates spec-compliant $formattedError with debug entries according to $debug flags
     * (@see \GraphQL\Error\DebugFlag for available flags)
     *
     * @param mixed[] $formattedError
     *
     * @return mixed[]
     *
     * @throws Throwable
     */
    public static function addDebugEntries(array $formattedError, Throwable $e, int $debugFlag) : array
    {
        if ($debugFlag === DebugFlag::NONE) {
            return $formattedError;
        }

        if (( $debugFlag & DebugFlag::RETHROW_INTERNAL_EXCEPTIONS) !== 0) {
            if (! $e instanceof Error) {
                throw $e;
            }

            if ($e->getPrevious() !== null) {
                throw $e->getPrevious();
            }
        }

        $isUnsafe = ! $e instanceof ClientAware || ! $e->isClientSafe();

        if (($debugFlag & DebugFlag::RETHROW_UNSAFE_EXCEPTIONS) !== 0 && $isUnsafe && $e->getPrevious() !== null) {
            throw $e->getPrevious();
        }

        if (($debugFlag & DebugFlag::INCLUDE_DEBUG_MESSAGE) !== 0 && $isUnsafe) {
            // Displaying debugMessage as a first entry:
            $formattedError = ['debugMessage' => $e->getMessage()] + $formattedError;
        }

        if (($debugFlag & DebugFlag::INCLUDE_TRACE) !== 0) {
            if ($e instanceof ErrorException || $e instanceof \Error) {
                $formattedError += [
                    'file' => $e->getFile(),
                    'line' => $e->getLine(),
                ];
            }

            $isTrivial = $e instanceof Error && $e->getPrevious() === null;

            if (! $isTrivial) {
                $debugging               = $e->getPrevious() ?? $e;
                $formattedError['trace'] = static::toSafeTrace($debugging);
            }
        }

        return $formattedError;
    }

    /**
     * Prepares final error formatter taking in account $debug flags.
     * If initial formatter is not set, FormattedError::createFromException is used
     */
    public static function prepareFormatter(?callable $formatter, int $debug) : callable
    {
        $formatter = $formatter ?? static function ($e) : array {
            return FormattedError::createFromException($e);
        };
        if ($debug !== DebugFlag::NONE) {
            $formatter = static function ($e) use ($formatter, $debug) : array {
                return FormattedError::addDebugEntries($formatter($e), $e, $debug);
            };
        }

        return $formatter;
    }

    /**
     * Returns error trace as serializable array
     *
     * @param Throwable $error
     *
     * @return mixed[]
     *
     * @api
     */
    public static function toSafeTrace($error)
    {
        $trace = $error->getTrace();

        if (isset($trace[0]['function']) && isset($trace[0]['class']) &&
            // Remove invariant entries as they don't provide much value:
            ($trace[0]['class'] . '::' . $trace[0]['function'] === 'GraphQL\Utils\Utils::invariant')) {
            array_shift($trace);
        } elseif (! isset($trace[0]['file'])) {
            // Remove root call as it's likely error handler trace:
            array_shift($trace);
        }

        return array_map(
            static function ($err) : array {
                $safeErr = array_intersect_key($err, ['file' => true, 'line' => true]);

                if (isset($err['function'])) {
                    $func    = $err['function'];
                    $args    = array_map([self::class, 'printVar'], $err['args'] ?? []);
                    $funcStr = $func . '(' . implode(', ', $args) . ')';

                    if (isset($err['class'])) {
                        $safeErr['call'] = $err['class'] . '::' . $funcStr;
                    } else {
                        $safeErr['function'] = $funcStr;
                    }
                }

                return $safeErr;
            },
            $trace
        );
    }

    /**
     * @param mixed $var
     *
     * @return string
     */
    public static function printVar($var)
    {
        if ($var instanceof Type) {
            // FIXME: Replace with schema printer call
            if ($var instanceof WrappingType) {
                $var = $var->getWrappedType(true);
            }

            return 'GraphQLType: ' . $var->name;
        }

        if (is_object($var)) {
            return 'instance of ' . get_class($var) . ($var instanceof Countable ? '(' . count($var) . ')' : '');
        }
        if (is_array($var)) {
            return 'array(' . count($var) . ')';
        }
        if ($var === '') {
            return '(empty string)';
        }
        if (is_string($var)) {
            return "'" . addcslashes($var, "'") . "'";
        }
        if (is_bool($var)) {
            return $var ? 'true' : 'false';
        }
        if (is_scalar($var)) {
            return $var;
        }
        if ($var === null) {
            return 'null';
        }

        return gettype($var);
    }

    /**
     * @deprecated as of v0.8.0
     *
     * @param string           $error
     * @param SourceLocation[] $locations
     *
     * @return mixed[]
     */
    public static function create($error, array $locations = [])
    {
        $formatted = ['message' => $error];

        if (count($locations) > 0) {
            $formatted['locations'] = array_map(
                static function ($loc) : array {
                    return $loc->toArray();
                },
                $locations
            );
        }

        return $formatted;
    }

    /**
     * @deprecated as of v0.10.0, use general purpose method createFromException() instead
     *
     * @return mixed[]
     *
     * @codeCoverageIgnore
     */
    public static function createFromPHPError(ErrorException $e)
    {
        return [
            'message'  => $e->getMessage(),
            'severity' => $e->getSeverity(),
            'trace'    => self::toSafeTrace($e),
        ];
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Error\InvariantViolation.php
<?php

declare(strict_types=1);

namespace GraphQL\Error;

use LogicException;

/**
 * Note:
 * This exception should not inherit base Error exception as it is raised when there is an error somewhere in
 * user-land code
 */
class InvariantViolation extends LogicException
{
    public static function shouldNotHappen() : self
    {
        return new self('This should not have happened');
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Error\SyntaxError.php
<?php

declare(strict_types=1);

namespace GraphQL\Error;

use GraphQL\Language\Source;
use function sprintf;

class SyntaxError extends Error
{
    /**
     * @param int    $position
     * @param string $description
     */
    public function __construct(Source $source, $position, $description)
    {
        parent::__construct(
            sprintf('Syntax Error: %s', $description),
            null,
            $source,
            [$position]
        );
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Error\UserError.php
<?php

declare(strict_types=1);

namespace GraphQL\Error;

use RuntimeException;

/**
 * Error caused by actions of GraphQL clients. Can be safely displayed to a client...
 */
class UserError extends RuntimeException implements ClientAware
{
    /**
     * @return bool
     */
    public function isClientSafe()
    {
        return true;
    }

    /**
     * @return string
     */
    public function getCategory()
    {
        return 'user';
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Error\Warning.php
<?php

declare(strict_types=1);

namespace GraphQL\Error;

use GraphQL\Exception\InvalidArgument;
use function is_int;
use function trigger_error;
use const E_USER_WARNING;

/**
 * Encapsulates warnings produced by the library.
 *
 * Warnings can be suppressed (individually or all) if required.
 * Also it is possible to override warning handler (which is **trigger_error()** by default)
 */
final class Warning
{
    public const WARNING_ASSIGN             = 2;
    public const WARNING_CONFIG             = 4;
    public const WARNING_FULL_SCHEMA_SCAN   = 8;
    public const WARNING_CONFIG_DEPRECATION = 16;
    public const WARNING_NOT_A_TYPE         = 32;
    public const ALL                        = 63;

    /** @var int */
    private static $enableWarnings = self::ALL;

    /** @var mixed[] */
    private static $warned = [];

    /** @var callable|null */
    private static $warningHandler;

    /**
     * Sets warning handler which can intercept all system warnings.
     * When not set, trigger_error() is used to notify about warnings.
     *
     * @api
     */
    public static function setWarningHandler(?callable $warningHandler = null) : void
    {
        self::$warningHandler = $warningHandler;
    }

    /**
     * Suppress warning by id (has no effect when custom warning handler is set)
     *
     * Usage example:
     * Warning::suppress(Warning::WARNING_NOT_A_TYPE)
     *
     * When passing true - suppresses all warnings.
     *
     * @param bool|int $suppress
     *
     * @api
     */
    public static function suppress($suppress = true) : void
    {
        if ($suppress === true) {
            self::$enableWarnings = 0;
        } elseif ($suppress === false) {
            self::$enableWarnings = self::ALL;
        } elseif (is_int($suppress)) {
            self::$enableWarnings &= ~$suppress;
        } else {
            throw InvalidArgument::fromExpectedTypeAndArgument('bool|int', $suppress);
        }
    }

    /**
     * Re-enable previously suppressed warning by id
     *
     * Usage example:
     * Warning::suppress(Warning::WARNING_NOT_A_TYPE)
     *
     * When passing true - re-enables all warnings.
     *
     * @param bool|int $enable
     *
     * @api
     */
    public static function enable($enable = true) : void
    {
        if ($enable === true) {
            self::$enableWarnings = self::ALL;
        } elseif ($enable === false) {
            self::$enableWarnings = 0;
        } elseif (is_int($enable)) {
            self::$enableWarnings |= $enable;
        } else {
            throw InvalidArgument::fromExpectedTypeAndArgument('bool|int', $enable);
        }
    }

    public static function warnOnce(string $errorMessage, int $warningId, ?int $messageLevel = null) : void
    {
        $messageLevel = $messageLevel ?? E_USER_WARNING;

        if (self::$warningHandler !== null) {
            $fn = self::$warningHandler;
            $fn($errorMessage, $warningId, $messageLevel);
        } elseif ((self::$enableWarnings & $warningId) > 0 && ! isset(self::$warned[$warningId])) {
            self::$warned[$warningId] = true;
            trigger_error($errorMessage, $messageLevel);
        }
    }

    public static function warn(string $errorMessage, int $warningId, ?int $messageLevel = null) : void
    {
        $messageLevel = $messageLevel ?? E_USER_WARNING;

        if (self::$warningHandler !== null) {
            $fn = self::$warningHandler;
            $fn($errorMessage, $warningId, $messageLevel);
        } elseif ((self::$enableWarnings & $warningId) > 0) {
            trigger_error($errorMessage, $messageLevel);
        }
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Exception\InvalidArgument.php
<?php

declare(strict_types=1);

namespace GraphQL\Exception;

use InvalidArgumentException;
use function gettype;
use function sprintf;

final class InvalidArgument extends InvalidArgumentException
{
    /**
     * @param mixed $argument
     */
    public static function fromExpectedTypeAndArgument(string $expectedType, $argument) : self
    {
        return new self(sprintf('Expected type "%s", got "%s"', $expectedType, gettype($argument)));
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Executor\ExecutionContext.php
<?php

declare(strict_types=1);

namespace GraphQL\Executor;

use GraphQL\Error\Error;
use GraphQL\Executor\Promise\PromiseAdapter;
use GraphQL\Language\AST\FragmentDefinitionNode;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Type\Schema;

/**
 * Data that must be available at all points during query execution.
 *
 * Namely, schema of the type system that is currently executing,
 * and the fragments defined in the query document.
 *
 * @internal
 */
class ExecutionContext
{
    /** @var Schema */
    public $schema;

    /** @var FragmentDefinitionNode[] */
    public $fragments;

    /** @var mixed */
    public $rootValue;

    /** @var mixed */
    public $contextValue;

    /** @var OperationDefinitionNode */
    public $operation;

    /** @var mixed[] */
    public $variableValues;

    /** @var callable */
    public $fieldResolver;

    /** @var Error[] */
    public $errors;

    /** @var PromiseAdapter */
    public $promiseAdapter;

    public function __construct(
        $schema,
        $fragments,
        $rootValue,
        $contextValue,
        $operation,
        $variableValues,
        $errors,
        $fieldResolver,
        $promiseAdapter
    ) {
        $this->schema         = $schema;
        $this->fragments      = $fragments;
        $this->rootValue      = $rootValue;
        $this->contextValue   = $contextValue;
        $this->operation      = $operation;
        $this->variableValues = $variableValues;
        $this->errors         = $errors ?? [];
        $this->fieldResolver  = $fieldResolver;
        $this->promiseAdapter = $promiseAdapter;
    }

    public function addError(Error $error)
    {
        $this->errors[] = $error;

        return $this;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Executor\ExecutionResult.php
<?php

declare(strict_types=1);

namespace GraphQL\Executor;

use GraphQL\Error\DebugFlag;
use GraphQL\Error\Error;
use GraphQL\Error\FormattedError;
use JsonSerializable;
use function array_map;
use function count;

/**
 * Returned after [query execution](executing-queries.md).
 * Represents both - result of successful execution and of a failed one
 * (with errors collected in `errors` prop)
 *
 * Could be converted to [spec-compliant](https://facebook.github.io/graphql/#sec-Response-Format)
 * serializable array using `toArray()`
 */
class ExecutionResult implements JsonSerializable
{
    /**
     * Data collected from resolvers during query execution
     *
     * @api
     * @var mixed[]
     */
    public $data;

    /**
     * Errors registered during query execution.
     *
     * If an error was caused by exception thrown in resolver, $error->getPrevious() would
     * contain original exception.
     *
     * @api
     * @var Error[]
     */
    public $errors;

    /**
     * User-defined serializable array of extensions included in serialized result.
     * Conforms to
     *
     * @api
     * @var mixed[]
     */
    public $extensions;

    /** @var callable */
    private $errorFormatter;

    /** @var callable */
    private $errorsHandler;

    /**
     * @param mixed[] $data
     * @param Error[] $errors
     * @param mixed[] $extensions
     */
    public function __construct($data = null, array $errors = [], array $extensions = [])
    {
        $this->data       = $data;
        $this->errors     = $errors;
        $this->extensions = $extensions;
    }

    /**
     * Define custom error formatting (must conform to http://facebook.github.io/graphql/#sec-Errors)
     *
     * Expected signature is: function (GraphQL\Error\Error $error): array
     *
     * Default formatter is "GraphQL\Error\FormattedError::createFromException"
     *
     * Expected returned value must be an array:
     * array(
     *    'message' => 'errorMessage',
     *    // ... other keys
     * );
     *
     * @return self
     *
     * @api
     */
    public function setErrorFormatter(callable $errorFormatter)
    {
        $this->errorFormatter = $errorFormatter;

        return $this;
    }

    /**
     * Define custom logic for error handling (filtering, logging, etc).
     *
     * Expected handler signature is: function (array $errors, callable $formatter): array
     *
     * Default handler is:
     * function (array $errors, callable $formatter) {
     *     return array_map($formatter, $errors);
     * }
     *
     * @return self
     *
     * @api
     */
    public function setErrorsHandler(callable $handler)
    {
        $this->errorsHandler = $handler;

        return $this;
    }

    /**
     * @return mixed[]
     */
    public function jsonSerialize() : array
    {
        return $this->toArray();
    }

    /**
     * Converts GraphQL query result to spec-compliant serializable array using provided
     * errors handler and formatter.
     *
     * If debug argument is passed, output of error formatter is enriched which debugging information
     * ("debugMessage", "trace" keys depending on flags).
     *
     * $debug argument must sum of flags from @see \GraphQL\Error\DebugFlag
     *
     * @return mixed[]
     *
     * @api
     */
    public function toArray(int $debug = DebugFlag::NONE) : array
    {
        $result = [];

        if (count($this->errors ?? []) > 0) {
            $errorsHandler = $this->errorsHandler ?? static function (array $errors, callable $formatter) : array {
                return array_map($formatter, $errors);
            };

            $handledErrors = $errorsHandler(
                $this->errors,
                FormattedError::prepareFormatter($this->errorFormatter, $debug)
            );

            // While we know that there were errors initially, they might have been discarded
            if ($handledErrors !== []) {
                $result['errors'] = $handledErrors;
            }
        }

        if ($this->data !== null) {
            $result['data'] = $this->data;
        }

        if (count($this->extensions ?? []) > 0) {
            $result['extensions'] = $this->extensions;
        }

        return $result;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Executor\Executor.php
<?php

declare(strict_types=1);

namespace GraphQL\Executor;

use ArrayAccess;
use Closure;
use GraphQL\Executor\Promise\Adapter\SyncPromiseAdapter;
use GraphQL\Executor\Promise\Promise;
use GraphQL\Executor\Promise\PromiseAdapter;
use GraphQL\Language\AST\DocumentNode;
use GraphQL\Type\Definition\ResolveInfo;
use GraphQL\Type\Schema;
use function is_array;
use function is_object;

/**
 * Implements the "Evaluating requests" section of the GraphQL specification.
 */
class Executor
{
    /** @var callable */
    private static $defaultFieldResolver = [self::class, 'defaultFieldResolver'];

    /** @var PromiseAdapter */
    private static $defaultPromiseAdapter;

    /** @var callable */
    private static $implementationFactory = [ReferenceExecutor::class, 'create'];

    public static function getDefaultFieldResolver() : callable
    {
        return self::$defaultFieldResolver;
    }

    /**
     * Set a custom default resolve function.
     */
    public static function setDefaultFieldResolver(callable $fieldResolver)
    {
        self::$defaultFieldResolver = $fieldResolver;
    }

    public static function getPromiseAdapter() : PromiseAdapter
    {
        return self::$defaultPromiseAdapter ?? (self::$defaultPromiseAdapter = new SyncPromiseAdapter());
    }

    /**
     * Set a custom default promise adapter.
     */
    public static function setPromiseAdapter(?PromiseAdapter $defaultPromiseAdapter = null)
    {
        self::$defaultPromiseAdapter = $defaultPromiseAdapter;
    }

    public static function getImplementationFactory() : callable
    {
        return self::$implementationFactory;
    }

    /**
     * Set a custom executor implementation factory.
     */
    public static function setImplementationFactory(callable $implementationFactory)
    {
        self::$implementationFactory = $implementationFactory;
    }

    /**
     * Executes DocumentNode against given $schema.
     *
     * Always returns ExecutionResult and never throws.
     * All errors which occur during operation execution are collected in `$result->errors`.
     *
     * @param mixed|null                    $rootValue
     * @param mixed|null                    $contextValue
     * @param array<mixed>|ArrayAccess|null $variableValues
     * @param string|null                   $operationName
     *
     * @return ExecutionResult|Promise
     *
     * @api
     */
    public static function execute(
        Schema $schema,
        DocumentNode $documentNode,
        $rootValue = null,
        $contextValue = null,
        $variableValues = null,
        $operationName = null,
        ?callable $fieldResolver = null
    ) {
        // TODO: deprecate (just always use SyncAdapter here) and have `promiseToExecute()` for other cases

        $promiseAdapter = static::getPromiseAdapter();

        $result = static::promiseToExecute(
            $promiseAdapter,
            $schema,
            $documentNode,
            $rootValue,
            $contextValue,
            $variableValues,
            $operationName,
            $fieldResolver
        );

        if ($promiseAdapter instanceof SyncPromiseAdapter) {
            $result = $promiseAdapter->wait($result);
        }

        return $result;
    }

    /**
     * Same as execute(), but requires promise adapter and returns a promise which is always
     * fulfilled with an instance of ExecutionResult and never rejected.
     *
     * Useful for async PHP platforms.
     *
     * @param mixed|null        $rootValue
     * @param mixed|null        $contextValue
     * @param array<mixed>|null $variableValues
     * @param string|null       $operationName
     *
     * @return Promise
     *
     * @api
     */
    public static function promiseToExecute(
        PromiseAdapter $promiseAdapter,
        Schema $schema,
        DocumentNode $documentNode,
        $rootValue = null,
        $contextValue = null,
        $variableValues = null,
        $operationName = null,
        ?callable $fieldResolver = null
    ) {
        $factory = self::$implementationFactory;

        /** @var ExecutorImplementation $executor */
        $executor = $factory(
            $promiseAdapter,
            $schema,
            $documentNode,
            $rootValue,
            $contextValue,
            $variableValues,
            $operationName,
            $fieldResolver ?? self::$defaultFieldResolver
        );

        return $executor->doExecute();
    }

    /**
     * If a resolve function is not given, then a default resolve behavior is used
     * which takes the property of the root value of the same name as the field
     * and returns it as the result, or if it's a function, returns the result
     * of calling that function while passing along args and context.
     *
     * @param mixed                $objectValue
     * @param array<string, mixed> $args
     * @param mixed|null           $contextValue
     *
     * @return mixed|null
     */
    public static function defaultFieldResolver($objectValue, $args, $contextValue, ResolveInfo $info)
    {
        $fieldName = $info->fieldName;
        $property  = null;

        if (is_array($objectValue) || $objectValue instanceof ArrayAccess) {
            if (isset($objectValue[$fieldName])) {
                $property = $objectValue[$fieldName];
            }
        } elseif (is_object($objectValue)) {
            if (isset($objectValue->{$fieldName})) {
                $property = $objectValue->{$fieldName};
            }
        }

        return $property instanceof Closure
            ? $property($objectValue, $args, $contextValue, $info)
            : $property;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Executor\ExecutorImplementation.php
<?php

declare(strict_types=1);

namespace GraphQL\Executor;

use GraphQL\Executor\Promise\Promise;

interface ExecutorImplementation
{
    /**
     * Returns promise of {@link ExecutionResult}. Promise should always resolve, never reject.
     */
    public function doExecute() : Promise;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Executor\ReferenceExecutor.php
<?php

declare(strict_types=1);

namespace GraphQL\Executor;

use ArrayAccess;
use ArrayObject;
use Exception;
use GraphQL\Error\Error;
use GraphQL\Error\InvariantViolation;
use GraphQL\Error\Warning;
use GraphQL\Executor\Promise\Promise;
use GraphQL\Executor\Promise\PromiseAdapter;
use GraphQL\Language\AST\DocumentNode;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\FragmentDefinitionNode;
use GraphQL\Language\AST\FragmentSpreadNode;
use GraphQL\Language\AST\InlineFragmentNode;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Language\AST\SelectionNode;
use GraphQL\Language\AST\SelectionSetNode;
use GraphQL\Type\Definition\AbstractType;
use GraphQL\Type\Definition\Directive;
use GraphQL\Type\Definition\FieldDefinition;
use GraphQL\Type\Definition\InterfaceType;
use GraphQL\Type\Definition\LeafType;
use GraphQL\Type\Definition\ListOfType;
use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\ResolveInfo;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Definition\UnionType;
use GraphQL\Type\Introspection;
use GraphQL\Type\Schema;
use GraphQL\Utils\TypeInfo;
use GraphQL\Utils\Utils;
use RuntimeException;
use SplObjectStorage;
use stdClass;
use Throwable;
use Traversable;
use function array_keys;
use function array_merge;
use function array_reduce;
use function array_values;
use function count;
use function get_class;
use function is_array;
use function is_callable;
use function is_string;
use function sprintf;

class ReferenceExecutor implements ExecutorImplementation
{
    /** @var object */
    protected static $UNDEFINED;

    /** @var ExecutionContext */
    protected $exeContext;

    /** @var SplObjectStorage */
    protected $subFieldCache;

    protected function __construct(ExecutionContext $context)
    {
        if (! static::$UNDEFINED) {
            static::$UNDEFINED = Utils::undefined();
        }
        $this->exeContext    = $context;
        $this->subFieldCache = new SplObjectStorage();
    }

    /**
     * @param mixed                    $rootValue
     * @param mixed                    $contextValue
     * @param array<mixed>|Traversable $variableValues
     */
    public static function create(
        PromiseAdapter $promiseAdapter,
        Schema $schema,
        DocumentNode $documentNode,
        $rootValue,
        $contextValue,
        $variableValues,
        ?string $operationName,
        callable $fieldResolver
    ) : ExecutorImplementation {
        $exeContext = static::buildExecutionContext(
            $schema,
            $documentNode,
            $rootValue,
            $contextValue,
            $variableValues,
            $operationName,
            $fieldResolver,
            $promiseAdapter
        );

        if (is_array($exeContext)) {
            return new class($promiseAdapter->createFulfilled(new ExecutionResult(null, $exeContext))) implements ExecutorImplementation
            {
                /** @var Promise */
                private $result;

                public function __construct(Promise $result)
                {
                    $this->result = $result;
                }

                public function doExecute() : Promise
                {
                    return $this->result;
                }
            };
        }

        return new static($exeContext);
    }

    /**
     * Constructs an ExecutionContext object from the arguments passed to
     * execute, which we will pass throughout the other execution methods.
     *
     * @param mixed                    $rootValue
     * @param mixed                    $contextValue
     * @param array<mixed>|Traversable $rawVariableValues
     *
     * @return ExecutionContext|array<Error>
     */
    protected static function buildExecutionContext(
        Schema $schema,
        DocumentNode $documentNode,
        $rootValue,
        $contextValue,
        $rawVariableValues,
        ?string $operationName = null,
        ?callable $fieldResolver = null,
        ?PromiseAdapter $promiseAdapter = null
    ) {
        $errors    = [];
        $fragments = [];
        /** @var OperationDefinitionNode|null $operation */
        $operation                    = null;
        $hasMultipleAssumedOperations = false;
        foreach ($documentNode->definitions as $definition) {
            switch (true) {
                case $definition instanceof OperationDefinitionNode:
                    if ($operationName === null && $operation !== null) {
                        $hasMultipleAssumedOperations = true;
                    }
                    if ($operationName === null ||
                        (isset($definition->name) && $definition->name->value === $operationName)) {
                        $operation = $definition;
                    }
                    break;
                case $definition instanceof FragmentDefinitionNode:
                    $fragments[$definition->name->value] = $definition;
                    break;
            }
        }
        if ($operation === null) {
            if ($operationName === null) {
                $errors[] = new Error('Must provide an operation.');
            } else {
                $errors[] = new Error(sprintf('Unknown operation named "%s".', $operationName));
            }
        } elseif ($hasMultipleAssumedOperations) {
            $errors[] = new Error(
                'Must provide operation name if query contains multiple operations.'
            );
        }
        $variableValues = null;
        if ($operation !== null) {
            [$coercionErrors, $coercedVariableValues] = Values::getVariableValues(
                $schema,
                $operation->variableDefinitions ?? [],
                $rawVariableValues ?? []
            );
            if (count($coercionErrors ?? []) === 0) {
                $variableValues = $coercedVariableValues;
            } else {
                $errors = array_merge($errors, $coercionErrors);
            }
        }
        if (count($errors) > 0) {
            return $errors;
        }
        Utils::invariant($operation, 'Has operation if no errors.');
        Utils::invariant($variableValues !== null, 'Has variables if no errors.');

        return new ExecutionContext(
            $schema,
            $fragments,
            $rootValue,
            $contextValue,
            $operation,
            $variableValues,
            $errors,
            $fieldResolver,
            $promiseAdapter
        );
    }

    public function doExecute() : Promise
    {
        // Return a Promise that will eventually resolve to the data described by
        // the "Response" section of the GraphQL specification.
        //
        // If errors are encountered while executing a GraphQL field, only that
        // field and its descendants will be omitted, and sibling fields will still
        // be executed. An execution which encounters errors will still result in a
        // resolved Promise.
        $data   = $this->executeOperation($this->exeContext->operation, $this->exeContext->rootValue);
        $result = $this->buildResponse($data);

        // Note: we deviate here from the reference implementation a bit by always returning promise
        // But for the "sync" case it is always fulfilled
        return $this->isPromise($result)
            ? $result
            : $this->exeContext->promiseAdapter->createFulfilled($result);
    }

    /**
     * @param mixed|Promise|null $data
     *
     * @return ExecutionResult|Promise
     */
    protected function buildResponse($data)
    {
        if ($this->isPromise($data)) {
            return $data->then(function ($resolved) {
                return $this->buildResponse($resolved);
            });
        }
        if ($data !== null) {
            $data = (array) $data;
        }

        return new ExecutionResult($data, $this->exeContext->errors);
    }

    /**
     * Implements the "Evaluating operations" section of the spec.
     *
     * @param mixed $rootValue
     *
     * @return array<mixed>|Promise|stdClass|null
     */
    protected function executeOperation(OperationDefinitionNode $operation, $rootValue)
    {
        $type   = $this->getOperationRootType($this->exeContext->schema, $operation);
        $fields = $this->collectFields($type, $operation->selectionSet, new ArrayObject(), new ArrayObject());
        $path   = [];
        // Errors from sub-fields of a NonNull type may propagate to the top level,
        // at which point we still log the error and null the parent field, which
        // in this case is the entire response.
        //
        // Similar to completeValueCatchingError.
        try {
            $result = $operation->operation === 'mutation'
                ? $this->executeFieldsSerially($type, $rootValue, $path, $fields)
                : $this->executeFields($type, $rootValue, $path, $fields);
            if ($this->isPromise($result)) {
                return $result->then(
                    null,
                    function ($error) : ?Promise {
                        if ($error instanceof Error) {
                            $this->exeContext->addError($error);

                            return $this->exeContext->promiseAdapter->createFulfilled(null);
                        }

                        return null;
                    }
                );
            }

            return $result;
        } catch (Error $error) {
            $this->exeContext->addError($error);

            return null;
        }
    }

    /**
     * Extracts the root type of the operation from the schema.
     *
     * @throws Error
     */
    protected function getOperationRootType(Schema $schema, OperationDefinitionNode $operation) : ObjectType
    {
        switch ($operation->operation) {
            case 'query':
                $queryType = $schema->getQueryType();
                if ($queryType === null) {
                    throw new Error(
                        'Schema does not define the required query root type.',
                        [$operation]
                    );
                }

                return $queryType;
            case 'mutation':
                $mutationType = $schema->getMutationType();
                if ($mutationType === null) {
                    throw new Error(
                        'Schema is not configured for mutations.',
                        [$operation]
                    );
                }

                return $mutationType;
            case 'subscription':
                $subscriptionType = $schema->getSubscriptionType();
                if ($subscriptionType === null) {
                    throw new Error(
                        'Schema is not configured for subscriptions.',
                        [$operation]
                    );
                }

                return $subscriptionType;
            default:
                throw new Error(
                    'Can only execute queries, mutations and subscriptions.',
                    [$operation]
                );
        }
    }

    /**
     * Given a selectionSet, adds all of the fields in that selection to
     * the passed in map of fields, and returns it at the end.
     *
     * CollectFields requires the "runtime type" of an object. For a field which
     * returns an Interface or Union type, the "runtime type" will be the actual
     * Object type returned by that field.
     */
    protected function collectFields(
        ObjectType $runtimeType,
        SelectionSetNode $selectionSet,
        ArrayObject $fields,
        ArrayObject $visitedFragmentNames
    ) : ArrayObject {
        $exeContext = $this->exeContext;
        foreach ($selectionSet->selections as $selection) {
            switch (true) {
                case $selection instanceof FieldNode:
                    if (! $this->shouldIncludeNode($selection)) {
                        break;
                    }
                    $name = static::getFieldEntryKey($selection);
                    if (! isset($fields[$name])) {
                        $fields[$name] = new ArrayObject();
                    }
                    $fields[$name][] = $selection;
                    break;
                case $selection instanceof InlineFragmentNode:
                    if (! $this->shouldIncludeNode($selection) ||
                        ! $this->doesFragmentConditionMatch($selection, $runtimeType)
                    ) {
                        break;
                    }
                    $this->collectFields(
                        $runtimeType,
                        $selection->selectionSet,
                        $fields,
                        $visitedFragmentNames
                    );
                    break;
                case $selection instanceof FragmentSpreadNode:
                    $fragName = $selection->name->value;

                    if (($visitedFragmentNames[$fragName] ?? false) === true || ! $this->shouldIncludeNode($selection)) {
                        break;
                    }
                    $visitedFragmentNames[$fragName] = true;
                    /** @var FragmentDefinitionNode|null $fragment */
                    $fragment = $exeContext->fragments[$fragName] ?? null;
                    if ($fragment === null || ! $this->doesFragmentConditionMatch($fragment, $runtimeType)) {
                        break;
                    }
                    $this->collectFields(
                        $runtimeType,
                        $fragment->selectionSet,
                        $fields,
                        $visitedFragmentNames
                    );
                    break;
            }
        }

        return $fields;
    }

    /**
     * Determines if a field should be included based on the @include and @skip
     * directives, where @skip has higher precedence than @include.
     *
     * @param FragmentSpreadNode|FieldNode|InlineFragmentNode $node
     */
    protected function shouldIncludeNode(SelectionNode $node) : bool
    {
        $variableValues = $this->exeContext->variableValues;
        $skipDirective  = Directive::skipDirective();
        $skip           = Values::getDirectiveValues(
            $skipDirective,
            $node,
            $variableValues
        );
        if (isset($skip['if']) && $skip['if'] === true) {
            return false;
        }
        $includeDirective = Directive::includeDirective();
        $include          = Values::getDirectiveValues(
            $includeDirective,
            $node,
            $variableValues
        );

        return ! isset($include['if']) || $include['if'] !== false;
    }

    /**
     * Implements the logic to compute the key of a given fields entry
     */
    protected static function getFieldEntryKey(FieldNode $node) : string
    {
        return $node->alias === null ? $node->name->value : $node->alias->value;
    }

    /**
     * Determines if a fragment is applicable to the given type.
     *
     * @param FragmentDefinitionNode|InlineFragmentNode $fragment
     */
    protected function doesFragmentConditionMatch(Node $fragment, ObjectType $type) : bool
    {
        $typeConditionNode = $fragment->typeCondition;
        if ($typeConditionNode === null) {
            return true;
        }
        $conditionalType = TypeInfo::typeFromAST($this->exeContext->schema, $typeConditionNode);
        if ($conditionalType === $type) {
            return true;
        }
        if ($conditionalType instanceof AbstractType) {
            return $this->exeContext->schema->isSubType($conditionalType, $type);
        }

        return false;
    }

    /**
     * Implements the "Evaluating selection sets" section of the spec
     * for "write" mode.
     *
     * @param mixed             $rootValue
     * @param array<string|int> $path
     *
     * @return array<mixed>|Promise|stdClass
     */
    protected function executeFieldsSerially(ObjectType $parentType, $rootValue, array $path, ArrayObject $fields)
    {
        $result = $this->promiseReduce(
            array_keys($fields->getArrayCopy()),
            function ($results, $responseName) use ($path, $parentType, $rootValue, $fields) {
                $fieldNodes  = $fields[$responseName];
                $fieldPath   = $path;
                $fieldPath[] = $responseName;
                $result      = $this->resolveField($parentType, $rootValue, $fieldNodes, $fieldPath);
                if ($result === static::$UNDEFINED) {
                    return $results;
                }
                $promise = $this->getPromise($result);
                if ($promise !== null) {
                    return $promise->then(static function ($resolvedResult) use ($responseName, $results) {
                        $results[$responseName] = $resolvedResult;

                        return $results;
                    });
                }
                $results[$responseName] = $result;

                return $results;
            },
            []
        );

        if ($this->isPromise($result)) {
            return $result->then(static function ($resolvedResults) {
                return static::fixResultsIfEmptyArray($resolvedResults);
            });
        }

        return static::fixResultsIfEmptyArray($result);
    }

    /**
     * Resolves the field on the given root value.
     *
     * In particular, this figures out the value that the field returns
     * by calling its resolve function, then calls completeValue to complete promises,
     * serialize scalars, or execute the sub-selection-set for objects.
     *
     * @param mixed             $rootValue
     * @param array<string|int> $path
     *
     * @return array<mixed>|Throwable|mixed|null
     */
    protected function resolveField(ObjectType $parentType, $rootValue, ArrayObject $fieldNodes, array $path)
    {
        $exeContext = $this->exeContext;
        $fieldNode  = $fieldNodes[0];
        $fieldName  = $fieldNode->name->value;
        $fieldDef   = $this->getFieldDef($exeContext->schema, $parentType, $fieldName);
        if ($fieldDef === null) {
            return static::$UNDEFINED;
        }
        $returnType = $fieldDef->getType();
        // The resolve function's optional 3rd argument is a context value that
        // is provided to every resolve function within an execution. It is commonly
        // used to represent an authenticated user, or request-specific caches.
        // The resolve function's optional 4th argument is a collection of
        // information about the current execution state.
        $info = new ResolveInfo(
            $fieldDef,
            $fieldNodes,
            $parentType,
            $path,
            $exeContext->schema,
            $exeContext->fragments,
            $exeContext->rootValue,
            $exeContext->operation,
            $exeContext->variableValues
        );
        if ($fieldDef->resolveFn !== null) {
            $resolveFn = $fieldDef->resolveFn;
        } elseif ($parentType->resolveFieldFn !== null) {
            $resolveFn = $parentType->resolveFieldFn;
        } else {
            $resolveFn = $this->exeContext->fieldResolver;
        }
        // Get the resolve function, regardless of if its result is normal
        // or abrupt (error).
        $result = $this->resolveFieldValueOrError(
            $fieldDef,
            $fieldNode,
            $resolveFn,
            $rootValue,
            $info
        );
        $result = $this->completeValueCatchingError(
            $returnType,
            $fieldNodes,
            $info,
            $path,
            $result
        );

        return $result;
    }

    /**
     * This method looks up the field on the given type definition.
     *
     * It has special casing for the two introspection fields, __schema
     * and __typename. __typename is special because it can always be
     * queried as a field, even in situations where no other fields
     * are allowed, like on a Union. __schema could get automatically
     * added to the query type, but that would require mutating type
     * definitions, which would cause issues.
     */
    protected function getFieldDef(Schema $schema, ObjectType $parentType, string $fieldName) : ?FieldDefinition
    {
        static $schemaMetaFieldDef, $typeMetaFieldDef, $typeNameMetaFieldDef;
        $schemaMetaFieldDef   = $schemaMetaFieldDef ?? Introspection::schemaMetaFieldDef();
        $typeMetaFieldDef     = $typeMetaFieldDef ?? Introspection::typeMetaFieldDef();
        $typeNameMetaFieldDef = $typeNameMetaFieldDef ?? Introspection::typeNameMetaFieldDef();
        if ($fieldName === $schemaMetaFieldDef->name && $schema->getQueryType() === $parentType) {
            return $schemaMetaFieldDef;
        }

        if ($fieldName === $typeMetaFieldDef->name && $schema->getQueryType() === $parentType) {
            return $typeMetaFieldDef;
        }

        if ($fieldName === $typeNameMetaFieldDef->name) {
            return $typeNameMetaFieldDef;
        }

        return $parentType->findField($fieldName);
    }

    /**
     * Isolates the "ReturnOrAbrupt" behavior to not de-opt the `resolveField` function.
     * Returns the result of resolveFn or the abrupt-return Error object.
     *
     * @param mixed $rootValue
     *
     * @return Throwable|Promise|mixed
     */
    protected function resolveFieldValueOrError(
        FieldDefinition $fieldDef,
        FieldNode $fieldNode,
        callable $resolveFn,
        $rootValue,
        ResolveInfo $info
    ) {
        try {
            // Build a map of arguments from the field.arguments AST, using the
            // variables scope to fulfill any variable references.
            $args         = Values::getArgumentValues(
                $fieldDef,
                $fieldNode,
                $this->exeContext->variableValues
            );
            $contextValue = $this->exeContext->contextValue;

            return $resolveFn($rootValue, $args, $contextValue, $info);
        } catch (Throwable $error) {
            return $error;
        }
    }

    /**
     * This is a small wrapper around completeValue which detects and logs errors
     * in the execution context.
     *
     * @param array<string|int> $path
     * @param mixed             $result
     *
     * @return array<mixed>|Promise|stdClass|null
     */
    protected function completeValueCatchingError(
        Type $returnType,
        ArrayObject $fieldNodes,
        ResolveInfo $info,
        array $path,
        $result
    ) {
        // Otherwise, error protection is applied, logging the error and resolving
        // a null value for this field if one is encountered.
        try {
            $promise = $this->getPromise($result);
            if ($promise !== null) {
                $completed = $promise->then(function (&$resolved) use ($returnType, $fieldNodes, $info, $path) {
                    return $this->completeValue($returnType, $fieldNodes, $info, $path, $resolved);
                });
            } else {
                $completed = $this->completeValue($returnType, $fieldNodes, $info, $path, $result);
            }

            $promise = $this->getPromise($completed);
            if ($promise !== null) {
                return $promise->then(null, function ($error) use ($fieldNodes, $path, $returnType) : void {
                    $this->handleFieldError($error, $fieldNodes, $path, $returnType);
                });
            }

            return $completed;
        } catch (Throwable $err) {
            $this->handleFieldError($err, $fieldNodes, $path, $returnType);

            return null;
        }
    }

    /**
     * @param mixed             $rawError
     * @param array<string|int> $path
     *
     * @throws Error
     */
    protected function handleFieldError($rawError, ArrayObject $fieldNodes, array $path, Type $returnType) : void
    {
        $error = Error::createLocatedError(
            $rawError,
            $fieldNodes,
            $path
        );

        // If the field type is non-nullable, then it is resolved without any
        // protection from errors, however it still properly locates the error.
        if ($returnType instanceof NonNull) {
            throw $error;
        }
        // Otherwise, error protection is applied, logging the error and resolving
        // a null value for this field if one is encountered.
        $this->exeContext->addError($error);
    }

    /**
     * Implements the instructions for completeValue as defined in the
     * "Field entries" section of the spec.
     *
     * If the field type is Non-Null, then this recursively completes the value
     * for the inner type. It throws a field error if that completion returns null,
     * as per the "Nullability" section of the spec.
     *
     * If the field type is a List, then this recursively completes the value
     * for the inner type on each item in the list.
     *
     * If the field type is a Scalar or Enum, ensures the completed value is a legal
     * value of the type by calling the `serialize` method of GraphQL type
     * definition.
     *
     * If the field is an abstract type, determine the runtime type of the value
     * and then complete based on that type
     *
     * Otherwise, the field type expects a sub-selection set, and will complete the
     * value by evaluating all sub-selections.
     *
     * @param array<string|int> $path
     * @param mixed             $result
     *
     * @return array<mixed>|mixed|Promise|null
     *
     * @throws Error
     * @throws Throwable
     */
    protected function completeValue(
        Type $returnType,
        ArrayObject $fieldNodes,
        ResolveInfo $info,
        array $path,
        &$result
    ) {
        // If result is an Error, throw a located error.
        if ($result instanceof Throwable) {
            throw $result;
        }

        // If field type is NonNull, complete for inner type, and throw field error
        // if result is null.
        if ($returnType instanceof NonNull) {
            $completed = $this->completeValue(
                $returnType->getWrappedType(),
                $fieldNodes,
                $info,
                $path,
                $result
            );
            if ($completed === null) {
                throw new InvariantViolation(
                    sprintf('Cannot return null for non-nullable field "%s.%s".', $info->parentType, $info->fieldName)
                );
            }

            return $completed;
        }
        // If result is null-like, return null.
        if ($result === null) {
            return null;
        }
        // If field type is List, complete each item in the list with the inner type
        if ($returnType instanceof ListOfType) {
            return $this->completeListValue($returnType, $fieldNodes, $info, $path, $result);
        }
        // Account for invalid schema definition when typeLoader returns different
        // instance than `resolveType` or $field->getType() or $arg->getType()
        if ($returnType !== $this->exeContext->schema->getType($returnType->name)) {
            $hint = '';
            if ($this->exeContext->schema->getConfig()->typeLoader !== null) {
                $hint = sprintf(
                    'Make sure that type loader returns the same instance as defined in %s.%s',
                    $info->parentType,
                    $info->fieldName
                );
            }
            throw new InvariantViolation(
                sprintf(
                    'Schema must contain unique named types but contains multiple types named "%s". %s ' .
                    '(see http://webonyx.github.io/graphql-php/type-system/#type-registry).',
                    $returnType,
                    $hint
                )
            );
        }
        // If field type is Scalar or Enum, serialize to a valid value, returning
        // null if serialization is not possible.
        if ($returnType instanceof LeafType) {
            return $this->completeLeafValue($returnType, $result);
        }
        if ($returnType instanceof AbstractType) {
            return $this->completeAbstractValue($returnType, $fieldNodes, $info, $path, $result);
        }
        // Field type must be Object, Interface or Union and expect sub-selections.
        if ($returnType instanceof ObjectType) {
            return $this->completeObjectValue($returnType, $fieldNodes, $info, $path, $result);
        }
        throw new RuntimeException(sprintf('Cannot complete value of unexpected type "%s".', $returnType));
    }

    /**
     * @param mixed $value
     */
    protected function isPromise($value) : bool
    {
        return $value instanceof Promise || $this->exeContext->promiseAdapter->isThenable($value);
    }

    /**
     * Only returns the value if it acts like a Promise, i.e. has a "then" function,
     * otherwise returns null.
     *
     * @param mixed $value
     */
    protected function getPromise($value) : ?Promise
    {
        if ($value === null || $value instanceof Promise) {
            return $value;
        }
        if ($this->exeContext->promiseAdapter->isThenable($value)) {
            $promise = $this->exeContext->promiseAdapter->convertThenable($value);
            if (! $promise instanceof Promise) {
                throw new InvariantViolation(sprintf(
                    '%s::convertThenable is expected to return instance of GraphQL\Executor\Promise\Promise, got: %s',
                    get_class($this->exeContext->promiseAdapter),
                    Utils::printSafe($promise)
                ));
            }

            return $promise;
        }

        return null;
    }

    /**
     * Similar to array_reduce(), however the reducing callback may return
     * a Promise, in which case reduction will continue after each promise resolves.
     *
     * If the callback does not return a Promise, then this function will also not
     * return a Promise.
     *
     * @param array<mixed>       $values
     * @param Promise|mixed|null $initialValue
     *
     * @return Promise|mixed|null
     */
    protected function promiseReduce(array $values, callable $callback, $initialValue)
    {
        return array_reduce(
            $values,
            function ($previous, $value) use ($callback) {
                $promise = $this->getPromise($previous);
                if ($promise !== null) {
                    return $promise->then(static function ($resolved) use ($callback, $value) {
                        return $callback($resolved, $value);
                    });
                }

                return $callback($previous, $value);
            },
            $initialValue
        );
    }

    /**
     * Complete a list value by completing each item in the list with the inner type.
     *
     * @param array<string|int>        $path
     * @param array<mixed>|Traversable $results
     *
     * @return array<mixed>|Promise|stdClass
     *
     * @throws Exception
     */
    protected function completeListValue(ListOfType $returnType, ArrayObject $fieldNodes, ResolveInfo $info, array $path, &$results)
    {
        $itemType = $returnType->getWrappedType();
        Utils::invariant(
            is_array($results) || $results instanceof Traversable,
            'User Error: expected iterable, but did not find one for field ' . $info->parentType . '.' . $info->fieldName . '.'
        );
        $containsPromise = false;
        $i               = 0;
        $completedItems  = [];
        foreach ($results as $item) {
            $fieldPath     = $path;
            $fieldPath[]   = $i++;
            $info->path    = $fieldPath;
            $completedItem = $this->completeValueCatchingError($itemType, $fieldNodes, $info, $fieldPath, $item);
            if (! $containsPromise && $this->getPromise($completedItem) !== null) {
                $containsPromise = true;
            }
            $completedItems[] = $completedItem;
        }

        return $containsPromise
            ? $this->exeContext->promiseAdapter->all($completedItems)
            : $completedItems;
    }

    /**
     * Complete a Scalar or Enum by serializing to a valid value, throwing if serialization is not possible.
     *
     * @param mixed $result
     *
     * @return mixed
     *
     * @throws Exception
     */
    protected function completeLeafValue(LeafType $returnType, &$result)
    {
        try {
            return $returnType->serialize($result);
        } catch (Throwable $error) {
            throw new InvariantViolation(
                'Expected a value of type "' . Utils::printSafe($returnType) . '" but received: ' . Utils::printSafe($result),
                0,
                $error
            );
        }
    }

    /**
     * Complete a value of an abstract type by determining the runtime object type
     * of that value, then complete the value for that type.
     *
     * @param array<string|int> $path
     * @param array<mixed>      $result
     *
     * @return array<mixed>|Promise|stdClass
     *
     * @throws Error
     */
    protected function completeAbstractValue(
        AbstractType $returnType,
        ArrayObject $fieldNodes,
        ResolveInfo $info,
        array $path,
        &$result
    ) {
        $exeContext    = $this->exeContext;
        $typeCandidate = $returnType->resolveType($result, $exeContext->contextValue, $info);

        if ($typeCandidate === null) {
            $runtimeType = static::defaultTypeResolver($result, $exeContext->contextValue, $info, $returnType);
        } elseif (is_callable($typeCandidate)) {
            $runtimeType = Schema::resolveType($typeCandidate);
        } else {
            $runtimeType = $typeCandidate;
        }
        $promise = $this->getPromise($runtimeType);
        if ($promise !== null) {
            return $promise->then(function ($resolvedRuntimeType) use (
                $returnType,
                $fieldNodes,
                $info,
                $path,
                &$result
            ) {
                return $this->completeObjectValue(
                    $this->ensureValidRuntimeType(
                        $resolvedRuntimeType,
                        $returnType,
                        $info,
                        $result
                    ),
                    $fieldNodes,
                    $info,
                    $path,
                    $result
                );
            });
        }

        return $this->completeObjectValue(
            $this->ensureValidRuntimeType(
                $runtimeType,
                $returnType,
                $info,
                $result
            ),
            $fieldNodes,
            $info,
            $path,
            $result
        );
    }

    /**
     * If a resolveType function is not given, then a default resolve behavior is
     * used which attempts two strategies:
     *
     * First, See if the provided value has a `__typename` field defined, if so, use
     * that value as name of the resolved type.
     *
     * Otherwise, test each possible type for the abstract type by calling
     * isTypeOf for the object being coerced, returning the first type that matches.
     *
     * @param mixed|null              $value
     * @param mixed|null              $contextValue
     * @param InterfaceType|UnionType $abstractType
     *
     * @return Promise|Type|string|null
     */
    protected function defaultTypeResolver($value, $contextValue, ResolveInfo $info, AbstractType $abstractType)
    {
        // First, look for `__typename`.
        if ($value !== null &&
            (is_array($value) || $value instanceof ArrayAccess) &&
            isset($value['__typename']) &&
            is_string($value['__typename'])
        ) {
            return $value['__typename'];
        }

        if ($abstractType instanceof InterfaceType && $info->schema->getConfig()->typeLoader !== null) {
            Warning::warnOnce(
                sprintf(
                    'GraphQL Interface Type `%s` returned `null` from its `resolveType` function ' .
                    'for value: %s. Switching to slow resolution method using `isTypeOf` ' .
                    'of all possible implementations. It requires full schema scan and degrades query performance significantly. ' .
                    ' Make sure your `resolveType` always returns valid implementation or throws.',
                    $abstractType->name,
                    Utils::printSafe($value)
                ),
                Warning::WARNING_FULL_SCHEMA_SCAN
            );
        }
        // Otherwise, test each possible type.
        $possibleTypes           = $info->schema->getPossibleTypes($abstractType);
        $promisedIsTypeOfResults = [];
        foreach ($possibleTypes as $index => $type) {
            $isTypeOfResult = $type->isTypeOf($value, $contextValue, $info);
            if ($isTypeOfResult === null) {
                continue;
            }
            $promise = $this->getPromise($isTypeOfResult);
            if ($promise !== null) {
                $promisedIsTypeOfResults[$index] = $promise;
            } elseif ($isTypeOfResult) {
                return $type;
            }
        }
        if (count($promisedIsTypeOfResults) > 0) {
            return $this->exeContext->promiseAdapter->all($promisedIsTypeOfResults)
                ->then(static function ($isTypeOfResults) use ($possibleTypes) : ?ObjectType {
                    foreach ($isTypeOfResults as $index => $result) {
                        if ($result) {
                            return $possibleTypes[$index];
                        }
                    }

                    return null;
                });
        }

        return null;
    }

    /**
     * Complete an Object value by executing all sub-selections.
     *
     * @param array<string|int> $path
     * @param mixed             $result
     *
     * @return array<mixed>|Promise|stdClass
     *
     * @throws Error
     */
    protected function completeObjectValue(
        ObjectType $returnType,
        ArrayObject $fieldNodes,
        ResolveInfo $info,
        array $path,
        &$result
    ) {
        // If there is an isTypeOf predicate function, call it with the
        // current result. If isTypeOf returns false, then raise an error rather
        // than continuing execution.
        $isTypeOf = $returnType->isTypeOf($result, $this->exeContext->contextValue, $info);
        if ($isTypeOf !== null) {
            $promise = $this->getPromise($isTypeOf);
            if ($promise !== null) {
                return $promise->then(function ($isTypeOfResult) use (
                    $returnType,
                    $fieldNodes,
                    $path,
                    &$result
                ) {
                    if (! $isTypeOfResult) {
                        throw $this->invalidReturnTypeError($returnType, $result, $fieldNodes);
                    }

                    return $this->collectAndExecuteSubfields(
                        $returnType,
                        $fieldNodes,
                        $path,
                        $result
                    );
                });
            }
            if (! $isTypeOf) {
                throw $this->invalidReturnTypeError($returnType, $result, $fieldNodes);
            }
        }

        return $this->collectAndExecuteSubfields(
            $returnType,
            $fieldNodes,
            $path,
            $result
        );
    }

    /**
     * @param array<mixed> $result
     *
     * @return Error
     */
    protected function invalidReturnTypeError(
        ObjectType $returnType,
        $result,
        ArrayObject $fieldNodes
    ) {
        return new Error(
            'Expected value of type "' . $returnType->name . '" but got: ' . Utils::printSafe($result) . '.',
            $fieldNodes
        );
    }

    /**
     * @param array<string|int> $path
     * @param mixed             $result
     *
     * @return array<mixed>|Promise|stdClass
     *
     * @throws Error
     */
    protected function collectAndExecuteSubfields(
        ObjectType $returnType,
        ArrayObject $fieldNodes,
        array $path,
        &$result
    ) {
        $subFieldNodes = $this->collectSubFields($returnType, $fieldNodes);

        return $this->executeFields($returnType, $result, $path, $subFieldNodes);
    }

    /**
     * A memoized collection of relevant subfields with regard to the return
     * type. Memoizing ensures the subfields are not repeatedly calculated, which
     * saves overhead when resolving lists of values.
     */
    protected function collectSubFields(ObjectType $returnType, ArrayObject $fieldNodes) : ArrayObject
    {
        if (! isset($this->subFieldCache[$returnType])) {
            $this->subFieldCache[$returnType] = new SplObjectStorage();
        }
        if (! isset($this->subFieldCache[$returnType][$fieldNodes])) {
            // Collect sub-fields to execute to complete this value.
            $subFieldNodes        = new ArrayObject();
            $visitedFragmentNames = new ArrayObject();
            foreach ($fieldNodes as $fieldNode) {
                if (! isset($fieldNode->selectionSet)) {
                    continue;
                }
                $subFieldNodes = $this->collectFields(
                    $returnType,
                    $fieldNode->selectionSet,
                    $subFieldNodes,
                    $visitedFragmentNames
                );
            }
            $this->subFieldCache[$returnType][$fieldNodes] = $subFieldNodes;
        }

        return $this->subFieldCache[$returnType][$fieldNodes];
    }

    /**
     * Implements the "Evaluating selection sets" section of the spec
     * for "read" mode.
     *
     * @param mixed             $rootValue
     * @param array<string|int> $path
     *
     * @return Promise|stdClass|array<mixed>
     */
    protected function executeFields(ObjectType $parentType, $rootValue, array $path, ArrayObject $fields)
    {
        $containsPromise = false;
        $results         = [];
        foreach ($fields as $responseName => $fieldNodes) {
            $fieldPath   = $path;
            $fieldPath[] = $responseName;
            $result      = $this->resolveField($parentType, $rootValue, $fieldNodes, $fieldPath);
            if ($result === static::$UNDEFINED) {
                continue;
            }
            if (! $containsPromise && $this->isPromise($result)) {
                $containsPromise = true;
            }
            $results[$responseName] = $result;
        }
        // If there are no promises, we can just return the object
        if (! $containsPromise) {
            return static::fixResultsIfEmptyArray($results);
        }

        // Otherwise, results is a map from field name to the result of resolving that
        // field, which is possibly a promise. Return a promise that will return this
        // same map, but with any promises replaced with the values they resolved to.
        return $this->promiseForAssocArray($results);
    }

    /**
     * Differentiate empty objects from empty lists.
     *
     * @see https://github.com/webonyx/graphql-php/issues/59
     *
     * @param array<mixed>|mixed $results
     *
     * @return array<mixed>|stdClass|mixed
     */
    protected static function fixResultsIfEmptyArray($results)
    {
        if ($results === []) {
            return new stdClass();
        }

        return $results;
    }

    /**
     * Transform an associative array with Promises to a Promise which resolves to an
     * associative array where all Promises were resolved.
     *
     * @param array<string, Promise|mixed> $assoc
     */
    protected function promiseForAssocArray(array $assoc) : Promise
    {
        $keys              = array_keys($assoc);
        $valuesAndPromises = array_values($assoc);
        $promise           = $this->exeContext->promiseAdapter->all($valuesAndPromises);

        return $promise->then(static function ($values) use ($keys) {
            $resolvedResults = [];
            foreach ($values as $i => $value) {
                $resolvedResults[$keys[$i]] = $value;
            }

            return static::fixResultsIfEmptyArray($resolvedResults);
        });
    }

    /**
     * @param string|ObjectType|null  $runtimeTypeOrName
     * @param InterfaceType|UnionType $returnType
     * @param mixed                   $result
     */
    protected function ensureValidRuntimeType(
        $runtimeTypeOrName,
        AbstractType $returnType,
        ResolveInfo $info,
        &$result
    ) : ObjectType {
        $runtimeType = is_string($runtimeTypeOrName)
            ? $this->exeContext->schema->getType($runtimeTypeOrName)
            : $runtimeTypeOrName;
        if (! $runtimeType instanceof ObjectType) {
            throw new InvariantViolation(
                sprintf(
                    'Abstract type %s must resolve to an Object type at ' .
                    'runtime for field %s.%s with value "%s", received "%s". ' .
                    'Either the %s type should provide a "resolveType" ' .
                    'function or each possible type should provide an "isTypeOf" function.',
                    $returnType,
                    $info->parentType,
                    $info->fieldName,
                    Utils::printSafe($result),
                    Utils::printSafe($runtimeType),
                    $returnType
                )
            );
        }
        if (! $this->exeContext->schema->isSubType($returnType, $runtimeType)) {
            throw new InvariantViolation(
                sprintf('Runtime Object type "%s" is not a possible type for "%s".', $runtimeType, $returnType)
            );
        }
        if ($runtimeType !== $this->exeContext->schema->getType($runtimeType->name)) {
            throw new InvariantViolation(
                sprintf(
                    'Schema must contain unique named types but contains multiple types named "%s". ' .
                    'Make sure that `resolveType` function of abstract type "%s" returns the same ' .
                    'type instance as referenced anywhere else within the schema ' .
                    '(see http://webonyx.github.io/graphql-php/type-system/#type-registry).',
                    $runtimeType,
                    $returnType
                )
            );
        }

        return $runtimeType;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Executor\Values.php
<?php

declare(strict_types=1);

namespace GraphQL\Executor;

use GraphQL\Error\Error;
use GraphQL\Language\AST\ArgumentNode;
use GraphQL\Language\AST\BooleanValueNode;
use GraphQL\Language\AST\DirectiveNode;
use GraphQL\Language\AST\EnumValueDefinitionNode;
use GraphQL\Language\AST\EnumValueNode;
use GraphQL\Language\AST\FieldDefinitionNode;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\FloatValueNode;
use GraphQL\Language\AST\FragmentSpreadNode;
use GraphQL\Language\AST\InlineFragmentNode;
use GraphQL\Language\AST\IntValueNode;
use GraphQL\Language\AST\ListValueNode;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\NodeList;
use GraphQL\Language\AST\NullValueNode;
use GraphQL\Language\AST\ObjectValueNode;
use GraphQL\Language\AST\StringValueNode;
use GraphQL\Language\AST\ValueNode;
use GraphQL\Language\AST\VariableDefinitionNode;
use GraphQL\Language\AST\VariableNode;
use GraphQL\Language\Printer;
use GraphQL\Type\Definition\Directive;
use GraphQL\Type\Definition\EnumType;
use GraphQL\Type\Definition\FieldDefinition;
use GraphQL\Type\Definition\InputObjectType;
use GraphQL\Type\Definition\InputType;
use GraphQL\Type\Definition\ListOfType;
use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\Definition\ScalarType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Schema;
use GraphQL\Utils\AST;
use GraphQL\Utils\TypeInfo;
use GraphQL\Utils\Utils;
use GraphQL\Utils\Value;
use stdClass;
use Throwable;
use function array_key_exists;
use function array_map;
use function count;
use function sprintf;

class Values
{
    /**
     * Prepares an object map of variables of the correct type based on the provided
     * variable definitions and arbitrary input. If the input cannot be coerced
     * to match the variable definitions, a Error will be thrown.
     *
     * @param VariableDefinitionNode[] $varDefNodes
     * @param mixed[]                  $inputs
     *
     * @return mixed[]
     */
    public static function getVariableValues(Schema $schema, $varDefNodes, array $inputs)
    {
        $errors        = [];
        $coercedValues = [];
        foreach ($varDefNodes as $varDefNode) {
            $varName = $varDefNode->variable->name->value;
            /** @var InputType|Type $varType */
            $varType = TypeInfo::typeFromAST($schema, $varDefNode->type);

            if (! Type::isInputType($varType)) {
                // Must use input types for variables. This should be caught during
                // validation, however is checked again here for safety.
                $errors[] = new Error(
                    sprintf(
                        'Variable "$%s" expected value of type "%s" which cannot be used as an input type.',
                        $varName,
                        Printer::doPrint($varDefNode->type)
                    ),
                    [$varDefNode->type]
                );
            } else {
                $hasValue = array_key_exists($varName, $inputs);
                $value    = $hasValue ? $inputs[$varName] : Utils::undefined();

                if (! $hasValue && ($varDefNode->defaultValue !== null)) {
                    // If no value was provided to a variable with a default value,
                    // use the default value.
                    $coercedValues[$varName] = AST::valueFromAST($varDefNode->defaultValue, $varType);
                } elseif ((! $hasValue || $value === null) && ($varType instanceof NonNull)) {
                    // If no value or a nullish value was provided to a variable with a
                    // non-null type (required), produce an error.
                    $errors[] = new Error(
                        sprintf(
                            $hasValue
                                ? 'Variable "$%s" of non-null type "%s" must not be null.'
                                : 'Variable "$%s" of required type "%s" was not provided.',
                            $varName,
                            Utils::printSafe($varType)
                        ),
                        [$varDefNode]
                    );
                } elseif ($hasValue) {
                    if ($value === null) {
                        // If the explicit value `null` was provided, an entry in the coerced
                        // values must exist as the value `null`.
                        $coercedValues[$varName] = null;
                    } else {
                        // Otherwise, a non-null value was provided, coerce it to the expected
                        // type or report an error if coercion fails.
                        $coerced = Value::coerceValue($value, $varType, $varDefNode);
                        /** @var Error[] $coercionErrors */
                        $coercionErrors = $coerced['errors'];
                        if (count($coercionErrors ?? []) > 0) {
                            $messagePrelude = sprintf(
                                'Variable "$%s" got invalid value %s; ',
                                $varName,
                                Utils::printSafeJson($value)
                            );

                            foreach ($coercionErrors as $error) {
                                $errors[] = new Error(
                                    $messagePrelude . $error->getMessage(),
                                    $error->getNodes(),
                                    $error->getSource(),
                                    $error->getPositions(),
                                    $error->getPath(),
                                    $error->getPrevious(),
                                    $error->getExtensions()
                                );
                            }
                        } else {
                            $coercedValues[$varName] = $coerced['value'];
                        }
                    }
                }
            }
        }

        if (count($errors) > 0) {
            return [$errors, null];
        }

        return [null, $coercedValues];
    }

    /**
     * Prepares an object map of argument values given a directive definition
     * and a AST node which may contain directives. Optionally also accepts a map
     * of variable values.
     *
     * If the directive does not exist on the node, returns undefined.
     *
     * @param FragmentSpreadNode|FieldNode|InlineFragmentNode|EnumValueDefinitionNode|FieldDefinitionNode $node
     * @param mixed[]|null                                                                                $variableValues
     *
     * @return mixed[]|null
     */
    public static function getDirectiveValues(Directive $directiveDef, $node, $variableValues = null)
    {
        if (isset($node->directives) && $node->directives instanceof NodeList) {
            $directiveNode = Utils::find(
                $node->directives,
                static function (DirectiveNode $directive) use ($directiveDef) : bool {
                    return $directive->name->value === $directiveDef->name;
                }
            );

            if ($directiveNode !== null) {
                return self::getArgumentValues($directiveDef, $directiveNode, $variableValues);
            }
        }

        return null;
    }

    /**
     * Prepares an object map of argument values given a list of argument
     * definitions and list of argument AST nodes.
     *
     * @param FieldDefinition|Directive $def
     * @param FieldNode|DirectiveNode   $node
     * @param mixed[]                   $variableValues
     *
     * @return mixed[]
     *
     * @throws Error
     */
    public static function getArgumentValues($def, $node, $variableValues = null)
    {
        if (count($def->args) === 0) {
            return [];
        }

        $argumentNodes    = $node->arguments ?? [];
        $argumentValueMap = [];
        foreach ($argumentNodes as $argumentNode) {
            $argumentValueMap[$argumentNode->name->value] = $argumentNode->value;
        }

        return static::getArgumentValuesForMap($def, $argumentValueMap, $variableValues, $node);
    }

    /**
     * @param FieldDefinition|Directive $fieldDefinition
     * @param ArgumentNode[]            $argumentValueMap
     * @param mixed[]                   $variableValues
     * @param Node|null                 $referenceNode
     *
     * @return mixed[]
     *
     * @throws Error
     */
    public static function getArgumentValuesForMap($fieldDefinition, $argumentValueMap, $variableValues = null, $referenceNode = null)
    {
        $argumentDefinitions = $fieldDefinition->args;
        $coercedValues       = [];

        foreach ($argumentDefinitions as $argumentDefinition) {
            $name              = $argumentDefinition->name;
            $argType           = $argumentDefinition->getType();
            $argumentValueNode = $argumentValueMap[$name] ?? null;

            if ($argumentValueNode instanceof VariableNode) {
                $variableName = $argumentValueNode->name->value;
                $hasValue     = array_key_exists($variableName, $variableValues ?? []);
                $isNull       = $hasValue ? $variableValues[$variableName] === null : false;
            } else {
                $hasValue = $argumentValueNode !== null;
                $isNull   = $argumentValueNode instanceof NullValueNode;
            }

            if (! $hasValue && $argumentDefinition->defaultValueExists()) {
                // If no argument was provided where the definition has a default value,
                // use the default value.
                $coercedValues[$name] = $argumentDefinition->defaultValue;
            } elseif ((! $hasValue || $isNull) && ($argType instanceof NonNull)) {
                // If no argument or a null value was provided to an argument with a
                // non-null type (required), produce a field error.
                if ($isNull) {
                    throw new Error(
                        'Argument "' . $name . '" of non-null type ' .
                        '"' . Utils::printSafe($argType) . '" must not be null.',
                        $referenceNode
                    );
                }

                if ($argumentValueNode instanceof VariableNode) {
                    $variableName = $argumentValueNode->name->value;
                    throw new Error(
                        'Argument "' . $name . '" of required type "' . Utils::printSafe($argType) . '" was ' .
                        'provided the variable "$' . $variableName . '" which was not provided ' .
                        'a runtime value.',
                        [$argumentValueNode]
                    );
                }

                throw new Error(
                    'Argument "' . $name . '" of required type ' .
                    '"' . Utils::printSafe($argType) . '" was not provided.',
                    $referenceNode
                );
            } elseif ($hasValue) {
                if ($argumentValueNode instanceof NullValueNode) {
                  // If the explicit value `null` was provided, an entry in the coerced
                  // values must exist as the value `null`.
                    $coercedValues[$name] = null;
                } elseif ($argumentValueNode instanceof VariableNode) {
                    $variableName = $argumentValueNode->name->value;
                    Utils::invariant($variableValues !== null, 'Must exist for hasValue to be true.');
                  // Note: This does no further checking that this variable is correct.
                  // This assumes that this query has been validated and the variable
                  // usage here is of the correct type.
                    $coercedValues[$name] = $variableValues[$variableName] ?? null;
                } else {
                    $valueNode    = $argumentValueNode;
                    $coercedValue = AST::valueFromAST($valueNode, $argType, $variableValues);
                    if (Utils::isInvalid($coercedValue)) {
                      // Note: ValuesOfCorrectType validation should catch this before
                      // execution. This is a runtime check to ensure execution does not
                      // continue with an invalid argument value.
                        throw new Error(
                            'Argument "' . $name . '" has invalid value ' . Printer::doPrint($valueNode) . '.',
                            [$argumentValueNode]
                        );
                    }
                    $coercedValues[$name] = $coercedValue;
                }
            }
        }

        return $coercedValues;
    }

    /**
     * @deprecated as of 8.0 (Moved to \GraphQL\Utils\AST::valueFromAST)
     *
     * @param VariableNode|NullValueNode|IntValueNode|FloatValueNode|StringValueNode|BooleanValueNode|EnumValueNode|ListValueNode|ObjectValueNode $valueNode
     * @param ScalarType|EnumType|InputObjectType|ListOfType|NonNull                                                                              $type
     * @param mixed[]|null                                                                                                                        $variables
     *
     * @return mixed[]|stdClass|null
     *
     * @codeCoverageIgnore
     */
    public static function valueFromAST(ValueNode $valueNode, InputType $type, ?array $variables = null)
    {
        return AST::valueFromAST($valueNode, $type, $variables);
    }

    /**
     * @deprecated as of 0.12 (Use coerceValue() directly for richer information)
     *
     * @param mixed[]                                                $value
     * @param ScalarType|EnumType|InputObjectType|ListOfType|NonNull $type
     *
     * @return string[]
     *
     * @codeCoverageIgnore
     */
    public static function isValidPHPValue($value, InputType $type)
    {
        $errors = Value::coerceValue($value, $type)['errors'];

        return $errors
            ? array_map(
                static function (Throwable $error) : string {
                    return $error->getMessage();
                },
                $errors
            )
            : [];
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Executor\Promise\Promise.php
<?php

declare(strict_types=1);

namespace GraphQL\Executor\Promise;

use GraphQL\Executor\Promise\Adapter\SyncPromise;
use GraphQL\Utils\Utils;
use React\Promise\Promise as ReactPromise;

/**
 * Convenience wrapper for promises represented by Promise Adapter
 */
class Promise
{
    /** @var SyncPromise|ReactPromise */
    public $adoptedPromise;

    /** @var PromiseAdapter */
    private $adapter;

    /**
     * @param mixed $adoptedPromise
     */
    public function __construct($adoptedPromise, PromiseAdapter $adapter)
    {
        Utils::invariant(! $adoptedPromise instanceof self, 'Expecting promise from adapted system, got ' . self::class);

        $this->adapter        = $adapter;
        $this->adoptedPromise = $adoptedPromise;
    }

    /**
     * @return Promise
     */
    public function then(?callable $onFulfilled = null, ?callable $onRejected = null)
    {
        return $this->adapter->then($this, $onFulfilled, $onRejected);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Executor\Promise\PromiseAdapter.php
<?php

declare(strict_types=1);

namespace GraphQL\Executor\Promise;

use Throwable;

/**
 * Provides a means for integration of async PHP platforms ([related docs](data-fetching.md#async-php))
 */
interface PromiseAdapter
{
    /**
     * Return true if the value is a promise or a deferred of the underlying platform
     *
     * @param mixed $value
     *
     * @return bool
     *
     * @api
     */
    public function isThenable($value);

    /**
     * Converts thenable of the underlying platform into GraphQL\Executor\Promise\Promise instance
     *
     * @param object $thenable
     *
     * @return Promise
     *
     * @api
     */
    public function convertThenable($thenable);

    /**
     * Accepts our Promise wrapper, extracts adopted promise out of it and executes actual `then` logic described
     * in Promises/A+ specs. Then returns new wrapped instance of GraphQL\Executor\Promise\Promise.
     *
     * @return Promise
     *
     * @api
     */
    public function then(Promise $promise, ?callable $onFulfilled = null, ?callable $onRejected = null);

    /**
     * Creates a Promise
     *
     * Expected resolver signature:
     *     function(callable $resolve, callable $reject)
     *
     * @return Promise
     *
     * @api
     */
    public function create(callable $resolver);

    /**
     * Creates a fulfilled Promise for a value if the value is not a promise.
     *
     * @param mixed $value
     *
     * @return Promise
     *
     * @api
     */
    public function createFulfilled($value = null);

    /**
     * Creates a rejected promise for a reason if the reason is not a promise. If
     * the provided reason is a promise, then it is returned as-is.
     *
     * @param Throwable $reason
     *
     * @return Promise
     *
     * @api
     */
    public function createRejected($reason);

    /**
     * Given an array of promises (or values), returns a promise that is fulfilled when all the
     * items in the array are fulfilled.
     *
     * @param Promise[]|mixed[] $promisesOrValues Promises or values.
     *
     * @return Promise
     *
     * @api
     */
    public function all(array $promisesOrValues);
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Executor\Promise\Adapter\AmpPromiseAdapter.php
<?php

declare(strict_types=1);

namespace GraphQL\Executor\Promise\Adapter;

use Amp\Deferred;
use Amp\Failure;
use Amp\Promise as AmpPromise;
use Amp\Success;
use GraphQL\Executor\Promise\Promise;
use GraphQL\Executor\Promise\PromiseAdapter;
use Throwable;
use function Amp\Promise\all;
use function array_replace;

class AmpPromiseAdapter implements PromiseAdapter
{
    /**
     * @inheritdoc
     */
    public function isThenable($value) : bool
    {
        return $value instanceof AmpPromise;
    }

    /**
     * @inheritdoc
     */
    public function convertThenable($thenable) : Promise
    {
        return new Promise($thenable, $this);
    }

    /**
     * @inheritdoc
     */
    public function then(Promise $promise, ?callable $onFulfilled = null, ?callable $onRejected = null) : Promise
    {
        $deferred  = new Deferred();
        $onResolve = static function (?Throwable $reason, $value) use ($onFulfilled, $onRejected, $deferred) : void {
            if ($reason === null && $onFulfilled !== null) {
                self::resolveWithCallable($deferred, $onFulfilled, $value);
            } elseif ($reason === null) {
                $deferred->resolve($value);
            } elseif ($onRejected !== null) {
                self::resolveWithCallable($deferred, $onRejected, $reason);
            } else {
                $deferred->fail($reason);
            }
        };

        /** @var AmpPromise $adoptedPromise */
        $adoptedPromise = $promise->adoptedPromise;
        $adoptedPromise->onResolve($onResolve);

        return new Promise($deferred->promise(), $this);
    }

    /**
     * @inheritdoc
     */
    public function create(callable $resolver) : Promise
    {
        $deferred = new Deferred();

        $resolver(
            static function ($value) use ($deferred) : void {
                $deferred->resolve($value);
            },
            static function (Throwable $exception) use ($deferred) : void {
                $deferred->fail($exception);
            }
        );

        return new Promise($deferred->promise(), $this);
    }

    /**
     * @inheritdoc
     */
    public function createFulfilled($value = null) : Promise
    {
        $promise = new Success($value);

        return new Promise($promise, $this);
    }

    /**
     * @inheritdoc
     */
    public function createRejected($reason) : Promise
    {
        $promise = new Failure($reason);

        return new Promise($promise, $this);
    }

    /**
     * @inheritdoc
     */
    public function all(array $promisesOrValues) : Promise
    {
        /** @var AmpPromise[] $promises */
        $promises = [];
        foreach ($promisesOrValues as $key => $item) {
            if ($item instanceof Promise) {
                $promises[$key] = $item->adoptedPromise;
            } elseif ($item instanceof AmpPromise) {
                $promises[$key] = $item;
            }
        }

        $deferred = new Deferred();

        $onResolve = static function (?Throwable $reason, ?array $values) use ($promisesOrValues, $deferred) : void {
            if ($reason === null) {
                $deferred->resolve(array_replace($promisesOrValues, $values));

                return;
            }

            $deferred->fail($reason);
        };

        all($promises)->onResolve($onResolve);

        return new Promise($deferred->promise(), $this);
    }

    private static function resolveWithCallable(Deferred $deferred, callable $callback, $argument) : void
    {
        try {
            $result = $callback($argument);
        } catch (Throwable $exception) {
            $deferred->fail($exception);

            return;
        }

        if ($result instanceof Promise) {
            $result = $result->adoptedPromise;
        }

        $deferred->resolve($result);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Executor\Promise\Adapter\ReactPromiseAdapter.php
<?php

declare(strict_types=1);

namespace GraphQL\Executor\Promise\Adapter;

use GraphQL\Executor\Promise\Promise;
use GraphQL\Executor\Promise\PromiseAdapter;
use GraphQL\Utils\Utils;
use React\Promise\Promise as ReactPromise;
use React\Promise\PromiseInterface as ReactPromiseInterface;
use function React\Promise\all;
use function React\Promise\reject;
use function React\Promise\resolve;

class ReactPromiseAdapter implements PromiseAdapter
{
    /**
     * @inheritdoc
     */
    public function isThenable($value)
    {
        return $value instanceof ReactPromiseInterface;
    }

    /**
     * @inheritdoc
     */
    public function convertThenable($thenable)
    {
        return new Promise($thenable, $this);
    }

    /**
     * @inheritdoc
     */
    public function then(Promise $promise, ?callable $onFulfilled = null, ?callable $onRejected = null)
    {
        /** @var ReactPromiseInterface $adoptedPromise */
        $adoptedPromise = $promise->adoptedPromise;

        return new Promise($adoptedPromise->then($onFulfilled, $onRejected), $this);
    }

    /**
     * @inheritdoc
     */
    public function create(callable $resolver)
    {
        $promise = new ReactPromise($resolver);

        return new Promise($promise, $this);
    }

    /**
     * @inheritdoc
     */
    public function createFulfilled($value = null)
    {
        $promise = resolve($value);

        return new Promise($promise, $this);
    }

    /**
     * @inheritdoc
     */
    public function createRejected($reason)
    {
        $promise = reject($reason);

        return new Promise($promise, $this);
    }

    /**
     * @inheritdoc
     */
    public function all(array $promisesOrValues)
    {
        // TODO: rework with generators when PHP minimum required version is changed to 5.5+
        $promisesOrValues = Utils::map(
            $promisesOrValues,
            static function ($item) {
                return $item instanceof Promise ? $item->adoptedPromise : $item;
            }
        );

        $promise = all($promisesOrValues)->then(static function ($values) use ($promisesOrValues) : array {
            $orderedResults = [];

            foreach ($promisesOrValues as $key => $value) {
                $orderedResults[$key] = $values[$key];
            }

            return $orderedResults;
        });

        return new Promise($promise, $this);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Executor\Promise\Adapter\SyncPromise.php
<?php

declare(strict_types=1);

namespace GraphQL\Executor\Promise\Adapter;

use Exception;
use GraphQL\Utils\Utils;
use SplQueue;
use Throwable;
use function is_object;
use function method_exists;

/**
 * Simplistic (yet full-featured) implementation of Promises A+ spec for regular PHP `sync` mode
 * (using queue to defer promises execution)
 *
 * Note:
 * Library users are not supposed to use SyncPromise class in their resolvers.
 * Instead they should use GraphQL\Deferred which enforces $executor callback in the constructor.
 *
 * Root SyncPromise without explicit $executor will never resolve (actually throw while trying).
 * The whole point of Deferred is to ensure it never happens and that any resolver creates
 * at least one $executor to start the promise chain.
 */
class SyncPromise
{
    const PENDING   = 'pending';
    const FULFILLED = 'fulfilled';
    const REJECTED  = 'rejected';

    /** @var SplQueue */
    public static $queue;

    /** @var string */
    public $state = self::PENDING;

    /** @var mixed */
    public $result;

    /**
     * Promises created in `then` method of this promise and awaiting for resolution of this promise
     *
     * @var mixed[][]
     */
    private $waiting = [];

    public static function runQueue() : void
    {
        $q = self::$queue;
        while ($q !== null && ! $q->isEmpty()) {
            $task = $q->dequeue();
            $task();
        }
    }

    /**
     * @param callable() : mixed $executor
     */
    public function __construct(?callable $executor = null)
    {
        if ($executor === null) {
            return;
        }
        self::getQueue()->enqueue(function () use ($executor) : void {
            try {
                $this->resolve($executor());
            } catch (Throwable $e) {
                $this->reject($e);
            }
        });
    }

    public function resolve($value) : self
    {
        switch ($this->state) {
            case self::PENDING:
                if ($value === $this) {
                    throw new Exception('Cannot resolve promise with self');
                }
                if (is_object($value) && method_exists($value, 'then')) {
                    $value->then(
                        function ($resolvedValue) : void {
                            $this->resolve($resolvedValue);
                        },
                        function ($reason) : void {
                            $this->reject($reason);
                        }
                    );

                    return $this;
                }

                $this->state  = self::FULFILLED;
                $this->result = $value;
                $this->enqueueWaitingPromises();
                break;
            case self::FULFILLED:
                if ($this->result !== $value) {
                    throw new Exception('Cannot change value of fulfilled promise');
                }
                break;
            case self::REJECTED:
                throw new Exception('Cannot resolve rejected promise');
        }

        return $this;
    }

    public function reject($reason) : self
    {
        if (! $reason instanceof Throwable) {
            throw new Exception('SyncPromise::reject() has to be called with an instance of \Throwable');
        }

        switch ($this->state) {
            case self::PENDING:
                $this->state  = self::REJECTED;
                $this->result = $reason;
                $this->enqueueWaitingPromises();
                break;
            case self::REJECTED:
                if ($reason !== $this->result) {
                    throw new Exception('Cannot change rejection reason');
                }
                break;
            case self::FULFILLED:
                throw new Exception('Cannot reject fulfilled promise');
        }

        return $this;
    }

    private function enqueueWaitingPromises() : void
    {
        Utils::invariant(
            $this->state !== self::PENDING,
            'Cannot enqueue derived promises when parent is still pending'
        );

        foreach ($this->waiting as $descriptor) {
            self::getQueue()->enqueue(function () use ($descriptor) : void {
                /** @var self $promise */
                [$promise, $onFulfilled, $onRejected] = $descriptor;

                if ($this->state === self::FULFILLED) {
                    try {
                        $promise->resolve($onFulfilled === null ? $this->result : $onFulfilled($this->result));
                    } catch (Throwable $e) {
                        $promise->reject($e);
                    }
                } elseif ($this->state === self::REJECTED) {
                    try {
                        if ($onRejected === null) {
                            $promise->reject($this->result);
                        } else {
                            $promise->resolve($onRejected($this->result));
                        }
                    } catch (Throwable $e) {
                        $promise->reject($e);
                    }
                }
            });
        }
        $this->waiting = [];
    }

    public static function getQueue() : SplQueue
    {
        return self::$queue ?? self::$queue = new SplQueue();
    }

    /**
     * @param callable(mixed) : mixed     $onFulfilled
     * @param callable(Throwable) : mixed $onRejected
     */
    public function then(?callable $onFulfilled = null, ?callable $onRejected = null) : self
    {
        if ($this->state === self::REJECTED && $onRejected === null) {
            return $this;
        }
        if ($this->state === self::FULFILLED && $onFulfilled === null) {
            return $this;
        }
        $tmp             = new self();
        $this->waiting[] = [$tmp, $onFulfilled, $onRejected];

        if ($this->state !== self::PENDING) {
            $this->enqueueWaitingPromises();
        }

        return $tmp;
    }

    /**
     * @param callable(Throwable) : mixed $onRejected
     */
    public function catch(callable $onRejected) : self
    {
        return $this->then(null, $onRejected);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Executor\Promise\Adapter\SyncPromiseAdapter.php
<?php

declare(strict_types=1);

namespace GraphQL\Executor\Promise\Adapter;

use GraphQL\Error\InvariantViolation;
use GraphQL\Executor\ExecutionResult;
use GraphQL\Executor\Promise\Promise;
use GraphQL\Executor\Promise\PromiseAdapter;
use GraphQL\Utils\Utils;
use Throwable;
use function count;

/**
 * Allows changing order of field resolution even in sync environments
 * (by leveraging queue of deferreds and promises)
 */
class SyncPromiseAdapter implements PromiseAdapter
{
    /**
     * @inheritdoc
     */
    public function isThenable($value)
    {
        return $value instanceof SyncPromise;
    }

    /**
     * @inheritdoc
     */
    public function convertThenable($thenable)
    {
        if (! $thenable instanceof SyncPromise) {
            // End-users should always use Deferred (and don't use SyncPromise directly)
            throw new InvariantViolation('Expected instance of GraphQL\Deferred, got ' . Utils::printSafe($thenable));
        }

        return new Promise($thenable, $this);
    }

    /**
     * @inheritdoc
     */
    public function then(Promise $promise, ?callable $onFulfilled = null, ?callable $onRejected = null)
    {
        /** @var SyncPromise $adoptedPromise */
        $adoptedPromise = $promise->adoptedPromise;

        return new Promise($adoptedPromise->then($onFulfilled, $onRejected), $this);
    }

    /**
     * @inheritdoc
     */
    public function create(callable $resolver)
    {
        $promise = new SyncPromise();

        try {
            $resolver(
                [
                    $promise,
                    'resolve',
                ],
                [
                    $promise,
                    'reject',
                ]
            );
        } catch (Throwable $e) {
            $promise->reject($e);
        }

        return new Promise($promise, $this);
    }

    /**
     * @inheritdoc
     */
    public function createFulfilled($value = null)
    {
        $promise = new SyncPromise();

        return new Promise($promise->resolve($value), $this);
    }

    /**
     * @inheritdoc
     */
    public function createRejected($reason)
    {
        $promise = new SyncPromise();

        return new Promise($promise->reject($reason), $this);
    }

    /**
     * @inheritdoc
     */
    public function all(array $promisesOrValues)
    {
        $all = new SyncPromise();

        $total  = count($promisesOrValues);
        $count  = 0;
        $result = [];

        foreach ($promisesOrValues as $index => $promiseOrValue) {
            if ($promiseOrValue instanceof Promise) {
                $result[$index] = null;
                $promiseOrValue->then(
                    static function ($value) use ($index, &$count, $total, &$result, $all) : void {
                        $result[$index] = $value;
                        $count++;
                        if ($count < $total) {
                            return;
                        }

                        $all->resolve($result);
                    },
                    [$all, 'reject']
                );
            } else {
                $result[$index] = $promiseOrValue;
                $count++;
            }
        }
        if ($count === $total) {
            $all->resolve($result);
        }

        return new Promise($all, $this);
    }

    /**
     * Synchronously wait when promise completes
     *
     * @return ExecutionResult
     */
    public function wait(Promise $promise)
    {
        $this->beforeWait($promise);
        $taskQueue = SyncPromise::getQueue();

        while ($promise->adoptedPromise->state === SyncPromise::PENDING &&
            ! $taskQueue->isEmpty()
        ) {
            SyncPromise::runQueue();
            $this->onWait($promise);
        }

        /** @var SyncPromise $syncPromise */
        $syncPromise = $promise->adoptedPromise;

        if ($syncPromise->state === SyncPromise::FULFILLED) {
            return $syncPromise->result;
        }

        if ($syncPromise->state === SyncPromise::REJECTED) {
            throw $syncPromise->result;
        }

        throw new InvariantViolation('Could not resolve promise');
    }

    /**
     * Execute just before starting to run promise completion
     */
    protected function beforeWait(Promise $promise)
    {
    }

    /**
     * Execute while running promise completion
     */
    protected function onWait(Promise $promise)
    {
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Experimental\Executor\Collector.php
<?php

declare(strict_types=1);

namespace GraphQL\Experimental\Executor;

use Generator;
use GraphQL\Error\Error;
use GraphQL\Language\AST\BooleanValueNode;
use GraphQL\Language\AST\DefinitionNode;
use GraphQL\Language\AST\DocumentNode;
use GraphQL\Language\AST\EnumValueNode;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\FloatValueNode;
use GraphQL\Language\AST\FragmentDefinitionNode;
use GraphQL\Language\AST\FragmentSpreadNode;
use GraphQL\Language\AST\InlineFragmentNode;
use GraphQL\Language\AST\IntValueNode;
use GraphQL\Language\AST\ListValueNode;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\NullValueNode;
use GraphQL\Language\AST\ObjectValueNode;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Language\AST\SelectionSetNode;
use GraphQL\Language\AST\StringValueNode;
use GraphQL\Language\AST\VariableNode;
use GraphQL\Type\Definition\AbstractType;
use GraphQL\Type\Definition\Directive;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Introspection;
use GraphQL\Type\Schema;
use function count;
use function sprintf;

/**
 * @internal
 */
class Collector
{
    /** @var Schema */
    private $schema;

    /** @var Runtime */
    private $runtime;

    /** @var OperationDefinitionNode|null */
    public $operation = null;

    /** @var FragmentDefinitionNode[] */
    public $fragments = [];

    /** @var ObjectType|null */
    public $rootType;

    /** @var FieldNode[][] */
    private $fields;

    /** @var array<string, bool> */
    private $visitedFragments;

    public function __construct(Schema $schema, Runtime $runtime)
    {
        $this->schema  = $schema;
        $this->runtime = $runtime;
    }

    public function initialize(DocumentNode $documentNode, ?string $operationName = null)
    {
        $hasMultipleAssumedOperations = false;

        foreach ($documentNode->definitions as $definitionNode) {
            /** @var DefinitionNode|Node $definitionNode */

            if ($definitionNode instanceof OperationDefinitionNode) {
                if ($operationName === null && $this->operation !== null) {
                    $hasMultipleAssumedOperations = true;
                }
                if ($operationName === null ||
                    (isset($definitionNode->name) && $definitionNode->name->value === $operationName)
                ) {
                    $this->operation = $definitionNode;
                }
            } elseif ($definitionNode instanceof FragmentDefinitionNode) {
                $this->fragments[$definitionNode->name->value] = $definitionNode;
            }
        }

        if ($this->operation === null) {
            if ($operationName !== null) {
                $this->runtime->addError(new Error(sprintf('Unknown operation named "%s".', $operationName)));
            } else {
                $this->runtime->addError(new Error('Must provide an operation.'));
            }

            return;
        }

        if ($hasMultipleAssumedOperations) {
            $this->runtime->addError(new Error('Must provide operation name if query contains multiple operations.'));

            return;
        }

        if ($this->operation->operation === 'query') {
            $this->rootType = $this->schema->getQueryType();
        } elseif ($this->operation->operation === 'mutation') {
            $this->rootType = $this->schema->getMutationType();
        } elseif ($this->operation->operation === 'subscription') {
            $this->rootType = $this->schema->getSubscriptionType();
        } else {
            $this->runtime->addError(new Error(sprintf('Cannot initialize collector with operation type "%s".', $this->operation->operation)));
        }
    }

    /**
     * @return Generator
     */
    public function collectFields(ObjectType $runtimeType, ?SelectionSetNode $selectionSet)
    {
        $this->fields           = [];
        $this->visitedFragments = [];

        $this->doCollectFields($runtimeType, $selectionSet);

        foreach ($this->fields as $resultName => $fieldNodes) {
            $fieldNode = $fieldNodes[0];
            $fieldName = $fieldNode->name->value;

            $argumentValueMap = null;
            if (count($fieldNode->arguments) > 0) {
                foreach ($fieldNode->arguments as $argumentNode) {
                    $argumentValueMap                             = $argumentValueMap ?? [];
                    $argumentValueMap[$argumentNode->name->value] = $argumentNode->value;
                }
            }

            if ($fieldName !== Introspection::TYPE_NAME_FIELD_NAME &&
                ! ($runtimeType === $this->schema->getQueryType() && ($fieldName === Introspection::SCHEMA_FIELD_NAME || $fieldName === Introspection::TYPE_FIELD_NAME)) &&
                ! $runtimeType->hasField($fieldName)
            ) {
                // do not emit error
                continue;
            }

            yield new CoroutineContextShared($fieldNodes, $fieldName, $resultName, $argumentValueMap);
        }
    }

    private function doCollectFields(ObjectType $runtimeType, ?SelectionSetNode $selectionSet)
    {
        if ($selectionSet === null) {
            return;
        }

        foreach ($selectionSet->selections as $selection) {
            /** @var FieldNode|FragmentSpreadNode|InlineFragmentNode $selection */
            if (count($selection->directives) > 0) {
                foreach ($selection->directives as $directiveNode) {
                    if ($directiveNode->name->value === Directive::SKIP_NAME) {
                        /** @var VariableNode|NullValueNode|IntValueNode|FloatValueNode|StringValueNode|BooleanValueNode|EnumValueNode|ListValueNode|ObjectValueNode|null $condition */
                        $condition = null;
                        foreach ($directiveNode->arguments as $argumentNode) {
                            if ($argumentNode->name->value === Directive::IF_ARGUMENT_NAME) {
                                $condition = $argumentNode->value;
                                break;
                            }
                        }

                        if ($condition === null) {
                            $this->runtime->addError(new Error(
                                sprintf('@%s directive is missing "%s" argument.', Directive::SKIP_NAME, Directive::IF_ARGUMENT_NAME),
                                $selection
                            ));
                        } else {
                            if ($this->runtime->evaluate($condition, Type::boolean()) === true) {
                                continue 2; // !!! advances outer loop
                            }
                        }
                    } elseif ($directiveNode->name->value === Directive::INCLUDE_NAME) {
                        /** @var VariableNode|NullValueNode|IntValueNode|FloatValueNode|StringValueNode|BooleanValueNode|EnumValueNode|ListValueNode|ObjectValueNode|null $condition */
                        $condition = null;
                        foreach ($directiveNode->arguments as $argumentNode) {
                            if ($argumentNode->name->value === Directive::IF_ARGUMENT_NAME) {
                                $condition = $argumentNode->value;
                                break;
                            }
                        }

                        if ($condition === null) {
                            $this->runtime->addError(new Error(
                                sprintf('@%s directive is missing "%s" argument.', Directive::INCLUDE_NAME, Directive::IF_ARGUMENT_NAME),
                                $selection
                            ));
                        } else {
                            if ($this->runtime->evaluate($condition, Type::boolean()) !== true) {
                                continue 2; // !!! advances outer loop
                            }
                        }
                    }
                }
            }

            if ($selection instanceof FieldNode) {
                $resultName = $selection->alias === null ? $selection->name->value : $selection->alias->value;

                if (! isset($this->fields[$resultName])) {
                    $this->fields[$resultName] = [];
                }

                $this->fields[$resultName][] = $selection;
            } elseif ($selection instanceof FragmentSpreadNode) {
                $fragmentName = $selection->name->value;

                if (isset($this->visitedFragments[$fragmentName])) {
                    continue;
                }

                if (! isset($this->fragments[$fragmentName])) {
                    $this->runtime->addError(new Error(
                        sprintf('Fragment "%s" does not exist.', $fragmentName),
                        $selection
                    ));
                    continue;
                }

                $this->visitedFragments[$fragmentName] = true;

                $fragmentDefinition = $this->fragments[$fragmentName];
                $conditionTypeName  = $fragmentDefinition->typeCondition->name->value;

                if (! $this->schema->hasType($conditionTypeName)) {
                    $this->runtime->addError(new Error(
                        sprintf('Cannot spread fragment "%s", type "%s" does not exist.', $fragmentName, $conditionTypeName),
                        $selection
                    ));
                    continue;
                }

                $conditionType = $this->schema->getType($conditionTypeName);

                if ($conditionType instanceof ObjectType) {
                    if ($runtimeType->name !== $conditionType->name) {
                        continue;
                    }
                } elseif ($conditionType instanceof AbstractType) {
                    if (! $this->schema->isSubType($conditionType, $runtimeType)) {
                        continue;
                    }
                }

                $this->doCollectFields($runtimeType, $fragmentDefinition->selectionSet);
            } elseif ($selection instanceof InlineFragmentNode) {
                if ($selection->typeCondition !== null) {
                    $conditionTypeName = $selection->typeCondition->name->value;

                    if (! $this->schema->hasType($conditionTypeName)) {
                        $this->runtime->addError(new Error(
                            sprintf('Cannot spread inline fragment, type "%s" does not exist.', $conditionTypeName),
                            $selection
                        ));
                        continue;
                    }

                    $conditionType = $this->schema->getType($conditionTypeName);

                    if ($conditionType instanceof ObjectType) {
                        if ($runtimeType->name !== $conditionType->name) {
                            continue;
                        }
                    } elseif ($conditionType instanceof AbstractType) {
                        if (! $this->schema->isSubType($conditionType, $runtimeType)) {
                            continue;
                        }
                    }
                }

                $this->doCollectFields($runtimeType, $selection->selectionSet);
            }
        }
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Experimental\Executor\CoroutineContext.php
<?php

declare(strict_types=1);

namespace GraphQL\Experimental\Executor;

use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\ResolveInfo;

/**
 * @internal
 */
class CoroutineContext
{
    /** @var CoroutineContextShared */
    public $shared;

    /** @var ObjectType */
    public $type;

    /** @var mixed */
    public $value;

    /** @var object */
    public $result;

    /** @var string[] */
    public $path;

    /** @var ResolveInfo */
    public $resolveInfo;

    /** @var string[]|null */
    public $nullFence;

    /**
     * @param mixed         $value
     * @param object        $result
     * @param string[]      $path
     * @param string[]|null $nullFence
     */
    public function __construct(
        CoroutineContextShared $shared,
        ObjectType $type,
        $value,
        $result,
        array $path,
        ?array $nullFence = null
    ) {
        $this->shared    = $shared;
        $this->type      = $type;
        $this->value     = $value;
        $this->result    = $result;
        $this->path      = $path;
        $this->nullFence = $nullFence;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Experimental\Executor\CoroutineContextShared.php
<?php

declare(strict_types=1);

namespace GraphQL\Experimental\Executor;

use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\SelectionSetNode;
use GraphQL\Language\AST\ValueNode;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\ResolveInfo;

/**
 * @internal
 */
class CoroutineContextShared
{
    /** @var FieldNode[] */
    public $fieldNodes;

    /** @var string */
    public $fieldName;

    /** @var string */
    public $resultName;

    /** @var ValueNode[]|null */
    public $argumentValueMap;

    /** @var SelectionSetNode|null */
    public $mergedSelectionSet;

    /** @var ObjectType|null */
    public $typeGuard1;

    /** @var callable|null */
    public $resolveIfType1;

    /** @var mixed */
    public $argumentsIfType1;

    /** @var ResolveInfo|null */
    public $resolveInfoIfType1;

    /** @var ObjectType|null */
    public $typeGuard2;

    /** @var CoroutineContext[]|null */
    public $childContextsIfType2;

    /**
     * @param FieldNode[]  $fieldNodes
     * @param mixed[]|null $argumentValueMap
     */
    public function __construct(array $fieldNodes, string $fieldName, string $resultName, ?array $argumentValueMap)
    {
        $this->fieldNodes       = $fieldNodes;
        $this->fieldName        = $fieldName;
        $this->resultName       = $resultName;
        $this->argumentValueMap = $argumentValueMap;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Experimental\Executor\CoroutineExecutor.php
<?php

declare(strict_types=1);

namespace GraphQL\Experimental\Executor;

use Generator;
use GraphQL\Error\Error;
use GraphQL\Error\InvariantViolation;
use GraphQL\Error\Warning;
use GraphQL\Executor\ExecutionResult;
use GraphQL\Executor\ExecutorImplementation;
use GraphQL\Executor\Promise\Promise;
use GraphQL\Executor\Promise\PromiseAdapter;
use GraphQL\Executor\Values;
use GraphQL\Language\AST\DocumentNode;
use GraphQL\Language\AST\SelectionSetNode;
use GraphQL\Language\AST\ValueNode;
use GraphQL\Type\Definition\AbstractType;
use GraphQL\Type\Definition\CompositeType;
use GraphQL\Type\Definition\EnumType;
use GraphQL\Type\Definition\InputObjectType;
use GraphQL\Type\Definition\InputType;
use GraphQL\Type\Definition\InterfaceType;
use GraphQL\Type\Definition\LeafType;
use GraphQL\Type\Definition\ListOfType;
use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\ResolveInfo;
use GraphQL\Type\Definition\ScalarType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Definition\UnionType;
use GraphQL\Type\Introspection;
use GraphQL\Type\Schema;
use GraphQL\Utils\AST;
use GraphQL\Utils\Utils;
use SplQueue;
use stdClass;
use Throwable;
use function count;
use function is_array;
use function is_string;
use function sprintf;

class CoroutineExecutor implements Runtime, ExecutorImplementation
{
    /** @var object */
    private static $undefined;

    /** @var Schema */
    private $schema;

    /** @var callable */
    private $fieldResolver;

    /** @var PromiseAdapter */
    private $promiseAdapter;

    /** @var mixed|null */
    private $rootValue;

    /** @var mixed|null */
    private $contextValue;

    /** @var mixed|null */
    private $rawVariableValues;

    /** @var mixed|null */
    private $variableValues;

    /** @var DocumentNode */
    private $documentNode;

    /** @var string|null */
    private $operationName;

    /** @var Collector|null */
    private $collector;

    /** @var array<Error> */
    private $errors;

    /** @var SplQueue */
    private $queue;

    /** @var SplQueue */
    private $schedule;

    /** @var stdClass|null */
    private $rootResult;

    /** @var int|null */
    private $pending;

    /** @var callable */
    private $doResolve;

    public function __construct(
        PromiseAdapter $promiseAdapter,
        Schema $schema,
        DocumentNode $documentNode,
        $rootValue,
        $contextValue,
        $rawVariableValues,
        ?string $operationName,
        callable $fieldResolver
    ) {
        if (self::$undefined === null) {
            self::$undefined = Utils::undefined();
        }

        $this->errors            = [];
        $this->queue             = new SplQueue();
        $this->schedule          = new SplQueue();
        $this->schema            = $schema;
        $this->fieldResolver     = $fieldResolver;
        $this->promiseAdapter    = $promiseAdapter;
        $this->rootValue         = $rootValue;
        $this->contextValue      = $contextValue;
        $this->rawVariableValues = $rawVariableValues;
        $this->documentNode      = $documentNode;
        $this->operationName     = $operationName;
    }

    public static function create(
        PromiseAdapter $promiseAdapter,
        Schema $schema,
        DocumentNode $documentNode,
        $rootValue,
        $contextValue,
        $variableValues,
        ?string $operationName,
        callable $fieldResolver
    ) {
        return new static(
            $promiseAdapter,
            $schema,
            $documentNode,
            $rootValue,
            $contextValue,
            $variableValues,
            $operationName,
            $fieldResolver
        );
    }

    private static function resultToArray($value, $emptyObjectAsStdClass = true)
    {
        if ($value instanceof stdClass) {
            $array = (array) $value;
            foreach ($array as $propertyName => $propertyValue) {
                $array[$propertyName] = self::resultToArray($propertyValue);
            }

            if ($emptyObjectAsStdClass && count($array) === 0) {
                return new stdClass();
            }

            return $array;
        }

        if (is_array($value)) {
            $array = [];
            foreach ($value as $key => $item) {
                $array[$key] = self::resultToArray($item);
            }

            return $array;
        }

        return $value;
    }

    public function doExecute() : Promise
    {
        $this->rootResult = new stdClass();
        $this->errors     = [];
        $this->queue      = new SplQueue();
        $this->schedule   = new SplQueue();
        $this->pending    = 0;

        $this->collector = new Collector($this->schema, $this);
        $this->collector->initialize($this->documentNode, $this->operationName);

        if (count($this->errors) > 0) {
            return $this->promiseAdapter->createFulfilled($this->finishExecute(null, $this->errors));
        }

        [$errors, $coercedVariableValues] = Values::getVariableValues(
            $this->schema,
            $this->collector->operation->variableDefinitions ?? [],
            $this->rawVariableValues ?? []
        );

        if (count($errors ?? []) > 0) {
            return $this->promiseAdapter->createFulfilled($this->finishExecute(null, $errors));
        }

        $this->variableValues = $coercedVariableValues;

        foreach ($this->collector->collectFields($this->collector->rootType, $this->collector->operation->selectionSet) as $shared) {
            /** @var CoroutineContextShared $shared */

            // !!! assign to keep object keys sorted
            $this->rootResult->{$shared->resultName} = null;

            $ctx = new CoroutineContext(
                $shared,
                $this->collector->rootType,
                $this->rootValue,
                $this->rootResult,
                [$shared->resultName]
            );

            $fieldDefinition = $this->findFieldDefinition($ctx);
            if (! $fieldDefinition->getType() instanceof NonNull) {
                $ctx->nullFence = [$shared->resultName];
            }

            if ($this->collector->operation->operation === 'mutation' && ! $this->queue->isEmpty()) {
                $this->schedule->enqueue($ctx);
            } else {
                $this->queue->enqueue(new Strand($this->spawn($ctx)));
            }
        }

        $this->run();

        if ($this->pending > 0) {
            return $this->promiseAdapter->create(function (callable $resolve) : void {
                $this->doResolve = $resolve;
            });
        }

        return $this->promiseAdapter->createFulfilled($this->finishExecute($this->rootResult, $this->errors));
    }

    /**
     * @param object|null $value
     * @param Error[]     $errors
     */
    private function finishExecute($value, array $errors) : ExecutionResult
    {
        $this->rootResult     = null;
        $this->errors         = [];
        $this->queue          = new SplQueue();
        $this->schedule       = new SplQueue();
        $this->pending        = null;
        $this->collector      = null;
        $this->variableValues = null;

        if ($value !== null) {
            $value = self::resultToArray($value, false);
        }

        return new ExecutionResult($value, $errors);
    }

    /**
     * @internal
     *
     * @param ScalarType|EnumType|InputObjectType|ListOfType|NonNull $type
     */
    public function evaluate(ValueNode $valueNode, InputType $type)
    {
        return AST::valueFromAST($valueNode, $type, $this->variableValues);
    }

    /**
     * @internal
     */
    public function addError($error)
    {
        $this->errors[] = $error;
    }

    private function run()
    {
        RUN:
        while (! $this->queue->isEmpty()) {
            /** @var Strand $strand */
            $strand = $this->queue->dequeue();

            try {
                if ($strand->success !== null) {
                    RESUME:

                    if ($strand->success) {
                        $strand->current->send($strand->value);
                    } else {
                        $strand->current->throw($strand->value);
                    }

                    $strand->success = null;
                    $strand->value   = null;
                }

                START:
                if ($strand->current->valid()) {
                    $value = $strand->current->current();

                    if ($value instanceof Generator) {
                        $strand->stack[$strand->depth++] = $strand->current;
                        $strand->current                 = $value;
                        goto START;
                    } elseif ($this->isPromise($value)) {
                        // !!! increment pending before calling ->then() as it may invoke the callback right away
                        ++$this->pending;

                        if (! $value instanceof Promise) {
                            $value = $this->promiseAdapter->convertThenable($value);
                        }

                        $this->promiseAdapter
                            ->then(
                                $value,
                                function ($value) use ($strand) : void {
                                    $strand->success = true;
                                    $strand->value   = $value;
                                    $this->queue->enqueue($strand);
                                    $this->done();
                                },
                                function (Throwable $throwable) use ($strand) : void {
                                    $strand->success = false;
                                    $strand->value   = $throwable;
                                    $this->queue->enqueue($strand);
                                    $this->done();
                                }
                            );
                        continue;
                    } else {
                        $strand->success = true;
                        $strand->value   = $value;
                        goto RESUME;
                    }
                }

                $strand->success = true;
                $strand->value   = $strand->current->getReturn();
            } catch (Throwable $reason) {
                $strand->success = false;
                $strand->value   = $reason;
            }

            if ($strand->depth <= 0) {
                continue;
            }

            $current         = &$strand->stack[--$strand->depth];
            $strand->current = $current;
            $current         = null;
            goto RESUME;
        }

        if ($this->pending > 0 || $this->schedule->isEmpty()) {
            return;
        }

        /** @var CoroutineContext $ctx */
        $ctx = $this->schedule->dequeue();
        $this->queue->enqueue(new Strand($this->spawn($ctx)));
        goto RUN;
    }

    private function done()
    {
        --$this->pending;

        $this->run();

        if ($this->pending > 0) {
            return;
        }

        $doResolve = $this->doResolve;
        $doResolve($this->finishExecute($this->rootResult, $this->errors));
    }

    private function spawn(CoroutineContext $ctx)
    {
        // short-circuit evaluation for __typename
        if ($ctx->shared->fieldName === Introspection::TYPE_NAME_FIELD_NAME) {
            $ctx->result->{$ctx->shared->resultName} = $ctx->type->name;

            return;
        }

        try {
            if ($ctx->shared->typeGuard1 === $ctx->type) {
                $resolve                = $ctx->shared->resolveIfType1;
                $ctx->resolveInfo       = clone $ctx->shared->resolveInfoIfType1;
                $ctx->resolveInfo->path = $ctx->path;
                $arguments              = $ctx->shared->argumentsIfType1;
                $returnType             = $ctx->resolveInfo->returnType;
            } else {
                $fieldDefinition = $this->findFieldDefinition($ctx);

                if ($fieldDefinition->resolveFn !== null) {
                    $resolve = $fieldDefinition->resolveFn;
                } elseif ($ctx->type->resolveFieldFn !== null) {
                    $resolve = $ctx->type->resolveFieldFn;
                } else {
                    $resolve = $this->fieldResolver;
                }

                $returnType = $fieldDefinition->getType();

                $ctx->resolveInfo = new ResolveInfo(
                    $fieldDefinition,
                    $ctx->shared->fieldNodes,
                    $ctx->type,
                    $ctx->path,
                    $this->schema,
                    $this->collector->fragments,
                    $this->rootValue,
                    $this->collector->operation,
                    $this->variableValues
                );

                $arguments = Values::getArgumentValuesForMap(
                    $fieldDefinition,
                    $ctx->shared->argumentValueMap,
                    $this->variableValues
                );

                // !!! assign only in batch when no exception can be thrown in-between
                $ctx->shared->typeGuard1         = $ctx->type;
                $ctx->shared->resolveIfType1     = $resolve;
                $ctx->shared->argumentsIfType1   = $arguments;
                $ctx->shared->resolveInfoIfType1 = $ctx->resolveInfo;
            }

            $value = $resolve($ctx->value, $arguments, $this->contextValue, $ctx->resolveInfo);

            if (! $this->completeValueFast($ctx, $returnType, $value, $ctx->path, $returnValue)) {
                $returnValue = yield $this->completeValue(
                    $ctx,
                    $returnType,
                    $value,
                    $ctx->path,
                    $ctx->nullFence
                );
            }
        } catch (Throwable $reason) {
            $this->addError(Error::createLocatedError(
                $reason,
                $ctx->shared->fieldNodes,
                $ctx->path
            ));

            $returnValue = self::$undefined;
        }

        if ($returnValue !== self::$undefined) {
            $ctx->result->{$ctx->shared->resultName} = $returnValue;
        } elseif ($ctx->resolveInfo !== null && $ctx->resolveInfo->returnType instanceof NonNull) { // !!! $ctx->resolveInfo might not have been initialized yet
            $result =& $this->rootResult;
            foreach ($ctx->nullFence ?? [] as $key) {
                if (is_string($key)) {
                    $result =& $result->{$key};
                } else {
                    $result =& $result[$key];
                }
            }
            $result = null;
        }
    }

    private function findFieldDefinition(CoroutineContext $ctx)
    {
        if ($ctx->shared->fieldName === Introspection::SCHEMA_FIELD_NAME && $ctx->type === $this->schema->getQueryType()) {
            return Introspection::schemaMetaFieldDef();
        }

        if ($ctx->shared->fieldName === Introspection::TYPE_FIELD_NAME && $ctx->type === $this->schema->getQueryType()) {
            return Introspection::typeMetaFieldDef();
        }

        if ($ctx->shared->fieldName === Introspection::TYPE_NAME_FIELD_NAME) {
            return Introspection::typeNameMetaFieldDef();
        }

        return $ctx->type->getField($ctx->shared->fieldName);
    }

    /**
     * @param mixed    $value
     * @param string[] $path
     * @param mixed    $returnValue
     */
    private function completeValueFast(CoroutineContext $ctx, Type $type, $value, array $path, &$returnValue) : bool
    {
        // special handling of Throwable inherited from JS reference implementation, but makes no sense in this PHP
        if ($this->isPromise($value) || $value instanceof Throwable) {
            return false;
        }

        $nonNull = false;
        if ($type instanceof NonNull) {
            $nonNull = true;
            $type    = $type->getWrappedType();
        }

        if (! $type instanceof LeafType) {
            return false;
        }

        if ($type !== $this->schema->getType($type->name)) {
            $hint = '';
            if ($this->schema->getConfig()->typeLoader !== null) {
                $hint = sprintf(
                    'Make sure that type loader returns the same instance as defined in %s.%s',
                    $ctx->type,
                    $ctx->shared->fieldName
                );
            }
            $this->addError(Error::createLocatedError(
                new InvariantViolation(
                    sprintf(
                        'Schema must contain unique named types but contains multiple types named "%s". %s ' .
                        '(see http://webonyx.github.io/graphql-php/type-system/#type-registry).',
                        $type->name,
                        $hint
                    )
                ),
                $ctx->shared->fieldNodes,
                $path
            ));

            $value = null;
        }

        if ($value === null) {
            $returnValue = null;
        } else {
            try {
                $returnValue = $type->serialize($value);
            } catch (Throwable $error) {
                $this->addError(Error::createLocatedError(
                    new InvariantViolation(
                        'Expected a value of type "' . Utils::printSafe($type) . '" but received: ' . Utils::printSafe($value),
                        0,
                        $error
                    ),
                    $ctx->shared->fieldNodes,
                    $path
                ));
                $returnValue = null;
            }
        }

        if ($nonNull && $returnValue === null) {
            $this->addError(Error::createLocatedError(
                new InvariantViolation(sprintf(
                    'Cannot return null for non-nullable field "%s.%s".',
                    $ctx->type->name,
                    $ctx->shared->fieldName
                )),
                $ctx->shared->fieldNodes,
                $path
            ));

            $returnValue = self::$undefined;
        }

        return true;
    }

    /**
     * @param mixed         $value
     * @param string[]      $path
     * @param string[]|null $nullFence
     *
     * @return mixed
     */
    private function completeValue(CoroutineContext $ctx, Type $type, $value, array $path, ?array $nullFence)
    {
        $nonNull     = false;
        $returnValue = null;

        if ($type instanceof NonNull) {
            $nonNull = true;
            $type    = $type->getWrappedType();
        } else {
            $nullFence = $path;
        }

        // !!! $value might be promise, yield to resolve
        try {
            if ($this->isPromise($value)) {
                $value = yield $value;
            }
        } catch (Throwable $reason) {
            $this->addError(Error::createLocatedError(
                $reason,
                $ctx->shared->fieldNodes,
                $path
            ));
            if ($nonNull) {
                $returnValue = self::$undefined;
            } else {
                $returnValue = null;
            }
            goto CHECKED_RETURN;
        }

        if ($value === null) {
            $returnValue = $value;
            goto CHECKED_RETURN;
        } elseif ($value instanceof Throwable) {
            // special handling of Throwable inherited from JS reference implementation, but makes no sense in this PHP
            $this->addError(Error::createLocatedError(
                $value,
                $ctx->shared->fieldNodes,
                $path
            ));
            if ($nonNull) {
                $returnValue = self::$undefined;
            } else {
                $returnValue = null;
            }
            goto CHECKED_RETURN;
        }

        if ($type instanceof ListOfType) {
            $returnValue = [];
            $index       = -1;
            $itemType    = $type->getWrappedType();
            foreach ($value as $itemValue) {
                ++$index;

                $itemPath               = $path;
                $itemPath[]             = $index; // !!! use arrays COW semantics
                $ctx->resolveInfo->path = $itemPath;

                try {
                    if (! $this->completeValueFast($ctx, $itemType, $itemValue, $itemPath, $itemReturnValue)) {
                        $itemReturnValue = yield $this->completeValue($ctx, $itemType, $itemValue, $itemPath, $nullFence);
                    }
                } catch (Throwable $reason) {
                    $this->addError(Error::createLocatedError(
                        $reason,
                        $ctx->shared->fieldNodes,
                        $itemPath
                    ));
                    $itemReturnValue = null;
                }
                if ($itemReturnValue === self::$undefined) {
                    $returnValue = self::$undefined;
                    goto CHECKED_RETURN;
                }
                $returnValue[$index] = $itemReturnValue;
            }

            goto CHECKED_RETURN;
        } else {
            if ($type !== $this->schema->getType($type->name)) {
                $hint = '';
                if ($this->schema->getConfig()->typeLoader !== null) {
                    $hint = sprintf(
                        'Make sure that type loader returns the same instance as defined in %s.%s',
                        $ctx->type,
                        $ctx->shared->fieldName
                    );
                }
                $this->addError(Error::createLocatedError(
                    new InvariantViolation(
                        sprintf(
                            'Schema must contain unique named types but contains multiple types named "%s". %s ' .
                            '(see http://webonyx.github.io/graphql-php/type-system/#type-registry).',
                            $type->name,
                            $hint
                        )
                    ),
                    $ctx->shared->fieldNodes,
                    $path
                ));

                $returnValue = null;
                goto CHECKED_RETURN;
            }

            if ($type instanceof LeafType) {
                try {
                    $returnValue = $type->serialize($value);
                } catch (Throwable $error) {
                    $this->addError(Error::createLocatedError(
                        new InvariantViolation(
                            'Expected a value of type "' . Utils::printSafe($type) . '" but received: ' . Utils::printSafe($value),
                            0,
                            $error
                        ),
                        $ctx->shared->fieldNodes,
                        $path
                    ));
                    $returnValue = null;
                }
                goto CHECKED_RETURN;
            } elseif ($type instanceof CompositeType) {
                /** @var ObjectType|null $objectType */
                $objectType = null;
                if ($type instanceof InterfaceType || $type instanceof UnionType) {
                    $objectType = $type->resolveType($value, $this->contextValue, $ctx->resolveInfo);

                    if ($objectType === null) {
                        $objectType = yield $this->resolveTypeSlow($ctx, $value, $type);
                    }

                    // !!! $objectType->resolveType() might return promise, yield to resolve
                    $objectType = yield $objectType;
                    if (is_string($objectType)) {
                        $objectType = $this->schema->getType($objectType);
                    }

                    if ($objectType === null) {
                        $this->addError(Error::createLocatedError(
                            sprintf(
                                'Composite type "%s" did not resolve concrete object type for value: %s.',
                                $type->name,
                                Utils::printSafe($value)
                            ),
                            $ctx->shared->fieldNodes,
                            $path
                        ));

                        $returnValue = self::$undefined;
                        goto CHECKED_RETURN;
                    } elseif (! $objectType instanceof ObjectType) {
                        $this->addError(Error::createLocatedError(
                            new InvariantViolation(sprintf(
                                'Abstract type %s must resolve to an Object type at ' .
                                'runtime for field %s.%s with value "%s", received "%s". ' .
                                'Either the %s type should provide a "resolveType" ' .
                                'function or each possible type should provide an "isTypeOf" function.',
                                $type,
                                $ctx->resolveInfo->parentType,
                                $ctx->resolveInfo->fieldName,
                                Utils::printSafe($value),
                                Utils::printSafe($objectType),
                                $type
                            )),
                            $ctx->shared->fieldNodes,
                            $path
                        ));

                        $returnValue = null;
                        goto CHECKED_RETURN;
                    } elseif (! $this->schema->isSubType($type, $objectType)) {
                        $this->addError(Error::createLocatedError(
                            new InvariantViolation(sprintf(
                                'Runtime Object type "%s" is not a possible type for "%s".',
                                $objectType,
                                $type
                            )),
                            $ctx->shared->fieldNodes,
                            $path
                        ));

                        $returnValue = null;
                        goto CHECKED_RETURN;
                    } elseif ($objectType !== $this->schema->getType($objectType->name)) {
                        $this->addError(Error::createLocatedError(
                            new InvariantViolation(
                                sprintf(
                                    'Schema must contain unique named types but contains multiple types named "%s". ' .
                                    'Make sure that `resolveType` function of abstract type "%s" returns the same ' .
                                    'type instance as referenced anywhere else within the schema ' .
                                    '(see http://webonyx.github.io/graphql-php/type-system/#type-registry).',
                                    $objectType,
                                    $type
                                )
                            ),
                            $ctx->shared->fieldNodes,
                            $path
                        ));

                        $returnValue = null;
                        goto CHECKED_RETURN;
                    }
                } elseif ($type instanceof ObjectType) {
                    $objectType = $type;
                } else {
                    $this->addError(Error::createLocatedError(
                        sprintf(
                            'Unexpected field type "%s".',
                            Utils::printSafe($type)
                        ),
                        $ctx->shared->fieldNodes,
                        $path
                    ));

                    $returnValue = self::$undefined;
                    goto CHECKED_RETURN;
                }

                $typeCheck = $objectType->isTypeOf($value, $this->contextValue, $ctx->resolveInfo);
                if ($typeCheck !== null) {
                    // !!! $objectType->isTypeOf() might return promise, yield to resolve
                    $typeCheck = yield $typeCheck;
                    if (! $typeCheck) {
                        $this->addError(Error::createLocatedError(
                            sprintf('Expected value of type "%s" but got: %s.', $type->name, Utils::printSafe($value)),
                            $ctx->shared->fieldNodes,
                            $path
                        ));

                        $returnValue = null;
                        goto CHECKED_RETURN;
                    }
                }

                $returnValue = new stdClass();

                if ($ctx->shared->typeGuard2 === $objectType) {
                    foreach ($ctx->shared->childContextsIfType2 as $childCtx) {
                        $childCtx              = clone $childCtx;
                        $childCtx->type        = $objectType;
                        $childCtx->value       = $value;
                        $childCtx->result      = $returnValue;
                        $childCtx->path        = $path;
                        $childCtx->path[]      = $childCtx->shared->resultName; // !!! uses array COW semantics
                        $childCtx->nullFence   = $nullFence;
                        $childCtx->resolveInfo = null;

                        $this->queue->enqueue(new Strand($this->spawn($childCtx)));

                        // !!! assign null to keep object keys sorted
                        $returnValue->{$childCtx->shared->resultName} = null;
                    }
                } else {
                    $childContexts = [];

                    $fields = [];
                    if ($this->collector !== null) {
                        $fields = $this->collector->collectFields(
                            $objectType,
                            $ctx->shared->mergedSelectionSet ?? $this->mergeSelectionSets($ctx)
                        );
                    }

                    /** @var CoroutineContextShared $childShared */
                    foreach ($fields as $childShared) {
                        $childPath   = $path;
                        $childPath[] = $childShared->resultName; // !!! uses array COW semantics
                        $childCtx    = new CoroutineContext(
                            $childShared,
                            $objectType,
                            $value,
                            $returnValue,
                            $childPath,
                            $nullFence
                        );

                        $childContexts[] = $childCtx;

                        $this->queue->enqueue(new Strand($this->spawn($childCtx)));

                        // !!! assign null to keep object keys sorted
                        $returnValue->{$childShared->resultName} = null;
                    }

                    $ctx->shared->typeGuard2           = $objectType;
                    $ctx->shared->childContextsIfType2 = $childContexts;
                }

                goto CHECKED_RETURN;
            } else {
                $this->addError(Error::createLocatedError(
                    sprintf('Unhandled type "%s".', Utils::printSafe($type)),
                    $ctx->shared->fieldNodes,
                    $path
                ));

                $returnValue = null;
                goto CHECKED_RETURN;
            }
        }

        CHECKED_RETURN:
        if ($nonNull && $returnValue === null) {
            $this->addError(Error::createLocatedError(
                new InvariantViolation(sprintf(
                    'Cannot return null for non-nullable field "%s.%s".',
                    $ctx->type->name,
                    $ctx->shared->fieldName
                )),
                $ctx->shared->fieldNodes,
                $path
            ));

            return self::$undefined;
        }

        return $returnValue;
    }

    private function mergeSelectionSets(CoroutineContext $ctx)
    {
        $selections = [];

        foreach ($ctx->shared->fieldNodes as $fieldNode) {
            if ($fieldNode->selectionSet === null) {
                continue;
            }

            foreach ($fieldNode->selectionSet->selections as $selection) {
                $selections[] = $selection;
            }
        }

        return $ctx->shared->mergedSelectionSet = new SelectionSetNode(['selections' => $selections]);
    }

    /**
     * @param InterfaceType|UnionType $abstractType
     *
     * @return Generator|ObjectType|Type|null
     */
    private function resolveTypeSlow(CoroutineContext $ctx, $value, AbstractType $abstractType)
    {
        if ($value !== null &&
            is_array($value) &&
            isset($value['__typename']) &&
            is_string($value['__typename'])
        ) {
            return $this->schema->getType($value['__typename']);
        }

        if ($abstractType instanceof InterfaceType && $this->schema->getConfig()->typeLoader !== null) {
            Warning::warnOnce(
                sprintf(
                    'GraphQL Interface Type `%s` returned `null` from its `resolveType` function ' .
                    'for value: %s. Switching to slow resolution method using `isTypeOf` ' .
                    'of all possible implementations. It requires full schema scan and degrades query performance significantly. ' .
                    ' Make sure your `resolveType` always returns valid implementation or throws.',
                    $abstractType->name,
                    Utils::printSafe($value)
                ),
                Warning::WARNING_FULL_SCHEMA_SCAN
            );
        }

        $possibleTypes = $this->schema->getPossibleTypes($abstractType);

        // to be backward-compatible with old executor, ->isTypeOf() is called for all possible types,
        // it cannot short-circuit when the match is found

        $selectedType = null;
        foreach ($possibleTypes as $type) {
            $typeCheck = yield $type->isTypeOf($value, $this->contextValue, $ctx->resolveInfo);
            if ($selectedType !== null || ! $typeCheck) {
                continue;
            }

            $selectedType = $type;
        }

        return $selectedType;
    }

    /**
     * @param mixed $value
     *
     * @return bool
     */
    private function isPromise($value)
    {
        return $value instanceof Promise || $this->promiseAdapter->isThenable($value);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Experimental\Executor\Runtime.php
<?php

declare(strict_types=1);

namespace GraphQL\Experimental\Executor;

use GraphQL\Language\AST\ValueNode;
use GraphQL\Type\Definition\EnumType;
use GraphQL\Type\Definition\InputObjectType;
use GraphQL\Type\Definition\InputType;
use GraphQL\Type\Definition\ListOfType;
use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\Definition\ScalarType;

/**
 * @internal
 */
interface Runtime
{
    /**
     * @param ScalarType|EnumType|InputObjectType|ListOfType|NonNull $type
     */
    public function evaluate(ValueNode $valueNode, InputType $type);

    public function addError($error);
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Experimental\Executor\Strand.php
<?php

declare(strict_types=1);

namespace GraphQL\Experimental\Executor;

use Generator;

/**
 * @internal
 */
class Strand
{
    /** @var Generator */
    public $current;

    /** @var Generator[] */
    public $stack;

    /** @var int */
    public $depth;

    /** @var bool|null */
    public $success;

    /** @var mixed */
    public $value;

    public function __construct(Generator $coroutine)
    {
        $this->current = $coroutine;
        $this->stack   = [];
        $this->depth   = 0;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\DirectiveLocation.php
<?php

declare(strict_types=1);

namespace GraphQL\Language;

/**
 * List of available directive locations
 */
class DirectiveLocation
{
    // Request Definitions
    const QUERY               = 'QUERY';
    const MUTATION            = 'MUTATION';
    const SUBSCRIPTION        = 'SUBSCRIPTION';
    const FIELD               = 'FIELD';
    const FRAGMENT_DEFINITION = 'FRAGMENT_DEFINITION';
    const FRAGMENT_SPREAD     = 'FRAGMENT_SPREAD';
    const INLINE_FRAGMENT     = 'INLINE_FRAGMENT';
    const VARIABLE_DEFINITION = 'VARIABLE_DEFINITION';

    // Type System Definitions
    const SCHEMA                 = 'SCHEMA';
    const SCALAR                 = 'SCALAR';
    const OBJECT                 = 'OBJECT';
    const FIELD_DEFINITION       = 'FIELD_DEFINITION';
    const ARGUMENT_DEFINITION    = 'ARGUMENT_DEFINITION';
    const IFACE                  = 'INTERFACE';
    const UNION                  = 'UNION';
    const ENUM                   = 'ENUM';
    const ENUM_VALUE             = 'ENUM_VALUE';
    const INPUT_OBJECT           = 'INPUT_OBJECT';
    const INPUT_FIELD_DEFINITION = 'INPUT_FIELD_DEFINITION';

    /** @var string[] */
    private static $locations = [
        self::QUERY => self::QUERY,
        self::MUTATION => self::MUTATION,
        self::SUBSCRIPTION => self::SUBSCRIPTION,
        self::FIELD => self::FIELD,
        self::FRAGMENT_DEFINITION => self::FRAGMENT_DEFINITION,
        self::FRAGMENT_SPREAD => self::FRAGMENT_SPREAD,
        self::INLINE_FRAGMENT => self::INLINE_FRAGMENT,
        self::SCHEMA => self::SCHEMA,
        self::SCALAR => self::SCALAR,
        self::OBJECT => self::OBJECT,
        self::FIELD_DEFINITION => self::FIELD_DEFINITION,
        self::ARGUMENT_DEFINITION => self::ARGUMENT_DEFINITION,
        self::IFACE => self::IFACE,
        self::UNION => self::UNION,
        self::ENUM => self::ENUM,
        self::ENUM_VALUE => self::ENUM_VALUE,
        self::INPUT_OBJECT => self::INPUT_OBJECT,
        self::INPUT_FIELD_DEFINITION => self::INPUT_FIELD_DEFINITION,
    ];

    public static function has(string $name) : bool
    {
        return isset(self::$locations[$name]);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\Lexer.php
<?php

declare(strict_types=1);

namespace GraphQL\Language;

use GraphQL\Error\SyntaxError;
use GraphQL\Utils\BlockString;
use GraphQL\Utils\Utils;
use function chr;
use function hexdec;
use function mb_convert_encoding;
use function ord;
use function pack;
use function preg_match;
use function substr;

/**
 * A Lexer is a stateful stream generator in that every time
 * it is advanced, it returns the next token in the Source. Assuming the
 * source lexes, the final Token emitted by the lexer will be of kind
 * EOF, after which the lexer will repeatedly return the same EOF token
 * whenever called.
 *
 * Algorithm is O(N) both on memory and time
 */
class Lexer
{
    private const TOKEN_BANG      = 33;
    private const TOKEN_HASH      = 35;
    private const TOKEN_DOLLAR    = 36;
    private const TOKEN_AMP       = 38;
    private const TOKEN_PAREN_L   = 40;
    private const TOKEN_PAREN_R   = 41;
    private const TOKEN_DOT       = 46;
    private const TOKEN_COLON     = 58;
    private const TOKEN_EQUALS    = 61;
    private const TOKEN_AT        = 64;
    private const TOKEN_BRACKET_L = 91;
    private const TOKEN_BRACKET_R = 93;
    private const TOKEN_BRACE_L   = 123;
    private const TOKEN_PIPE      = 124;
    private const TOKEN_BRACE_R   = 125;

    /** @var Source */
    public $source;

    /** @var bool[] */
    public $options;

    /**
     * The previously focused non-ignored token.
     *
     * @var Token
     */
    public $lastToken;

    /**
     * The currently focused non-ignored token.
     *
     * @var Token
     */
    public $token;

    /**
     * The (1-indexed) line containing the current token.
     *
     * @var int
     */
    public $line;

    /**
     * The character offset at which the current line begins.
     *
     * @var int
     */
    public $lineStart;

    /**
     * Current cursor position for UTF8 encoding of the source
     *
     * @var int
     */
    private $position;

    /**
     * Current cursor position for ASCII representation of the source
     *
     * @var int
     */
    private $byteStreamPosition;

    /**
     * @param bool[] $options
     */
    public function __construct(Source $source, array $options = [])
    {
        $startOfFileToken = new Token(Token::SOF, 0, 0, 0, 0, null);

        $this->source    = $source;
        $this->options   = $options;
        $this->lastToken = $startOfFileToken;
        $this->token     = $startOfFileToken;
        $this->line      = 1;
        $this->lineStart = 0;
        $this->position  = $this->byteStreamPosition = 0;
    }

    /**
     * @return Token
     */
    public function advance()
    {
        $this->lastToken = $this->token;

        return $this->token = $this->lookahead();
    }

    public function lookahead()
    {
        $token = $this->token;
        if ($token->kind !== Token::EOF) {
            do {
                $token = $token->next ?? ($token->next = $this->readToken($token));
            } while ($token->kind === Token::COMMENT);
        }

        return $token;
    }

    /**
     * @return Token
     *
     * @throws SyntaxError
     */
    private function readToken(Token $prev)
    {
        $bodyLength = $this->source->length;

        $this->positionAfterWhitespace();
        $position = $this->position;

        $line = $this->line;
        $col  = 1 + $position - $this->lineStart;

        if ($position >= $bodyLength) {
            return new Token(Token::EOF, $bodyLength, $bodyLength, $line, $col, $prev);
        }

        // Read next char and advance string cursor:
        [, $code, $bytes] = $this->readChar(true);

        switch ($code) {
            case self::TOKEN_BANG:
                return new Token(Token::BANG, $position, $position + 1, $line, $col, $prev);
            case self::TOKEN_HASH: // #
                $this->moveStringCursor(-1, -1 * $bytes);

                return $this->readComment($line, $col, $prev);
            case self::TOKEN_DOLLAR:
                return new Token(Token::DOLLAR, $position, $position + 1, $line, $col, $prev);
            case self::TOKEN_AMP:
                return new Token(Token::AMP, $position, $position + 1, $line, $col, $prev);
            case self::TOKEN_PAREN_L:
                return new Token(Token::PAREN_L, $position, $position + 1, $line, $col, $prev);
            case self::TOKEN_PAREN_R:
                return new Token(Token::PAREN_R, $position, $position + 1, $line, $col, $prev);
            case self::TOKEN_DOT: // .
                [, $charCode1] = $this->readChar(true);
                [, $charCode2] = $this->readChar(true);

                if ($charCode1 === self::TOKEN_DOT && $charCode2 === self::TOKEN_DOT) {
                    return new Token(Token::SPREAD, $position, $position + 3, $line, $col, $prev);
                }
                break;
            case self::TOKEN_COLON:
                return new Token(Token::COLON, $position, $position + 1, $line, $col, $prev);
            case self::TOKEN_EQUALS:
                return new Token(Token::EQUALS, $position, $position + 1, $line, $col, $prev);
            case self::TOKEN_AT:
                return new Token(Token::AT, $position, $position + 1, $line, $col, $prev);
            case self::TOKEN_BRACKET_L:
                return new Token(Token::BRACKET_L, $position, $position + 1, $line, $col, $prev);
            case self::TOKEN_BRACKET_R:
                return new Token(Token::BRACKET_R, $position, $position + 1, $line, $col, $prev);
            case self::TOKEN_BRACE_L:
                return new Token(Token::BRACE_L, $position, $position + 1, $line, $col, $prev);
            case self::TOKEN_PIPE:
                return new Token(Token::PIPE, $position, $position + 1, $line, $col, $prev);
            case self::TOKEN_BRACE_R:
                return new Token(Token::BRACE_R, $position, $position + 1, $line, $col, $prev);

            // A-Z
            case 65:
            case 66:
            case 67:
            case 68:
            case 69:
            case 70:
            case 71:
            case 72:
            case 73:
            case 74:
            case 75:
            case 76:
            case 77:
            case 78:
            case 79:
            case 80:
            case 81:
            case 82:
            case 83:
            case 84:
            case 85:
            case 86:
            case 87:
            case 88:
            case 89:
            case 90:
                // _
            case 95:
                // a-z
            case 97:
            case 98:
            case 99:
            case 100:
            case 101:
            case 102:
            case 103:
            case 104:
            case 105:
            case 106:
            case 107:
            case 108:
            case 109:
            case 110:
            case 111:
            case 112:
            case 113:
            case 114:
            case 115:
            case 116:
            case 117:
            case 118:
            case 119:
            case 120:
            case 121:
            case 122:
                return $this->moveStringCursor(-1, -1 * $bytes)
                    ->readName($line, $col, $prev);

            // -
            case 45:
                // 0-9
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
                return $this->moveStringCursor(-1, -1 * $bytes)
                    ->readNumber($line, $col, $prev);

            // "
            case 34:
                [, $nextCode]     = $this->readChar();
                [, $nextNextCode] = $this->moveStringCursor(1, 1)->readChar();

                if ($nextCode === 34 && $nextNextCode === 34) {
                    return $this->moveStringCursor(-2, (-1 * $bytes) - 1)
                        ->readBlockString($line, $col, $prev);
                }

                return $this->moveStringCursor(-2, (-1 * $bytes) - 1)
                    ->readString($line, $col, $prev);
        }

        throw new SyntaxError(
            $this->source,
            $position,
            $this->unexpectedCharacterMessage($code)
        );
    }

    private function unexpectedCharacterMessage($code)
    {
        // SourceCharacter
        if ($code < 0x0020 && $code !== 0x0009 && $code !== 0x000A && $code !== 0x000D) {
            return 'Cannot contain the invalid character ' . Utils::printCharCode($code);
        }

        if ($code === 39) {
            return "Unexpected single quote character ('), did you mean to use " .
                'a double quote (")?';
        }

        return 'Cannot parse the unexpected character ' . Utils::printCharCode($code) . '.';
    }

    /**
     * Reads an alphanumeric + underscore name from the source.
     *
     * [_A-Za-z][_0-9A-Za-z]*
     *
     * @param int $line
     * @param int $col
     *
     * @return Token
     */
    private function readName($line, $col, Token $prev)
    {
        $value         = '';
        $start         = $this->position;
        [$char, $code] = $this->readChar();

        while ($code !== null && (
                $code === 95 || // _
                ($code >= 48 && $code <= 57) || // 0-9
                ($code >= 65 && $code <= 90) || // A-Z
                ($code >= 97 && $code <= 122) // a-z
            )) {
            $value        .= $char;
            [$char, $code] = $this->moveStringCursor(1, 1)->readChar();
        }

        return new Token(
            Token::NAME,
            $start,
            $this->position,
            $line,
            $col,
            $prev,
            $value
        );
    }

    /**
     * Reads a number token from the source file, either a float
     * or an int depending on whether a decimal point appears.
     *
     * Int:   -?(0|[1-9][0-9]*)
     * Float: -?(0|[1-9][0-9]*)(\.[0-9]+)?((E|e)(+|-)?[0-9]+)?
     *
     * @param int $line
     * @param int $col
     *
     * @return Token
     *
     * @throws SyntaxError
     */
    private function readNumber($line, $col, Token $prev)
    {
        $value         = '';
        $start         = $this->position;
        [$char, $code] = $this->readChar();

        $isFloat = false;

        if ($code === 45) { // -
            $value        .= $char;
            [$char, $code] = $this->moveStringCursor(1, 1)->readChar();
        }

        // guard against leading zero's
        if ($code === 48) { // 0
            $value        .= $char;
            [$char, $code] = $this->moveStringCursor(1, 1)->readChar();

            if ($code >= 48 && $code <= 57) {
                throw new SyntaxError(
                    $this->source,
                    $this->position,
                    'Invalid number, unexpected digit after 0: ' . Utils::printCharCode($code)
                );
            }
        } else {
            $value        .= $this->readDigits();
            [$char, $code] = $this->readChar();
        }

        if ($code === 46) { // .
            $isFloat = true;
            $this->moveStringCursor(1, 1);

            $value        .= $char;
            $value        .= $this->readDigits();
            [$char, $code] = $this->readChar();
        }

        if ($code === 69 || $code === 101) { // E e
            $isFloat       = true;
            $value        .= $char;
            [$char, $code] = $this->moveStringCursor(1, 1)->readChar();

            if ($code === 43 || $code === 45) { // + -
                $value .= $char;
                $this->moveStringCursor(1, 1);
            }
            $value .= $this->readDigits();
        }

        return new Token(
            $isFloat ? Token::FLOAT : Token::INT,
            $start,
            $this->position,
            $line,
            $col,
            $prev,
            $value
        );
    }

    /**
     * Returns string with all digits + changes current string cursor position to point to the first char after digits
     */
    private function readDigits()
    {
        [$char, $code] = $this->readChar();

        if ($code >= 48 && $code <= 57) { // 0 - 9
            $value = '';

            do {
                $value        .= $char;
                [$char, $code] = $this->moveStringCursor(1, 1)->readChar();
            } while ($code >= 48 && $code <= 57); // 0 - 9

            return $value;
        }

        if ($this->position > $this->source->length - 1) {
            $code = null;
        }

        throw new SyntaxError(
            $this->source,
            $this->position,
            'Invalid number, expected digit but got: ' . Utils::printCharCode($code)
        );
    }

    /**
     * @param int $line
     * @param int $col
     *
     * @return Token
     *
     * @throws SyntaxError
     */
    private function readString($line, $col, Token $prev)
    {
        $start = $this->position;

        // Skip leading quote and read first string char:
        [$char, $code, $bytes] = $this->moveStringCursor(1, 1)->readChar();

        $chunk = '';
        $value = '';

        while ($code !== null &&
            // not LineTerminator
            $code !== 10 && $code !== 13
        ) {
            // Closing Quote (")
            if ($code === 34) {
                $value .= $chunk;

                // Skip quote
                $this->moveStringCursor(1, 1);

                return new Token(
                    Token::STRING,
                    $start,
                    $this->position,
                    $line,
                    $col,
                    $prev,
                    $value
                );
            }

            $this->assertValidStringCharacterCode($code, $this->position);
            $this->moveStringCursor(1, $bytes);

            if ($code === 92) { // \
                $value   .= $chunk;
                [, $code] = $this->readChar(true);

                switch ($code) {
                    case 34:
                        $value .= '"';
                        break;
                    case 47:
                        $value .= '/';
                        break;
                    case 92:
                        $value .= '\\';
                        break;
                    case 98:
                        $value .= chr(8);
                        break; // \b (backspace)
                    case 102:
                        $value .= "\f";
                        break;
                    case 110:
                        $value .= "\n";
                        break;
                    case 114:
                        $value .= "\r";
                        break;
                    case 116:
                        $value .= "\t";
                        break;
                    case 117:
                        $position = $this->position;
                        [$hex]    = $this->readChars(4, true);
                        if (! preg_match('/[0-9a-fA-F]{4}/', $hex)) {
                            throw new SyntaxError(
                                $this->source,
                                $position - 1,
                                'Invalid character escape sequence: \\u' . $hex
                            );
                        }

                        $code = hexdec($hex);

                        // UTF-16 surrogate pair detection and handling.
                        $highOrderByte = $code >> 8;
                        if (0xD8 <= $highOrderByte && $highOrderByte <= 0xDF) {
                            [$utf16Continuation] = $this->readChars(6, true);
                            if (! preg_match('/^\\\u[0-9a-fA-F]{4}$/', $utf16Continuation)) {
                                throw new SyntaxError(
                                    $this->source,
                                    $this->position - 5,
                                    'Invalid UTF-16 trailing surrogate: ' . $utf16Continuation
                                );
                            }
                            $surrogatePairHex = $hex . substr($utf16Continuation, 2, 4);
                            $value           .= mb_convert_encoding(pack('H*', $surrogatePairHex), 'UTF-8', 'UTF-16');
                            break;
                        }

                        $this->assertValidStringCharacterCode($code, $position - 2);

                        $value .= Utils::chr($code);
                        break;
                    default:
                        throw new SyntaxError(
                            $this->source,
                            $this->position - 1,
                            'Invalid character escape sequence: \\' . Utils::chr($code)
                        );
                }
                $chunk = '';
            } else {
                $chunk .= $char;
            }

            [$char, $code, $bytes] = $this->readChar();
        }

        throw new SyntaxError(
            $this->source,
            $this->position,
            'Unterminated string.'
        );
    }

    /**
     * Reads a block string token from the source file.
     *
     * """("?"?(\\"""|\\(?!=""")|[^"\\]))*"""
     */
    private function readBlockString($line, $col, Token $prev)
    {
        $start = $this->position;

        // Skip leading quotes and read first string char:
        [$char, $code, $bytes] = $this->moveStringCursor(3, 3)->readChar();

        $chunk = '';
        $value = '';

        while ($code !== null) {
            // Closing Triple-Quote (""")
            if ($code === 34) {
                // Move 2 quotes
                [, $nextCode]     = $this->moveStringCursor(1, 1)->readChar();
                [, $nextNextCode] = $this->moveStringCursor(1, 1)->readChar();

                if ($nextCode === 34 && $nextNextCode === 34) {
                    $value .= $chunk;

                    $this->moveStringCursor(1, 1);

                    return new Token(
                        Token::BLOCK_STRING,
                        $start,
                        $this->position,
                        $line,
                        $col,
                        $prev,
                        BlockString::value($value)
                    );
                }

                // move cursor back to before the first quote
                $this->moveStringCursor(-2, -2);
            }

            $this->assertValidBlockStringCharacterCode($code, $this->position);
            $this->moveStringCursor(1, $bytes);

            [, $nextCode]         = $this->readChar();
            [, $nextNextCode]     = $this->moveStringCursor(1, 1)->readChar();
            [, $nextNextNextCode] = $this->moveStringCursor(1, 1)->readChar();

            // Escape Triple-Quote (\""")
            if ($code === 92 &&
                $nextCode === 34 &&
                $nextNextCode === 34 &&
                $nextNextNextCode === 34
            ) {
                $this->moveStringCursor(1, 1);
                $value .= $chunk . '"""';
                $chunk  = '';
            } else {
                $this->moveStringCursor(-2, -2);
                $chunk .= $char;
            }

            [$char, $code, $bytes] = $this->readChar();
        }

        throw new SyntaxError(
            $this->source,
            $this->position,
            'Unterminated string.'
        );
    }

    private function assertValidStringCharacterCode($code, $position)
    {
        // SourceCharacter
        if ($code < 0x0020 && $code !== 0x0009) {
            throw new SyntaxError(
                $this->source,
                $position,
                'Invalid character within String: ' . Utils::printCharCode($code)
            );
        }
    }

    private function assertValidBlockStringCharacterCode($code, $position)
    {
        // SourceCharacter
        if ($code < 0x0020 && $code !== 0x0009 && $code !== 0x000A && $code !== 0x000D) {
            throw new SyntaxError(
                $this->source,
                $position,
                'Invalid character within String: ' . Utils::printCharCode($code)
            );
        }
    }

    /**
     * Reads from body starting at startPosition until it finds a non-whitespace
     * or commented character, then places cursor to the position of that character.
     */
    private function positionAfterWhitespace()
    {
        while ($this->position < $this->source->length) {
            [, $code, $bytes] = $this->readChar();

            // Skip whitespace
            // tab | space | comma | BOM
            if ($code === 9 || $code === 32 || $code === 44 || $code === 0xFEFF) {
                $this->moveStringCursor(1, $bytes);
            } elseif ($code === 10) { // new line
                $this->moveStringCursor(1, $bytes);
                $this->line++;
                $this->lineStart = $this->position;
            } elseif ($code === 13) { // carriage return
                [, $nextCode, $nextBytes] = $this->moveStringCursor(1, $bytes)->readChar();

                if ($nextCode === 10) { // lf after cr
                    $this->moveStringCursor(1, $nextBytes);
                }
                $this->line++;
                $this->lineStart = $this->position;
            } else {
                break;
            }
        }
    }

    /**
     * Reads a comment token from the source file.
     *
     * #[\u0009\u0020-\uFFFF]*
     *
     * @param int $line
     * @param int $col
     *
     * @return Token
     */
    private function readComment($line, $col, Token $prev)
    {
        $start = $this->position;
        $value = '';
        $bytes = 1;

        do {
            [$char, $code, $bytes] = $this->moveStringCursor(1, $bytes)->readChar();
            $value                .= $char;
        } while ($code !== null &&
        // SourceCharacter but not LineTerminator
        ($code > 0x001F || $code === 0x0009)
        );

        return new Token(
            Token::COMMENT,
            $start,
            $this->position,
            $line,
            $col,
            $prev,
            $value
        );
    }

    /**
     * Reads next UTF8Character from the byte stream, starting from $byteStreamPosition.
     *
     * @param bool $advance
     * @param int  $byteStreamPosition
     *
     * @return (string|int)[]
     */
    private function readChar($advance = false, $byteStreamPosition = null)
    {
        if ($byteStreamPosition === null) {
            $byteStreamPosition = $this->byteStreamPosition;
        }

        $code           = null;
        $utf8char       = '';
        $bytes          = 0;
        $positionOffset = 0;

        if (isset($this->source->body[$byteStreamPosition])) {
            $ord = ord($this->source->body[$byteStreamPosition]);

            if ($ord < 128) {
                $bytes = 1;
            } elseif ($ord < 224) {
                $bytes = 2;
            } elseif ($ord < 240) {
                $bytes = 3;
            } else {
                $bytes = 4;
            }

            $utf8char = '';
            for ($pos = $byteStreamPosition; $pos < $byteStreamPosition + $bytes; $pos++) {
                $utf8char .= $this->source->body[$pos];
            }
            $positionOffset = 1;
            $code           = $bytes === 1 ? $ord : Utils::ord($utf8char);
        }

        if ($advance) {
            $this->moveStringCursor($positionOffset, $bytes);
        }

        return [$utf8char, $code, $bytes];
    }

    /**
     * Reads next $numberOfChars UTF8 characters from the byte stream, starting from $byteStreamPosition.
     *
     * @param int  $charCount
     * @param bool $advance
     * @param null $byteStreamPosition
     *
     * @return (string|int)[]
     */
    private function readChars($charCount, $advance = false, $byteStreamPosition = null)
    {
        $result     = '';
        $totalBytes = 0;
        $byteOffset = $byteStreamPosition ?? $this->byteStreamPosition;

        for ($i = 0; $i < $charCount; $i++) {
            [$char, $code, $bytes] = $this->readChar(false, $byteOffset);
            $totalBytes           += $bytes;
            $byteOffset           += $bytes;
            $result               .= $char;
        }
        if ($advance) {
            $this->moveStringCursor($charCount, $totalBytes);
        }

        return [$result, $totalBytes];
    }

    /**
     * Moves internal string cursor position
     *
     * @param int $positionOffset
     * @param int $byteStreamOffset
     *
     * @return self
     */
    private function moveStringCursor($positionOffset, $byteStreamOffset)
    {
        $this->position           += $positionOffset;
        $this->byteStreamPosition += $byteStreamOffset;

        return $this;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\Parser.php
<?php

declare(strict_types=1);

namespace GraphQL\Language;

use GraphQL\Error\SyntaxError;
use GraphQL\Language\AST\ArgumentNode;
use GraphQL\Language\AST\BooleanValueNode;
use GraphQL\Language\AST\DefinitionNode;
use GraphQL\Language\AST\DirectiveDefinitionNode;
use GraphQL\Language\AST\DirectiveNode;
use GraphQL\Language\AST\DocumentNode;
use GraphQL\Language\AST\EnumTypeDefinitionNode;
use GraphQL\Language\AST\EnumTypeExtensionNode;
use GraphQL\Language\AST\EnumValueDefinitionNode;
use GraphQL\Language\AST\EnumValueNode;
use GraphQL\Language\AST\ExecutableDefinitionNode;
use GraphQL\Language\AST\FieldDefinitionNode;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\FloatValueNode;
use GraphQL\Language\AST\FragmentDefinitionNode;
use GraphQL\Language\AST\FragmentSpreadNode;
use GraphQL\Language\AST\InlineFragmentNode;
use GraphQL\Language\AST\InputObjectTypeDefinitionNode;
use GraphQL\Language\AST\InputObjectTypeExtensionNode;
use GraphQL\Language\AST\InputValueDefinitionNode;
use GraphQL\Language\AST\InterfaceTypeDefinitionNode;
use GraphQL\Language\AST\InterfaceTypeExtensionNode;
use GraphQL\Language\AST\IntValueNode;
use GraphQL\Language\AST\ListTypeNode;
use GraphQL\Language\AST\ListValueNode;
use GraphQL\Language\AST\Location;
use GraphQL\Language\AST\NamedTypeNode;
use GraphQL\Language\AST\NameNode;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\NodeList;
use GraphQL\Language\AST\NonNullTypeNode;
use GraphQL\Language\AST\NullValueNode;
use GraphQL\Language\AST\ObjectFieldNode;
use GraphQL\Language\AST\ObjectTypeDefinitionNode;
use GraphQL\Language\AST\ObjectTypeExtensionNode;
use GraphQL\Language\AST\ObjectValueNode;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Language\AST\OperationTypeDefinitionNode;
use GraphQL\Language\AST\ScalarTypeDefinitionNode;
use GraphQL\Language\AST\ScalarTypeExtensionNode;
use GraphQL\Language\AST\SchemaDefinitionNode;
use GraphQL\Language\AST\SchemaTypeExtensionNode;
use GraphQL\Language\AST\SelectionNode;
use GraphQL\Language\AST\SelectionSetNode;
use GraphQL\Language\AST\StringValueNode;
use GraphQL\Language\AST\TypeExtensionNode;
use GraphQL\Language\AST\TypeNode;
use GraphQL\Language\AST\TypeSystemDefinitionNode;
use GraphQL\Language\AST\UnionTypeDefinitionNode;
use GraphQL\Language\AST\UnionTypeExtensionNode;
use GraphQL\Language\AST\ValueNode;
use GraphQL\Language\AST\VariableDefinitionNode;
use GraphQL\Language\AST\VariableNode;
use function count;
use function sprintf;

/**
 * Parses string containing GraphQL query or [type definition](type-system/type-language.md) to Abstract Syntax Tree.
 *
 * Those magic functions allow partial parsing:
 *
 * @method static NameNode name(Source|string $source, bool[] $options = [])
 * @method static DocumentNode document(Source|string $source, bool[] $options = [])
 * @method static ExecutableDefinitionNode|TypeSystemDefinitionNode definition(Source|string $source, bool[] $options = [])
 * @method static ExecutableDefinitionNode executableDefinition(Source|string $source, bool[] $options = [])
 * @method static OperationDefinitionNode operationDefinition(Source|string $source, bool[] $options = [])
 * @method static string operationType(Source|string $source, bool[] $options = [])
 * @method static NodeList<VariableDefinitionNode> variableDefinitions(Source|string $source, bool[] $options = [])
 * @method static VariableDefinitionNode variableDefinition(Source|string $source, bool[] $options = [])
 * @method static VariableNode variable(Source|string $source, bool[] $options = [])
 * @method static SelectionSetNode selectionSet(Source|string $source, bool[] $options = [])
 * @method static mixed selection(Source|string $source, bool[] $options = [])
 * @method static FieldNode field(Source|string $source, bool[] $options = [])
 * @method static NodeList<ArgumentNode> arguments(Source|string $source, bool[] $options = [])
 * @method static NodeList<ArgumentNode> constArguments(Source|string $source, bool[] $options = [])
 * @method static ArgumentNode argument(Source|string $source, bool[] $options = [])
 * @method static ArgumentNode constArgument(Source|string $source, bool[] $options = [])
 * @method static FragmentSpreadNode|InlineFragmentNode fragment(Source|string $source, bool[] $options = [])
 * @method static FragmentDefinitionNode fragmentDefinition(Source|string $source, bool[] $options = [])
 * @method static NameNode fragmentName(Source|string $source, bool[] $options = [])
 * @method static BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|ListValueNode|NullValueNode|ObjectValueNode|StringValueNode|VariableNode valueLiteral(Source|string $source, bool[] $options = [])
 * @method static BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|ListValueNode|NullValueNode|ObjectValueNode|StringValueNode constValueLiteral(Source|string $source, bool[] $options = [])
 * @method static StringValueNode stringLiteral(Source|string $source, bool[] $options = [])
 * @method static BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|StringValueNode constValue(Source|string $source, bool[] $options = [])
 * @method static BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|ListValueNode|ObjectValueNode|StringValueNode|VariableNode variableValue(Source|string $source, bool[] $options = [])
 * @method static ListValueNode array(Source|string $source, bool[] $options = [])
 * @method static ListValueNode constArray(Source|string $source, bool[] $options = [])
 * @method static ObjectValueNode object(Source|string $source, bool[] $options = [])
 * @method static ObjectValueNode constObject(Source|string $source, bool[] $options = [])
 * @method static ObjectFieldNode objectField(Source|string $source, bool[] $options = [])
 * @method static ObjectFieldNode constObjectField(Source|string $source, bool[] $options = [])
 * @method static NodeList<DirectiveNode> directives(Source|string $source, bool[] $options = [])
 * @method static NodeList<DirectiveNode> constDirectives(Source|string $source, bool[] $options = [])
 * @method static DirectiveNode directive(Source|string $source, bool[] $options = [])
 * @method static DirectiveNode constDirective(Source|string $source, bool[] $options = [])
 * @method static ListTypeNode|NamedTypeNode|NonNullTypeNode typeReference(Source|string $source, bool[] $options = [])
 * @method static NamedTypeNode namedType(Source|string $source, bool[] $options = [])
 * @method static TypeSystemDefinitionNode typeSystemDefinition(Source|string $source, bool[] $options = [])
 * @method static StringValueNode|null description(Source|string $source, bool[] $options = [])
 * @method static SchemaDefinitionNode schemaDefinition(Source|string $source, bool[] $options = [])
 * @method static OperationTypeDefinitionNode operationTypeDefinition(Source|string $source, bool[] $options = [])
 * @method static ScalarTypeDefinitionNode scalarTypeDefinition(Source|string $source, bool[] $options = [])
 * @method static ObjectTypeDefinitionNode objectTypeDefinition(Source|string $source, bool[] $options = [])
 * @method static NodeList<NamedTypeNode> implementsInterfaces(Source|string $source, bool[] $options = [])
 * @method static NodeList<FieldDefinitionNode> fieldsDefinition(Source|string $source, bool[] $options = [])
 * @method static FieldDefinitionNode fieldDefinition(Source|string $source, bool[] $options = [])
 * @method static NodeList<InputValueDefinitionNode> argumentsDefinition(Source|string $source, bool[] $options = [])
 * @method static InputValueDefinitionNode inputValueDefinition(Source|string $source, bool[] $options = [])
 * @method static InterfaceTypeDefinitionNode interfaceTypeDefinition(Source|string $source, bool[] $options = [])
 * @method static UnionTypeDefinitionNode unionTypeDefinition(Source|string $source, bool[] $options = [])
 * @method static NodeList<NamedTypeNode> unionMemberTypes(Source|string $source, bool[] $options = [])
 * @method static EnumTypeDefinitionNode enumTypeDefinition(Source|string $source, bool[] $options = [])
 * @method static NodeList<EnumValueDefinitionNode> enumValuesDefinition(Source|string $source, bool[] $options = [])
 * @method static EnumValueDefinitionNode enumValueDefinition(Source|string $source, bool[] $options = [])
 * @method static InputObjectTypeDefinitionNode inputObjectTypeDefinition(Source|string $source, bool[] $options = [])
 * @method static NodeList<InputValueDefinitionNode> inputFieldsDefinition(Source|string $source, bool[] $options = [])
 * @method static TypeExtensionNode typeExtension(Source|string $source, bool[] $options = [])
 * @method static SchemaTypeExtensionNode schemaTypeExtension(Source|string $source, bool[] $options = [])
 * @method static ScalarTypeExtensionNode scalarTypeExtension(Source|string $source, bool[] $options = [])
 * @method static ObjectTypeExtensionNode objectTypeExtension(Source|string $source, bool[] $options = [])
 * @method static InterfaceTypeExtensionNode interfaceTypeExtension(Source|string $source, bool[] $options = [])
 * @method static UnionTypeExtensionNode unionTypeExtension(Source|string $source, bool[] $options = [])
 * @method static EnumTypeExtensionNode enumTypeExtension(Source|string $source, bool[] $options = [])
 * @method static InputObjectTypeExtensionNode inputObjectTypeExtension(Source|string $source, bool[] $options = [])
 * @method static DirectiveDefinitionNode directiveDefinition(Source|string $source, bool[] $options = [])
 * @method static NodeList<NameNode> directiveLocations(Source|string $source, bool[] $options = [])
 * @method static NameNode directiveLocation(Source|string $source, bool[] $options = [])
 */
class Parser
{
    /**
     * Given a GraphQL source, parses it into a `GraphQL\Language\AST\DocumentNode`.
     * Throws `GraphQL\Error\SyntaxError` if a syntax error is encountered.
     *
     * Available options:
     *
     * noLocation: boolean,
     *   (By default, the parser creates AST nodes that know the location
     *   in the source that they correspond to. This configuration flag
     *   disables that behavior for performance or testing.)
     *
     * allowLegacySDLEmptyFields: boolean
     *   If enabled, the parser will parse empty fields sets in the Schema
     *   Definition Language. Otherwise, the parser will follow the current
     *   specification.
     *
     *   This option is provided to ease adoption of the final SDL specification
     *   and will be removed in a future major release.
     *
     * allowLegacySDLImplementsInterfaces: boolean
     *   If enabled, the parser will parse implemented interfaces with no `&`
     *   character between each interface. Otherwise, the parser will follow the
     *   current specification.
     *
     *   This option is provided to ease adoption of the final SDL specification
     *   and will be removed in a future major release.
     *
     * experimentalFragmentVariables: boolean,
     *   (If enabled, the parser will understand and parse variable definitions
     *   contained in a fragment definition. They'll be represented in the
     *   `variableDefinitions` field of the FragmentDefinitionNode.
     *
     *   The syntax is identical to normal, query-defined variables. For example:
     *
     *     fragment A($var: Boolean = false) on T  {
     *       ...
     *     }
     *
     *   Note: this feature is experimental and may change or be removed in the
     *   future.)
     *
     * @param Source|string $source
     * @param bool[]        $options
     *
     * @return DocumentNode
     *
     * @throws SyntaxError
     *
     * @api
     */
    public static function parse($source, array $options = [])
    {
        $parser = new self($source, $options);

        return $parser->parseDocument();
    }

    /**
     * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for
     * that value.
     * Throws `GraphQL\Error\SyntaxError` if a syntax error is encountered.
     *
     * This is useful within tools that operate upon GraphQL Values directly and
     * in isolation of complete GraphQL documents.
     *
     * Consider providing the results to the utility function: `GraphQL\Utils\AST::valueFromAST()`.
     *
     * @param Source|string $source
     * @param bool[]        $options
     *
     * @return BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|ListValueNode|ObjectValueNode|StringValueNode|VariableNode
     *
     * @api
     */
    public static function parseValue($source, array $options = [])
    {
        $parser = new Parser($source, $options);
        $parser->expect(Token::SOF);
        $value = $parser->parseValueLiteral(false);
        $parser->expect(Token::EOF);

        return $value;
    }

    /**
     * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for
     * that type.
     * Throws `GraphQL\Error\SyntaxError` if a syntax error is encountered.
     *
     * This is useful within tools that operate upon GraphQL Types directly and
     * in isolation of complete GraphQL documents.
     *
     * Consider providing the results to the utility function: `GraphQL\Utils\AST::typeFromAST()`.
     *
     * @param Source|string $source
     * @param bool[]        $options
     *
     * @return ListTypeNode|NamedTypeNode|NonNullTypeNode
     *
     * @api
     */
    public static function parseType($source, array $options = [])
    {
        $parser = new Parser($source, $options);
        $parser->expect(Token::SOF);
        $type = $parser->parseTypeReference();
        $parser->expect(Token::EOF);

        return $type;
    }

    /**
     * Parse partial source by delegating calls to the internal parseX methods.
     *
     * @param bool[] $arguments
     *
     * @throws SyntaxError
     */
    public static function __callStatic(string $name, array $arguments)
    {
        $parser = new Parser(...$arguments);
        $parser->expect(Token::SOF);

        switch ($name) {
            case 'arguments':
            case 'valueLiteral':
            case 'array':
            case 'object':
            case 'objectField':
            case 'directives':
            case 'directive':
                $type = $parser->{'parse' . $name}(false);
                break;
            case 'constArguments':
                $type = $parser->parseArguments(true);
                break;
            case 'constValueLiteral':
                $type = $parser->parseValueLiteral(true);
                break;
            case 'constArray':
                $type = $parser->parseArray(true);
                break;
            case 'constObject':
                $type = $parser->parseObject(true);
                break;
            case 'constObjectField':
                $type = $parser->parseObjectField(true);
                break;
            case 'constDirectives':
                $type = $parser->parseDirectives(true);
                break;
            case 'constDirective':
                $type = $parser->parseDirective(true);
                break;
            default:
                $type = $parser->{'parse' . $name}();
        }

        $parser->expect(Token::EOF);

        return $type;
    }

    /** @var Lexer */
    private $lexer;

    /**
     * @param Source|string $source
     * @param bool[]        $options
     */
    public function __construct($source, array $options = [])
    {
        $sourceObj   = $source instanceof Source ? $source : new Source($source);
        $this->lexer = new Lexer($sourceObj, $options);
    }

    /**
     * Returns a location object, used to identify the place in
     * the source that created a given parsed object.
     */
    private function loc(Token $startToken) : ?Location
    {
        if (! ($this->lexer->options['noLocation'] ?? false)) {
            return new Location($startToken, $this->lexer->lastToken, $this->lexer->source);
        }

        return null;
    }

    /**
     * Determines if the next token is of a given kind
     */
    private function peek(string $kind) : bool
    {
        return $this->lexer->token->kind === $kind;
    }

    /**
     * If the next token is of the given kind, return true after advancing
     * the parser. Otherwise, do not change the parser state and return false.
     */
    private function skip(string $kind) : bool
    {
        $match = $this->lexer->token->kind === $kind;

        if ($match) {
            $this->lexer->advance();
        }

        return $match;
    }

    /**
     * If the next token is of the given kind, return that token after advancing
     * the parser. Otherwise, do not change the parser state and return false.
     *
     * @throws SyntaxError
     */
    private function expect(string $kind) : Token
    {
        $token = $this->lexer->token;

        if ($token->kind === $kind) {
            $this->lexer->advance();

            return $token;
        }

        throw new SyntaxError(
            $this->lexer->source,
            $token->start,
            sprintf('Expected %s, found %s', $kind, $token->getDescription())
        );
    }

    /**
     * If the next token is a keyword with the given value, advance the lexer.
     * Otherwise, throw an error.
     *
     * @throws SyntaxError
     */
    private function expectKeyword(string $value) : void
    {
        $token = $this->lexer->token;
        if ($token->kind !== Token::NAME || $token->value !== $value) {
            throw new SyntaxError(
                $this->lexer->source,
                $token->start,
                'Expected "' . $value . '", found ' . $token->getDescription()
            );
        }

        $this->lexer->advance();
    }

    /**
     * If the next token is a given keyword, return "true" after advancing
     * the lexer. Otherwise, do not change the parser state and return "false".
     */
    private function expectOptionalKeyword(string $value) : bool
    {
        $token = $this->lexer->token;
        if ($token->kind === Token::NAME && $token->value === $value) {
            $this->lexer->advance();

            return true;
        }

        return false;
    }

    private function unexpected(?Token $atToken = null) : SyntaxError
    {
        $token = $atToken ?? $this->lexer->token;

        return new SyntaxError($this->lexer->source, $token->start, 'Unexpected ' . $token->getDescription());
    }

    /**
     * Returns a possibly empty list of parse nodes, determined by
     * the parseFn. This list begins with a lex token of openKind
     * and ends with a lex token of closeKind. Advances the parser
     * to the next lex token after the closing token.
     *
     * @throws SyntaxError
     */
    private function any(string $openKind, callable $parseFn, string $closeKind) : NodeList
    {
        $this->expect($openKind);

        $nodes = [];
        while (! $this->skip($closeKind)) {
            $nodes[] = $parseFn($this);
        }

        return new NodeList($nodes);
    }

    /**
     * Returns a non-empty list of parse nodes, determined by
     * the parseFn. This list begins with a lex token of openKind
     * and ends with a lex token of closeKind. Advances the parser
     * to the next lex token after the closing token.
     *
     * @throws SyntaxError
     */
    private function many(string $openKind, callable $parseFn, string $closeKind) : NodeList
    {
        $this->expect($openKind);

        $nodes = [$parseFn($this)];
        while (! $this->skip($closeKind)) {
            $nodes[] = $parseFn($this);
        }

        return new NodeList($nodes);
    }

    /**
     * Converts a name lex token into a name parse node.
     *
     * @throws SyntaxError
     */
    private function parseName() : NameNode
    {
        $token = $this->expect(Token::NAME);

        return new NameNode([
            'value' => $token->value,
            'loc'   => $this->loc($token),
        ]);
    }

    /**
     * Implements the parsing rules in the Document section.
     *
     * @throws SyntaxError
     */
    private function parseDocument() : DocumentNode
    {
        $start = $this->lexer->token;

        return new DocumentNode([
            'definitions' => $this->many(
                Token::SOF,
                function () {
                    return $this->parseDefinition();
                },
                Token::EOF
            ),
            'loc'         => $this->loc($start),
        ]);
    }

    /**
     * @return ExecutableDefinitionNode|TypeSystemDefinitionNode
     *
     * @throws SyntaxError
     */
    private function parseDefinition() : DefinitionNode
    {
        if ($this->peek(Token::NAME)) {
            switch ($this->lexer->token->value) {
                case 'query':
                case 'mutation':
                case 'subscription':
                case 'fragment':
                    return $this->parseExecutableDefinition();

                // Note: The schema definition language is an experimental addition.
                case 'schema':
                case 'scalar':
                case 'type':
                case 'interface':
                case 'union':
                case 'enum':
                case 'input':
                case 'extend':
                case 'directive':
                    // Note: The schema definition language is an experimental addition.
                    return $this->parseTypeSystemDefinition();
            }
        } elseif ($this->peek(Token::BRACE_L)) {
            return $this->parseExecutableDefinition();
        } elseif ($this->peekDescription()) {
            // Note: The schema definition language is an experimental addition.
            return $this->parseTypeSystemDefinition();
        }

        throw $this->unexpected();
    }

    /**
     * @throws SyntaxError
     */
    private function parseExecutableDefinition() : ExecutableDefinitionNode
    {
        if ($this->peek(Token::NAME)) {
            switch ($this->lexer->token->value) {
                case 'query':
                case 'mutation':
                case 'subscription':
                    return $this->parseOperationDefinition();
                case 'fragment':
                    return $this->parseFragmentDefinition();
            }
        } elseif ($this->peek(Token::BRACE_L)) {
            return $this->parseOperationDefinition();
        }

        throw $this->unexpected();
    }

    // Implements the parsing rules in the Operations section.

    /**
     * @throws SyntaxError
     */
    private function parseOperationDefinition() : OperationDefinitionNode
    {
        $start = $this->lexer->token;
        if ($this->peek(Token::BRACE_L)) {
            return new OperationDefinitionNode([
                'operation'           => 'query',
                'name'                => null,
                'variableDefinitions' => new NodeList([]),
                'directives'          => new NodeList([]),
                'selectionSet'        => $this->parseSelectionSet(),
                'loc'                 => $this->loc($start),
            ]);
        }

        $operation = $this->parseOperationType();

        $name = null;
        if ($this->peek(Token::NAME)) {
            $name = $this->parseName();
        }

        return new OperationDefinitionNode([
            'operation'           => $operation,
            'name'                => $name,
            'variableDefinitions' => $this->parseVariableDefinitions(),
            'directives'          => $this->parseDirectives(false),
            'selectionSet'        => $this->parseSelectionSet(),
            'loc'                 => $this->loc($start),
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseOperationType() : string
    {
        $operationToken = $this->expect(Token::NAME);
        switch ($operationToken->value) {
            case 'query':
                return 'query';
            case 'mutation':
                return 'mutation';
            case 'subscription':
                return 'subscription';
        }

        throw $this->unexpected($operationToken);
    }

    private function parseVariableDefinitions() : NodeList
    {
        return $this->peek(Token::PAREN_L)
            ? $this->many(
                Token::PAREN_L,
                function () : VariableDefinitionNode {
                    return $this->parseVariableDefinition();
                },
                Token::PAREN_R
            )
            : new NodeList([]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseVariableDefinition() : VariableDefinitionNode
    {
        $start = $this->lexer->token;
        $var   = $this->parseVariable();

        $this->expect(Token::COLON);
        $type = $this->parseTypeReference();

        return new VariableDefinitionNode([
            'variable'     => $var,
            'type'         => $type,
            'defaultValue' => $this->skip(Token::EQUALS)
                ? $this->parseValueLiteral(true)
                : null,
            'directives'   => $this->parseDirectives(true),
            'loc'          => $this->loc($start),
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseVariable() : VariableNode
    {
        $start = $this->lexer->token;
        $this->expect(Token::DOLLAR);

        return new VariableNode([
            'name' => $this->parseName(),
            'loc'  => $this->loc($start),
        ]);
    }

    private function parseSelectionSet() : SelectionSetNode
    {
        $start = $this->lexer->token;

        return new SelectionSetNode(
            [
                'selections' => $this->many(
                    Token::BRACE_L,
                    function () : SelectionNode {
                        return $this->parseSelection();
                    },
                    Token::BRACE_R
                ),
                'loc'        => $this->loc($start),
            ]
        );
    }

    /**
     *  Selection :
     *   - Field
     *   - FragmentSpread
     *   - InlineFragment
     */
    private function parseSelection() : SelectionNode
    {
        return $this->peek(Token::SPREAD)
            ? $this->parseFragment()
            : $this->parseField();
    }

    /**
     * @throws SyntaxError
     */
    private function parseField() : FieldNode
    {
        $start       = $this->lexer->token;
        $nameOrAlias = $this->parseName();

        if ($this->skip(Token::COLON)) {
            $alias = $nameOrAlias;
            $name  = $this->parseName();
        } else {
            $alias = null;
            $name  = $nameOrAlias;
        }

        return new FieldNode([
            'alias'        => $alias,
            'name'         => $name,
            'arguments'    => $this->parseArguments(false),
            'directives'   => $this->parseDirectives(false),
            'selectionSet' => $this->peek(Token::BRACE_L) ? $this->parseSelectionSet() : null,
            'loc'          => $this->loc($start),
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseArguments(bool $isConst) : NodeList
    {
        $parseFn = $isConst
            ? function () : ArgumentNode {
                return $this->parseConstArgument();
            }
            : function () : ArgumentNode {
                return $this->parseArgument();
            };

        return $this->peek(Token::PAREN_L)
            ? $this->many(Token::PAREN_L, $parseFn, Token::PAREN_R)
            : new NodeList([]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseArgument() : ArgumentNode
    {
        $start = $this->lexer->token;
        $name  = $this->parseName();

        $this->expect(Token::COLON);
        $value = $this->parseValueLiteral(false);

        return new ArgumentNode([
            'name'  => $name,
            'value' => $value,
            'loc'   => $this->loc($start),
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseConstArgument() : ArgumentNode
    {
        $start = $this->lexer->token;
        $name  = $this->parseName();

        $this->expect(Token::COLON);
        $value = $this->parseConstValue();

        return new ArgumentNode([
            'name'  => $name,
            'value' => $value,
            'loc'   => $this->loc($start),
        ]);
    }

    // Implements the parsing rules in the Fragments section.

    /**
     * @return FragmentSpreadNode|InlineFragmentNode
     *
     * @throws SyntaxError
     */
    private function parseFragment() : SelectionNode
    {
        $start = $this->lexer->token;
        $this->expect(Token::SPREAD);

        $hasTypeCondition = $this->expectOptionalKeyword('on');
        if (! $hasTypeCondition && $this->peek(Token::NAME)) {
            return new FragmentSpreadNode([
                'name'       => $this->parseFragmentName(),
                'directives' => $this->parseDirectives(false),
                'loc'        => $this->loc($start),
            ]);
        }

        return new InlineFragmentNode([
            'typeCondition' => $hasTypeCondition ? $this->parseNamedType() : null,
            'directives'    => $this->parseDirectives(false),
            'selectionSet'  => $this->parseSelectionSet(),
            'loc'           => $this->loc($start),
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseFragmentDefinition() : FragmentDefinitionNode
    {
        $start = $this->lexer->token;
        $this->expectKeyword('fragment');

        $name = $this->parseFragmentName();

        // Experimental support for defining variables within fragments changes
        // the grammar of FragmentDefinition:
        //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet
        $variableDefinitions = null;
        if (isset($this->lexer->options['experimentalFragmentVariables'])) {
            $variableDefinitions = $this->parseVariableDefinitions();
        }
        $this->expectKeyword('on');
        $typeCondition = $this->parseNamedType();

        return new FragmentDefinitionNode([
            'name'                => $name,
            'variableDefinitions' => $variableDefinitions,
            'typeCondition'       => $typeCondition,
            'directives'          => $this->parseDirectives(false),
            'selectionSet'        => $this->parseSelectionSet(),
            'loc'                 => $this->loc($start),
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseFragmentName() : NameNode
    {
        if ($this->lexer->token->value === 'on') {
            throw $this->unexpected();
        }

        return $this->parseName();
    }

    // Implements the parsing rules in the Values section.

    /**
     * Value[Const] :
     *   - [~Const] Variable
     *   - IntValue
     *   - FloatValue
     *   - StringValue
     *   - BooleanValue
     *   - NullValue
     *   - EnumValue
     *   - ListValue[?Const]
     *   - ObjectValue[?Const]
     *
     * BooleanValue : one of `true` `false`
     *
     * NullValue : `null`
     *
     * EnumValue : Name but not `true`, `false` or `null`
     *
     * @return BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|StringValueNode|VariableNode|ListValueNode|ObjectValueNode|NullValueNode
     *
     * @throws SyntaxError
     */
    private function parseValueLiteral(bool $isConst) : ValueNode
    {
        $token = $this->lexer->token;
        switch ($token->kind) {
            case Token::BRACKET_L:
                return $this->parseArray($isConst);
            case Token::BRACE_L:
                return $this->parseObject($isConst);
            case Token::INT:
                $this->lexer->advance();

                return new IntValueNode([
                    'value' => $token->value,
                    'loc'   => $this->loc($token),
                ]);
            case Token::FLOAT:
                $this->lexer->advance();

                return new FloatValueNode([
                    'value' => $token->value,
                    'loc'   => $this->loc($token),
                ]);
            case Token::STRING:
            case Token::BLOCK_STRING:
                return $this->parseStringLiteral();
            case Token::NAME:
                if ($token->value === 'true' || $token->value === 'false') {
                    $this->lexer->advance();

                    return new BooleanValueNode([
                        'value' => $token->value === 'true',
                        'loc'   => $this->loc($token),
                    ]);
                }

                if ($token->value === 'null') {
                    $this->lexer->advance();

                    return new NullValueNode([
                        'loc' => $this->loc($token),
                    ]);
                } else {
                    $this->lexer->advance();

                    return new EnumValueNode([
                        'value' => $token->value,
                        'loc'   => $this->loc($token),
                    ]);
                }
                break;

            case Token::DOLLAR:
                if (! $isConst) {
                    return $this->parseVariable();
                }
                break;
        }
        throw $this->unexpected();
    }

    private function parseStringLiteral() : StringValueNode
    {
        $token = $this->lexer->token;
        $this->lexer->advance();

        return new StringValueNode([
            'value' => $token->value,
            'block' => $token->kind === Token::BLOCK_STRING,
            'loc'   => $this->loc($token),
        ]);
    }

    /**
     * @return BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|StringValueNode|VariableNode
     *
     * @throws SyntaxError
     */
    private function parseConstValue() : ValueNode
    {
        return $this->parseValueLiteral(true);
    }

    /**
     * @return BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|ListValueNode|ObjectValueNode|StringValueNode|VariableNode
     */
    private function parseVariableValue() : ValueNode
    {
        return $this->parseValueLiteral(false);
    }

    private function parseArray(bool $isConst) : ListValueNode
    {
        $start   = $this->lexer->token;
        $parseFn = $isConst
            ? function () {
                return $this->parseConstValue();
            }
            : function () {
                return $this->parseVariableValue();
            };

        return new ListValueNode(
            [
                'values' => $this->any(Token::BRACKET_L, $parseFn, Token::BRACKET_R),
                'loc'    => $this->loc($start),
            ]
        );
    }

    private function parseObject(bool $isConst) : ObjectValueNode
    {
        $start = $this->lexer->token;
        $this->expect(Token::BRACE_L);
        $fields = [];
        while (! $this->skip(Token::BRACE_R)) {
            $fields[] = $this->parseObjectField($isConst);
        }

        return new ObjectValueNode([
            'fields' => new NodeList($fields),
            'loc'    => $this->loc($start),
        ]);
    }

    private function parseObjectField(bool $isConst) : ObjectFieldNode
    {
        $start = $this->lexer->token;
        $name  = $this->parseName();

        $this->expect(Token::COLON);

        return new ObjectFieldNode([
            'name'  => $name,
            'value' => $this->parseValueLiteral($isConst),
            'loc'   => $this->loc($start),
        ]);
    }

    // Implements the parsing rules in the Directives section.

    /**
     * @throws SyntaxError
     */
    private function parseDirectives(bool $isConst) : NodeList
    {
        $directives = [];
        while ($this->peek(Token::AT)) {
            $directives[] = $this->parseDirective($isConst);
        }

        return new NodeList($directives);
    }

    /**
     * @throws SyntaxError
     */
    private function parseDirective(bool $isConst) : DirectiveNode
    {
        $start = $this->lexer->token;
        $this->expect(Token::AT);

        return new DirectiveNode([
            'name'      => $this->parseName(),
            'arguments' => $this->parseArguments($isConst),
            'loc'       => $this->loc($start),
        ]);
    }

    // Implements the parsing rules in the Types section.

    /**
     * Handles the Type: TypeName, ListType, and NonNullType parsing rules.
     *
     * @return ListTypeNode|NamedTypeNode|NonNullTypeNode
     *
     * @throws SyntaxError
     */
    private function parseTypeReference() : TypeNode
    {
        $start = $this->lexer->token;

        if ($this->skip(Token::BRACKET_L)) {
            $type = $this->parseTypeReference();
            $this->expect(Token::BRACKET_R);
            $type = new ListTypeNode([
                'type' => $type,
                'loc'  => $this->loc($start),
            ]);
        } else {
            $type = $this->parseNamedType();
        }
        if ($this->skip(Token::BANG)) {
            return new NonNullTypeNode([
                'type' => $type,
                'loc'  => $this->loc($start),
            ]);
        }

        return $type;
    }

    private function parseNamedType() : NamedTypeNode
    {
        $start = $this->lexer->token;

        return new NamedTypeNode([
            'name' => $this->parseName(),
            'loc'  => $this->loc($start),
        ]);
    }

    // Implements the parsing rules in the Type Definition section.

    /**
     * TypeSystemDefinition :
     *   - SchemaDefinition
     *   - TypeDefinition
     *   - TypeExtension
     *   - DirectiveDefinition
     *
     * TypeDefinition :
     *   - ScalarTypeDefinition
     *   - ObjectTypeDefinition
     *   - InterfaceTypeDefinition
     *   - UnionTypeDefinition
     *   - EnumTypeDefinition
     *   - InputObjectTypeDefinition
     *
     * @throws SyntaxError
     */
    private function parseTypeSystemDefinition() : TypeSystemDefinitionNode
    {
        // Many definitions begin with a description and require a lookahead.
        $keywordToken = $this->peekDescription()
            ? $this->lexer->lookahead()
            : $this->lexer->token;

        if ($keywordToken->kind === Token::NAME) {
            switch ($keywordToken->value) {
                case 'schema':
                    return $this->parseSchemaDefinition();
                case 'scalar':
                    return $this->parseScalarTypeDefinition();
                case 'type':
                    return $this->parseObjectTypeDefinition();
                case 'interface':
                    return $this->parseInterfaceTypeDefinition();
                case 'union':
                    return $this->parseUnionTypeDefinition();
                case 'enum':
                    return $this->parseEnumTypeDefinition();
                case 'input':
                    return $this->parseInputObjectTypeDefinition();
                case 'extend':
                    return $this->parseTypeExtension();
                case 'directive':
                    return $this->parseDirectiveDefinition();
            }
        }

        throw $this->unexpected($keywordToken);
    }

    private function peekDescription() : bool
    {
        return $this->peek(Token::STRING) || $this->peek(Token::BLOCK_STRING);
    }

    private function parseDescription() : ?StringValueNode
    {
        if ($this->peekDescription()) {
            return $this->parseStringLiteral();
        }

        return null;
    }

    /**
     * @throws SyntaxError
     */
    private function parseSchemaDefinition() : SchemaDefinitionNode
    {
        $start = $this->lexer->token;
        $this->expectKeyword('schema');
        $directives = $this->parseDirectives(true);

        $operationTypes = $this->many(
            Token::BRACE_L,
            function () : OperationTypeDefinitionNode {
                return $this->parseOperationTypeDefinition();
            },
            Token::BRACE_R
        );

        return new SchemaDefinitionNode([
            'directives'     => $directives,
            'operationTypes' => $operationTypes,
            'loc'            => $this->loc($start),
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseOperationTypeDefinition() : OperationTypeDefinitionNode
    {
        $start     = $this->lexer->token;
        $operation = $this->parseOperationType();
        $this->expect(Token::COLON);
        $type = $this->parseNamedType();

        return new OperationTypeDefinitionNode([
            'operation' => $operation,
            'type'      => $type,
            'loc'       => $this->loc($start),
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseScalarTypeDefinition() : ScalarTypeDefinitionNode
    {
        $start       = $this->lexer->token;
        $description = $this->parseDescription();
        $this->expectKeyword('scalar');
        $name       = $this->parseName();
        $directives = $this->parseDirectives(true);

        return new ScalarTypeDefinitionNode([
            'name'        => $name,
            'directives'  => $directives,
            'loc'         => $this->loc($start),
            'description' => $description,
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseObjectTypeDefinition() : ObjectTypeDefinitionNode
    {
        $start       = $this->lexer->token;
        $description = $this->parseDescription();
        $this->expectKeyword('type');
        $name       = $this->parseName();
        $interfaces = $this->parseImplementsInterfaces();
        $directives = $this->parseDirectives(true);
        $fields     = $this->parseFieldsDefinition();

        return new ObjectTypeDefinitionNode([
            'name'        => $name,
            'interfaces'  => $interfaces,
            'directives'  => $directives,
            'fields'      => $fields,
            'loc'         => $this->loc($start),
            'description' => $description,
        ]);
    }

    /**
     * ImplementsInterfaces :
     *   - implements `&`? NamedType
     *   - ImplementsInterfaces & NamedType
     */
    private function parseImplementsInterfaces() : NodeList
    {
        $types = [];
        if ($this->expectOptionalKeyword('implements')) {
            // Optional leading ampersand
            $this->skip(Token::AMP);
            do {
                $types[] = $this->parseNamedType();
            } while ($this->skip(Token::AMP) ||
                // Legacy support for the SDL?
                (($this->lexer->options['allowLegacySDLImplementsInterfaces'] ?? false) && $this->peek(Token::NAME))
            );
        }

        return new NodeList($types);
    }

    /**
     * @throws SyntaxError
     */
    private function parseFieldsDefinition() : NodeList
    {
        // Legacy support for the SDL?
        if (($this->lexer->options['allowLegacySDLEmptyFields'] ?? false)
            && $this->peek(Token::BRACE_L)
            && $this->lexer->lookahead()->kind === Token::BRACE_R
        ) {
            $this->lexer->advance();
            $this->lexer->advance();

            /** @phpstan-var NodeList<FieldDefinitionNode&Node> $nodeList */
            $nodeList = new NodeList([]);
        } else {
            /** @phpstan-var NodeList<FieldDefinitionNode&Node> $nodeList */
            $nodeList = $this->peek(Token::BRACE_L)
                ? $this->many(
                    Token::BRACE_L,
                    function () : FieldDefinitionNode {
                        return $this->parseFieldDefinition();
                    },
                    Token::BRACE_R
                )
                : new NodeList([]);
        }

        return $nodeList;
    }

    /**
     * @throws SyntaxError
     */
    private function parseFieldDefinition() : FieldDefinitionNode
    {
        $start       = $this->lexer->token;
        $description = $this->parseDescription();
        $name        = $this->parseName();
        $args        = $this->parseArgumentsDefinition();
        $this->expect(Token::COLON);
        $type       = $this->parseTypeReference();
        $directives = $this->parseDirectives(true);

        return new FieldDefinitionNode([
            'name'        => $name,
            'arguments'   => $args,
            'type'        => $type,
            'directives'  => $directives,
            'loc'         => $this->loc($start),
            'description' => $description,
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseArgumentsDefinition() : NodeList
    {
        /** @var NodeList<InputValueDefinitionNode&Node> $nodeList */
        $nodeList = $this->peek(Token::PAREN_L)
            ? $this->many(
                Token::PAREN_L,
                function () : InputValueDefinitionNode {
                    return $this->parseInputValueDefinition();
                },
                Token::PAREN_R
            )
            : new NodeList([]);

        return $nodeList;
    }

    /**
     * @throws SyntaxError
     */
    private function parseInputValueDefinition() : InputValueDefinitionNode
    {
        $start       = $this->lexer->token;
        $description = $this->parseDescription();
        $name        = $this->parseName();
        $this->expect(Token::COLON);
        $type         = $this->parseTypeReference();
        $defaultValue = null;
        if ($this->skip(Token::EQUALS)) {
            $defaultValue = $this->parseConstValue();
        }
        $directives = $this->parseDirectives(true);

        return new InputValueDefinitionNode([
            'name'         => $name,
            'type'         => $type,
            'defaultValue' => $defaultValue,
            'directives'   => $directives,
            'loc'          => $this->loc($start),
            'description'  => $description,
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseInterfaceTypeDefinition() : InterfaceTypeDefinitionNode
    {
        $start       = $this->lexer->token;
        $description = $this->parseDescription();
        $this->expectKeyword('interface');
        $name       = $this->parseName();
        $interfaces = $this->parseImplementsInterfaces();
        $directives = $this->parseDirectives(true);
        $fields     = $this->parseFieldsDefinition();

        return new InterfaceTypeDefinitionNode([
            'name'        => $name,
            'directives'  => $directives,
            'interfaces'  => $interfaces,
            'fields'      => $fields,
            'loc'         => $this->loc($start),
            'description' => $description,
        ]);
    }

    /**
     * UnionTypeDefinition :
     *   - Description? union Name Directives[Const]? UnionMemberTypes?
     *
     * @throws SyntaxError
     */
    private function parseUnionTypeDefinition() : UnionTypeDefinitionNode
    {
        $start       = $this->lexer->token;
        $description = $this->parseDescription();
        $this->expectKeyword('union');
        $name       = $this->parseName();
        $directives = $this->parseDirectives(true);
        $types      = $this->parseUnionMemberTypes();

        return new UnionTypeDefinitionNode([
            'name'        => $name,
            'directives'  => $directives,
            'types'       => $types,
            'loc'         => $this->loc($start),
            'description' => $description,
        ]);
    }

    /**
     * UnionMemberTypes :
     *   - = `|`? NamedType
     *   - UnionMemberTypes | NamedType
     */
    private function parseUnionMemberTypes() : NodeList
    {
        $types = [];
        if ($this->skip(Token::EQUALS)) {
            // Optional leading pipe
            $this->skip(Token::PIPE);
            do {
                $types[] = $this->parseNamedType();
            } while ($this->skip(Token::PIPE));
        }

        return new NodeList($types);
    }

    /**
     * @throws SyntaxError
     */
    private function parseEnumTypeDefinition() : EnumTypeDefinitionNode
    {
        $start       = $this->lexer->token;
        $description = $this->parseDescription();
        $this->expectKeyword('enum');
        $name       = $this->parseName();
        $directives = $this->parseDirectives(true);
        $values     = $this->parseEnumValuesDefinition();

        return new EnumTypeDefinitionNode([
            'name'        => $name,
            'directives'  => $directives,
            'values'      => $values,
            'loc'         => $this->loc($start),
            'description' => $description,
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseEnumValuesDefinition() : NodeList
    {
        /** @var NodeList<EnumValueDefinitionNode&Node> $nodeList */
        $nodeList = $this->peek(Token::BRACE_L)
            ? $this->many(
                Token::BRACE_L,
                function () : EnumValueDefinitionNode {
                    return $this->parseEnumValueDefinition();
                },
                Token::BRACE_R
            )
            : new NodeList([]);

        return $nodeList;
    }

    /**
     * @throws SyntaxError
     */
    private function parseEnumValueDefinition() : EnumValueDefinitionNode
    {
        $start       = $this->lexer->token;
        $description = $this->parseDescription();
        $name        = $this->parseName();
        $directives  = $this->parseDirectives(true);

        return new EnumValueDefinitionNode([
            'name'        => $name,
            'directives'  => $directives,
            'loc'         => $this->loc($start),
            'description' => $description,
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseInputObjectTypeDefinition() : InputObjectTypeDefinitionNode
    {
        $start       = $this->lexer->token;
        $description = $this->parseDescription();
        $this->expectKeyword('input');
        $name       = $this->parseName();
        $directives = $this->parseDirectives(true);
        $fields     = $this->parseInputFieldsDefinition();

        return new InputObjectTypeDefinitionNode([
            'name'        => $name,
            'directives'  => $directives,
            'fields'      => $fields,
            'loc'         => $this->loc($start),
            'description' => $description,
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseInputFieldsDefinition() : NodeList
    {
        /** @var NodeList<InputValueDefinitionNode&Node> $nodeList */
        $nodeList = $this->peek(Token::BRACE_L)
            ? $this->many(
                Token::BRACE_L,
                function () : InputValueDefinitionNode {
                    return $this->parseInputValueDefinition();
                },
                Token::BRACE_R
            )
            : new NodeList([]);

        return $nodeList;
    }

    /**
     * TypeExtension :
     *   - ScalarTypeExtension
     *   - ObjectTypeExtension
     *   - InterfaceTypeExtension
     *   - UnionTypeExtension
     *   - EnumTypeExtension
     *   - InputObjectTypeDefinition
     *
     * @throws SyntaxError
     */
    private function parseTypeExtension() : TypeExtensionNode
    {
        $keywordToken = $this->lexer->lookahead();

        if ($keywordToken->kind === Token::NAME) {
            switch ($keywordToken->value) {
                case 'schema':
                    return $this->parseSchemaTypeExtension();
                case 'scalar':
                    return $this->parseScalarTypeExtension();
                case 'type':
                    return $this->parseObjectTypeExtension();
                case 'interface':
                    return $this->parseInterfaceTypeExtension();
                case 'union':
                    return $this->parseUnionTypeExtension();
                case 'enum':
                    return $this->parseEnumTypeExtension();
                case 'input':
                    return $this->parseInputObjectTypeExtension();
            }
        }

        throw $this->unexpected($keywordToken);
    }

    /**
     * @throws SyntaxError
     */
    private function parseSchemaTypeExtension() : SchemaTypeExtensionNode
    {
        $start = $this->lexer->token;
        $this->expectKeyword('extend');
        $this->expectKeyword('schema');
        $directives     = $this->parseDirectives(true);
        $operationTypes = $this->peek(Token::BRACE_L)
            ? $this->many(
                Token::BRACE_L,
                [$this, 'parseOperationTypeDefinition'],
                Token::BRACE_R
            )
            : new NodeList([]);
        if (count($directives) === 0 && count($operationTypes) === 0) {
            $this->unexpected();
        }

        return new SchemaTypeExtensionNode([
            'directives' => $directives,
            'operationTypes' => $operationTypes,
            'loc' => $this->loc($start),
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseScalarTypeExtension() : ScalarTypeExtensionNode
    {
        $start = $this->lexer->token;
        $this->expectKeyword('extend');
        $this->expectKeyword('scalar');
        $name       = $this->parseName();
        $directives = $this->parseDirectives(true);
        if (count($directives) === 0) {
            throw $this->unexpected();
        }

        return new ScalarTypeExtensionNode([
            'name'       => $name,
            'directives' => $directives,
            'loc'        => $this->loc($start),
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseObjectTypeExtension() : ObjectTypeExtensionNode
    {
        $start = $this->lexer->token;
        $this->expectKeyword('extend');
        $this->expectKeyword('type');
        $name       = $this->parseName();
        $interfaces = $this->parseImplementsInterfaces();
        $directives = $this->parseDirectives(true);
        $fields     = $this->parseFieldsDefinition();

        if (count($interfaces) === 0 &&
            count($directives) === 0 &&
            count($fields) === 0
        ) {
            throw $this->unexpected();
        }

        return new ObjectTypeExtensionNode([
            'name'       => $name,
            'interfaces' => $interfaces,
            'directives' => $directives,
            'fields'     => $fields,
            'loc'        => $this->loc($start),
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseInterfaceTypeExtension() : InterfaceTypeExtensionNode
    {
        $start = $this->lexer->token;
        $this->expectKeyword('extend');
        $this->expectKeyword('interface');
        $name       = $this->parseName();
        $interfaces = $this->parseImplementsInterfaces();
        $directives = $this->parseDirectives(true);
        $fields     = $this->parseFieldsDefinition();
        if (count($interfaces) === 0
            && count($directives) === 0
            && count($fields) === 0
        ) {
            throw $this->unexpected();
        }

        return new InterfaceTypeExtensionNode([
            'name'       => $name,
            'directives' => $directives,
            'interfaces' => $interfaces,
            'fields'     => $fields,
            'loc'        => $this->loc($start),
        ]);
    }

    /**
     * UnionTypeExtension :
     *   - extend union Name Directives[Const]? UnionMemberTypes
     *   - extend union Name Directives[Const]
     *
     * @throws SyntaxError
     */
    private function parseUnionTypeExtension() : UnionTypeExtensionNode
    {
        $start = $this->lexer->token;
        $this->expectKeyword('extend');
        $this->expectKeyword('union');
        $name       = $this->parseName();
        $directives = $this->parseDirectives(true);
        $types      = $this->parseUnionMemberTypes();
        if (count($directives) === 0 && count($types) === 0) {
            throw $this->unexpected();
        }

        return new UnionTypeExtensionNode([
            'name'       => $name,
            'directives' => $directives,
            'types'      => $types,
            'loc'        => $this->loc($start),
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseEnumTypeExtension() : EnumTypeExtensionNode
    {
        $start = $this->lexer->token;
        $this->expectKeyword('extend');
        $this->expectKeyword('enum');
        $name       = $this->parseName();
        $directives = $this->parseDirectives(true);
        $values     = $this->parseEnumValuesDefinition();
        if (count($directives) === 0 &&
            count($values) === 0
        ) {
            throw $this->unexpected();
        }

        return new EnumTypeExtensionNode([
            'name'       => $name,
            'directives' => $directives,
            'values'     => $values,
            'loc'        => $this->loc($start),
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseInputObjectTypeExtension() : InputObjectTypeExtensionNode
    {
        $start = $this->lexer->token;
        $this->expectKeyword('extend');
        $this->expectKeyword('input');
        $name       = $this->parseName();
        $directives = $this->parseDirectives(true);
        $fields     = $this->parseInputFieldsDefinition();
        if (count($directives) === 0 &&
            count($fields) === 0
        ) {
            throw $this->unexpected();
        }

        return new InputObjectTypeExtensionNode([
            'name'       => $name,
            'directives' => $directives,
            'fields'     => $fields,
            'loc'        => $this->loc($start),
        ]);
    }

    /**
     * DirectiveDefinition :
     *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
     *
     * @throws SyntaxError
     */
    private function parseDirectiveDefinition() : DirectiveDefinitionNode
    {
        $start       = $this->lexer->token;
        $description = $this->parseDescription();
        $this->expectKeyword('directive');
        $this->expect(Token::AT);
        $name       = $this->parseName();
        $args       = $this->parseArgumentsDefinition();
        $repeatable = $this->expectOptionalKeyword('repeatable');
        $this->expectKeyword('on');
        $locations = $this->parseDirectiveLocations();

        return new DirectiveDefinitionNode([
            'name'        => $name,
            'description' => $description,
            'arguments'   => $args,
            'repeatable'  => $repeatable,
            'locations'   => $locations,
            'loc'         => $this->loc($start),
        ]);
    }

    /**
     * @throws SyntaxError
     */
    private function parseDirectiveLocations() : NodeList
    {
        // Optional leading pipe
        $this->skip(Token::PIPE);
        $locations = [];
        do {
            $locations[] = $this->parseDirectiveLocation();
        } while ($this->skip(Token::PIPE));

        return new NodeList($locations);
    }

    /**
     * @throws SyntaxError
     */
    private function parseDirectiveLocation() : NameNode
    {
        $start = $this->lexer->token;
        $name  = $this->parseName();
        if (DirectiveLocation::has($name->value)) {
            return $name;
        }

        throw $this->unexpected($start);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\Printer.php
<?php

declare(strict_types=1);

namespace GraphQL\Language;

use GraphQL\Language\AST\ArgumentNode;
use GraphQL\Language\AST\BooleanValueNode;
use GraphQL\Language\AST\DirectiveDefinitionNode;
use GraphQL\Language\AST\DirectiveNode;
use GraphQL\Language\AST\DocumentNode;
use GraphQL\Language\AST\EnumTypeDefinitionNode;
use GraphQL\Language\AST\EnumTypeExtensionNode;
use GraphQL\Language\AST\EnumValueDefinitionNode;
use GraphQL\Language\AST\EnumValueNode;
use GraphQL\Language\AST\FieldDefinitionNode;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\FloatValueNode;
use GraphQL\Language\AST\FragmentDefinitionNode;
use GraphQL\Language\AST\FragmentSpreadNode;
use GraphQL\Language\AST\InlineFragmentNode;
use GraphQL\Language\AST\InputObjectTypeDefinitionNode;
use GraphQL\Language\AST\InputObjectTypeExtensionNode;
use GraphQL\Language\AST\InputValueDefinitionNode;
use GraphQL\Language\AST\InterfaceTypeDefinitionNode;
use GraphQL\Language\AST\InterfaceTypeExtensionNode;
use GraphQL\Language\AST\IntValueNode;
use GraphQL\Language\AST\ListTypeNode;
use GraphQL\Language\AST\ListValueNode;
use GraphQL\Language\AST\NamedTypeNode;
use GraphQL\Language\AST\NameNode;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\NonNullTypeNode;
use GraphQL\Language\AST\NullValueNode;
use GraphQL\Language\AST\ObjectFieldNode;
use GraphQL\Language\AST\ObjectTypeDefinitionNode;
use GraphQL\Language\AST\ObjectTypeExtensionNode;
use GraphQL\Language\AST\ObjectValueNode;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Language\AST\OperationTypeDefinitionNode;
use GraphQL\Language\AST\ScalarTypeDefinitionNode;
use GraphQL\Language\AST\ScalarTypeExtensionNode;
use GraphQL\Language\AST\SchemaDefinitionNode;
use GraphQL\Language\AST\SchemaTypeExtensionNode;
use GraphQL\Language\AST\SelectionSetNode;
use GraphQL\Language\AST\StringValueNode;
use GraphQL\Language\AST\UnionTypeDefinitionNode;
use GraphQL\Language\AST\UnionTypeExtensionNode;
use GraphQL\Language\AST\VariableDefinitionNode;
use GraphQL\Language\AST\VariableNode;
use GraphQL\Utils\Utils;
use function count;
use function implode;
use function json_encode;
use function preg_replace;
use function sprintf;
use function str_replace;
use function strlen;
use function strpos;

/**
 * Prints AST to string. Capable of printing GraphQL queries and Type definition language.
 * Useful for pretty-printing queries or printing back AST for logging, documentation, etc.
 *
 * Usage example:
 *
 * ```php
 * $query = 'query myQuery {someField}';
 * $ast = GraphQL\Language\Parser::parse($query);
 * $printed = GraphQL\Language\Printer::doPrint($ast);
 * ```
 */
class Printer
{
    /**
     * Prints AST to string. Capable of printing GraphQL queries and Type definition language.
     *
     * @param Node $ast
     *
     * @return string
     *
     * @api
     */
    public static function doPrint($ast)
    {
        static $instance;
        $instance = $instance ?? new static();

        return $instance->printAST($ast);
    }

    protected function __construct()
    {
    }

    /**
     * Traverse an AST bottom-up, converting all nodes to strings.
     *
     * That means the AST is manipulated in such a way that it no longer
     * resembles the well-formed result of parsing.
     */
    public function printAST($ast)
    {
        return Visitor::visit(
            $ast,
            [
                'leave' => [
                    NodeKind::NAME => static function (NameNode $node) : string {
                        return $node->value;
                    },

                    NodeKind::VARIABLE => static function (VariableNode $node) : string {
                        return '$' . $node->name;
                    },

                    NodeKind::DOCUMENT => function (DocumentNode $node) : string {
                        return $this->join($node->definitions, "\n\n") . "\n";
                    },

                    NodeKind::OPERATION_DEFINITION => function (OperationDefinitionNode $node) : string {
                        $op           = $node->operation;
                        $name         = $node->name;
                        $varDefs      = $this->wrap('(', $this->join($node->variableDefinitions, ', '), ')');
                        $directives   = $this->join($node->directives, ' ');
                        $selectionSet = $node->selectionSet;

                        // Anonymous queries with no directives or variable definitions can use
                        // the query short form.
                        return $name === null && strlen($directives ?? '') === 0 && ! $varDefs && $op === 'query'
                            ? $selectionSet
                            : $this->join([$op, $this->join([$name, $varDefs]), $directives, $selectionSet], ' ');
                    },

                    NodeKind::VARIABLE_DEFINITION => function (VariableDefinitionNode $node) : string {
                        return $node->variable
                            . ': '
                            . $node->type
                            . $this->wrap(' = ', $node->defaultValue)
                            . $this->wrap(' ', $this->join($node->directives, ' '));
                    },

                    NodeKind::SELECTION_SET => function (SelectionSetNode $node) {
                        return $this->block($node->selections);
                    },

                    NodeKind::FIELD => function (FieldNode $node) : string {
                        return $this->join(
                            [
                                $this->wrap('', $node->alias, ': ') . $node->name . $this->wrap(
                                    '(',
                                    $this->join($node->arguments, ', '),
                                    ')'
                                ),
                                $this->join($node->directives, ' '),
                                $node->selectionSet,
                            ],
                            ' '
                        );
                    },

                    NodeKind::ARGUMENT => static function (ArgumentNode $node) : string {
                        return $node->name . ': ' . $node->value;
                    },

                    NodeKind::FRAGMENT_SPREAD => function (FragmentSpreadNode $node) : string {
                        return '...'
                            . $node->name
                            . $this->wrap(' ', $this->join($node->directives, ' '));
                    },

                    NodeKind::INLINE_FRAGMENT => function (InlineFragmentNode $node) : string {
                        return $this->join(
                            [
                                '...',
                                $this->wrap('on ', $node->typeCondition),
                                $this->join($node->directives, ' '),
                                $node->selectionSet,
                            ],
                            ' '
                        );
                    },

                    NodeKind::FRAGMENT_DEFINITION => function (FragmentDefinitionNode $node) : string {
                        // Note: fragment variable definitions are experimental and may be changed or removed in the future.
                        return sprintf('fragment %s', $node->name)
                            . $this->wrap('(', $this->join($node->variableDefinitions, ', '), ')')
                            . sprintf(' on %s ', $node->typeCondition)
                            . $this->wrap('', $this->join($node->directives, ' '), ' ')
                            . $node->selectionSet;
                    },

                    NodeKind::INT => static function (IntValueNode $node) : string {
                        return $node->value;
                    },

                    NodeKind::FLOAT => static function (FloatValueNode $node) : string {
                        return $node->value;
                    },

                    NodeKind::STRING => function (StringValueNode $node, $key) : string {
                        if ($node->block) {
                            return $this->printBlockString($node->value, $key === 'description');
                        }

                        return json_encode($node->value);
                    },

                    NodeKind::BOOLEAN => static function (BooleanValueNode $node) : string {
                        return $node->value ? 'true' : 'false';
                    },

                    NodeKind::NULL => static function (NullValueNode $node) : string {
                        return 'null';
                    },

                    NodeKind::ENUM => static function (EnumValueNode $node) : string {
                        return $node->value;
                    },

                    NodeKind::LST => function (ListValueNode $node) : string {
                        return '[' . $this->join($node->values, ', ') . ']';
                    },

                    NodeKind::OBJECT => function (ObjectValueNode $node) : string {
                        return '{' . $this->join($node->fields, ', ') . '}';
                    },

                    NodeKind::OBJECT_FIELD => static function (ObjectFieldNode $node) : string {
                        return $node->name . ': ' . $node->value;
                    },

                    NodeKind::DIRECTIVE => function (DirectiveNode $node) : string {
                        return '@' . $node->name . $this->wrap('(', $this->join($node->arguments, ', '), ')');
                    },

                    NodeKind::NAMED_TYPE => static function (NamedTypeNode $node) : string {
                        // @phpstan-ignore-next-line the printer works bottom up, so this is already a string here
                        return $node->name;
                    },

                    NodeKind::LIST_TYPE => static function (ListTypeNode $node) : string {
                        return '[' . $node->type . ']';
                    },

                    NodeKind::NON_NULL_TYPE => static function (NonNullTypeNode $node) : string {
                        return $node->type . '!';
                    },

                    NodeKind::SCHEMA_DEFINITION => function (SchemaDefinitionNode $def) : string {
                        return $this->join(
                            [
                                'schema',
                                $this->join($def->directives, ' '),
                                $this->block($def->operationTypes),
                            ],
                            ' '
                        );
                    },

                    NodeKind::OPERATION_TYPE_DEFINITION => static function (OperationTypeDefinitionNode $def) : string {
                        return $def->operation . ': ' . $def->type;
                    },

                    NodeKind::SCALAR_TYPE_DEFINITION => $this->addDescription(function (ScalarTypeDefinitionNode $def) : string {
                        return $this->join(['scalar', $def->name, $this->join($def->directives, ' ')], ' ');
                    }),

                    NodeKind::OBJECT_TYPE_DEFINITION => $this->addDescription(function (ObjectTypeDefinitionNode $def) : string {
                        return $this->join(
                            [
                                'type',
                                $def->name,
                                $this->wrap('implements ', $this->join($def->interfaces, ' & ')),
                                $this->join($def->directives, ' '),
                                $this->block($def->fields),
                            ],
                            ' '
                        );
                    }),

                    NodeKind::FIELD_DEFINITION => $this->addDescription(function (FieldDefinitionNode $def) : string {
                        $noIndent = Utils::every($def->arguments, static function (string $arg) : bool {
                            return strpos($arg, "\n") === false;
                        });

                        return $def->name
                            . ($noIndent
                                ? $this->wrap('(', $this->join($def->arguments, ', '), ')')
                                : $this->wrap("(\n", $this->indent($this->join($def->arguments, "\n")), "\n)"))
                            . ': ' . $def->type
                            . $this->wrap(' ', $this->join($def->directives, ' '));
                    }),

                    NodeKind::INPUT_VALUE_DEFINITION => $this->addDescription(function (InputValueDefinitionNode $def) : string {
                        return $this->join(
                            [
                                $def->name . ': ' . $def->type,
                                $this->wrap('= ', $def->defaultValue),
                                $this->join($def->directives, ' '),
                            ],
                            ' '
                        );
                    }),

                    NodeKind::INTERFACE_TYPE_DEFINITION => $this->addDescription(
                        function (InterfaceTypeDefinitionNode $def) : string {
                            return $this->join(
                                [
                                    'interface',
                                    $def->name,
                                    $this->wrap('implements ', $this->join($def->interfaces, ' & ')),
                                    $this->join($def->directives, ' '),
                                    $this->block($def->fields),
                                ],
                                ' '
                            );
                        }
                    ),

                    NodeKind::UNION_TYPE_DEFINITION => $this->addDescription(function (UnionTypeDefinitionNode $def) : string {
                        return $this->join(
                            [
                                'union',
                                $def->name,
                                $this->join($def->directives, ' '),
                                count($def->types ?? []) > 0
                                    ? '= ' . $this->join($def->types, ' | ')
                                    : '',
                            ],
                            ' '
                        );
                    }),

                    NodeKind::ENUM_TYPE_DEFINITION => $this->addDescription(function (EnumTypeDefinitionNode $def) : string {
                        return $this->join(
                            [
                                'enum',
                                $def->name,
                                $this->join($def->directives, ' '),
                                $this->block($def->values),
                            ],
                            ' '
                        );
                    }),

                    NodeKind::ENUM_VALUE_DEFINITION => $this->addDescription(function (EnumValueDefinitionNode $def) : string {
                        return $this->join([$def->name, $this->join($def->directives, ' ')], ' ');
                    }),

                    NodeKind::INPUT_OBJECT_TYPE_DEFINITION => $this->addDescription(function (
                        InputObjectTypeDefinitionNode $def
                    ) : string {
                        return $this->join(
                            [
                                'input',
                                $def->name,
                                $this->join($def->directives, ' '),
                                $this->block($def->fields),
                            ],
                            ' '
                        );
                    }),

                    NodeKind::SCHEMA_EXTENSION => function (SchemaTypeExtensionNode $def) : string {
                        return $this->join(
                            [
                                'extend schema',
                                $this->join($def->directives, ' '),
                                $this->block($def->operationTypes),
                            ],
                            ' '
                        );
                    },

                    NodeKind::SCALAR_TYPE_EXTENSION => function (ScalarTypeExtensionNode $def) : string {
                        return $this->join(
                            [
                                'extend scalar',
                                $def->name,
                                $this->join($def->directives, ' '),
                            ],
                            ' '
                        );
                    },

                    NodeKind::OBJECT_TYPE_EXTENSION => function (ObjectTypeExtensionNode $def) : string {
                        return $this->join(
                            [
                                'extend type',
                                $def->name,
                                $this->wrap('implements ', $this->join($def->interfaces, ' & ')),
                                $this->join($def->directives, ' '),
                                $this->block($def->fields),
                            ],
                            ' '
                        );
                    },

                    NodeKind::INTERFACE_TYPE_EXTENSION => function (InterfaceTypeExtensionNode $def) : string {
                        return $this->join(
                            [
                                'extend interface',
                                $def->name,
                                $this->wrap('implements ', $this->join($def->interfaces, ' & ')),
                                $this->join($def->directives, ' '),
                                $this->block($def->fields),
                            ],
                            ' '
                        );
                    },

                    NodeKind::UNION_TYPE_EXTENSION => function (UnionTypeExtensionNode $def) : string {
                        return $this->join(
                            [
                                'extend union',
                                $def->name,
                                $this->join($def->directives, ' '),
                                count($def->types ?? []) > 0
                                    ? '= ' . $this->join($def->types, ' | ')
                                    : '',
                            ],
                            ' '
                        );
                    },

                    NodeKind::ENUM_TYPE_EXTENSION => function (EnumTypeExtensionNode $def) : string {
                        return $this->join(
                            [
                                'extend enum',
                                $def->name,
                                $this->join($def->directives, ' '),
                                $this->block($def->values),
                            ],
                            ' '
                        );
                    },

                    NodeKind::INPUT_OBJECT_TYPE_EXTENSION => function (InputObjectTypeExtensionNode $def) : string {
                        return $this->join(
                            [
                                'extend input',
                                $def->name,
                                $this->join($def->directives, ' '),
                                $this->block($def->fields),
                            ],
                            ' '
                        );
                    },

                    NodeKind::DIRECTIVE_DEFINITION => $this->addDescription(function (DirectiveDefinitionNode $def) : string {
                        $noIndent = Utils::every($def->arguments, static function (string $arg) : bool {
                            return strpos($arg, "\n") === false;
                        });

                        return 'directive @'
                            . $def->name
                            . ($noIndent
                                ? $this->wrap('(', $this->join($def->arguments, ', '), ')')
                                : $this->wrap("(\n", $this->indent($this->join($def->arguments, "\n")), "\n"))
                            . ($def->repeatable ? ' repeatable' : '')
                            . ' on ' . $this->join($def->locations, ' | ');
                    }),
                ],
            ]
        );
    }

    public function addDescription(callable $cb)
    {
        return function ($node) use ($cb) : string {
            return $this->join([$node->description, $cb($node)], "\n");
        };
    }

    /**
     * If maybeString is not null or empty, then wrap with start and end, otherwise
     * print an empty string.
     */
    public function wrap($start, $maybeString, $end = '')
    {
        return $maybeString ? ($start . $maybeString . $end) : '';
    }

    /**
     * Given array, print each item on its own line, wrapped in an
     * indented "{ }" block.
     */
    public function block($array)
    {
        return $array && $this->length($array)
            ? "{\n" . $this->indent($this->join($array, "\n")) . "\n}"
            : '';
    }

    public function indent($maybeString)
    {
        return $maybeString ? '  ' . str_replace("\n", "\n  ", $maybeString) : '';
    }

    public function manyList($start, $list, $separator, $end)
    {
        return $this->length($list) === 0 ? null : ($start . $this->join($list, $separator) . $end);
    }

    public function length($maybeArray)
    {
        return $maybeArray ? count($maybeArray) : 0;
    }

    public function join($maybeArray, $separator = '') : string
    {
        return $maybeArray
            ? implode(
                $separator,
                Utils::filter(
                    $maybeArray,
                    static function ($x) : bool {
                        return (bool) $x;
                    }
                )
            )
            : '';
    }

    /**
     * Print a block string in the indented block form by adding a leading and
     * trailing blank line. However, if a block string starts with whitespace and is
     * a single-line, adding a leading blank line would strip that whitespace.
     */
    private function printBlockString($value, $isDescription)
    {
        $escaped = str_replace('"""', '\\"""', $value);

        return ($value[0] === ' ' || $value[0] === "\t") && strpos($value, "\n") === false
            ? ('"""' . preg_replace('/"$/', "\"\n", $escaped) . '"""')
            : ('"""' . "\n" . ($isDescription ? $escaped : $this->indent($escaped)) . "\n" . '"""');
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\Source.php
<?php

declare(strict_types=1);

namespace GraphQL\Language;

use GraphQL\Utils\Utils;
use function is_string;
use function json_decode;
use function mb_strlen;
use function mb_substr;
use function preg_match_all;
use const PREG_OFFSET_CAPTURE;

class Source
{
    /** @var string */
    public $body;

    /** @var int */
    public $length;

    /** @var string */
    public $name;

    /** @var SourceLocation */
    public $locationOffset;

    /**
     * A representation of source input to GraphQL.
     * `name` and `locationOffset` are optional. They are useful for clients who
     * store GraphQL documents in source files; for example, if the GraphQL input
     * starts at line 40 in a file named Foo.graphql, it might be useful for name to
     * be "Foo.graphql" and location to be `{ line: 40, column: 0 }`.
     * line and column in locationOffset are 1-indexed
     *
     * @param string      $body
     * @param string|null $name
     */
    public function __construct($body, $name = null, ?SourceLocation $location = null)
    {
        Utils::invariant(
            is_string($body),
            'GraphQL query body is expected to be string, but got ' . Utils::getVariableType($body)
        );

        $this->body           = $body;
        $this->length         = mb_strlen($body, 'UTF-8');
        $this->name           = $name === '' || $name === null ? 'GraphQL request' : $name;
        $this->locationOffset = $location ?? new SourceLocation(1, 1);

        Utils::invariant(
            $this->locationOffset->line > 0,
            'line in locationOffset is 1-indexed and must be positive'
        );
        Utils::invariant(
            $this->locationOffset->column > 0,
            'column in locationOffset is 1-indexed and must be positive'
        );
    }

    /**
     * @param int $position
     *
     * @return SourceLocation
     */
    public function getLocation($position)
    {
        $line   = 1;
        $column = $position + 1;

        $utfChars   = json_decode('"\u2028\u2029"');
        $lineRegexp = '/\r\n|[\n\r' . $utfChars . ']/su';
        $matches    = [];
        preg_match_all($lineRegexp, mb_substr($this->body, 0, $position, 'UTF-8'), $matches, PREG_OFFSET_CAPTURE);

        foreach ($matches[0] as $index => $match) {
            $line += 1;

            $column = $position + 1 - ($match[1] + mb_strlen($match[0], 'UTF-8'));
        }

        return new SourceLocation($line, $column);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\SourceLocation.php
<?php

declare(strict_types=1);

namespace GraphQL\Language;

use JsonSerializable;
use ReturnTypeWillChange;

class SourceLocation implements JsonSerializable
{
    /** @var int */
    public $line;

    /** @var int */
    public $column;

    /**
     * @param int $line
     * @param int $col
     */
    public function __construct($line, $col)
    {
        $this->line   = $line;
        $this->column = $col;
    }

    /**
     * @return int[]
     */
    public function toArray()
    {
        return [
            'line'   => $this->line,
            'column' => $this->column,
        ];
    }

    /**
     * @return int[]
     */
    public function toSerializableArray()
    {
        return $this->toArray();
    }

    /**
     * @return int[]
     */
    #[ReturnTypeWillChange]
    public function jsonSerialize()
    {
        return $this->toSerializableArray();
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\Token.php
<?php

declare(strict_types=1);

namespace GraphQL\Language;

/**
 * Represents a range of characters represented by a lexical token
 * within a Source.
 */
class Token
{
    // Each kind of token.
    public const SOF          = '<SOF>';
    public const EOF          = '<EOF>';
    public const BANG         = '!';
    public const DOLLAR       = '$';
    public const AMP          = '&';
    public const PAREN_L      = '(';
    public const PAREN_R      = ')';
    public const SPREAD       = '...';
    public const COLON        = ':';
    public const EQUALS       = '=';
    public const AT           = '@';
    public const BRACKET_L    = '[';
    public const BRACKET_R    = ']';
    public const BRACE_L      = '{';
    public const PIPE         = '|';
    public const BRACE_R      = '}';
    public const NAME         = 'Name';
    public const INT          = 'Int';
    public const FLOAT        = 'Float';
    public const STRING       = 'String';
    public const BLOCK_STRING = 'BlockString';
    public const COMMENT      = 'Comment';

    /**
     * The kind of Token (see one of constants above).
     *
     * @var string
     */
    public $kind;

    /**
     * The character offset at which this Node begins.
     *
     * @var int
     */
    public $start;

    /**
     * The character offset at which this Node ends.
     *
     * @var int
     */
    public $end;

    /**
     * The 1-indexed line number on which this Token appears.
     *
     * @var int
     */
    public $line;

    /**
     * The 1-indexed column number at which this Token begins.
     *
     * @var int
     */
    public $column;

    /** @var string|null */
    public $value;

    /**
     * Tokens exist as nodes in a double-linked-list amongst all tokens
     * including ignored tokens. <SOF> is always the first node and <EOF>
     * the last.
     *
     * @var Token
     */
    public $prev;

    /** @var Token|null */
    public $next;

    /**
     * @param mixed $value
     */
    public function __construct(string $kind, int $start, int $end, int $line, int $column, ?Token $previous = null, $value = null)
    {
        $this->kind   = $kind;
        $this->start  = $start;
        $this->end    = $end;
        $this->line   = $line;
        $this->column = $column;
        $this->prev   = $previous;
        $this->next   = null;
        $this->value  = $value;
    }

    public function getDescription() : string
    {
        return $this->kind . ($this->value === null ? '' : ' "' . $this->value . '"');
    }

    /**
     * @return (string|int|null)[]
     */
    public function toArray() : array
    {
        return [
            'kind'   => $this->kind,
            'value'  => $this->value,
            'line'   => $this->line,
            'column' => $this->column,
        ];
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\Visitor.php
<?php

declare(strict_types=1);

namespace GraphQL\Language;

use ArrayObject;
use Exception;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\NodeList;
use GraphQL\Utils\TypeInfo;
use SplFixedArray;
use stdClass;
use function array_pop;
use function array_splice;
use function count;
use function func_get_args;
use function is_array;
use function is_callable;
use function json_encode;

/**
 * Utility for efficient AST traversal and modification.
 *
 * `visit()` will walk through an AST using a depth first traversal, calling
 * the visitor's enter function at each node in the traversal, and calling the
 * leave function after visiting that node and all of it's child nodes.
 *
 * By returning different values from the enter and leave functions, the
 * behavior of the visitor can be altered, including skipping over a sub-tree of
 * the AST (by returning false), editing the AST by returning a value or null
 * to remove the value, or to stop the whole traversal by returning BREAK.
 *
 * When using `visit()` to edit an AST, the original AST will not be modified, and
 * a new version of the AST with the changes applied will be returned from the
 * visit function.
 *
 *     $editedAST = Visitor::visit($ast, [
 *       'enter' => function ($node, $key, $parent, $path, $ancestors) {
 *         // return
 *         //   null: no action
 *         //   Visitor::skipNode(): skip visiting this node
 *         //   Visitor::stop(): stop visiting altogether
 *         //   Visitor::removeNode(): delete this node
 *         //   any value: replace this node with the returned value
 *       },
 *       'leave' => function ($node, $key, $parent, $path, $ancestors) {
 *         // return
 *         //   null: no action
 *         //   Visitor::stop(): stop visiting altogether
 *         //   Visitor::removeNode(): delete this node
 *         //   any value: replace this node with the returned value
 *       }
 *     ]);
 *
 * Alternatively to providing enter() and leave() functions, a visitor can
 * instead provide functions named the same as the [kinds of AST nodes](reference.md#graphqllanguageastnodekind),
 * or enter/leave visitors at a named key, leading to four permutations of
 * visitor API:
 *
 * 1) Named visitors triggered when entering a node a specific kind.
 *
 *     Visitor::visit($ast, [
 *       'Kind' => function ($node) {
 *         // enter the "Kind" node
 *       }
 *     ]);
 *
 * 2) Named visitors that trigger upon entering and leaving a node of
 *    a specific kind.
 *
 *     Visitor::visit($ast, [
 *       'Kind' => [
 *         'enter' => function ($node) {
 *           // enter the "Kind" node
 *         }
 *         'leave' => function ($node) {
 *           // leave the "Kind" node
 *         }
 *       ]
 *     ]);
 *
 * 3) Generic visitors that trigger upon entering and leaving any node.
 *
 *     Visitor::visit($ast, [
 *       'enter' => function ($node) {
 *         // enter any node
 *       },
 *       'leave' => function ($node) {
 *         // leave any node
 *       }
 *     ]);
 *
 * 4) Parallel visitors for entering and leaving nodes of a specific kind.
 *
 *     Visitor::visit($ast, [
 *       'enter' => [
 *         'Kind' => function($node) {
 *           // enter the "Kind" node
 *         }
 *       },
 *       'leave' => [
 *         'Kind' => function ($node) {
 *           // leave the "Kind" node
 *         }
 *       ]
 *     ]);
 */
class Visitor
{
    /** @var string[][] */
    public static $visitorKeys = [
        NodeKind::NAME                 => [],
        NodeKind::DOCUMENT             => ['definitions'],
        NodeKind::OPERATION_DEFINITION => ['name', 'variableDefinitions', 'directives', 'selectionSet'],
        NodeKind::VARIABLE_DEFINITION  => ['variable', 'type', 'defaultValue', 'directives'],
        NodeKind::VARIABLE             => ['name'],
        NodeKind::SELECTION_SET        => ['selections'],
        NodeKind::FIELD                => ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
        NodeKind::ARGUMENT             => ['name', 'value'],
        NodeKind::FRAGMENT_SPREAD      => ['name', 'directives'],
        NodeKind::INLINE_FRAGMENT      => ['typeCondition', 'directives', 'selectionSet'],
        NodeKind::FRAGMENT_DEFINITION  => [
            'name',
            // Note: fragment variable definitions are experimental and may be changed
            // or removed in the future.
            'variableDefinitions',
            'typeCondition',
            'directives',
            'selectionSet',
        ],

        NodeKind::INT           => [],
        NodeKind::FLOAT         => [],
        NodeKind::STRING        => [],
        NodeKind::BOOLEAN       => [],
        NodeKind::NULL          => [],
        NodeKind::ENUM          => [],
        NodeKind::LST           => ['values'],
        NodeKind::OBJECT        => ['fields'],
        NodeKind::OBJECT_FIELD  => ['name', 'value'],
        NodeKind::DIRECTIVE     => ['name', 'arguments'],
        NodeKind::NAMED_TYPE    => ['name'],
        NodeKind::LIST_TYPE     => ['type'],
        NodeKind::NON_NULL_TYPE => ['type'],

        NodeKind::SCHEMA_DEFINITION            => ['directives', 'operationTypes'],
        NodeKind::OPERATION_TYPE_DEFINITION    => ['type'],
        NodeKind::SCALAR_TYPE_DEFINITION       => ['description', 'name', 'directives'],
        NodeKind::OBJECT_TYPE_DEFINITION       => ['description', 'name', 'interfaces', 'directives', 'fields'],
        NodeKind::FIELD_DEFINITION             => ['description', 'name', 'arguments', 'type', 'directives'],
        NodeKind::INPUT_VALUE_DEFINITION       => ['description', 'name', 'type', 'defaultValue', 'directives'],
        NodeKind::INTERFACE_TYPE_DEFINITION    => ['description', 'name', 'interfaces', 'directives', 'fields'],
        NodeKind::UNION_TYPE_DEFINITION        => ['description', 'name', 'directives', 'types'],
        NodeKind::ENUM_TYPE_DEFINITION         => ['description', 'name', 'directives', 'values'],
        NodeKind::ENUM_VALUE_DEFINITION        => ['description', 'name', 'directives'],
        NodeKind::INPUT_OBJECT_TYPE_DEFINITION => ['description', 'name', 'directives', 'fields'],

        NodeKind::SCALAR_TYPE_EXTENSION       => ['name', 'directives'],
        NodeKind::OBJECT_TYPE_EXTENSION       => ['name', 'interfaces', 'directives', 'fields'],
        NodeKind::INTERFACE_TYPE_EXTENSION    => ['name', 'interfaces', 'directives', 'fields'],
        NodeKind::UNION_TYPE_EXTENSION        => ['name', 'directives', 'types'],
        NodeKind::ENUM_TYPE_EXTENSION         => ['name', 'directives', 'values'],
        NodeKind::INPUT_OBJECT_TYPE_EXTENSION => ['name', 'directives', 'fields'],

        NodeKind::DIRECTIVE_DEFINITION => ['description', 'name', 'arguments', 'locations'],

        NodeKind::SCHEMA_EXTENSION => ['directives', 'operationTypes'],
    ];

    /**
     * Visit the AST (see class description for details)
     *
     * @param Node|ArrayObject|stdClass $root
     * @param callable[]                $visitor
     * @param mixed[]|null              $keyMap
     *
     * @return Node|mixed
     *
     * @throws Exception
     *
     * @api
     */
    public static function visit($root, $visitor, $keyMap = null)
    {
        $visitorKeys = $keyMap ?? self::$visitorKeys;

        $stack     = null;
        $inArray   = $root instanceof NodeList || is_array($root);
        $keys      = [$root];
        $index     = -1;
        $edits     = [];
        $parent    = null;
        $path      = [];
        $ancestors = [];
        $newRoot   = $root;

        $UNDEFINED = null;

        do {
            $index++;
            $isLeaving = $index === count($keys);
            $key       = null;
            $node      = null;
            $isEdited  = $isLeaving && count($edits) > 0;

            if ($isLeaving) {
                $key    = ! $ancestors ? $UNDEFINED : $path[count($path) - 1];
                $node   = $parent;
                $parent = array_pop($ancestors);

                if ($isEdited) {
                    if ($inArray) {
                        // $node = $node; // arrays are value types in PHP
                        if ($node instanceof NodeList) {
                            $node = clone $node;
                        }
                    } else {
                        $node = clone $node;
                    }
                    $editOffset = 0;
                    for ($ii = 0; $ii < count($edits); $ii++) {
                        $editKey   = $edits[$ii][0];
                        $editValue = $edits[$ii][1];

                        if ($inArray) {
                            $editKey -= $editOffset;
                        }
                        if ($inArray && $editValue === null) {
                            $node->splice($editKey, 1);
                            $editOffset++;
                        } else {
                            if ($node instanceof NodeList || is_array($node)) {
                                $node[$editKey] = $editValue;
                            } else {
                                $node->{$editKey} = $editValue;
                            }
                        }
                    }
                }
                $index   = $stack['index'];
                $keys    = $stack['keys'];
                $edits   = $stack['edits'];
                $inArray = $stack['inArray'];
                $stack   = $stack['prev'];
            } else {
                $key  = $parent !== null
                    ? ($inArray
                        ? $index
                        : $keys[$index]
                    )
                    : $UNDEFINED;
                $node = $parent !== null
                    ? ($parent instanceof NodeList || is_array($parent)
                        ? $parent[$key]
                        : $parent->{$key}
                    )
                    : $newRoot;
                if ($node === null || $node === $UNDEFINED) {
                    continue;
                }
                if ($parent !== null) {
                    $path[] = $key;
                }
            }

            $result = null;
            if (! $node instanceof NodeList && ! is_array($node)) {
                if (! ($node instanceof Node)) {
                    throw new Exception('Invalid AST Node: ' . json_encode($node));
                }

                $visitFn = self::getVisitFn($visitor, $node->kind, $isLeaving);

                if ($visitFn !== null) {
                    $result    = $visitFn($node, $key, $parent, $path, $ancestors);
                    $editValue = null;

                    if ($result !== null) {
                        if ($result instanceof VisitorOperation) {
                            if ($result->doBreak) {
                                break;
                            }
                            if (! $isLeaving && $result->doContinue) {
                                array_pop($path);
                                continue;
                            }
                            if ($result->removeNode) {
                                $editValue = null;
                            }
                        } else {
                            $editValue = $result;
                        }

                        $edits[] = [$key, $editValue];
                        if (! $isLeaving) {
                            if (! ($editValue instanceof Node)) {
                                array_pop($path);
                                continue;
                            }

                            $node = $editValue;
                        }
                    }
                }
            }

            if ($result === null && $isEdited) {
                $edits[] = [$key, $node];
            }

            if ($isLeaving) {
                array_pop($path);
            } else {
                $stack   = [
                    'inArray' => $inArray,
                    'index'   => $index,
                    'keys'    => $keys,
                    'edits'   => $edits,
                    'prev'    => $stack,
                ];
                $inArray = $node instanceof NodeList || is_array($node);

                $keys  = ($inArray ? $node : $visitorKeys[$node->kind]) ?? [];
                $index = -1;
                $edits = [];
                if ($parent !== null) {
                    $ancestors[] = $parent;
                }
                $parent = $node;
            }
        } while ($stack);

        if (count($edits) > 0) {
            $newRoot = $edits[0][1];
        }

        return $newRoot;
    }

    /**
     * Returns marker for visitor break
     *
     * @return VisitorOperation
     *
     * @api
     */
    public static function stop()
    {
        $r          = new VisitorOperation();
        $r->doBreak = true;

        return $r;
    }

    /**
     * Returns marker for skipping current node
     *
     * @return VisitorOperation
     *
     * @api
     */
    public static function skipNode()
    {
        $r             = new VisitorOperation();
        $r->doContinue = true;

        return $r;
    }

    /**
     * Returns marker for removing a node
     *
     * @return VisitorOperation
     *
     * @api
     */
    public static function removeNode()
    {
        $r             = new VisitorOperation();
        $r->removeNode = true;

        return $r;
    }

    /**
     * @param callable[][] $visitors
     *
     * @return array<string, callable>
     */
    public static function visitInParallel($visitors)
    {
        $visitorsCount = count($visitors);
        $skipping      = new SplFixedArray($visitorsCount);

        return [
            'enter' => static function (Node $node) use ($visitors, $skipping, $visitorsCount) {
                for ($i = 0; $i < $visitorsCount; $i++) {
                    if ($skipping[$i] !== null) {
                        continue;
                    }

                    $fn = self::getVisitFn(
                        $visitors[$i],
                        $node->kind, /* isLeaving */
                        false
                    );

                    if (! $fn) {
                        continue;
                    }

                    $result = $fn(...func_get_args());

                    if ($result instanceof VisitorOperation) {
                        if ($result->doContinue) {
                            $skipping[$i] = $node;
                        } elseif ($result->doBreak) {
                            $skipping[$i] = $result;
                        } elseif ($result->removeNode) {
                            return $result;
                        }
                    } elseif ($result !== null) {
                        return $result;
                    }
                }
            },
            'leave' => static function (Node $node) use ($visitors, $skipping, $visitorsCount) {
                for ($i = 0; $i < $visitorsCount; $i++) {
                    if ($skipping[$i] === null) {
                        $fn = self::getVisitFn(
                            $visitors[$i],
                            $node->kind, /* isLeaving */
                            true
                        );

                        if (isset($fn)) {
                            $result = $fn(...func_get_args());
                            if ($result instanceof VisitorOperation) {
                                if ($result->doBreak) {
                                    $skipping[$i] = $result;
                                } elseif ($result->removeNode) {
                                    return $result;
                                }
                            } elseif ($result !== null) {
                                return $result;
                            }
                        }
                    } elseif ($skipping[$i] === $node) {
                        $skipping[$i] = null;
                    }
                }
            },
        ];
    }

    /**
     * Creates a new visitor instance which maintains a provided TypeInfo instance
     * along with visiting visitor.
     */
    public static function visitWithTypeInfo(TypeInfo $typeInfo, $visitor)
    {
        return [
            'enter' => static function (Node $node) use ($typeInfo, $visitor) {
                $typeInfo->enter($node);
                $fn = self::getVisitFn($visitor, $node->kind, false);

                if (isset($fn)) {
                    $result = $fn(...func_get_args());
                    if ($result !== null) {
                        $typeInfo->leave($node);
                        if ($result instanceof Node) {
                            $typeInfo->enter($result);
                        }
                    }

                    return $result;
                }

                return null;
            },
            'leave' => static function (Node $node) use ($typeInfo, $visitor) {
                $fn     = self::getVisitFn($visitor, $node->kind, true);
                $result = $fn !== null
                    ? $fn(...func_get_args())
                    : null;

                $typeInfo->leave($node);

                return $result;
            },
        ];
    }

    /**
     * @param callable[]|null $visitor
     * @param string          $kind
     * @param bool            $isLeaving
     */
    public static function getVisitFn($visitor, $kind, $isLeaving) : ?callable
    {
        if ($visitor === null) {
            return null;
        }

        $kindVisitor = $visitor[$kind] ?? null;

        if (is_array($kindVisitor)) {
            if ($isLeaving) {
                $kindSpecificVisitor = $kindVisitor['leave'] ?? null;
            } else {
                $kindSpecificVisitor = $kindVisitor['enter'] ?? null;
            }

            return $kindSpecificVisitor;
        }

        if ($kindVisitor !== null && ! $isLeaving) {
            return $kindVisitor;
        }

        $visitor += ['leave' => null, 'enter' => null];

        $specificVisitor = $isLeaving ? $visitor['leave'] : $visitor['enter'];

        if (isset($specificVisitor)) {
            if (! is_array($specificVisitor)) {
                // { enter() {}, leave() {} }
                return $specificVisitor;
            }

            return $specificVisitor[$kind] ?? null;
        }

        return null;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\VisitorOperation.php
<?php

declare(strict_types=1);

namespace GraphQL\Language;

class VisitorOperation
{
    /** @var bool */
    public $doBreak;

    /** @var bool */
    public $doContinue;

    /** @var bool */
    public $removeNode;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\ArgumentNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class ArgumentNode extends Node
{
    /** @var string */
    public $kind = NodeKind::ARGUMENT;

    /** @var VariableNode|NullValueNode|IntValueNode|FloatValueNode|StringValueNode|BooleanValueNode|EnumValueNode|ListValueNode|ObjectValueNode */
    public $value;

    /** @var NameNode */
    public $name;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\BooleanValueNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class BooleanValueNode extends Node implements ValueNode
{
    /** @var string */
    public $kind = NodeKind::BOOLEAN;

    /** @var bool */
    public $value;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\DefinitionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

/**
 * export type DefinitionNode =
 *   | ExecutableDefinitionNode
 *   | TypeSystemDefinitionNode;
 */
interface DefinitionNode
{
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\DirectiveDefinitionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class DirectiveDefinitionNode extends Node implements TypeSystemDefinitionNode
{
    /** @var string */
    public $kind = NodeKind::DIRECTIVE_DEFINITION;

    /** @var NameNode */
    public $name;

    /** @var StringValueNode|null */
    public $description;

    /** @var NodeList<InputValueDefinitionNode> */
    public $arguments;

    /** @var bool */
    public $repeatable;

    /** @var NodeList<NameNode> */
    public $locations;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\DirectiveNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class DirectiveNode extends Node
{
    /** @var string */
    public $kind = NodeKind::DIRECTIVE;

    /** @var NameNode */
    public $name;

    /** @var NodeList<ArgumentNode> */
    public $arguments;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\DocumentNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

#[\AllowDynamicProperties]
class DocumentNode extends Node
{
    /** @var string */
    public $kind = NodeKind::DOCUMENT;

    /** @var NodeList<DefinitionNode&Node> */
    public $definitions;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\EnumTypeDefinitionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class EnumTypeDefinitionNode extends Node implements TypeDefinitionNode
{
    /** @var string */
    public $kind = NodeKind::ENUM_TYPE_DEFINITION;

    /** @var NameNode */
    public $name;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var NodeList<EnumValueDefinitionNode> */
    public $values;

    /** @var StringValueNode|null */
    public $description;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\EnumTypeExtensionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class EnumTypeExtensionNode extends Node implements TypeExtensionNode
{
    /** @var string */
    public $kind = NodeKind::ENUM_TYPE_EXTENSION;

    /** @var NameNode */
    public $name;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var NodeList<EnumValueDefinitionNode> */
    public $values;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\EnumValueDefinitionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class EnumValueDefinitionNode extends Node
{
    /** @var string */
    public $kind = NodeKind::ENUM_VALUE_DEFINITION;

    /** @var NameNode */
    public $name;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var StringValueNode|null */
    public $description;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\EnumValueNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class EnumValueNode extends Node implements ValueNode
{
    /** @var string */
    public $kind = NodeKind::ENUM;

    /** @var string */
    public $value;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\ExecutableDefinitionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

/**
 * export type ExecutableDefinitionNode =
 *   | OperationDefinitionNode
 *   | FragmentDefinitionNode;
 */
interface ExecutableDefinitionNode extends DefinitionNode
{
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\FieldDefinitionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class FieldDefinitionNode extends Node
{
    /** @var string */
    public $kind = NodeKind::FIELD_DEFINITION;

    /** @var NameNode */
    public $name;

    /** @var NodeList<InputValueDefinitionNode> */
    public $arguments;

    /** @var NamedTypeNode|ListTypeNode|NonNullTypeNode */
    public $type;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var StringValueNode|null */
    public $description;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\FieldNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class FieldNode extends Node implements SelectionNode
{
    /** @var string */
    public $kind = NodeKind::FIELD;

    /** @var NameNode */
    public $name;

    /** @var NameNode|null */
    public $alias;

    /** @var NodeList<ArgumentNode> */
    public $arguments;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var SelectionSetNode|null */
    public $selectionSet;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\FloatValueNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class FloatValueNode extends Node implements ValueNode
{
    /** @var string */
    public $kind = NodeKind::FLOAT;

    /** @var string */
    public $value;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\FragmentDefinitionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class FragmentDefinitionNode extends Node implements ExecutableDefinitionNode, HasSelectionSet
{
    /** @var string */
    public $kind = NodeKind::FRAGMENT_DEFINITION;

    /** @var NameNode */
    public $name;

    /**
     * Note: fragment variable definitions are experimental and may be changed
     * or removed in the future.
     *
     * @var NodeList<VariableDefinitionNode>
     */
    public $variableDefinitions;

    /** @var NamedTypeNode */
    public $typeCondition;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var SelectionSetNode */
    public $selectionSet;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\FragmentSpreadNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class FragmentSpreadNode extends Node implements SelectionNode
{
    /** @var string */
    public $kind = NodeKind::FRAGMENT_SPREAD;

    /** @var NameNode */
    public $name;

    /** @var NodeList<DirectiveNode> */
    public $directives;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\HasSelectionSet.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

/**
 * export type DefinitionNode = OperationDefinitionNode
 *                        | FragmentDefinitionNode
 *
 * @property SelectionSetNode $selectionSet
 */
interface HasSelectionSet
{
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\InlineFragmentNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class InlineFragmentNode extends Node implements SelectionNode
{
    /** @var string */
    public $kind = NodeKind::INLINE_FRAGMENT;

    /** @var NamedTypeNode */
    public $typeCondition;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var SelectionSetNode */
    public $selectionSet;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\InputObjectTypeDefinitionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class InputObjectTypeDefinitionNode extends Node implements TypeDefinitionNode
{
    /** @var string */
    public $kind = NodeKind::INPUT_OBJECT_TYPE_DEFINITION;

    /** @var NameNode */
    public $name;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var NodeList<InputValueDefinitionNode> */
    public $fields;

    /** @var StringValueNode|null */
    public $description;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\InputObjectTypeExtensionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class InputObjectTypeExtensionNode extends Node implements TypeExtensionNode
{
    /** @var string */
    public $kind = NodeKind::INPUT_OBJECT_TYPE_EXTENSION;

    /** @var NameNode */
    public $name;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var NodeList<InputValueDefinitionNode> */
    public $fields;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\InputValueDefinitionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class InputValueDefinitionNode extends Node
{
    /** @var string */
    public $kind = NodeKind::INPUT_VALUE_DEFINITION;

    /** @var NameNode */
    public $name;

    /** @var NamedTypeNode|ListTypeNode|NonNullTypeNode */
    public $type;

    /** @var VariableNode|NullValueNode|IntValueNode|FloatValueNode|StringValueNode|BooleanValueNode|EnumValueNode|ListValueNode|ObjectValueNode|null */
    public $defaultValue;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var StringValueNode|null */
    public $description;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\InterfaceTypeDefinitionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class InterfaceTypeDefinitionNode extends Node implements TypeDefinitionNode
{
    /** @var string */
    public $kind = NodeKind::INTERFACE_TYPE_DEFINITION;

    /** @var NameNode */
    public $name;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var NodeList<NamedTypeNode> */
    public $interfaces;

    /** @var NodeList<FieldDefinitionNode> */
    public $fields;

    /** @var StringValueNode|null */
    public $description;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\InterfaceTypeExtensionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class InterfaceTypeExtensionNode extends Node implements TypeExtensionNode
{
    /** @var string */
    public $kind = NodeKind::INTERFACE_TYPE_EXTENSION;

    /** @var NameNode */
    public $name;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var NodeList<InterfaceTypeDefinitionNode> */
    public $interfaces;

    /** @var NodeList<FieldDefinitionNode> */
    public $fields;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\IntValueNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class IntValueNode extends Node implements ValueNode
{
    /** @var string */
    public $kind = NodeKind::INT;

    /** @var string */
    public $value;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\ListTypeNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class ListTypeNode extends Node implements TypeNode
{
    /** @var string */
    public $kind = NodeKind::LIST_TYPE;

    /** @var NamedTypeNode|ListTypeNode|NonNullTypeNode */
    public $type;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\ListValueNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class ListValueNode extends Node implements ValueNode
{
    /** @var string */
    public $kind = NodeKind::LST;

    /** @var NodeList<ValueNode&Node> */
    public $values;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\Location.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

use GraphQL\Language\Source;
use GraphQL\Language\Token;

/**
 * Contains a range of UTF-8 character offsets and token references that
 * identify the region of the source from which the AST derived.
 */
class Location
{
    /**
     * The character offset at which this Node begins.
     *
     * @var int
     */
    public $start;

    /**
     * The character offset at which this Node ends.
     *
     * @var int
     */
    public $end;

    /**
     * The Token at which this Node begins.
     *
     * @var Token|null
     */
    public $startToken;

    /**
     * The Token at which this Node ends.
     *
     * @var Token|null
     */
    public $endToken;

    /**
     * The Source document the AST represents.
     *
     * @var Source|null
     */
    public $source;

    /**
     * @param int $start
     * @param int $end
     *
     * @return static
     */
    public static function create($start, $end)
    {
        $tmp        = new static();
        $tmp->start = $start;
        $tmp->end   = $end;

        return $tmp;
    }

    public function __construct(?Token $startToken = null, ?Token $endToken = null, ?Source $source = null)
    {
        $this->startToken = $startToken;
        $this->endToken   = $endToken;
        $this->source     = $source;

        if ($startToken === null || $endToken === null) {
            return;
        }

        $this->start = $startToken->start;
        $this->end   = $endToken->end;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\NamedTypeNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class NamedTypeNode extends Node implements TypeNode
{
    /** @var string */
    public $kind = NodeKind::NAMED_TYPE;

    /** @var NameNode */
    public $name;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\NameNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class NameNode extends Node implements TypeNode
{
    /** @var string */
    public $kind = NodeKind::NAME;

    /** @var string */
    public $value;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\Node.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

use GraphQL\Utils\Utils;
use function count;
use function get_object_vars;
use function is_array;
use function is_scalar;
use function json_encode;

/**
 * type Node = NameNode
 * | DocumentNode
 * | OperationDefinitionNode
 * | VariableDefinitionNode
 * | VariableNode
 * | SelectionSetNode
 * | FieldNode
 * | ArgumentNode
 * | FragmentSpreadNode
 * | InlineFragmentNode
 * | FragmentDefinitionNode
 * | IntValueNode
 * | FloatValueNode
 * | StringValueNode
 * | BooleanValueNode
 * | EnumValueNode
 * | ListValueNode
 * | ObjectValueNode
 * | ObjectFieldNode
 * | DirectiveNode
 * | ListTypeNode
 * | NonNullTypeNode
 */
abstract class Node
{
    /** @var Location|null */
    public $loc;

    /** @var string */
    public $kind;

    /**
     * @param (NameNode|NodeList|SelectionSetNode|Location|string|int|bool|float|null)[] $vars
     */
    public function __construct(array $vars)
    {
        if (count($vars) === 0) {
            return;
        }

        Utils::assign($this, $vars);
    }

    /**
     * @return self
     */
    public function cloneDeep()
    {
        return $this->cloneValue($this);
    }

    /**
     * @param string|NodeList|Location|Node|(Node|NodeList|Location)[] $value
     *
     * @return string|NodeList|Location|Node
     */
    private function cloneValue($value)
    {
        if (is_array($value)) {
            $cloned = [];
            foreach ($value as $key => $arrValue) {
                $cloned[$key] = $this->cloneValue($arrValue);
            }
        } elseif ($value instanceof self) {
            $cloned = clone $value;
            foreach (get_object_vars($cloned) as $prop => $propValue) {
                $cloned->{$prop} = $this->cloneValue($propValue);
            }
        } else {
            $cloned = $value;
        }

        return $cloned;
    }

    public function __toString() : string
    {
        $tmp = $this->toArray(true);

        return (string) json_encode($tmp);
    }

    /**
     * @return mixed[]
     */
    public function toArray(bool $recursive = false) : array
    {
        if ($recursive) {
            return $this->recursiveToArray($this);
        }

        $tmp = (array) $this;

        if ($this->loc !== null) {
            $tmp['loc'] = [
                'start' => $this->loc->start,
                'end'   => $this->loc->end,
            ];
        }

        return $tmp;
    }

    /**
     * @return mixed[]
     */
    private function recursiveToArray(Node $node)
    {
        $result = [
            'kind' => $node->kind,
        ];

        if ($node->loc !== null) {
            $result['loc'] = [
                'start' => $node->loc->start,
                'end'   => $node->loc->end,
            ];
        }

        foreach (get_object_vars($node) as $prop => $propValue) {
            if (isset($result[$prop])) {
                continue;
            }

            if ($propValue === null) {
                continue;
            }

            if (is_array($propValue) || $propValue instanceof NodeList) {
                $tmp = [];
                foreach ($propValue as $tmp1) {
                    $tmp[] = $tmp1 instanceof Node ? $this->recursiveToArray($tmp1) : (array) $tmp1;
                }
            } elseif ($propValue instanceof Node) {
                $tmp = $this->recursiveToArray($propValue);
            } elseif (is_scalar($propValue) || $propValue === null) {
                $tmp = $propValue;
            } else {
                $tmp = null;
            }

            $result[$prop] = $tmp;
        }

        return $result;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\NodeKind.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class NodeKind
{
    // constants from language/kinds.js:

    const NAME = 'Name';
    // Document

    const DOCUMENT             = 'Document';
    const OPERATION_DEFINITION = 'OperationDefinition';
    const VARIABLE_DEFINITION  = 'VariableDefinition';
    const VARIABLE             = 'Variable';
    const SELECTION_SET        = 'SelectionSet';
    const FIELD                = 'Field';
    const ARGUMENT             = 'Argument';
    // Fragments

    const FRAGMENT_SPREAD     = 'FragmentSpread';
    const INLINE_FRAGMENT     = 'InlineFragment';
    const FRAGMENT_DEFINITION = 'FragmentDefinition';
    // Values

    const INT          = 'IntValue';
    const FLOAT        = 'FloatValue';
    const STRING       = 'StringValue';
    const BOOLEAN      = 'BooleanValue';
    const ENUM         = 'EnumValue';
    const NULL         = 'NullValue';
    const LST          = 'ListValue';
    const OBJECT       = 'ObjectValue';
    const OBJECT_FIELD = 'ObjectField';
    // Directives

    const DIRECTIVE = 'Directive';
    // Types

    const NAMED_TYPE    = 'NamedType';
    const LIST_TYPE     = 'ListType';
    const NON_NULL_TYPE = 'NonNullType';
    // Type System Definitions

    const SCHEMA_DEFINITION         = 'SchemaDefinition';
    const OPERATION_TYPE_DEFINITION = 'OperationTypeDefinition';
    // Type Definitions

    const SCALAR_TYPE_DEFINITION       = 'ScalarTypeDefinition';
    const OBJECT_TYPE_DEFINITION       = 'ObjectTypeDefinition';
    const FIELD_DEFINITION             = 'FieldDefinition';
    const INPUT_VALUE_DEFINITION       = 'InputValueDefinition';
    const INTERFACE_TYPE_DEFINITION    = 'InterfaceTypeDefinition';
    const UNION_TYPE_DEFINITION        = 'UnionTypeDefinition';
    const ENUM_TYPE_DEFINITION         = 'EnumTypeDefinition';
    const ENUM_VALUE_DEFINITION        = 'EnumValueDefinition';
    const INPUT_OBJECT_TYPE_DEFINITION = 'InputObjectTypeDefinition';
    // Type Extensions

    const SCALAR_TYPE_EXTENSION       = 'ScalarTypeExtension';
    const OBJECT_TYPE_EXTENSION       = 'ObjectTypeExtension';
    const INTERFACE_TYPE_EXTENSION    = 'InterfaceTypeExtension';
    const UNION_TYPE_EXTENSION        = 'UnionTypeExtension';
    const ENUM_TYPE_EXTENSION         = 'EnumTypeExtension';
    const INPUT_OBJECT_TYPE_EXTENSION = 'InputObjectTypeExtension';
    // Directive Definitions

    const DIRECTIVE_DEFINITION = 'DirectiveDefinition';

    // Type System Extensions
    const SCHEMA_EXTENSION = 'SchemaExtension';

    /** @var string[] */
    public static $classMap = [
        self::NAME                         => NameNode::class,

        // Document
        self::DOCUMENT                     => DocumentNode::class,
        self::OPERATION_DEFINITION         => OperationDefinitionNode::class,
        self::VARIABLE_DEFINITION          => VariableDefinitionNode::class,
        self::VARIABLE                     => VariableNode::class,
        self::SELECTION_SET                => SelectionSetNode::class,
        self::FIELD                        => FieldNode::class,
        self::ARGUMENT                     => ArgumentNode::class,

        // Fragments
        self::FRAGMENT_SPREAD              => FragmentSpreadNode::class,
        self::INLINE_FRAGMENT              => InlineFragmentNode::class,
        self::FRAGMENT_DEFINITION          => FragmentDefinitionNode::class,

        // Values
        self::INT                          => IntValueNode::class,
        self::FLOAT                        => FloatValueNode::class,
        self::STRING                       => StringValueNode::class,
        self::BOOLEAN                      => BooleanValueNode::class,
        self::ENUM                         => EnumValueNode::class,
        self::NULL                         => NullValueNode::class,
        self::LST                          => ListValueNode::class,
        self::OBJECT                       => ObjectValueNode::class,
        self::OBJECT_FIELD                 => ObjectFieldNode::class,

        // Directives
        self::DIRECTIVE                    => DirectiveNode::class,

        // Types
        self::NAMED_TYPE                   => NamedTypeNode::class,
        self::LIST_TYPE                    => ListTypeNode::class,
        self::NON_NULL_TYPE                => NonNullTypeNode::class,

        // Type System Definitions
        self::SCHEMA_DEFINITION            => SchemaDefinitionNode::class,
        self::OPERATION_TYPE_DEFINITION    => OperationTypeDefinitionNode::class,

        // Type Definitions
        self::SCALAR_TYPE_DEFINITION       => ScalarTypeDefinitionNode::class,
        self::OBJECT_TYPE_DEFINITION       => ObjectTypeDefinitionNode::class,
        self::FIELD_DEFINITION             => FieldDefinitionNode::class,
        self::INPUT_VALUE_DEFINITION       => InputValueDefinitionNode::class,
        self::INTERFACE_TYPE_DEFINITION    => InterfaceTypeDefinitionNode::class,
        self::UNION_TYPE_DEFINITION        => UnionTypeDefinitionNode::class,
        self::ENUM_TYPE_DEFINITION         => EnumTypeDefinitionNode::class,
        self::ENUM_VALUE_DEFINITION        => EnumValueDefinitionNode::class,
        self::INPUT_OBJECT_TYPE_DEFINITION => InputObjectTypeDefinitionNode::class,

        // Type Extensions
        self::SCALAR_TYPE_EXTENSION        => ScalarTypeExtensionNode::class,
        self::OBJECT_TYPE_EXTENSION        => ObjectTypeExtensionNode::class,
        self::INTERFACE_TYPE_EXTENSION     => InterfaceTypeExtensionNode::class,
        self::UNION_TYPE_EXTENSION         => UnionTypeExtensionNode::class,
        self::ENUM_TYPE_EXTENSION          => EnumTypeExtensionNode::class,
        self::INPUT_OBJECT_TYPE_EXTENSION  => InputObjectTypeExtensionNode::class,

        // Directive Definitions
        self::DIRECTIVE_DEFINITION         => DirectiveDefinitionNode::class,
    ];
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\NodeList.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

use ArrayAccess;
use Countable;
use GraphQL\Utils\AST;
use InvalidArgumentException;
use IteratorAggregate;
use ReturnTypeWillChange;
use Traversable;
use function array_merge;
use function array_splice;
use function count;
use function is_array;

/**
 * @template T of Node
 * @phpstan-implements ArrayAccess<int|string, T>
 * @phpstan-implements IteratorAggregate<T>
 */
class NodeList implements ArrayAccess, IteratorAggregate, Countable
{
    /**
     * @var Node[]
     * @phpstan-var array<T>
     */
    private $nodes;

    /**
     * @param Node[] $nodes
     *
     * @phpstan-param array<T> $nodes
     * @phpstan-return self<T>
     */
    public static function create(array $nodes) : self
    {
        return new static($nodes);
    }

    /**
     * @param Node[] $nodes
     *
     * @phpstan-param array<T> $nodes
     */
    public function __construct(array $nodes)
    {
        $this->nodes = $nodes;
    }

    /**
     * @param int|string $offset
     */
    public function offsetExists($offset) : bool
    {
        return isset($this->nodes[$offset]);
    }

    /**
     * TODO enable strict typing by changing how the Visitor deals with NodeList.
     * Ideally, this function should always return a Node instance.
     * However, the Visitor currently allows mutation of the NodeList
     * and puts arbitrary values in the NodeList, such as strings.
     * We will have to switch to using an array or a less strict
     * type instead so we can enable strict typing in this class.
     *
     * @param int|string $offset
     *
     * @phpstan-return T
     */
    #[ReturnTypeWillChange]
    public function offsetGet($offset)// : Node
    {
        $item = $this->nodes[$offset];

        if (is_array($item) && isset($item['kind'])) {
            /** @phpstan-var T $node */
            $node                 = AST::fromArray($item);
            $this->nodes[$offset] = $node;
        }

        return $this->nodes[$offset];
    }

    /**
     * @param int|string|null $offset
     * @param Node|mixed[]    $value
     *
     * @phpstan-param T|mixed[] $value
     */
    public function offsetSet($offset, $value) : void
    {
        if (is_array($value)) {
            /** @phpstan-var T $value */
            $value = AST::fromArray($value);
        }

        // Happens when a Node is pushed via []=
        if ($offset === null) {
            $this->nodes[] = $value;

            return;
        }

        $this->nodes[$offset] = $value;
    }

    /**
     * @param int|string $offset
     */
    public function offsetUnset($offset) : void
    {
        unset($this->nodes[$offset]);
    }

    /**
     * @param mixed $replacement
     *
     * @phpstan-return NodeList<T>
     */
    public function splice(int $offset, int $length, $replacement = null) : NodeList
    {
        return new NodeList(array_splice($this->nodes, $offset, $length, $replacement));
    }

    /**
     * @param NodeList|Node[] $list
     *
     * @phpstan-param NodeList<T>|array<T> $list
     * @phpstan-return NodeList<T>
     */
    public function merge($list) : NodeList
    {
        if ($list instanceof self) {
            $list = $list->nodes;
        }

        return new NodeList(array_merge($this->nodes, $list));
    }

    public function getIterator() : Traversable
    {
        foreach ($this->nodes as $key => $_) {
            yield $this->offsetGet($key);
        }
    }

    public function count() : int
    {
        return count($this->nodes);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\NonNullTypeNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class NonNullTypeNode extends Node implements TypeNode
{
    /** @var string */
    public $kind = NodeKind::NON_NULL_TYPE;

    /** @var NamedTypeNode|ListTypeNode */
    public $type;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\NullValueNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class NullValueNode extends Node implements ValueNode
{
    /** @var string */
    public $kind = NodeKind::NULL;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\ObjectFieldNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class ObjectFieldNode extends Node
{
    /** @var string */
    public $kind = NodeKind::OBJECT_FIELD;

    /** @var NameNode */
    public $name;

    /** @var VariableNode|NullValueNode|IntValueNode|FloatValueNode|StringValueNode|BooleanValueNode|EnumValueNode|ListValueNode|ObjectValueNode */
    public $value;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\ObjectTypeDefinitionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class ObjectTypeDefinitionNode extends Node implements TypeDefinitionNode
{
    /** @var string */
    public $kind = NodeKind::OBJECT_TYPE_DEFINITION;

    /** @var NameNode */
    public $name;

    /** @var NodeList<NamedTypeNode> */
    public $interfaces;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var NodeList<FieldDefinitionNode> */
    public $fields;

    /** @var StringValueNode|null */
    public $description;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\ObjectTypeExtensionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class ObjectTypeExtensionNode extends Node implements TypeExtensionNode
{
    /** @var string */
    public $kind = NodeKind::OBJECT_TYPE_EXTENSION;

    /** @var NameNode */
    public $name;

    /** @var NodeList<NamedTypeNode> */
    public $interfaces;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var NodeList<FieldDefinitionNode> */
    public $fields;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\ObjectValueNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class ObjectValueNode extends Node implements ValueNode
{
    /** @var string */
    public $kind = NodeKind::OBJECT;

    /** @var NodeList<ObjectFieldNode> */
    public $fields;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\OperationDefinitionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

#[\AllowDynamicProperties]
class OperationDefinitionNode extends Node implements ExecutableDefinitionNode, HasSelectionSet
{
    /** @var string */
    public $kind = NodeKind::OPERATION_DEFINITION;

    /** @var NameNode|null */
    public $name;

    /** @var string (oneOf 'query', 'mutation', 'subscription')) */
    public $operation;

    /** @var NodeList<VariableDefinitionNode> */
    public $variableDefinitions;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var SelectionSetNode */
    public $selectionSet;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\OperationTypeDefinitionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class OperationTypeDefinitionNode extends Node
{
    /** @var string */
    public $kind = NodeKind::OPERATION_TYPE_DEFINITION;

    /**
     * One of 'query' | 'mutation' | 'subscription'
     *
     * @var string
     */
    public $operation;

    /** @var NamedTypeNode */
    public $type;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\ScalarTypeDefinitionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class ScalarTypeDefinitionNode extends Node implements TypeDefinitionNode
{
    /** @var string */
    public $kind = NodeKind::SCALAR_TYPE_DEFINITION;

    /** @var NameNode */
    public $name;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var StringValueNode|null */
    public $description;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\ScalarTypeExtensionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class ScalarTypeExtensionNode extends Node implements TypeExtensionNode
{
    /** @var string */
    public $kind = NodeKind::SCALAR_TYPE_EXTENSION;

    /** @var NameNode */
    public $name;

    /** @var NodeList<DirectiveNode> */
    public $directives;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\SchemaDefinitionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class SchemaDefinitionNode extends Node implements TypeSystemDefinitionNode
{
    /** @var string */
    public $kind = NodeKind::SCHEMA_DEFINITION;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var NodeList<OperationTypeDefinitionNode> */
    public $operationTypes;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\SchemaTypeExtensionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class SchemaTypeExtensionNode extends Node implements TypeExtensionNode
{
    /** @var string */
    public $kind = NodeKind::SCHEMA_EXTENSION;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var NodeList<OperationTypeDefinitionNode> */
    public $operationTypes;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\SelectionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

/**
 * export type SelectionNode = FieldNode | FragmentSpreadNode | InlineFragmentNode
 */
interface SelectionNode
{
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\SelectionSetNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class SelectionSetNode extends Node
{
    /** @var string */
    public $kind = NodeKind::SELECTION_SET;

    /** @var NodeList<SelectionNode&Node> */
    public $selections;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\StringValueNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class StringValueNode extends Node implements ValueNode
{
    /** @var string */
    public $kind = NodeKind::STRING;

    /** @var string */
    public $value;

    /** @var bool */
    public $block;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\TypeDefinitionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

/**
 * export type TypeDefinitionNode = ScalarTypeDefinitionNode
 * | ObjectTypeDefinitionNode
 * | InterfaceTypeDefinitionNode
 * | UnionTypeDefinitionNode
 * | EnumTypeDefinitionNode
 * | InputObjectTypeDefinitionNode
 */
interface TypeDefinitionNode extends TypeSystemDefinitionNode
{
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\TypeExtensionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

/**
 * export type TypeExtensionNode =
 * | ScalarTypeExtensionNode
 * | ObjectTypeExtensionNode
 * | InterfaceTypeExtensionNode
 * | UnionTypeExtensionNode
 * | EnumTypeExtensionNode
 * | InputObjectTypeExtensionNode;
 */
interface TypeExtensionNode extends TypeSystemDefinitionNode
{
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\TypeNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

/**
 * export type TypeNode = NamedTypeNode
 * | ListTypeNode
 * | NonNullTypeNode
 */
interface TypeNode
{
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\TypeSystemDefinitionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

/**
 * export type TypeSystemDefinitionNode =
 * | SchemaDefinitionNode
 * | TypeDefinitionNode
 * | TypeExtensionNode
 * | DirectiveDefinitionNode
 *
 * @property NameNode $name
 */
interface TypeSystemDefinitionNode extends DefinitionNode
{
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\UnionTypeDefinitionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class UnionTypeDefinitionNode extends Node implements TypeDefinitionNode
{
    /** @var string */
    public $kind = NodeKind::UNION_TYPE_DEFINITION;

    /** @var NameNode */
    public $name;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var NodeList<NamedTypeNode> */
    public $types;

    /** @var StringValueNode|null */
    public $description;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\UnionTypeExtensionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class UnionTypeExtensionNode extends Node implements TypeExtensionNode
{
    /** @var string */
    public $kind = NodeKind::UNION_TYPE_EXTENSION;

    /** @var NameNode */
    public $name;

    /** @var NodeList<DirectiveNode> */
    public $directives;

    /** @var NodeList<NamedTypeNode> */
    public $types;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\ValueNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

/**
export type ValueNode = VariableNode
| NullValueNode
| IntValueNode
| FloatValueNode
| StringValueNode
| BooleanValueNode
| EnumValueNode
| ListValueNode
| ObjectValueNode
 */
interface ValueNode
{
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\VariableDefinitionNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class VariableDefinitionNode extends Node implements DefinitionNode
{
    /** @var string */
    public $kind = NodeKind::VARIABLE_DEFINITION;

    /** @var VariableNode */
    public $variable;

    /** @var NamedTypeNode|ListTypeNode|NonNullTypeNode */
    public $type;

    /** @var VariableNode|NullValueNode|IntValueNode|FloatValueNode|StringValueNode|BooleanValueNode|EnumValueNode|ListValueNode|ObjectValueNode|null */
    public $defaultValue;

    /** @var NodeList<DirectiveNode> */
    public $directives;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Language\AST\VariableNode.php
<?php

declare(strict_types=1);

namespace GraphQL\Language\AST;

class VariableNode extends Node implements ValueNode
{
    /** @var string */
    public $kind = NodeKind::VARIABLE;

    /** @var NameNode */
    public $name;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Server\Helper.php
<?php

declare(strict_types=1);

namespace GraphQL\Server;

use GraphQL\Error\DebugFlag;
use GraphQL\Error\Error;
use GraphQL\Error\FormattedError;
use GraphQL\Error\InvariantViolation;
use GraphQL\Executor\ExecutionResult;
use GraphQL\Executor\Executor;
use GraphQL\Executor\Promise\Adapter\SyncPromiseAdapter;
use GraphQL\Executor\Promise\Promise;
use GraphQL\Executor\Promise\PromiseAdapter;
use GraphQL\GraphQL;
use GraphQL\Language\AST\DocumentNode;
use GraphQL\Language\Parser;
use GraphQL\Utils\AST;
use GraphQL\Utils\Utils;
use JsonSerializable;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Message\StreamInterface;
use function count;
use function file_get_contents;
use function header;
use function html_entity_decode;
use function is_array;
use function is_callable;
use function is_string;
use function json_decode;
use function json_encode;
use function json_last_error;
use function json_last_error_msg;
use function parse_str;
use function sprintf;
use function stripos;

/**
 * Contains functionality that could be re-used by various server implementations
 */
class Helper
{
    /**
     * Parses HTTP request using PHP globals and returns GraphQL OperationParams
     * contained in this request. For batched requests it returns an array of OperationParams.
     *
     * This function does not check validity of these params
     * (validation is performed separately in validateOperationParams() method).
     *
     * If $readRawBodyFn argument is not provided - will attempt to read raw request body
     * from `php://input` stream.
     *
     * Internally it normalizes input to $method, $bodyParams and $queryParams and
     * calls `parseRequestParams()` to produce actual return value.
     *
     * For PSR-7 request parsing use `parsePsrRequest()` instead.
     *
     * @return OperationParams|OperationParams[]
     *
     * @throws RequestError
     *
     * @api
     */
    public function parseHttpRequest(?callable $readRawBodyFn = null)
    {
        $method     = $_SERVER['REQUEST_METHOD'] ?? null;
        $bodyParams = [];
        $urlParams  = $_GET;

        if ($method === 'POST') {
            $contentType = $_SERVER['CONTENT_TYPE'] ?? null;

            if ($contentType === null) {
                throw new RequestError('Missing "Content-Type" header');
            }

            if (stripos($contentType, 'application/graphql') !== false) {
                $rawBody    = $readRawBodyFn
                    ? $readRawBodyFn()
                    : $this->readRawBody();
                $bodyParams = ['query' => $rawBody ?? ''];
            } elseif (stripos($contentType, 'application/json') !== false) {
                $rawBody    = $readRawBodyFn ?
                    $readRawBodyFn()
                    : $this->readRawBody();
                $bodyParams = json_decode($rawBody ?? '', true);

                if (json_last_error()) {
                    throw new RequestError('Could not parse JSON: ' . json_last_error_msg());
                }

                if (! is_array($bodyParams)) {
                    throw new RequestError(
                        'GraphQL Server expects JSON object or array, but got ' .
                        Utils::printSafeJson($bodyParams)
                    );
                }
            } elseif (stripos($contentType, 'application/x-www-form-urlencoded') !== false) {
                $bodyParams = $_POST;
            } elseif (stripos($contentType, 'multipart/form-data') !== false) {
                $bodyParams = $_POST;
            } else {
                throw new RequestError('Unexpected content type: ' . Utils::printSafeJson($contentType));
            }
        }

        return $this->parseRequestParams($method, $bodyParams, $urlParams);
    }

    /**
     * Parses normalized request params and returns instance of OperationParams
     * or array of OperationParams in case of batch operation.
     *
     * Returned value is a suitable input for `executeOperation` or `executeBatch` (if array)
     *
     * @param string  $method
     * @param mixed[] $bodyParams
     * @param mixed[] $queryParams
     *
     * @return OperationParams|OperationParams[]
     *
     * @throws RequestError
     *
     * @api
     */
    public function parseRequestParams($method, array $bodyParams, array $queryParams)
    {
        if ($method === 'GET') {
            $result = OperationParams::create($queryParams, true);
        } elseif ($method === 'POST') {
            if (isset($bodyParams[0])) {
                $result = [];
                foreach ($bodyParams as $index => $entry) {
                    $op       = OperationParams::create($entry);
                    $result[] = $op;
                }
            } else {
                $result = OperationParams::create($bodyParams);
            }
        } else {
            throw new RequestError('HTTP Method "' . $method . '" is not supported');
        }

        return $result;
    }

    /**
     * Checks validity of OperationParams extracted from HTTP request and returns an array of errors
     * if params are invalid (or empty array when params are valid)
     *
     * @return array<int, RequestError>
     *
     * @api
     */
    public function validateOperationParams(OperationParams $params)
    {
        $errors = [];
        if (! $params->query && ! $params->queryId) {
            $errors[] = new RequestError('GraphQL Request must include at least one of those two parameters: "query" or "queryId"');
        }

        if ($params->query && $params->queryId) {
            $errors[] = new RequestError('GraphQL Request parameters "query" and "queryId" are mutually exclusive');
        }

        if ($params->query !== null && ! is_string($params->query)) {
            $errors[] = new RequestError(
                'GraphQL Request parameter "query" must be string, but got ' .
                Utils::printSafeJson($params->query)
            );
        }

        if ($params->queryId !== null && ! is_string($params->queryId)) {
            $errors[] = new RequestError(
                'GraphQL Request parameter "queryId" must be string, but got ' .
                Utils::printSafeJson($params->queryId)
            );
        }

        if ($params->operation !== null && ! is_string($params->operation)) {
            $errors[] = new RequestError(
                'GraphQL Request parameter "operation" must be string, but got ' .
                Utils::printSafeJson($params->operation)
            );
        }

        if ($params->variables !== null && (! is_array($params->variables) || isset($params->variables[0]))) {
            $errors[] = new RequestError(
                'GraphQL Request parameter "variables" must be object or JSON string parsed to object, but got ' .
                Utils::printSafeJson($params->getOriginalInput('variables'))
            );
        }

        return $errors;
    }

    /**
     * Executes GraphQL operation with given server configuration and returns execution result
     * (or promise when promise adapter is different from SyncPromiseAdapter)
     *
     * @return ExecutionResult|Promise
     *
     * @api
     */
    public function executeOperation(ServerConfig $config, OperationParams $op)
    {
        $promiseAdapter = $config->getPromiseAdapter() ?? Executor::getPromiseAdapter();
        $result         = $this->promiseToExecuteOperation($promiseAdapter, $config, $op);

        if ($promiseAdapter instanceof SyncPromiseAdapter) {
            $result = $promiseAdapter->wait($result);
        }

        return $result;
    }

    /**
     * Executes batched GraphQL operations with shared promise queue
     * (thus, effectively batching deferreds|promises of all queries at once)
     *
     * @param OperationParams[] $operations
     *
     * @return ExecutionResult|ExecutionResult[]|Promise
     *
     * @api
     */
    public function executeBatch(ServerConfig $config, array $operations)
    {
        $promiseAdapter = $config->getPromiseAdapter() ?? Executor::getPromiseAdapter();
        $result         = [];

        foreach ($operations as $operation) {
            $result[] = $this->promiseToExecuteOperation($promiseAdapter, $config, $operation, true);
        }

        $result = $promiseAdapter->all($result);

        // Wait for promised results when using sync promises
        if ($promiseAdapter instanceof SyncPromiseAdapter) {
            $result = $promiseAdapter->wait($result);
        }

        return $result;
    }

    /**
     * @param bool $isBatch
     *
     * @return Promise
     */
    private function promiseToExecuteOperation(
        PromiseAdapter $promiseAdapter,
        ServerConfig $config,
        OperationParams $op,
        $isBatch = false
    ) {
        try {
            if ($config->getSchema() === null) {
                throw new InvariantViolation('Schema is required for the server');
            }

            if ($isBatch && ! $config->getQueryBatching()) {
                throw new RequestError('Batched queries are not supported by this server');
            }

            $errors = $this->validateOperationParams($op);

            if (count($errors) > 0) {
                $errors = Utils::map(
                    $errors,
                    static function (RequestError $err) : Error {
                        return Error::createLocatedError($err, null, null);
                    }
                );

                return $promiseAdapter->createFulfilled(
                    new ExecutionResult(null, $errors)
                );
            }

            $doc = $op->queryId
                ? $this->loadPersistedQuery($config, $op)
                : $op->query;

            if (! $doc instanceof DocumentNode) {
                $doc = Parser::parse($doc);
            }

            $operationType = AST::getOperation($doc, $op->operation);

            if ($operationType === false) {
                throw new RequestError('Failed to determine operation type');
            }

            if ($operationType !== 'query' && $op->isReadOnly()) {
                throw new RequestError('GET supports only query operation');
            }

            $result = GraphQL::promiseToExecute(
                $promiseAdapter,
                $config->getSchema(),
                $doc,
                $this->resolveRootValue($config, $op, $doc, $operationType),
                $this->resolveContextValue($config, $op, $doc, $operationType),
                $op->variables,
                $op->operation,
                $config->getFieldResolver(),
                $this->resolveValidationRules($config, $op, $doc, $operationType)
            );
        } catch (RequestError $e) {
            $result = $promiseAdapter->createFulfilled(
                new ExecutionResult(null, [Error::createLocatedError($e)])
            );
        } catch (Error $e) {
            $result = $promiseAdapter->createFulfilled(
                new ExecutionResult(null, [$e])
            );
        }

        $applyErrorHandling = static function (ExecutionResult $result) use ($config) : ExecutionResult {
            if ($config->getErrorsHandler()) {
                $result->setErrorsHandler($config->getErrorsHandler());
            }
            if ($config->getErrorFormatter() || $config->getDebugFlag() !== DebugFlag::NONE) {
                $result->setErrorFormatter(
                    FormattedError::prepareFormatter(
                        $config->getErrorFormatter(),
                        $config->getDebugFlag()
                    )
                );
            }

            return $result;
        };

        return $result->then($applyErrorHandling);
    }

    /**
     * @return mixed
     *
     * @throws RequestError
     */
    private function loadPersistedQuery(ServerConfig $config, OperationParams $operationParams)
    {
        // Load query if we got persisted query id:
        $loader = $config->getPersistentQueryLoader();

        if ($loader === null) {
            throw new RequestError('Persisted queries are not supported by this server');
        }

        $source = $loader($operationParams->queryId, $operationParams);

        if (! is_string($source) && ! $source instanceof DocumentNode) {
            throw new InvariantViolation(sprintf(
                'Persistent query loader must return query string or instance of %s but got: %s',
                DocumentNode::class,
                Utils::printSafe($source)
            ));
        }

        return $source;
    }

    /**
     * @param string $operationType
     *
     * @return mixed[]|null
     */
    private function resolveValidationRules(
        ServerConfig $config,
        OperationParams $params,
        DocumentNode $doc,
        $operationType
    ) {
        // Allow customizing validation rules per operation:
        $validationRules = $config->getValidationRules();

        if (is_callable($validationRules)) {
            $validationRules = $validationRules($params, $doc, $operationType);

            if (! is_array($validationRules)) {
                throw new InvariantViolation(sprintf(
                    'Expecting validation rules to be array or callable returning array, but got: %s',
                    Utils::printSafe($validationRules)
                ));
            }
        }

        return $validationRules;
    }

    /**
     * @return mixed
     */
    private function resolveRootValue(ServerConfig $config, OperationParams $params, DocumentNode $doc, string $operationType)
    {
        $rootValue = $config->getRootValue();

        if (is_callable($rootValue)) {
            $rootValue = $rootValue($params, $doc, $operationType);
        }

        return $rootValue;
    }

    /**
     * @param string $operationType
     *
     * @return mixed
     */
    private function resolveContextValue(
        ServerConfig $config,
        OperationParams $params,
        DocumentNode $doc,
        $operationType
    ) {
        $context = $config->getContext();

        if (is_callable($context)) {
            $context = $context($params, $doc, $operationType);
        }

        return $context;
    }

    /**
     * Send response using standard PHP `header()` and `echo`.
     *
     * @param Promise|ExecutionResult|ExecutionResult[] $result
     * @param bool                                      $exitWhenDone
     *
     * @api
     */
    public function sendResponse($result, $exitWhenDone = false)
    {
        if ($result instanceof Promise) {
            $result->then(function ($actualResult) use ($exitWhenDone) : void {
                $this->doSendResponse($actualResult, $exitWhenDone);
            });
        } else {
            $this->doSendResponse($result, $exitWhenDone);
        }
    }

    private function doSendResponse($result, $exitWhenDone)
    {
        $httpStatus = $this->resolveHttpStatus($result);
        $this->emitResponse($result, $httpStatus, $exitWhenDone);
    }

    /**
     * @param mixed[]|JsonSerializable $jsonSerializable
     * @param int                      $httpStatus
     * @param bool                     $exitWhenDone
     */
    public function emitResponse($jsonSerializable, $httpStatus, $exitWhenDone)
    {
        $body = json_encode($jsonSerializable);
        header('Content-Type: application/json', true, $httpStatus);
        echo $body;

        if ($exitWhenDone) {
            exit;
        }
    }

    /**
     * @return bool|string
     */
    private function readRawBody()
    {
        return file_get_contents('php://input');
    }

    /**
     * @param ExecutionResult|mixed[] $result
     *
     * @return int
     */
    private function resolveHttpStatus($result)
    {
        if (is_array($result) && isset($result[0])) {
            Utils::each(
                $result,
                static function ($executionResult, $index) : void {
                    if (! $executionResult instanceof ExecutionResult) {
                        throw new InvariantViolation(sprintf(
                            'Expecting every entry of batched query result to be instance of %s but entry at position %d is %s',
                            ExecutionResult::class,
                            $index,
                            Utils::printSafe($executionResult)
                        ));
                    }
                }
            );
            $httpStatus = 200;
        } else {
            if (! $result instanceof ExecutionResult) {
                throw new InvariantViolation(sprintf(
                    'Expecting query result to be instance of %s but got %s',
                    ExecutionResult::class,
                    Utils::printSafe($result)
                ));
            }
            if ($result->data === null && count($result->errors) > 0) {
                $httpStatus = 400;
            } else {
                $httpStatus = 200;
            }
        }

        return $httpStatus;
    }

    /**
     * Converts PSR-7 request to OperationParams[]
     *
     * @return OperationParams[]|OperationParams
     *
     * @throws RequestError
     *
     * @api
     */
    public function parsePsrRequest(RequestInterface $request)
    {
        if ($request->getMethod() === 'GET') {
            $bodyParams = [];
        } else {
            $contentType = $request->getHeader('content-type');

            if (! isset($contentType[0])) {
                throw new RequestError('Missing "Content-Type" header');
            }

            if (stripos($contentType[0], 'application/graphql') !== false) {
                $bodyParams = ['query' => (string) $request->getBody()];
            } elseif (stripos($contentType[0], 'application/json') !== false) {
                $bodyParams = $request instanceof ServerRequestInterface
                    ? $request->getParsedBody()
                    : json_decode((string) $request->getBody(), true);

                if ($bodyParams === null) {
                    throw new InvariantViolation(
                        $request instanceof ServerRequestInterface
                         ? 'Expected to receive a parsed body for "application/json" PSR-7 request but got null'
                         : 'Expected to receive a JSON array in body for "application/json" PSR-7 request'
                    );
                }

                if (! is_array($bodyParams)) {
                    throw new RequestError(
                        'GraphQL Server expects JSON object or array, but got ' .
                        Utils::printSafeJson($bodyParams)
                    );
                }
            } else {
                if ($request instanceof ServerRequestInterface) {
                    $bodyParams = $request->getParsedBody();
                }

                if (! isset($bodyParams)) {
                    $bodyParams = $this->decodeContent((string) $request->getBody(), $contentType[0]);
                }
            }
        }

        parse_str(html_entity_decode($request->getUri()->getQuery()), $queryParams);

        return $this->parseRequestParams(
            $request->getMethod(),
            $bodyParams,
            $queryParams
        );
    }

    /**
     * @return array<string, mixed>
     *
     * @throws RequestError
     */
    protected function decodeContent(string $rawBody, string $contentType) : array
    {
        parse_str($rawBody, $bodyParams);

        if (! is_array($bodyParams)) {
            throw new RequestError('Unexpected content type: ' . Utils::printSafeJson($contentType));
        }

        return $bodyParams;
    }

    /**
     * Converts query execution result to PSR-7 response
     *
     * @param Promise|ExecutionResult|ExecutionResult[] $result
     *
     * @return Promise|ResponseInterface
     *
     * @api
     */
    public function toPsrResponse($result, ResponseInterface $response, StreamInterface $writableBodyStream)
    {
        if ($result instanceof Promise) {
            return $result->then(function ($actualResult) use ($response, $writableBodyStream) {
                return $this->doConvertToPsrResponse($actualResult, $response, $writableBodyStream);
            });
        }

        return $this->doConvertToPsrResponse($result, $response, $writableBodyStream);
    }

    private function doConvertToPsrResponse($result, ResponseInterface $response, StreamInterface $writableBodyStream)
    {
        $httpStatus = $this->resolveHttpStatus($result);

        $result = json_encode($result);
        $writableBodyStream->write($result);

        return $response
            ->withStatus($httpStatus)
            ->withHeader('Content-Type', 'application/json')
            ->withBody($writableBodyStream);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Server\OperationParams.php
<?php

declare(strict_types=1);

namespace GraphQL\Server;

use function array_change_key_case;
use function is_string;
use function json_decode;
use function json_last_error;
use function strlen;
use const CASE_LOWER;
use const JSON_ERROR_NONE;

/**
 * Structure representing parsed HTTP parameters for GraphQL operation
 */
class OperationParams
{
    /**
     * Id of the query (when using persistent queries).
     *
     * Valid aliases (case-insensitive):
     * - id
     * - queryId
     * - documentId
     *
     * @api
     * @var string
     */
    public $queryId;

    /**
     * @api
     * @var string
     */
    public $query;

    /**
     * @api
     * @var string
     */
    public $operation;

    /**
     * @api
     * @var mixed[]|null
     */
    public $variables;

    /**
     * @api
     * @var mixed[]|null
     */
    public $extensions;

    /** @var mixed[] */
    private $originalInput;

    /** @var bool */
    private $readOnly;

    /**
     * Creates an instance from given array
     *
     * @param mixed[] $params
     *
     * @api
     */
    public static function create(array $params, bool $readonly = false) : OperationParams
    {
        $instance = new static();

        $params                  = array_change_key_case($params, CASE_LOWER);
        $instance->originalInput = $params;

        $params += [
            'query' => null,
            'queryid' => null,
            'documentid' => null, // alias to queryid
            'id' => null, // alias to queryid
            'operationname' => null,
            'variables' => null,
            'extensions' => null,
        ];

        if ($params['variables'] === '') {
            $params['variables'] = null;
        }

        // Some parameters could be provided as serialized JSON.
        foreach (['extensions', 'variables'] as $param) {
            if (! is_string($params[$param])) {
                continue;
            }

            $tmp = json_decode($params[$param], true);
            if (json_last_error() !== JSON_ERROR_NONE) {
                continue;
            }

            $params[$param] = $tmp;
        }

        $instance->query      = $params['query'];
        $instance->queryId    = $params['queryid'] ?? $params['documentid'] ?? $params['id'];
        $instance->operation  = $params['operationname'];
        $instance->variables  = $params['variables'];
        $instance->extensions = $params['extensions'];
        $instance->readOnly   = $readonly;

        // Apollo server/client compatibility: look for the queryid in extensions
        if (isset($instance->extensions['persistedQuery']['sha256Hash']) && strlen($instance->query ?? '') === 0 && strlen($instance->queryId ?? '') === 0) {
            $instance->queryId = $instance->extensions['persistedQuery']['sha256Hash'];
        }

        return $instance;
    }

    /**
     * @param string $key
     *
     * @return mixed
     *
     * @api
     */
    public function getOriginalInput($key)
    {
        return $this->originalInput[$key] ?? null;
    }

    /**
     * Indicates that operation is executed in read-only context
     * (e.g. via HTTP GET request)
     *
     * @return bool
     *
     * @api
     */
    public function isReadOnly()
    {
        return $this->readOnly;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Server\RequestError.php
<?php

declare(strict_types=1);

namespace GraphQL\Server;

use Exception;
use GraphQL\Error\ClientAware;

class RequestError extends Exception implements ClientAware
{
    /**
     * Returns true when exception message is safe to be displayed to client
     *
     * @return bool
     */
    public function isClientSafe()
    {
        return true;
    }

    /**
     * Returns string describing error category. E.g. "validation" for your own validation errors.
     *
     * Value "graphql" is reserved for errors produced by query parsing or validation, do not use it.
     *
     * @return string
     */
    public function getCategory()
    {
        return 'request';
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Server\ServerConfig.php
<?php

declare(strict_types=1);

namespace GraphQL\Server;

use GraphQL\Error\DebugFlag;
use GraphQL\Error\InvariantViolation;
use GraphQL\Executor\Promise\PromiseAdapter;
use GraphQL\Type\Schema;
use GraphQL\Utils\Utils;
use GraphQL\Validator\Rules\ValidationRule;
use function is_array;
use function is_callable;
use function method_exists;
use function sprintf;
use function ucfirst;

/**
 * Server configuration class.
 * Could be passed directly to server constructor. List of options accepted by **create** method is
 * [described in docs](executing-queries.md#server-configuration-options).
 *
 * Usage example:
 *
 *     $config = GraphQL\Server\ServerConfig::create()
 *         ->setSchema($mySchema)
 *         ->setContext($myContext);
 *
 *     $server = new GraphQL\Server\StandardServer($config);
 */
class ServerConfig
{
    /**
     * Converts an array of options to instance of ServerConfig
     * (or just returns empty config when array is not passed).
     *
     * @param mixed[] $config
     *
     * @return ServerConfig
     *
     * @api
     */
    public static function create(array $config = [])
    {
        $instance = new static();
        foreach ($config as $key => $value) {
            $method = 'set' . ucfirst($key);
            if (! method_exists($instance, $method)) {
                throw new InvariantViolation(sprintf('Unknown server config option "%s"', $key));
            }
            $instance->$method($value);
        }

        return $instance;
    }

    /** @var Schema|null */
    private $schema;

    /** @var mixed|callable */
    private $context;

    /** @var mixed|callable */
    private $rootValue;

    /** @var callable|null */
    private $errorFormatter;

    /** @var callable|null */
    private $errorsHandler;

    /** @var int */
    private $debugFlag = DebugFlag::NONE;

    /** @var bool */
    private $queryBatching = false;

    /** @var ValidationRule[]|callable|null */
    private $validationRules;

    /** @var callable|null */
    private $fieldResolver;

    /** @var PromiseAdapter|null */
    private $promiseAdapter;

    /** @var callable|null */
    private $persistentQueryLoader;

    /**
     * @return self
     *
     * @api
     */
    public function setSchema(Schema $schema)
    {
        $this->schema = $schema;

        return $this;
    }

    /**
     * @param mixed|callable $context
     *
     * @return self
     *
     * @api
     */
    public function setContext($context)
    {
        $this->context = $context;

        return $this;
    }

    /**
     * @param mixed|callable $rootValue
     *
     * @return self
     *
     * @api
     */
    public function setRootValue($rootValue)
    {
        $this->rootValue = $rootValue;

        return $this;
    }

    /**
     * Expects function(Throwable $e) : array
     *
     * @return self
     *
     * @api
     */
    public function setErrorFormatter(callable $errorFormatter)
    {
        $this->errorFormatter = $errorFormatter;

        return $this;
    }

    /**
     * Expects function(array $errors, callable $formatter) : array
     *
     * @return self
     *
     * @api
     */
    public function setErrorsHandler(callable $handler)
    {
        $this->errorsHandler = $handler;

        return $this;
    }

    /**
     * Set validation rules for this server.
     *
     * @param ValidationRule[]|callable|null $validationRules
     *
     * @return self
     *
     * @api
     */
    public function setValidationRules($validationRules)
    {
        if (! is_callable($validationRules) && ! is_array($validationRules) && $validationRules !== null) {
            throw new InvariantViolation(
                'Server config expects array of validation rules or callable returning such array, but got ' .
                Utils::printSafe($validationRules)
            );
        }

        $this->validationRules = $validationRules;

        return $this;
    }

    /**
     * @return self
     *
     * @api
     */
    public function setFieldResolver(callable $fieldResolver)
    {
        $this->fieldResolver = $fieldResolver;

        return $this;
    }

    /**
     * Expects function($queryId, OperationParams $params) : string|DocumentNode
     *
     * This function must return query string or valid DocumentNode.
     *
     * @return self
     *
     * @api
     */
    public function setPersistentQueryLoader(callable $persistentQueryLoader)
    {
        $this->persistentQueryLoader = $persistentQueryLoader;

        return $this;
    }

    /**
     * Set response debug flags. @see \GraphQL\Error\DebugFlag class for a list of all available flags
     *
     * @api
     */
    public function setDebugFlag(int $debugFlag = DebugFlag::INCLUDE_DEBUG_MESSAGE) : self
    {
        $this->debugFlag = $debugFlag;

        return $this;
    }

    /**
     * Allow batching queries (disabled by default)
     *
     * @api
     */
    public function setQueryBatching(bool $enableBatching) : self
    {
        $this->queryBatching = $enableBatching;

        return $this;
    }

    /**
     * @return self
     *
     * @api
     */
    public function setPromiseAdapter(PromiseAdapter $promiseAdapter)
    {
        $this->promiseAdapter = $promiseAdapter;

        return $this;
    }

    /**
     * @return mixed|callable
     */
    public function getContext()
    {
        return $this->context;
    }

    /**
     * @return mixed|callable
     */
    public function getRootValue()
    {
        return $this->rootValue;
    }

    /**
     * @return Schema|null
     */
    public function getSchema()
    {
        return $this->schema;
    }

    /**
     * @return callable|null
     */
    public function getErrorFormatter()
    {
        return $this->errorFormatter;
    }

    /**
     * @return callable|null
     */
    public function getErrorsHandler()
    {
        return $this->errorsHandler;
    }

    /**
     * @return PromiseAdapter|null
     */
    public function getPromiseAdapter()
    {
        return $this->promiseAdapter;
    }

    /**
     * @return ValidationRule[]|callable|null
     */
    public function getValidationRules()
    {
        return $this->validationRules;
    }

    /**
     * @return callable|null
     */
    public function getFieldResolver()
    {
        return $this->fieldResolver;
    }

    /**
     * @return callable|null
     */
    public function getPersistentQueryLoader()
    {
        return $this->persistentQueryLoader;
    }

    public function getDebugFlag() : int
    {
        return $this->debugFlag;
    }

    /**
     * @return bool
     */
    public function getQueryBatching()
    {
        return $this->queryBatching;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Server\StandardServer.php
<?php

declare(strict_types=1);

namespace GraphQL\Server;

use GraphQL\Error\DebugFlag;
use GraphQL\Error\FormattedError;
use GraphQL\Error\InvariantViolation;
use GraphQL\Executor\ExecutionResult;
use GraphQL\Executor\Promise\Promise;
use GraphQL\Utils\Utils;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\StreamInterface;
use Throwable;
use function is_array;

/**
 * GraphQL server compatible with both: [express-graphql](https://github.com/graphql/express-graphql)
 * and [Apollo Server](https://github.com/apollographql/graphql-server).
 * Usage Example:
 *
 *     $server = new StandardServer([
 *       'schema' => $mySchema
 *     ]);
 *     $server->handleRequest();
 *
 * Or using [ServerConfig](reference.md#graphqlserverserverconfig) instance:
 *
 *     $config = GraphQL\Server\ServerConfig::create()
 *         ->setSchema($mySchema)
 *         ->setContext($myContext);
 *
 *     $server = new GraphQL\Server\StandardServer($config);
 *     $server->handleRequest();
 *
 * See [dedicated section in docs](executing-queries.md#using-server) for details.
 */
class StandardServer
{
    /** @var ServerConfig */
    private $config;

    /** @var Helper */
    private $helper;

    /**
     * Converts and exception to error and sends spec-compliant HTTP 500 error.
     * Useful when an exception is thrown somewhere outside of server execution context
     * (e.g. during schema instantiation).
     *
     * @param Throwable $error
     * @param int       $debug
     * @param bool      $exitWhenDone
     *
     * @api
     */
    public static function send500Error($error, $debug = DebugFlag::NONE, $exitWhenDone = false)
    {
        $response = [
            'errors' => [FormattedError::createFromException($error, $debug)],
        ];
        $helper   = new Helper();
        $helper->emitResponse($response, 500, $exitWhenDone);
    }

    /**
     * Creates new instance of a standard GraphQL HTTP server
     *
     * @param ServerConfig|mixed[] $config
     *
     * @api
     */
    public function __construct($config)
    {
        if (is_array($config)) {
            $config = ServerConfig::create($config);
        }
        if (! $config instanceof ServerConfig) {
            throw new InvariantViolation('Expecting valid server config, but got ' . Utils::printSafe($config));
        }
        $this->config = $config;
        $this->helper = new Helper();
    }

    /**
     * Parses HTTP request, executes and emits response (using standard PHP `header` function and `echo`)
     *
     * By default (when $parsedBody is not set) it uses PHP globals to parse a request.
     * It is possible to implement request parsing elsewhere (e.g. using framework Request instance)
     * and then pass it to the server.
     *
     * See `executeRequest()` if you prefer to emit response yourself
     * (e.g. using Response object of some framework)
     *
     * @param OperationParams|OperationParams[] $parsedBody
     * @param bool                              $exitWhenDone
     *
     * @api
     */
    public function handleRequest($parsedBody = null, $exitWhenDone = false)
    {
        $result = $this->executeRequest($parsedBody);
        $this->helper->sendResponse($result, $exitWhenDone);
    }

    /**
     * Executes GraphQL operation and returns execution result
     * (or promise when promise adapter is different from SyncPromiseAdapter).
     *
     * By default (when $parsedBody is not set) it uses PHP globals to parse a request.
     * It is possible to implement request parsing elsewhere (e.g. using framework Request instance)
     * and then pass it to the server.
     *
     * PSR-7 compatible method executePsrRequest() does exactly this.
     *
     * @param OperationParams|OperationParams[] $parsedBody
     *
     * @return ExecutionResult|ExecutionResult[]|Promise
     *
     * @throws InvariantViolation
     *
     * @api
     */
    public function executeRequest($parsedBody = null)
    {
        if ($parsedBody === null) {
            $parsedBody = $this->helper->parseHttpRequest();
        }

        if (is_array($parsedBody)) {
            return $this->helper->executeBatch($this->config, $parsedBody);
        }

        return $this->helper->executeOperation($this->config, $parsedBody);
    }

    /**
     * Executes PSR-7 request and fulfills PSR-7 response.
     *
     * See `executePsrRequest()` if you prefer to create response yourself
     * (e.g. using specific JsonResponse instance of some framework).
     *
     * @return ResponseInterface|Promise
     *
     * @api
     */
    public function processPsrRequest(
        RequestInterface $request,
        ResponseInterface $response,
        StreamInterface $writableBodyStream
    ) {
        $result = $this->executePsrRequest($request);

        return $this->helper->toPsrResponse($result, $response, $writableBodyStream);
    }

    /**
     * Executes GraphQL operation and returns execution result
     * (or promise when promise adapter is different from SyncPromiseAdapter)
     *
     * @return ExecutionResult|ExecutionResult[]|Promise
     *
     * @api
     */
    public function executePsrRequest(RequestInterface $request)
    {
        $parsedBody = $this->helper->parsePsrRequest($request);

        return $this->executeRequest($parsedBody);
    }

    /**
     * Returns an instance of Server helper, which contains most of the actual logic for
     * parsing / validating / executing request (which could be re-used by other server implementations)
     *
     * @return Helper
     *
     * @api
     */
    public function getHelper()
    {
        return $this->helper;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Introspection.php
<?php

declare(strict_types=1);

namespace GraphQL\Type;

use Exception;
use GraphQL\GraphQL;
use GraphQL\Language\DirectiveLocation;
use GraphQL\Language\Printer;
use GraphQL\Type\Definition\Directive;
use GraphQL\Type\Definition\EnumType;
use GraphQL\Type\Definition\FieldArgument;
use GraphQL\Type\Definition\FieldDefinition;
use GraphQL\Type\Definition\InputObjectField;
use GraphQL\Type\Definition\InputObjectType;
use GraphQL\Type\Definition\InterfaceType;
use GraphQL\Type\Definition\ListOfType;
use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\ResolveInfo;
use GraphQL\Type\Definition\ScalarType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Definition\UnionType;
use GraphQL\Type\Definition\WrappingType;
use GraphQL\Utils\AST;
use GraphQL\Utils\Utils;
use function array_filter;
use function array_key_exists;
use function array_merge;
use function array_values;
use function is_bool;
use function method_exists;
use function trigger_error;
use const E_USER_DEPRECATED;

class Introspection
{
    const SCHEMA_FIELD_NAME    = '__schema';
    const TYPE_FIELD_NAME      = '__type';
    const TYPE_NAME_FIELD_NAME = '__typename';

    /** @var array<string, mixed> */
    private static $map = [];

    /**
     * @param array<string, bool> $options
     *      Available options:
     *      - descriptions
     *        Whether to include descriptions in the introspection result.
     *        Default: true
     *      - directiveIsRepeatable
     *        Whether to include `isRepeatable` flag on directives.
     *        Default: false
     *
     * @return string
     *
     * @api
     */
    public static function getIntrospectionQuery(array $options = [])
    {
        $optionsWithDefaults = array_merge([
            'descriptions' => true,
            'directiveIsRepeatable' => false,
        ], $options);

        $descriptions          = $optionsWithDefaults['descriptions'] ? 'description' : '';
        $directiveIsRepeatable = $optionsWithDefaults['directiveIsRepeatable'] ? 'isRepeatable' : '';

        return <<<EOD
  query IntrospectionQuery {
    __schema {
      queryType { name }
      mutationType { name }
      subscriptionType { name }
      types {
        ...FullType
      }
      directives {
        name
        {$descriptions}
        args {
          ...InputValue
        }
        {$directiveIsRepeatable}
        locations
      }
    }
  }

  fragment FullType on __Type {
    kind
    name
    {$descriptions}
    fields(includeDeprecated: true) {
      name
      {$descriptions}
      args {
        ...InputValue
      }
      type {
        ...TypeRef
      }
      isDeprecated
      deprecationReason
    }
    inputFields {
      ...InputValue
    }
    interfaces {
      ...TypeRef
    }
    enumValues(includeDeprecated: true) {
      name
      {$descriptions}
      isDeprecated
      deprecationReason
    }
    possibleTypes {
      ...TypeRef
    }
  }

  fragment InputValue on __InputValue {
    name
    {$descriptions}
    type { ...TypeRef }
    defaultValue
  }

  fragment TypeRef on __Type {
    kind
    name
    ofType {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                }
              }
            }
          }
        }
      }
    }
  }
EOD;
    }

    /**
     * @param Type $type
     *
     * @return bool
     */
    public static function isIntrospectionType($type)
    {
        return array_key_exists($type->name, self::getTypes());
    }

    public static function getTypes()
    {
        return [
            '__Schema'            => self::_schema(),
            '__Type'              => self::_type(),
            '__Directive'         => self::_directive(),
            '__Field'             => self::_field(),
            '__InputValue'        => self::_inputValue(),
            '__EnumValue'         => self::_enumValue(),
            '__TypeKind'          => self::_typeKind(),
            '__DirectiveLocation' => self::_directiveLocation(),
        ];
    }

    /**
     * Build an introspection query from a Schema
     *
     * Introspection is useful for utilities that care about type and field
     * relationships, but do not need to traverse through those relationships.
     *
     * This is the inverse of BuildClientSchema::build(). The primary use case is outside
     * of the server context, for instance when doing schema comparisons.
     *
     * @param array<string, bool> $options
     *      Available options:
     *      - descriptions
     *        Whether to include `isRepeatable` flag on directives.
     *        Default: true
     *      - directiveIsRepeatable
     *        Whether to include descriptions in the introspection result.
     *        Default: true
     *
     * @return array<string, array<mixed>>|null
     *
     * @api
     */
    public static function fromSchema(Schema $schema, array $options = []) : ?array
    {
        $optionsWithDefaults = array_merge(['directiveIsRepeatable' => true], $options);

        $result = GraphQL::executeQuery(
            $schema,
            self::getIntrospectionQuery($optionsWithDefaults)
        );

        return $result->data;
    }

    public static function _schema()
    {
        if (! isset(self::$map['__Schema'])) {
            self::$map['__Schema'] = new ObjectType([
                'name'            => '__Schema',
                'isIntrospection' => true,
                'description'     =>
                    'A GraphQL Schema defines the capabilities of a GraphQL ' .
                    'server. It exposes all available types and directives on ' .
                    'the server, as well as the entry points for query, mutation, and ' .
                    'subscription operations.',
                'fields'          => [
                    'types'            => [
                        'description' => 'A list of all types supported by this server.',
                        'type'        => new NonNull(new ListOfType(new NonNull(self::_type()))),
                        'resolve'     => static function (Schema $schema) : array {
                            return array_values($schema->getTypeMap());
                        },
                    ],
                    'queryType'        => [
                        'description' => 'The type that query operations will be rooted at.',
                        'type'        => new NonNull(self::_type()),
                        'resolve'     => static function (Schema $schema) : ?ObjectType {
                            return $schema->getQueryType();
                        },
                    ],
                    'mutationType'     => [
                        'description' =>
                            'If this server supports mutation, the type that ' .
                            'mutation operations will be rooted at.',
                        'type'        => self::_type(),
                        'resolve'     => static function (Schema $schema) : ?ObjectType {
                            return $schema->getMutationType();
                        },
                    ],
                    'subscriptionType' => [
                        'description' => 'If this server support subscription, the type that subscription operations will be rooted at.',
                        'type'        => self::_type(),
                        'resolve'     => static function (Schema $schema) : ?ObjectType {
                            return $schema->getSubscriptionType();
                        },
                    ],
                    'directives'       => [
                        'description' => 'A list of all directives supported by this server.',
                        'type'        => Type::nonNull(Type::listOf(Type::nonNull(self::_directive()))),
                        'resolve'     => static function (Schema $schema) : array {
                            return $schema->getDirectives();
                        },
                    ],
                ],
            ]);
        }

        return self::$map['__Schema'];
    }

    public static function _type()
    {
        if (! isset(self::$map['__Type'])) {
            self::$map['__Type'] = new ObjectType([
                'name'            => '__Type',
                'isIntrospection' => true,
                'description'     =>
                    'The fundamental unit of any GraphQL Schema is the type. There are ' .
                    'many kinds of types in GraphQL as represented by the `__TypeKind` enum.' .
                    "\n\n" .
                    'Depending on the kind of a type, certain fields describe ' .
                    'information about that type. Scalar types provide no information ' .
                    'beyond a name and description, while Enum types provide their values. ' .
                    'Object and Interface types provide the fields they describe. Abstract ' .
                    'types, Union and Interface, provide the Object types possible ' .
                    'at runtime. List and NonNull types compose other types.',
                'fields'          => static function () : array {
                    return [
                        'kind'          => [
                            'type'    => Type::nonNull(self::_typeKind()),
                            'resolve' => static function (Type $type) {
                                switch (true) {
                                    case $type instanceof ListOfType:
                                        return TypeKind::LIST;
                                    case $type instanceof NonNull:
                                        return TypeKind::NON_NULL;
                                    case $type instanceof ScalarType:
                                        return TypeKind::SCALAR;
                                    case $type instanceof ObjectType:
                                        return TypeKind::OBJECT;
                                    case $type instanceof EnumType:
                                        return TypeKind::ENUM;
                                    case $type instanceof InputObjectType:
                                        return TypeKind::INPUT_OBJECT;
                                    case $type instanceof InterfaceType:
                                        return TypeKind::INTERFACE;
                                    case $type instanceof UnionType:
                                        return TypeKind::UNION;
                                    default:
                                        throw new Exception('Unknown kind of type: ' . Utils::printSafe($type));
                                }
                            },
                        ],
                        'name'          => [
                            'type' => Type::string(),
                            'resolve' => static function ($obj) {
                                return $obj->name;
                            },
                        ],
                        'description'   => [
                            'type' => Type::string(),
                            'resolve' => static function ($obj) {
                                return $obj->description;
                            },
                        ],
                        'fields'        => [
                            'type'    => Type::listOf(Type::nonNull(self::_field())),
                            'args'    => [
                                'includeDeprecated' => ['type' => Type::boolean(), 'defaultValue' => false],
                            ],
                            'resolve' => static function (Type $type, $args) : ?array {
                                if ($type instanceof ObjectType || $type instanceof InterfaceType) {
                                    $fields = $type->getFields();

                                    if (! ($args['includeDeprecated'] ?? false)) {
                                        $fields = array_filter(
                                            $fields,
                                            static function (FieldDefinition $field) : bool {
                                                return ! $field->deprecationReason;
                                            }
                                        );
                                    }

                                    return array_values($fields);
                                }

                                return null;
                            },
                        ],
                        'interfaces'    => [
                            'type'    => Type::listOf(Type::nonNull(self::_type())),
                            'resolve' => static function ($type) : ?array {
                                if ($type instanceof ObjectType || $type instanceof InterfaceType) {
                                    return $type->getInterfaces();
                                }

                                return null;
                            },
                        ],
                        'possibleTypes' => [
                            'type'    => Type::listOf(Type::nonNull(self::_type())),
                            'resolve' => static function ($type, $args, $context, ResolveInfo $info) : ?array {
                                if ($type instanceof InterfaceType || $type instanceof UnionType) {
                                    return $info->schema->getPossibleTypes($type);
                                }

                                return null;
                            },
                        ],
                        'enumValues'    => [
                            'type'    => Type::listOf(Type::nonNull(self::_enumValue())),
                            'args'    => [
                                'includeDeprecated' => ['type' => Type::boolean(), 'defaultValue' => false],
                            ],
                            'resolve' => static function ($type, $args) : ?array {
                                if ($type instanceof EnumType) {
                                    $values = array_values($type->getValues());

                                    if (! ($args['includeDeprecated'] ?? false)) {
                                        $values = array_filter(
                                            $values,
                                            static function ($value) : bool {
                                                return ! $value->deprecationReason;
                                            }
                                        );
                                    }

                                    return $values;
                                }

                                return null;
                            },
                        ],
                        'inputFields'   => [
                            'type'    => Type::listOf(Type::nonNull(self::_inputValue())),
                            'resolve' => static function ($type) : ?array {
                                if ($type instanceof InputObjectType) {
                                    return array_values($type->getFields());
                                }

                                return null;
                            },
                        ],
                        'ofType'        => [
                            'type'    => self::_type(),
                            'resolve' => static function ($type) : ?Type {
                                if ($type instanceof WrappingType) {
                                    return $type->getWrappedType();
                                }

                                return null;
                            },
                        ],
                    ];
                },
            ]);
        }

        return self::$map['__Type'];
    }

    public static function _typeKind()
    {
        if (! isset(self::$map['__TypeKind'])) {
            self::$map['__TypeKind'] = new EnumType([
                'name'            => '__TypeKind',
                'isIntrospection' => true,
                'description'     => 'An enum describing what kind of type a given `__Type` is.',
                'values'          => [
                    'SCALAR'       => [
                        'value'       => TypeKind::SCALAR,
                        'description' => 'Indicates this type is a scalar.',
                    ],
                    'OBJECT'       => [
                        'value'       => TypeKind::OBJECT,
                        'description' => 'Indicates this type is an object. `fields` and `interfaces` are valid fields.',
                    ],
                    'INTERFACE'    => [
                        'value'       => TypeKind::INTERFACE,
                        'description' => 'Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields.',
                    ],
                    'UNION'        => [
                        'value'       => TypeKind::UNION,
                        'description' => 'Indicates this type is a union. `possibleTypes` is a valid field.',
                    ],
                    'ENUM'         => [
                        'value'       => TypeKind::ENUM,
                        'description' => 'Indicates this type is an enum. `enumValues` is a valid field.',
                    ],
                    'INPUT_OBJECT' => [
                        'value'       => TypeKind::INPUT_OBJECT,
                        'description' => 'Indicates this type is an input object. `inputFields` is a valid field.',
                    ],
                    'LIST'         => [
                        'value'       => TypeKind::LIST,
                        'description' => 'Indicates this type is a list. `ofType` is a valid field.',
                    ],
                    'NON_NULL'     => [
                        'value'       => TypeKind::NON_NULL,
                        'description' => 'Indicates this type is a non-null. `ofType` is a valid field.',
                    ],
                ],
            ]);
        }

        return self::$map['__TypeKind'];
    }

    public static function _field()
    {
        if (! isset(self::$map['__Field'])) {
            self::$map['__Field'] = new ObjectType([
                'name'            => '__Field',
                'isIntrospection' => true,
                'description'     =>
                    'Object and Interface types are described by a list of Fields, each of ' .
                    'which has a name, potentially a list of arguments, and a return type.',
                'fields'          => static function () : array {
                    return [
                        'name'              => [
                            'type' => Type::nonNull(Type::string()),
                            'resolve' => static function (FieldDefinition $field) : string {
                                return $field->name;
                            },
                        ],
                        'description'       => [
                            'type' => Type::string(),
                            'resolve' => static function (FieldDefinition $field) : ?string {
                                return $field->description;
                            },
                        ],
                        'args'              => [
                            'type'    => Type::nonNull(Type::listOf(Type::nonNull(self::_inputValue()))),
                            'resolve' => static function (FieldDefinition $field) : array {
                                return $field->args ?? [];
                            },
                        ],
                        'type'              => [
                            'type'    => Type::nonNull(self::_type()),
                            'resolve' => static function (FieldDefinition $field) : Type {
                                return $field->getType();
                            },
                        ],
                        'isDeprecated'      => [
                            'type'    => Type::nonNull(Type::boolean()),
                            'resolve' => static function (FieldDefinition $field) : bool {
                                return (bool) $field->deprecationReason;
                            },
                        ],
                        'deprecationReason' => [
                            'type'    => Type::string(),
                            'resolve' => static function (FieldDefinition $field) : ?string {
                                return $field->deprecationReason;
                            },
                        ],
                    ];
                },
            ]);
        }

        return self::$map['__Field'];
    }

    public static function _inputValue()
    {
        if (! isset(self::$map['__InputValue'])) {
            self::$map['__InputValue'] = new ObjectType([
                'name'            => '__InputValue',
                'isIntrospection' => true,
                'description'     =>
                    'Arguments provided to Fields or Directives and the input fields of an ' .
                    'InputObject are represented as Input Values which describe their type ' .
                    'and optionally a default value.',
                'fields'          => static function () : array {
                    return [
                        'name'         => [
                            'type' => Type::nonNull(Type::string()),
                            'resolve' => static function ($inputValue) : string {
                                /** @var FieldArgument|InputObjectField $inputValue */
                                $inputValue = $inputValue;

                                return $inputValue->name;
                            },
                        ],
                        'description'  => [
                            'type' => Type::string(),
                            'resolve' => static function ($inputValue) : ?string {
                                /** @var FieldArgument|InputObjectField $inputValue */
                                $inputValue = $inputValue;

                                return $inputValue->description;
                            },
                        ],
                        'type'         => [
                            'type'    => Type::nonNull(self::_type()),
                            'resolve' => static function ($value) {
                                return method_exists($value, 'getType')
                                    ? $value->getType()
                                    : $value->type;
                            },
                        ],
                        'defaultValue' => [
                            'type'        => Type::string(),
                            'description' =>
                                'A GraphQL-formatted string representing the default value for this input value.',
                            'resolve'     => static function ($inputValue) : ?string {
                                /** @var FieldArgument|InputObjectField $inputValue */
                                $inputValue = $inputValue;

                                return ! $inputValue->defaultValueExists()
                                    ? null
                                    : Printer::doPrint(AST::astFromValue(
                                        $inputValue->defaultValue,
                                        $inputValue->getType()
                                    ));
                            },
                        ],
                    ];
                },
            ]);
        }

        return self::$map['__InputValue'];
    }

    public static function _enumValue()
    {
        if (! isset(self::$map['__EnumValue'])) {
            self::$map['__EnumValue'] = new ObjectType([
                'name'            => '__EnumValue',
                'isIntrospection' => true,
                'description'     =>
                    'One possible value for a given Enum. Enum values are unique values, not ' .
                    'a placeholder for a string or numeric value. However an Enum value is ' .
                    'returned in a JSON response as a string.',
                'fields'          => [
                    'name'              => [
                        'type' => Type::nonNull(Type::string()),
                        'resolve' => static function ($enumValue) {
                            return $enumValue->name;
                        },
                    ],
                    'description'       => [
                        'type' => Type::string(),
                        'resolve' => static function ($enumValue) {
                            return $enumValue->description;
                        },
                    ],
                    'isDeprecated'      => [
                        'type'    => Type::nonNull(Type::boolean()),
                        'resolve' => static function ($enumValue) : bool {
                            return (bool) $enumValue->deprecationReason;
                        },
                    ],
                    'deprecationReason' => [
                        'type' => Type::string(),
                        'resolve' => static function ($enumValue) {
                            return $enumValue->deprecationReason;
                        },
                    ],
                ],
            ]);
        }

        return self::$map['__EnumValue'];
    }

    public static function _directive()
    {
        if (! isset(self::$map['__Directive'])) {
            self::$map['__Directive'] = new ObjectType([
                'name'            => '__Directive',
                'isIntrospection' => true,
                'description'     => 'A Directive provides a way to describe alternate runtime execution and ' .
                    'type validation behavior in a GraphQL document.' .
                    "\n\nIn some cases, you need to provide options to alter GraphQL's " .
                    'execution behavior in ways field arguments will not suffice, such as ' .
                    'conditionally including or skipping a field. Directives provide this by ' .
                    'describing additional information to the executor.',
                'fields'          => [
                    'name'        => [
                        'type'    => Type::nonNull(Type::string()),
                        'resolve' => static function ($obj) {
                            return $obj->name;
                        },
                    ],
                    'description' => [
                        'type' => Type::string(),
                        'resolve' => static function ($obj) {
                            return $obj->description;
                        },
                    ],
                    'args'        => [
                        'type'    => Type::nonNull(Type::listOf(Type::nonNull(self::_inputValue()))),
                        'resolve' => static function (Directive $directive) : array {
                            return $directive->args ?? [];
                        },
                    ],
                    'isRepeatable' => [
                        'type' => Type::nonNull(Type::boolean()),
                        'resolve' => static function (Directive $directive) : bool {
                            return $directive->isRepeatable;
                        },
                    ],
                    'locations'   => [
                        'type' => Type::nonNull(Type::listOf(Type::nonNull(
                            self::_directiveLocation()
                        ))),
                        'resolve' => static function ($obj) {
                            return $obj->locations;
                        },
                    ],
                ],
            ]);
        }

        return self::$map['__Directive'];
    }

    public static function _directiveLocation()
    {
        if (! isset(self::$map['__DirectiveLocation'])) {
            self::$map['__DirectiveLocation'] = new EnumType([
                'name'            => '__DirectiveLocation',
                'isIntrospection' => true,
                'description'     =>
                    'A Directive can be adjacent to many parts of the GraphQL language, a ' .
                    '__DirectiveLocation describes one such possible adjacencies.',
                'values'          => [
                    'QUERY'                  => [
                        'value'       => DirectiveLocation::QUERY,
                        'description' => 'Location adjacent to a query operation.',
                    ],
                    'MUTATION'               => [
                        'value'       => DirectiveLocation::MUTATION,
                        'description' => 'Location adjacent to a mutation operation.',
                    ],
                    'SUBSCRIPTION'           => [
                        'value'       => DirectiveLocation::SUBSCRIPTION,
                        'description' => 'Location adjacent to a subscription operation.',
                    ],
                    'FIELD'                  => [
                        'value'       => DirectiveLocation::FIELD,
                        'description' => 'Location adjacent to a field.',
                    ],
                    'FRAGMENT_DEFINITION'    => [
                        'value'       => DirectiveLocation::FRAGMENT_DEFINITION,
                        'description' => 'Location adjacent to a fragment definition.',
                    ],
                    'FRAGMENT_SPREAD'        => [
                        'value'       => DirectiveLocation::FRAGMENT_SPREAD,
                        'description' => 'Location adjacent to a fragment spread.',
                    ],
                    'INLINE_FRAGMENT'        => [
                        'value'       => DirectiveLocation::INLINE_FRAGMENT,
                        'description' => 'Location adjacent to an inline fragment.',
                    ],
                    'VARIABLE_DEFINITION'    => [
                        'value'       => DirectiveLocation::VARIABLE_DEFINITION,
                        'description' => 'Location adjacent to a variable definition.',
                    ],
                    'SCHEMA'                 => [
                        'value'       => DirectiveLocation::SCHEMA,
                        'description' => 'Location adjacent to a schema definition.',
                    ],
                    'SCALAR'                 => [
                        'value'       => DirectiveLocation::SCALAR,
                        'description' => 'Location adjacent to a scalar definition.',
                    ],
                    'OBJECT'                 => [
                        'value'       => DirectiveLocation::OBJECT,
                        'description' => 'Location adjacent to an object type definition.',
                    ],
                    'FIELD_DEFINITION'       => [
                        'value'       => DirectiveLocation::FIELD_DEFINITION,
                        'description' => 'Location adjacent to a field definition.',
                    ],
                    'ARGUMENT_DEFINITION'    => [
                        'value'       => DirectiveLocation::ARGUMENT_DEFINITION,
                        'description' => 'Location adjacent to an argument definition.',
                    ],
                    'INTERFACE'              => [
                        'value'       => DirectiveLocation::IFACE,
                        'description' => 'Location adjacent to an interface definition.',
                    ],
                    'UNION'                  => [
                        'value'       => DirectiveLocation::UNION,
                        'description' => 'Location adjacent to a union definition.',
                    ],
                    'ENUM'                   => [
                        'value'       => DirectiveLocation::ENUM,
                        'description' => 'Location adjacent to an enum definition.',
                    ],
                    'ENUM_VALUE'             => [
                        'value'       => DirectiveLocation::ENUM_VALUE,
                        'description' => 'Location adjacent to an enum value definition.',
                    ],
                    'INPUT_OBJECT'           => [
                        'value'       => DirectiveLocation::INPUT_OBJECT,
                        'description' => 'Location adjacent to an input object type definition.',
                    ],
                    'INPUT_FIELD_DEFINITION' => [
                        'value'       => DirectiveLocation::INPUT_FIELD_DEFINITION,
                        'description' => 'Location adjacent to an input object field definition.',
                    ],

                ],
            ]);
        }

        return self::$map['__DirectiveLocation'];
    }

    public static function schemaMetaFieldDef() : FieldDefinition
    {
        if (! isset(self::$map[self::SCHEMA_FIELD_NAME])) {
            self::$map[self::SCHEMA_FIELD_NAME] = FieldDefinition::create([
                'name'        => self::SCHEMA_FIELD_NAME,
                'type'        => Type::nonNull(self::_schema()),
                'description' => 'Access the current type schema of this server.',
                'args'        => [],
                'resolve'     => static function (
                    $source,
                    $args,
                    $context,
                    ResolveInfo $info
                ) : Schema {
                    return $info->schema;
                },
            ]);
        }

        return self::$map[self::SCHEMA_FIELD_NAME];
    }

    public static function typeMetaFieldDef() : FieldDefinition
    {
        if (! isset(self::$map[self::TYPE_FIELD_NAME])) {
            self::$map[self::TYPE_FIELD_NAME] = FieldDefinition::create([
                'name'        => self::TYPE_FIELD_NAME,
                'type'        => self::_type(),
                'description' => 'Request the type information of a single type.',
                'args'        => [
                    ['name' => 'name', 'type' => Type::nonNull(Type::string())],
                ],
                'resolve'     => static function ($source, $args, $context, ResolveInfo $info) : Type {
                    return $info->schema->getType($args['name']);
                },
            ]);
        }

        return self::$map[self::TYPE_FIELD_NAME];
    }

    public static function typeNameMetaFieldDef() : FieldDefinition
    {
        if (! isset(self::$map[self::TYPE_NAME_FIELD_NAME])) {
            self::$map[self::TYPE_NAME_FIELD_NAME] = FieldDefinition::create([
                'name'        => self::TYPE_NAME_FIELD_NAME,
                'type'        => Type::nonNull(Type::string()),
                'description' => 'The name of the current Object type at runtime.',
                'args'        => [],
                'resolve'     => static function (
                    $source,
                    $args,
                    $context,
                    ResolveInfo $info
                ) : string {
                    return $info->parentType->name;
                },
            ]);
        }

        return self::$map[self::TYPE_NAME_FIELD_NAME];
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Schema.php
<?php

declare(strict_types=1);

namespace GraphQL\Type;

use Generator;
use GraphQL\Error\Error;
use GraphQL\Error\InvariantViolation;
use GraphQL\GraphQL;
use GraphQL\Language\AST\SchemaDefinitionNode;
use GraphQL\Language\AST\SchemaTypeExtensionNode;
use GraphQL\Type\Definition\AbstractType;
use GraphQL\Type\Definition\Directive;
use GraphQL\Type\Definition\ImplementingType;
use GraphQL\Type\Definition\InterfaceType;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Definition\UnionType;
use GraphQL\Utils\InterfaceImplementations;
use GraphQL\Utils\TypeInfo;
use GraphQL\Utils\Utils;
use InvalidArgumentException;
use Traversable;
use function array_map;
use function get_class;
use function implode;
use function is_array;
use function is_callable;
use function sprintf;

/**
 * Schema Definition (see [related docs](type-system/schema.md))
 *
 * A Schema is created by supplying the root types of each type of operation:
 * query, mutation (optional) and subscription (optional). A schema definition is
 * then supplied to the validator and executor. Usage Example:
 *
 *     $schema = new GraphQL\Type\Schema([
 *       'query' => $MyAppQueryRootType,
 *       'mutation' => $MyAppMutationRootType,
 *     ]);
 *
 * Or using Schema Config instance:
 *
 *     $config = GraphQL\Type\SchemaConfig::create()
 *         ->setQuery($MyAppQueryRootType)
 *         ->setMutation($MyAppMutationRootType);
 *
 *     $schema = new GraphQL\Type\Schema($config);
 */
class Schema
{
    /** @var SchemaConfig */
    private $config;

    /**
     * Contains currently resolved schema types
     *
     * @var Type[]
     */
    private $resolvedTypes = [];

    /**
     * Lazily initialised.
     *
     * @var array<string, InterfaceImplementations>
     */
    private $implementationsMap;

    /**
     * True when $resolvedTypes contain all possible schema types
     *
     * @var bool
     */
    private $fullyLoaded = false;

    /** @var Error[] */
    private $validationErrors;

    /** @var SchemaTypeExtensionNode[] */
    public $extensionASTNodes = [];

    /**
     * @param mixed[]|SchemaConfig $config
     *
     * @api
     */
    public function __construct($config)
    {
        if (is_array($config)) {
            $config = SchemaConfig::create($config);
        }

        // If this schema was built from a source known to be valid, then it may be
        // marked with assumeValid to avoid an additional type system validation.
        if ($config->getAssumeValid()) {
            $this->validationErrors = [];
        } else {
            // Otherwise check for common mistakes during construction to produce
            // clear and early error messages.
            Utils::invariant(
                $config instanceof SchemaConfig,
                'Schema constructor expects instance of GraphQL\Type\SchemaConfig or an array with keys: %s; but got: %s',
                implode(
                    ', ',
                    [
                        'query',
                        'mutation',
                        'subscription',
                        'types',
                        'directives',
                        'typeLoader',
                    ]
                ),
                Utils::getVariableType($config)
            );
            Utils::invariant(
                ! $config->types || is_array($config->types) || is_callable($config->types),
                '"types" must be array or callable if provided but got: ' . Utils::getVariableType($config->types)
            );
            Utils::invariant(
                $config->directives === null || is_array($config->directives),
                '"directives" must be Array if provided but got: ' . Utils::getVariableType($config->directives)
            );
        }

        $this->config            = $config;
        $this->extensionASTNodes = $config->extensionASTNodes;

        if ($config->query !== null) {
            $this->resolvedTypes[$config->query->name] = $config->query;
        }
        if ($config->mutation !== null) {
            $this->resolvedTypes[$config->mutation->name] = $config->mutation;
        }
        if ($config->subscription !== null) {
            $this->resolvedTypes[$config->subscription->name] = $config->subscription;
        }
        if (is_array($this->config->types)) {
            foreach ($this->resolveAdditionalTypes() as $type) {
                if (isset($this->resolvedTypes[$type->name])) {
                    Utils::invariant(
                        $type === $this->resolvedTypes[$type->name],
                        sprintf(
                            'Schema must contain unique named types but contains multiple types named "%s" (see http://webonyx.github.io/graphql-php/type-system/#type-registry).',
                            $type
                        )
                    );
                }
                $this->resolvedTypes[$type->name] = $type;
            }
        }
        $this->resolvedTypes += Type::getStandardTypes() + Introspection::getTypes();

        if ($this->config->typeLoader) {
            return;
        }

        // Perform full scan of the schema
        $this->getTypeMap();
    }

    /**
     * @return Generator
     */
    private function resolveAdditionalTypes()
    {
        $types = $this->config->types ?? [];

        if (is_callable($types)) {
            $types = $types();
        }

        if (! is_array($types) && ! $types instanceof Traversable) {
            throw new InvariantViolation(sprintf(
                'Schema types callable must return array or instance of Traversable but got: %s',
                Utils::getVariableType($types)
            ));
        }

        foreach ($types as $index => $type) {
            $type = self::resolveType($type);
            if (! $type instanceof Type) {
                throw new InvariantViolation(sprintf(
                    'Each entry of schema types must be instance of GraphQL\Type\Definition\Type but entry at %s is %s',
                    $index,
                    Utils::printSafe($type)
                ));
            }
            yield $type;
        }
    }

    /**
     * Returns array of all types in this schema. Keys of this array represent type names, values are instances
     * of corresponding type definitions
     *
     * This operation requires full schema scan. Do not use in production environment.
     *
     * @return array<string, Type>
     *
     * @api
     */
    public function getTypeMap() : array
    {
        if (! $this->fullyLoaded) {
            $this->resolvedTypes = $this->collectAllTypes();
            $this->fullyLoaded   = true;
        }

        return $this->resolvedTypes;
    }

    /**
     * @return Type[]
     */
    private function collectAllTypes()
    {
        $typeMap = [];
        foreach ($this->resolvedTypes as $type) {
            $typeMap = TypeInfo::extractTypes($type, $typeMap);
        }
        foreach ($this->getDirectives() as $directive) {
            if (! ($directive instanceof Directive)) {
                continue;
            }

            $typeMap = TypeInfo::extractTypesFromDirectives($directive, $typeMap);
        }
        // When types are set as array they are resolved in constructor
        if (is_callable($this->config->types)) {
            foreach ($this->resolveAdditionalTypes() as $type) {
                $typeMap = TypeInfo::extractTypes($type, $typeMap);
            }
        }

        return $typeMap;
    }

    /**
     * Returns a list of directives supported by this schema
     *
     * @return Directive[]
     *
     * @api
     */
    public function getDirectives()
    {
        return $this->config->directives ?? GraphQL::getStandardDirectives();
    }

    /**
     * @param string $operation
     *
     * @return ObjectType|null
     */
    public function getOperationType($operation)
    {
        switch ($operation) {
            case 'query':
                return $this->getQueryType();
            case 'mutation':
                return $this->getMutationType();
            case 'subscription':
                return $this->getSubscriptionType();
            default:
                return null;
        }
    }

    /**
     * Returns schema query type
     *
     * @return ObjectType
     *
     * @api
     */
    public function getQueryType() : ?Type
    {
        return $this->config->query;
    }

    /**
     * Returns schema mutation type
     *
     * @return ObjectType|null
     *
     * @api
     */
    public function getMutationType() : ?Type
    {
        return $this->config->mutation;
    }

    /**
     * Returns schema subscription
     *
     * @return ObjectType|null
     *
     * @api
     */
    public function getSubscriptionType() : ?Type
    {
        return $this->config->subscription;
    }

    /**
     * @return SchemaConfig
     *
     * @api
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Returns type by its name
     *
     * @api
     */
    public function getType(string $name) : ?Type
    {
        if (! isset($this->resolvedTypes[$name])) {
            $type = $this->loadType($name);

            if (! $type) {
                return null;
            }
            $this->resolvedTypes[$name] = self::resolveType($type);
        }

        return $this->resolvedTypes[$name];
    }

    public function hasType(string $name) : bool
    {
        return $this->getType($name) !== null;
    }

    private function loadType(string $typeName) : ?Type
    {
        $typeLoader = $this->config->typeLoader;

        if (! isset($typeLoader)) {
            return $this->defaultTypeLoader($typeName);
        }

        $type = $typeLoader($typeName);

        if (! $type instanceof Type) {
            // Unless you know what you're doing, kindly resist the temptation to refactor or simplify this block. The
            // twisty logic here is tuned for performance, and meant to prioritize the "happy path" (the result returned
            // from the type loader is already a Type), and only checks for callable if that fails. If the result is
            // neither a Type nor a callable, then we throw an exception.

            if (is_callable($type)) {
                $type = $type();

                if (! $type instanceof Type) {
                    $this->throwNotAType($type, $typeName);
                }
            } else {
                $this->throwNotAType($type, $typeName);
            }
        }

        if ($type->name !== $typeName) {
            throw new InvariantViolation(
                sprintf('Type loader is expected to return type "%s", but it returned "%s"', $typeName, $type->name)
            );
        }

        return $type;
    }

    protected function throwNotAType($type, string $typeName)
    {
        throw new InvariantViolation(
            sprintf(
                'Type loader is expected to return a callable or valid type "%s", but it returned %s',
                $typeName,
                Utils::printSafe($type)
            )
        );
    }

    private function defaultTypeLoader(string $typeName) : ?Type
    {
        // Default type loader simply falls back to collecting all types
        $typeMap = $this->getTypeMap();

        return $typeMap[$typeName] ?? null;
    }

    /**
     * @param Type|callable():Type $type
     */
    public static function resolveType($type) : Type
    {
        if ($type instanceof Type) {
            return $type;
        }

        return $type();
    }

    /**
     * Returns all possible concrete types for given abstract type
     * (implementations for interfaces and members of union type for unions)
     *
     * This operation requires full schema scan. Do not use in production environment.
     *
     * @param InterfaceType|UnionType $abstractType
     *
     * @return array<Type&ObjectType>
     *
     * @api
     */
    public function getPossibleTypes(Type $abstractType) : array
    {
        return $abstractType instanceof UnionType
            ? $abstractType->getTypes()
            : $this->getImplementations($abstractType)->objects();
    }

    /**
     * Returns all types that implement a given interface type.
     *
     * This operations requires full schema scan. Do not use in production environment.
     *
     * @api
     */
    public function getImplementations(InterfaceType $abstractType) : InterfaceImplementations
    {
        return $this->collectImplementations()[$abstractType->name];
    }

    /**
     * @return array<string, InterfaceImplementations>
     */
    private function collectImplementations() : array
    {
        if (! isset($this->implementationsMap)) {
            /** @var array<string, array<string, Type>> $foundImplementations */
            $foundImplementations = [];
            foreach ($this->getTypeMap() as $type) {
                if ($type instanceof InterfaceType) {
                    if (! isset($foundImplementations[$type->name])) {
                        $foundImplementations[$type->name] = ['objects' => [], 'interfaces' => []];
                    }

                    foreach ($type->getInterfaces() as $iface) {
                        if (! isset($foundImplementations[$iface->name])) {
                            $foundImplementations[$iface->name] = ['objects' => [], 'interfaces' => []];
                        }
                        $foundImplementations[$iface->name]['interfaces'][] = $type;
                    }
                } elseif ($type instanceof ObjectType) {
                    foreach ($type->getInterfaces() as $iface) {
                        if (! isset($foundImplementations[$iface->name])) {
                            $foundImplementations[$iface->name] = ['objects' => [], 'interfaces' => []];
                        }
                        $foundImplementations[$iface->name]['objects'][] = $type;
                    }
                }
            }
            $this->implementationsMap = array_map(
                static function (array $implementations) : InterfaceImplementations {
                    return new InterfaceImplementations($implementations['objects'], $implementations['interfaces']);
                },
                $foundImplementations
            );
        }

        return $this->implementationsMap;
    }

    /**
     * @deprecated as of 14.4.0 use isSubType instead, will be removed in 15.0.0.
     *
     * Returns true if object type is concrete type of given abstract type
     * (implementation for interfaces and members of union type for unions)
     *
     * @api
     * @codeCoverageIgnore
     */
    public function isPossibleType(AbstractType $abstractType, ObjectType $possibleType) : bool
    {
        return $this->isSubType($abstractType, $possibleType);
    }

    /**
     * Returns true if the given type is a sub type of the given abstract type.
     *
     * @param UnionType|InterfaceType  $abstractType
     * @param ObjectType|InterfaceType $maybeSubType
     *
     * @api
     */
    public function isSubType(AbstractType $abstractType, ImplementingType $maybeSubType) : bool
    {
        if ($abstractType instanceof InterfaceType) {
            return $maybeSubType->implementsInterface($abstractType);
        }

        if ($abstractType instanceof UnionType) {
            return $abstractType->isPossibleType($maybeSubType);
        }

        throw new InvalidArgumentException(sprintf('$abstractType must be of type UnionType|InterfaceType got: %s.', get_class($abstractType)));
    }

    /**
     * Returns instance of directive by name
     *
     * @api
     */
    public function getDirective(string $name) : ?Directive
    {
        foreach ($this->getDirectives() as $directive) {
            if ($directive->name === $name) {
                return $directive;
            }
        }

        return null;
    }

    public function getAstNode() : ?SchemaDefinitionNode
    {
        return $this->config->getAstNode();
    }

    /**
     * Validates schema.
     *
     * This operation requires full schema scan. Do not use in production environment.
     *
     * @throws InvariantViolation
     *
     * @api
     */
    public function assertValid()
    {
        $errors = $this->validate();

        if ($errors) {
            throw new InvariantViolation(implode("\n\n", $this->validationErrors));
        }

        $internalTypes = Type::getStandardTypes() + Introspection::getTypes();
        foreach ($this->getTypeMap() as $name => $type) {
            if (isset($internalTypes[$name])) {
                continue;
            }

            $type->assertValid();

            // Make sure type loader returns the same instance as registered in other places of schema
            if (! $this->config->typeLoader) {
                continue;
            }

            Utils::invariant(
                $this->loadType($name) === $type,
                sprintf(
                    'Type loader returns different instance for %s than field/argument definitions. Make sure you always return the same instance for the same type name.',
                    $name
                )
            );
        }
    }

    /**
     * Validates schema.
     *
     * This operation requires full schema scan. Do not use in production environment.
     *
     * @return InvariantViolation[]|Error[]
     *
     * @api
     */
    public function validate()
    {
        // If this Schema has already been validated, return the previous results.
        if ($this->validationErrors !== null) {
            return $this->validationErrors;
        }
        // Validate the schema, producing a list of errors.
        $context = new SchemaValidationContext($this);
        $context->validateRootTypes();
        $context->validateDirectives();
        $context->validateTypes();

        // Persist the results of validation before returning to ensure validation
        // does not run multiple times for this schema.
        $this->validationErrors = $context->getErrors();

        return $this->validationErrors;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\SchemaConfig.php
<?php

declare(strict_types=1);

namespace GraphQL\Type;

use GraphQL\Language\AST\SchemaDefinitionNode;
use GraphQL\Language\AST\SchemaTypeExtensionNode;
use GraphQL\Type\Definition\Directive;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\Type;
use GraphQL\Utils\Utils;
use function count;
use function is_callable;

/**
 * Schema configuration class.
 * Could be passed directly to schema constructor. List of options accepted by **create** method is
 * [described in docs](type-system/schema.md#configuration-options).
 *
 * Usage example:
 *
 *     $config = SchemaConfig::create()
 *         ->setQuery($myQueryType)
 *         ->setTypeLoader($myTypeLoader);
 *
 *     $schema = new Schema($config);
 */
class SchemaConfig
{
    /** @var ObjectType|null */
    public $query;

    /** @var ObjectType|null */
    public $mutation;

    /** @var ObjectType|null */
    public $subscription;

    /** @var Type[]|callable */
    public $types = [];

    /** @var Directive[]|null */
    public $directives;

    /** @var callable|null */
    public $typeLoader;

    /** @var SchemaDefinitionNode|null */
    public $astNode;

    /** @var bool */
    public $assumeValid = false;

    /** @var SchemaTypeExtensionNode[] */
    public $extensionASTNodes = [];

    /**
     * Converts an array of options to instance of SchemaConfig
     * (or just returns empty config when array is not passed).
     *
     * @param mixed[] $options
     *
     * @return SchemaConfig
     *
     * @api
     */
    public static function create(array $options = [])
    {
        $config = new static();

        if (count($options) > 0) {
            if (isset($options['query'])) {
                $config->setQuery($options['query']);
            }

            if (isset($options['mutation'])) {
                $config->setMutation($options['mutation']);
            }

            if (isset($options['subscription'])) {
                $config->setSubscription($options['subscription']);
            }

            if (isset($options['types'])) {
                $config->setTypes($options['types']);
            }

            if (isset($options['directives'])) {
                $config->setDirectives($options['directives']);
            }

            if (isset($options['typeLoader'])) {
                Utils::invariant(
                    is_callable($options['typeLoader']),
                    'Schema type loader must be callable if provided but got: %s',
                    Utils::printSafe($options['typeLoader'])
                );
                $config->setTypeLoader($options['typeLoader']);
            }

            if (isset($options['astNode'])) {
                $config->setAstNode($options['astNode']);
            }

            if (isset($options['assumeValid'])) {
                $config->setAssumeValid((bool) $options['assumeValid']);
            }

            if (isset($options['extensionASTNodes'])) {
                $config->setExtensionASTNodes($options['extensionASTNodes']);
            }
        }

        return $config;
    }

    /**
     * @return SchemaDefinitionNode|null
     */
    public function getAstNode()
    {
        return $this->astNode;
    }

    /**
     * @return SchemaConfig
     */
    public function setAstNode(SchemaDefinitionNode $astNode)
    {
        $this->astNode = $astNode;

        return $this;
    }

    /**
     * @return ObjectType|null
     *
     * @api
     */
    public function getQuery()
    {
        return $this->query;
    }

    /**
     * @param ObjectType|null $query
     *
     * @return SchemaConfig
     *
     * @api
     */
    public function setQuery($query)
    {
        $this->query = $query;

        return $this;
    }

    /**
     * @return ObjectType|null
     *
     * @api
     */
    public function getMutation()
    {
        return $this->mutation;
    }

    /**
     * @param ObjectType|null $mutation
     *
     * @return SchemaConfig
     *
     * @api
     */
    public function setMutation($mutation)
    {
        $this->mutation = $mutation;

        return $this;
    }

    /**
     * @return ObjectType|null
     *
     * @api
     */
    public function getSubscription()
    {
        return $this->subscription;
    }

    /**
     * @param ObjectType|null $subscription
     *
     * @return SchemaConfig
     *
     * @api
     */
    public function setSubscription($subscription)
    {
        $this->subscription = $subscription;

        return $this;
    }

    /**
     * @return Type[]|callable
     *
     * @api
     */
    public function getTypes()
    {
        return $this->types;
    }

    /**
     * @param Type[]|callable $types
     *
     * @return SchemaConfig
     *
     * @api
     */
    public function setTypes($types)
    {
        $this->types = $types;

        return $this;
    }

    /**
     * @return Directive[]|null
     *
     * @api
     */
    public function getDirectives()
    {
        return $this->directives;
    }

    /**
     * @param Directive[] $directives
     *
     * @return SchemaConfig
     *
     * @api
     */
    public function setDirectives(array $directives)
    {
        $this->directives = $directives;

        return $this;
    }

    /**
     * @return callable|null
     *
     * @api
     */
    public function getTypeLoader()
    {
        return $this->typeLoader;
    }

    /**
     * @return SchemaConfig
     *
     * @api
     */
    public function setTypeLoader(callable $typeLoader)
    {
        $this->typeLoader = $typeLoader;

        return $this;
    }

    /**
     * @return bool
     */
    public function getAssumeValid()
    {
        return $this->assumeValid;
    }

    /**
     * @param bool $assumeValid
     *
     * @return SchemaConfig
     */
    public function setAssumeValid($assumeValid)
    {
        $this->assumeValid = $assumeValid;

        return $this;
    }

    /**
     * @return SchemaTypeExtensionNode[]
     */
    public function getExtensionASTNodes()
    {
        return $this->extensionASTNodes;
    }

    /**
     * @param SchemaTypeExtensionNode[] $extensionASTNodes
     */
    public function setExtensionASTNodes(array $extensionASTNodes)
    {
        $this->extensionASTNodes = $extensionASTNodes;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\SchemaValidationContext.php
<?php

declare(strict_types=1);

namespace GraphQL\Type;

use GraphQL\Error\Error;
use GraphQL\Language\AST\DirectiveDefinitionNode;
use GraphQL\Language\AST\DirectiveNode;
use GraphQL\Language\AST\EnumValueDefinitionNode;
use GraphQL\Language\AST\FieldDefinitionNode;
use GraphQL\Language\AST\InputValueDefinitionNode;
use GraphQL\Language\AST\InterfaceTypeDefinitionNode;
use GraphQL\Language\AST\InterfaceTypeExtensionNode;
use GraphQL\Language\AST\ListTypeNode;
use GraphQL\Language\AST\NamedTypeNode;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\NodeList;
use GraphQL\Language\AST\NonNullTypeNode;
use GraphQL\Language\AST\ObjectTypeDefinitionNode;
use GraphQL\Language\AST\ObjectTypeExtensionNode;
use GraphQL\Language\AST\SchemaDefinitionNode;
use GraphQL\Language\AST\TypeDefinitionNode;
use GraphQL\Language\AST\TypeNode;
use GraphQL\Language\DirectiveLocation;
use GraphQL\Type\Definition\Directive;
use GraphQL\Type\Definition\EnumType;
use GraphQL\Type\Definition\EnumValueDefinition;
use GraphQL\Type\Definition\FieldDefinition;
use GraphQL\Type\Definition\ImplementingType;
use GraphQL\Type\Definition\InputObjectField;
use GraphQL\Type\Definition\InputObjectType;
use GraphQL\Type\Definition\InterfaceType;
use GraphQL\Type\Definition\NamedType;
use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\ScalarType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Definition\UnionType;
use GraphQL\Type\Validation\InputObjectCircularRefs;
use GraphQL\Utils\TypeComparators;
use GraphQL\Utils\Utils;
use function array_filter;
use function array_key_exists;
use function array_merge;
use function count;
use function in_array;
use function is_array;
use function is_object;
use function sprintf;

class SchemaValidationContext
{
    /** @var Error[] */
    private $errors = [];

    /** @var Schema */
    private $schema;

    /** @var InputObjectCircularRefs */
    private $inputObjectCircularRefs;

    public function __construct(Schema $schema)
    {
        $this->schema                  = $schema;
        $this->inputObjectCircularRefs = new InputObjectCircularRefs($this);
    }

    /**
     * @return Error[]
     */
    public function getErrors()
    {
        return $this->errors;
    }

    public function validateRootTypes() : void
    {
        $queryType = $this->schema->getQueryType();
        if (! $queryType) {
            $this->reportError(
                'Query root type must be provided.',
                $this->schema->getAstNode()
            );
        } elseif (! $queryType instanceof ObjectType) {
            $this->reportError(
                'Query root type must be Object type, it cannot be ' . Utils::printSafe($queryType) . '.',
                $this->getOperationTypeNode($queryType, 'query')
            );
        }

        $mutationType = $this->schema->getMutationType();
        if ($mutationType && ! $mutationType instanceof ObjectType) {
            $this->reportError(
                'Mutation root type must be Object type if provided, it cannot be ' . Utils::printSafe($mutationType) . '.',
                $this->getOperationTypeNode($mutationType, 'mutation')
            );
        }

        $subscriptionType = $this->schema->getSubscriptionType();
        if ($subscriptionType === null || $subscriptionType instanceof ObjectType) {
            return;
        }

        $this->reportError(
            'Subscription root type must be Object type if provided, it cannot be ' . Utils::printSafe($subscriptionType) . '.',
            $this->getOperationTypeNode($subscriptionType, 'subscription')
        );
    }

    /**
     * @param string                                       $message
     * @param Node[]|Node|TypeNode|TypeDefinitionNode|null $nodes
     */
    public function reportError($message, $nodes = null)
    {
        $nodes = array_filter($nodes && is_array($nodes) ? $nodes : [$nodes]);
        $this->addError(new Error($message, $nodes));
    }

    /**
     * @param Error $error
     */
    private function addError($error)
    {
        $this->errors[] = $error;
    }

    /**
     * @param Type   $type
     * @param string $operation
     *
     * @return NamedTypeNode|ListTypeNode|NonNullTypeNode|TypeDefinitionNode
     */
    private function getOperationTypeNode($type, $operation)
    {
        $astNode = $this->schema->getAstNode();

        $operationTypeNode = null;
        if ($astNode instanceof SchemaDefinitionNode) {
            $operationTypeNode = null;

            foreach ($astNode->operationTypes as $operationType) {
                if ($operationType->operation === $operation) {
                    $operationTypeNode = $operationType;
                    break;
                }
            }
        }

        return $operationTypeNode ? $operationTypeNode->type : ($type ? $type->astNode : null);
    }

    public function validateDirectives()
    {
        $this->validateDirectiveDefinitions();

        // Validate directives that are used on the schema
        $this->validateDirectivesAtLocation(
            $this->getDirectives($this->schema),
            DirectiveLocation::SCHEMA
        );
    }

    public function validateDirectiveDefinitions()
    {
        $directiveDefinitions = [];

        $directives = $this->schema->getDirectives();
        foreach ($directives as $directive) {
            // Ensure all directives are in fact GraphQL directives.
            if (! $directive instanceof Directive) {
                $nodes = is_object($directive)
                    ? $directive->astNode
                    : null;

                $this->reportError(
                    'Expected directive but got: ' . Utils::printSafe($directive) . '.',
                    $nodes
                );
                continue;
            }
            $existingDefinitions                    = $directiveDefinitions[$directive->name] ?? [];
            $existingDefinitions[]                  = $directive;
            $directiveDefinitions[$directive->name] = $existingDefinitions;

            // Ensure they are named correctly.
            $this->validateName($directive);

            // TODO: Ensure proper locations.

            $argNames = [];
            foreach ($directive->args as $arg) {
                $argName = $arg->name;

                // Ensure they are named correctly.
                $this->validateName($directive);

                if (isset($argNames[$argName])) {
                    $this->reportError(
                        sprintf('Argument @%s(%s:) can only be defined once.', $directive->name, $argName),
                        $this->getAllDirectiveArgNodes($directive, $argName)
                    );
                    continue;
                }

                $argNames[$argName] = true;

                // Ensure the type is an input type.
                if (Type::isInputType($arg->getType())) {
                    continue;
                }

                $this->reportError(
                    sprintf(
                        'The type of @%s(%s:) must be Input Type but got: %s.',
                        $directive->name,
                        $argName,
                        Utils::printSafe($arg->getType())
                    ),
                    $this->getDirectiveArgTypeNode($directive, $argName)
                );
            }
        }
        foreach ($directiveDefinitions as $directiveName => $directiveList) {
            if (count($directiveList) <= 1) {
                continue;
            }

            $nodes = Utils::map(
                $directiveList,
                static function (Directive $directive) : ?DirectiveDefinitionNode {
                    return $directive->astNode;
                }
            );
            $this->reportError(
                sprintf('Directive @%s defined multiple times.', $directiveName),
                array_filter($nodes)
            );
        }
    }

    /**
     * @param Type|Directive|FieldDefinition|EnumValueDefinition|InputObjectField $node
     */
    private function validateName($node)
    {
        // Ensure names are valid, however introspection types opt out.
        $error = Utils::isValidNameError($node->name, $node->astNode);
        if (! $error || Introspection::isIntrospectionType($node)) {
            return;
        }

        $this->addError($error);
    }

    /**
     * @param string $argName
     *
     * @return InputValueDefinitionNode[]
     */
    private function getAllDirectiveArgNodes(Directive $directive, $argName)
    {
        $subNodes = $this->getAllSubNodes(
            $directive,
            static function ($directiveNode) {
                return $directiveNode->arguments;
            }
        );

        return Utils::filter(
            $subNodes,
            static function ($argNode) use ($argName) : bool {
                return $argNode->name->value === $argName;
            }
        );
    }

    /**
     * @param string $argName
     *
     * @return NamedTypeNode|ListTypeNode|NonNullTypeNode|null
     */
    private function getDirectiveArgTypeNode(Directive $directive, $argName) : ?TypeNode
    {
        $argNode = $this->getAllDirectiveArgNodes($directive, $argName)[0];

        return $argNode ? $argNode->type : null;
    }

    public function validateTypes() : void
    {
        $typeMap = $this->schema->getTypeMap();
        foreach ($typeMap as $typeName => $type) {
            // Ensure all provided types are in fact GraphQL type.
            if (! $type instanceof NamedType) {
                $this->reportError(
                    'Expected GraphQL named type but got: ' . Utils::printSafe($type) . '.',
                    $type instanceof Type ? $type->astNode : null
                );
                continue;
            }

            $this->validateName($type);

            if ($type instanceof ObjectType) {
                // Ensure fields are valid
                $this->validateFields($type);

                // Ensure objects implement the interfaces they claim to.
                $this->validateInterfaces($type);

                // Ensure directives are valid
                $this->validateDirectivesAtLocation(
                    $this->getDirectives($type),
                    DirectiveLocation::OBJECT
                );
            } elseif ($type instanceof InterfaceType) {
                // Ensure fields are valid.
                $this->validateFields($type);

                // Ensure interfaces implement the interfaces they claim to.
                $this->validateInterfaces($type);

                // Ensure directives are valid
                $this->validateDirectivesAtLocation(
                    $this->getDirectives($type),
                    DirectiveLocation::IFACE
                );
            } elseif ($type instanceof UnionType) {
                // Ensure Unions include valid member types.
                $this->validateUnionMembers($type);

                // Ensure directives are valid
                $this->validateDirectivesAtLocation(
                    $this->getDirectives($type),
                    DirectiveLocation::UNION
                );
            } elseif ($type instanceof EnumType) {
                // Ensure Enums have valid values.
                $this->validateEnumValues($type);

                // Ensure directives are valid
                $this->validateDirectivesAtLocation(
                    $this->getDirectives($type),
                    DirectiveLocation::ENUM
                );
            } elseif ($type instanceof InputObjectType) {
                // Ensure Input Object fields are valid.
                $this->validateInputFields($type);

                // Ensure directives are valid
                $this->validateDirectivesAtLocation(
                    $this->getDirectives($type),
                    DirectiveLocation::INPUT_OBJECT
                );

                // Ensure Input Objects do not contain non-nullable circular references
                $this->inputObjectCircularRefs->validate($type);
            } elseif ($type instanceof ScalarType) {
                // Ensure directives are valid
                $this->validateDirectivesAtLocation(
                    $this->getDirectives($type),
                    DirectiveLocation::SCALAR
                );
            }
        }
    }

    /**
     * @param NodeList<DirectiveNode> $directives
     */
    private function validateDirectivesAtLocation($directives, string $location)
    {
        /** @var array<string, array<int, DirectiveNode>> $potentiallyDuplicateDirectives */
        $potentiallyDuplicateDirectives = [];
        $schema                         = $this->schema;
        foreach ($directives as $directive) {
            $directiveName = $directive->name->value;

            // Ensure directive used is also defined
            $schemaDirective = $schema->getDirective($directiveName);
            if ($schemaDirective === null) {
                $this->reportError(
                    sprintf('No directive @%s defined.', $directiveName),
                    $directive
                );
                continue;
            }

            $includes = Utils::some(
                $schemaDirective->locations,
                static function ($schemaLocation) use ($location) : bool {
                    return $schemaLocation === $location;
                }
            );
            if (! $includes) {
                $errorNodes = $schemaDirective->astNode
                    ? [$directive, $schemaDirective->astNode]
                    : [$directive];
                $this->reportError(
                    sprintf('Directive @%s not allowed at %s location.', $directiveName, $location),
                    $errorNodes
                );
            }

            if ($schemaDirective->isRepeatable) {
                continue;
            }

            $existingNodes                                  = $potentiallyDuplicateDirectives[$directiveName] ?? [];
            $existingNodes[]                                = $directive;
            $potentiallyDuplicateDirectives[$directiveName] = $existingNodes;
        }

        foreach ($potentiallyDuplicateDirectives as $directiveName => $directiveList) {
            if (count($directiveList) <= 1) {
                continue;
            }

            $this->reportError(
                sprintf('Non-repeatable directive @%s used more than once at the same location.', $directiveName),
                $directiveList
            );
        }
    }

    /**
     * @param ObjectType|InterfaceType $type
     */
    private function validateFields($type)
    {
        $fieldMap = $type->getFields();

        // Objects and Interfaces both must define one or more fields.
        if ($fieldMap === []) {
            $this->reportError(
                sprintf('Type %s must define one or more fields.', $type->name),
                $this->getAllNodes($type)
            );
        }

        foreach ($fieldMap as $fieldName => $field) {
            // Ensure they are named correctly.
            $this->validateName($field);

            // Ensure they were defined at most once.
            $fieldNodes = $this->getAllFieldNodes($type, $fieldName);
            if ($fieldNodes && count($fieldNodes) > 1) {
                $this->reportError(
                    sprintf('Field %s.%s can only be defined once.', $type->name, $fieldName),
                    $fieldNodes
                );
                continue;
            }

            // Ensure the type is an output type
            if (! Type::isOutputType($field->getType())) {
                $this->reportError(
                    sprintf(
                        'The type of %s.%s must be Output Type but got: %s.',
                        $type->name,
                        $fieldName,
                        Utils::printSafe($field->getType())
                    ),
                    $this->getFieldTypeNode($type, $fieldName)
                );
            }

            // Ensure the arguments are valid
            $argNames = [];
            foreach ($field->args as $arg) {
                $argName = $arg->name;

                // Ensure they are named correctly.
                $this->validateName($arg);

                if (isset($argNames[$argName])) {
                    $this->reportError(
                        sprintf(
                            'Field argument %s.%s(%s:) can only be defined once.',
                            $type->name,
                            $fieldName,
                            $argName
                        ),
                        $this->getAllFieldArgNodes($type, $fieldName, $argName)
                    );
                }
                $argNames[$argName] = true;

                // Ensure the type is an input type
                if (! Type::isInputType($arg->getType())) {
                    $this->reportError(
                        sprintf(
                            'The type of %s.%s(%s:) must be Input Type but got: %s.',
                            $type->name,
                            $fieldName,
                            $argName,
                            Utils::printSafe($arg->getType())
                        ),
                        $this->getFieldArgTypeNode($type, $fieldName, $argName)
                    );
                }

                // Ensure argument definition directives are valid
                if (! isset($arg->astNode, $arg->astNode->directives)) {
                    continue;
                }

                $this->validateDirectivesAtLocation(
                    $arg->astNode->directives,
                    DirectiveLocation::ARGUMENT_DEFINITION
                );
            }

            // Ensure any directives are valid
            if (! isset($field->astNode, $field->astNode->directives)) {
                continue;
            }

            $this->validateDirectivesAtLocation(
                $field->astNode->directives,
                DirectiveLocation::FIELD_DEFINITION
            );
        }
    }

    /**
     * @param Schema|ObjectType|InterfaceType|UnionType|EnumType|InputObjectType|Directive $obj
     *
     * @return ObjectTypeDefinitionNode[]|ObjectTypeExtensionNode[]|InterfaceTypeDefinitionNode[]|InterfaceTypeExtensionNode[]
     */
    private function getAllNodes($obj)
    {
        if ($obj instanceof Schema) {
            $astNode        = $obj->getAstNode();
            $extensionNodes = $obj->extensionASTNodes;
        } else {
            $astNode        = $obj->astNode;
            $extensionNodes = $obj->extensionASTNodes;
        }

        return $astNode
            ? ($extensionNodes
                ? array_merge([$astNode], $extensionNodes)
                : [$astNode])
            : ($extensionNodes ?? []);
    }

    /**
     * @param Schema|ObjectType|InterfaceType|UnionType|EnumType|Directive $obj
     */
    private function getAllSubNodes($obj, callable $getter) : NodeList
    {
        $result = new NodeList([]);
        foreach ($this->getAllNodes($obj) as $astNode) {
            if (! $astNode) {
                continue;
            }

            $subNodes = $getter($astNode);
            if (! $subNodes) {
                continue;
            }

            $result = $result->merge($subNodes);
        }

        return $result;
    }

    /**
     * @param ObjectType|InterfaceType $type
     * @param string                   $fieldName
     *
     * @return FieldDefinitionNode[]
     */
    private function getAllFieldNodes($type, $fieldName)
    {
        $subNodes = $this->getAllSubNodes($type, static function ($typeNode) {
            return $typeNode->fields;
        });

        return Utils::filter($subNodes, static function ($fieldNode) use ($fieldName) : bool {
            return $fieldNode->name->value === $fieldName;
        });
    }

    /**
     * @param ObjectType|InterfaceType $type
     * @param string                   $fieldName
     *
     * @return NamedTypeNode|ListTypeNode|NonNullTypeNode|null
     */
    private function getFieldTypeNode($type, $fieldName) : ?TypeNode
    {
        $fieldNode = $this->getFieldNode($type, $fieldName);

        return $fieldNode ? $fieldNode->type : null;
    }

    /**
     * @param ObjectType|InterfaceType $type
     * @param string                   $fieldName
     *
     * @return FieldDefinitionNode|null
     */
    private function getFieldNode($type, $fieldName)
    {
        $nodes = $this->getAllFieldNodes($type, $fieldName);

        return $nodes[0] ?? null;
    }

    /**
     * @param ObjectType|InterfaceType $type
     * @param string                   $fieldName
     * @param string                   $argName
     *
     * @return InputValueDefinitionNode[]
     */
    private function getAllFieldArgNodes($type, $fieldName, $argName)
    {
        $argNodes  = [];
        $fieldNode = $this->getFieldNode($type, $fieldName);
        if ($fieldNode && $fieldNode->arguments) {
            foreach ($fieldNode->arguments as $node) {
                if ($node->name->value !== $argName) {
                    continue;
                }

                $argNodes[] = $node;
            }
        }

        return $argNodes;
    }

    /**
     * @param ObjectType|InterfaceType $type
     * @param string                   $fieldName
     * @param string                   $argName
     *
     * @return NamedTypeNode|ListTypeNode|NonNullTypeNode|null
     */
    private function getFieldArgTypeNode($type, $fieldName, $argName) : ?TypeNode
    {
        $fieldArgNode = $this->getFieldArgNode($type, $fieldName, $argName);

        return $fieldArgNode ? $fieldArgNode->type : null;
    }

    /**
     * @param ObjectType|InterfaceType $type
     * @param string                   $fieldName
     * @param string                   $argName
     *
     * @return InputValueDefinitionNode|null
     */
    private function getFieldArgNode($type, $fieldName, $argName)
    {
        $nodes = $this->getAllFieldArgNodes($type, $fieldName, $argName);

        return $nodes[0] ?? null;
    }

    /**
     * @param ObjectType|InterfaceType $type
     */
    private function validateInterfaces(ImplementingType $type) : void
    {
        $ifaceTypeNames = [];
        foreach ($type->getInterfaces() as $iface) {
            if (! $iface instanceof InterfaceType) {
                $this->reportError(
                    sprintf(
                        'Type %s must only implement Interface types, it cannot implement %s.',
                        $type->name,
                        Utils::printSafe($iface)
                    ),
                    $this->getImplementsInterfaceNode($type, $iface)
                );
                continue;
            }

            if ($type === $iface) {
                $this->reportError(
                    sprintf(
                        'Type %s cannot implement itself because it would create a circular reference.',
                        $type->name
                    ),
                    $this->getImplementsInterfaceNode($type, $iface)
                );
                continue;
            }

            if (isset($ifaceTypeNames[$iface->name])) {
                $this->reportError(
                    sprintf('Type %s can only implement %s once.', $type->name, $iface->name),
                    $this->getAllImplementsInterfaceNodes($type, $iface)
                );
                continue;
            }
            $ifaceTypeNames[$iface->name] = true;

            $this->validateTypeImplementsAncestors($type, $iface);
            $this->validateTypeImplementsInterface($type, $iface);
        }
    }

    /**
     * @param Schema|Type $object
     *
     * @return NodeList<DirectiveNode>
     */
    private function getDirectives($object)
    {
        return $this->getAllSubNodes($object, static function ($node) {
            return $node->directives;
        });
    }

    /**
     * @param ObjectType|InterfaceType $type
     */
    private function getImplementsInterfaceNode(ImplementingType $type, Type $shouldBeInterface) : ?NamedTypeNode
    {
        $nodes = $this->getAllImplementsInterfaceNodes($type, $shouldBeInterface);

        return $nodes[0] ?? null;
    }

    /**
     * @param ObjectType|InterfaceType $type
     *
     * @return array<int, NamedTypeNode>
     */
    private function getAllImplementsInterfaceNodes(ImplementingType $type, Type $shouldBeInterface) : array
    {
        $subNodes = $this->getAllSubNodes($type, static function (Node $typeNode) : NodeList {
            /** @var ObjectTypeDefinitionNode|ObjectTypeExtensionNode|InterfaceTypeDefinitionNode|InterfaceTypeExtensionNode $typeNode */
            return $typeNode->interfaces;
        });

        return Utils::filter($subNodes, static function (NamedTypeNode $ifaceNode) use ($shouldBeInterface) : bool {
            return $ifaceNode->name->value === $shouldBeInterface->name;
        });
    }

    /**
     * @param ObjectType|InterfaceType $type
     */
    private function validateTypeImplementsInterface(ImplementingType $type, InterfaceType $iface)
    {
        $typeFieldMap  = $type->getFields();
        $ifaceFieldMap = $iface->getFields();

        // Assert each interface field is implemented.
        foreach ($ifaceFieldMap as $fieldName => $ifaceField) {
            $typeField = array_key_exists($fieldName, $typeFieldMap)
                ? $typeFieldMap[$fieldName]
                : null;

            // Assert interface field exists on type.
            if (! $typeField) {
                $this->reportError(
                    sprintf(
                        'Interface field %s.%s expected but %s does not provide it.',
                        $iface->name,
                        $fieldName,
                        $type->name
                    ),
                    array_merge(
                        [$this->getFieldNode($iface, $fieldName)],
                        $this->getAllNodes($type)
                    )
                );
                continue;
            }

            // Assert interface field type is satisfied by type field type, by being
            // a valid subtype. (covariant)
            if (! TypeComparators::isTypeSubTypeOf(
                $this->schema,
                $typeField->getType(),
                $ifaceField->getType()
            )
            ) {
                $this->reportError(
                    sprintf(
                        'Interface field %s.%s expects type %s but %s.%s is type %s.',
                        $iface->name,
                        $fieldName,
                        $ifaceField->getType(),
                        $type->name,
                        $fieldName,
                        Utils::printSafe($typeField->getType())
                    ),
                    [
                        $this->getFieldTypeNode($iface, $fieldName),
                        $this->getFieldTypeNode($type, $fieldName),
                    ]
                );
            }

            // Assert each interface field arg is implemented.
            foreach ($ifaceField->args as $ifaceArg) {
                $argName = $ifaceArg->name;
                $typeArg = null;

                foreach ($typeField->args as $arg) {
                    if ($arg->name === $argName) {
                        $typeArg = $arg;
                        break;
                    }
                }

                // Assert interface field arg exists on type field.
                if (! $typeArg) {
                    $this->reportError(
                        sprintf(
                            'Interface field argument %s.%s(%s:) expected but %s.%s does not provide it.',
                            $iface->name,
                            $fieldName,
                            $argName,
                            $type->name,
                            $fieldName
                        ),
                        [
                            $this->getFieldArgNode($iface, $fieldName, $argName),
                            $this->getFieldNode($type, $fieldName),
                        ]
                    );
                    continue;
                }

                // Assert interface field arg type matches type field arg type.
                // (invariant)
                // TODO: change to contravariant?
                if (! TypeComparators::isEqualType($ifaceArg->getType(), $typeArg->getType())) {
                    $this->reportError(
                        sprintf(
                            'Interface field argument %s.%s(%s:) expects type %s but %s.%s(%s:) is type %s.',
                            $iface->name,
                            $fieldName,
                            $argName,
                            Utils::printSafe($ifaceArg->getType()),
                            $type->name,
                            $fieldName,
                            $argName,
                            Utils::printSafe($typeArg->getType())
                        ),
                        [
                            $this->getFieldArgTypeNode($iface, $fieldName, $argName),
                            $this->getFieldArgTypeNode($type, $fieldName, $argName),
                        ]
                    );
                }
                // TODO: validate default values?
            }

            // Assert additional arguments must not be required.
            foreach ($typeField->args as $typeArg) {
                $argName  = $typeArg->name;
                $ifaceArg = null;

                foreach ($ifaceField->args as $arg) {
                    if ($arg->name === $argName) {
                        $ifaceArg = $arg;
                        break;
                    }
                }

                if ($ifaceArg || ! $typeArg->isRequired()) {
                    continue;
                }

                $this->reportError(
                    sprintf(
                        'Object field %s.%s includes required argument %s that is missing from the Interface field %s.%s.',
                        $type->name,
                        $fieldName,
                        $argName,
                        $iface->name,
                        $fieldName
                    ),
                    [
                        $this->getFieldArgNode($type, $fieldName, $argName),
                        $this->getFieldNode($iface, $fieldName),
                    ]
                );
            }
        }
    }

    /**
     * @param ObjectType|InterfaceType $type
     */
    private function validateTypeImplementsAncestors(ImplementingType $type, InterfaceType $iface) : void
    {
        $typeInterfaces = $type->getInterfaces();
        foreach ($iface->getInterfaces() as $transitive) {
            if (in_array($transitive, $typeInterfaces, true)) {
                continue;
            }

            $error = $transitive === $type ?
                sprintf(
                    'Type %s cannot implement %s because it would create a circular reference.',
                    $type->name,
                    $iface->name
                ) :
                sprintf(
                    'Type %s must implement %s because it is implemented by %s.',
                    $type->name,
                    $transitive->name,
                    $iface->name
                );
            $this->reportError(
                $error,
                array_merge(
                    $this->getAllImplementsInterfaceNodes($iface, $transitive),
                    $this->getAllImplementsInterfaceNodes($type, $iface)
                )
            );
        }
    }

    private function validateUnionMembers(UnionType $union)
    {
        $memberTypes = $union->getTypes();

        if (! $memberTypes) {
            $this->reportError(
                sprintf('Union type %s must define one or more member types.', $union->name),
                $this->getAllNodes($union)
            );
        }

        $includedTypeNames = [];

        foreach ($memberTypes as $memberType) {
            if (isset($includedTypeNames[$memberType->name])) {
                $this->reportError(
                    sprintf('Union type %s can only include type %s once.', $union->name, $memberType->name),
                    $this->getUnionMemberTypeNodes($union, $memberType->name)
                );
                continue;
            }
            $includedTypeNames[$memberType->name] = true;
            if ($memberType instanceof ObjectType) {
                continue;
            }

            $this->reportError(
                sprintf(
                    'Union type %s can only include Object types, it cannot include %s.',
                    $union->name,
                    Utils::printSafe($memberType)
                ),
                $this->getUnionMemberTypeNodes($union, Utils::printSafe($memberType))
            );
        }
    }

    /**
     * @param string $typeName
     *
     * @return NamedTypeNode[]
     */
    private function getUnionMemberTypeNodes(UnionType $union, $typeName)
    {
        $subNodes = $this->getAllSubNodes($union, static function ($unionNode) {
            return $unionNode->types;
        });

        return Utils::filter($subNodes, static function ($typeNode) use ($typeName) : bool {
            return $typeNode->name->value === $typeName;
        });
    }

    private function validateEnumValues(EnumType $enumType)
    {
        $enumValues = $enumType->getValues();

        if (! $enumValues) {
            $this->reportError(
                sprintf('Enum type %s must define one or more values.', $enumType->name),
                $this->getAllNodes($enumType)
            );
        }

        foreach ($enumValues as $enumValue) {
            $valueName = $enumValue->name;

            // Ensure no duplicates
            $allNodes = $this->getEnumValueNodes($enumType, $valueName);
            if ($allNodes && count($allNodes) > 1) {
                $this->reportError(
                    sprintf('Enum type %s can include value %s only once.', $enumType->name, $valueName),
                    $allNodes
                );
            }

            // Ensure valid name.
            $this->validateName($enumValue);
            if ($valueName === 'true' || $valueName === 'false' || $valueName === 'null') {
                $this->reportError(
                    sprintf('Enum type %s cannot include value: %s.', $enumType->name, $valueName),
                    $enumValue->astNode
                );
            }

            // Ensure valid directives
            if (! isset($enumValue->astNode, $enumValue->astNode->directives)) {
                continue;
            }

            $this->validateDirectivesAtLocation(
                $enumValue->astNode->directives,
                DirectiveLocation::ENUM_VALUE
            );
        }
    }

    /**
     * @param string $valueName
     *
     * @return EnumValueDefinitionNode[]
     */
    private function getEnumValueNodes(EnumType $enum, $valueName)
    {
        $subNodes = $this->getAllSubNodes($enum, static function ($enumNode) {
            return $enumNode->values;
        });

        return Utils::filter($subNodes, static function ($valueNode) use ($valueName) : bool {
            return $valueNode->name->value === $valueName;
        });
    }

    private function validateInputFields(InputObjectType $inputObj)
    {
        $fieldMap = $inputObj->getFields();

        if (! $fieldMap) {
            $this->reportError(
                sprintf('Input Object type %s must define one or more fields.', $inputObj->name),
                $this->getAllNodes($inputObj)
            );
        }

        // Ensure the arguments are valid
        foreach ($fieldMap as $fieldName => $field) {
            // Ensure they are named correctly.
            $this->validateName($field);

            // TODO: Ensure they are unique per field.

            // Ensure the type is an input type
            if (! Type::isInputType($field->getType())) {
                $this->reportError(
                    sprintf(
                        'The type of %s.%s must be Input Type but got: %s.',
                        $inputObj->name,
                        $fieldName,
                        Utils::printSafe($field->getType())
                    ),
                    $field->astNode ? $field->astNode->type : null
                );
            }

            // Ensure valid directives
            if (! isset($field->astNode, $field->astNode->directives)) {
                continue;
            }

            $this->validateDirectivesAtLocation(
                $field->astNode->directives,
                DirectiveLocation::INPUT_FIELD_DEFINITION
            );
        }
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\TypeKind.php
<?php

declare(strict_types=1);

namespace GraphQL\Type;

class TypeKind
{
    const SCALAR       = 'SCALAR';
    const OBJECT       = 'OBJECT';
    const INTERFACE    = 'INTERFACE';
    const UNION        = 'UNION';
    const ENUM         = 'ENUM';
    const INPUT_OBJECT = 'INPUT_OBJECT';
    const LIST         = 'LIST';
    const NON_NULL     = 'NON_NULL';
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\AbstractType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

/**
export type AbstractType =
InterfaceType |
UnionType;
 */
interface AbstractType
{
    /**
     * Resolves concrete ObjectType for given object value
     *
     * @param object  $objectValue
     * @param mixed[] $context
     *
     * @return mixed
     */
    public function resolveType($objectValue, $context, ResolveInfo $info);
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\BooleanType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use Exception;
use GraphQL\Error\Error;
use GraphQL\Language\AST\BooleanValueNode;
use GraphQL\Language\AST\Node;
use GraphQL\Utils\Utils;
use function is_bool;

class BooleanType extends ScalarType
{
    /** @var string */
    public $name = Type::BOOLEAN;

    /** @var string */
    public $description = 'The `Boolean` scalar type represents `true` or `false`.';

    /**
     * Serialize the given value to a boolean.
     *
     * The GraphQL spec leaves this up to the implementations, so we just do what
     * PHP does natively to make this intuitive for developers.
     *
     * @param mixed $value
     */
    public function serialize($value) : bool
    {
        return (bool) $value;
    }

    /**
     * @param mixed $value
     *
     * @return bool
     *
     * @throws Error
     */
    public function parseValue($value)
    {
        if (is_bool($value)) {
            return $value;
        }

        throw new Error('Boolean cannot represent a non boolean value: ' . Utils::printSafe($value));
    }

    /**
     * @param mixed[]|null $variables
     *
     * @throws Exception
     */
    public function parseLiteral(Node $valueNode, ?array $variables = null)
    {
        if (! $valueNode instanceof BooleanValueNode) {
            // Intentionally without message, as all information already in wrapped Exception
            throw new Error();
        }

        return $valueNode->value;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\CompositeType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

/*
export type GraphQLCompositeType =
GraphQLObjectType |
GraphQLInterfaceType |
GraphQLUnionType;
*/

interface CompositeType
{
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\CustomScalarType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use Exception;
use GraphQL\Language\AST\Node;
use GraphQL\Utils\AST;
use GraphQL\Utils\Utils;
use function is_callable;
use function sprintf;

class CustomScalarType extends ScalarType
{
    /**
     * @param mixed $value
     *
     * @return mixed
     */
    public function serialize($value)
    {
        return $this->config['serialize']($value);
    }

    /**
     * @param mixed $value
     *
     * @return mixed
     */
    public function parseValue($value)
    {
        if (isset($this->config['parseValue'])) {
            return $this->config['parseValue']($value);
        }

        return $value;
    }

    /**
     * @param mixed[]|null $variables
     *
     * @return mixed
     *
     * @throws Exception
     */
    public function parseLiteral(Node $valueNode, ?array $variables = null)
    {
        if (isset($this->config['parseLiteral'])) {
            return $this->config['parseLiteral']($valueNode, $variables);
        }

        return AST::valueFromASTUntyped($valueNode, $variables);
    }

    public function assertValid()
    {
        parent::assertValid();

        Utils::invariant(
            isset($this->config['serialize']) && is_callable($this->config['serialize']),
            sprintf('%s must provide "serialize" function. If this custom Scalar ', $this->name) .
            'is also used as an input type, ensure "parseValue" and "parseLiteral" ' .
            'functions are also provided.'
        );
        if (! isset($this->config['parseValue']) && ! isset($this->config['parseLiteral'])) {
            return;
        }

        Utils::invariant(
            isset($this->config['parseValue']) && isset($this->config['parseLiteral']) &&
            is_callable($this->config['parseValue']) && is_callable($this->config['parseLiteral']),
            sprintf('%s must provide both "parseValue" and "parseLiteral" functions.', $this->name)
        );
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\Directive.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use GraphQL\Error\InvariantViolation;
use GraphQL\Language\AST\DirectiveDefinitionNode;
use GraphQL\Language\DirectiveLocation;
use function array_key_exists;
use function is_array;

class Directive
{
    public const DEFAULT_DEPRECATION_REASON = 'No longer supported';

    public const INCLUDE_NAME         = 'include';
    public const IF_ARGUMENT_NAME     = 'if';
    public const SKIP_NAME            = 'skip';
    public const DEPRECATED_NAME      = 'deprecated';
    public const REASON_ARGUMENT_NAME = 'reason';

    /** @var Directive[]|null */
    public static $internalDirectives;

    // Schema Definitions

    /** @var string */
    public $name;

    /** @var string|null */
    public $description;

    /** @var FieldArgument[] */
    public $args = [];

    /** @var bool */
    public $isRepeatable;

    /** @var string[] */
    public $locations;

    /** @var DirectiveDefinitionNode|null */
    public $astNode;

    /** @var mixed[] */
    public $config;

    /**
     * @param mixed[] $config
     */
    public function __construct(array $config)
    {
        if (! isset($config['name'])) {
            throw new InvariantViolation('Directive must be named.');
        }
        $this->name = $config['name'];

        $this->description = $config['description'] ?? null;

        if (isset($config['args'])) {
            $args = [];
            foreach ($config['args'] as $name => $arg) {
                if (is_array($arg)) {
                    $args[] = new FieldArgument($arg + ['name' => $name]);
                } else {
                    $args[] = $arg;
                }
            }
            $this->args = $args;
        }

        if (! isset($config['locations']) || ! is_array($config['locations'])) {
            throw new InvariantViolation('Must provide locations for directive.');
        }
        $this->locations = $config['locations'];

        $this->isRepeatable = $config['isRepeatable'] ?? false;
        $this->astNode      = $config['astNode'] ?? null;

        $this->config = $config;
    }

    /**
     * @return Directive
     */
    public static function includeDirective()
    {
        $internal = self::getInternalDirectives();

        return $internal['include'];
    }

    /**
     * @return Directive[]
     */
    public static function getInternalDirectives() : array
    {
        if (self::$internalDirectives === null) {
            self::$internalDirectives = [
                'include'    => new self([
                    'name'        => self::INCLUDE_NAME,
                    'description' => 'Directs the executor to include this field or fragment only when the `if` argument is true.',
                    'locations'   => [
                        DirectiveLocation::FIELD,
                        DirectiveLocation::FRAGMENT_SPREAD,
                        DirectiveLocation::INLINE_FRAGMENT,
                    ],
                    'args'        => [
                        new FieldArgument([
                            'name'        => self::IF_ARGUMENT_NAME,
                            'type'        => Type::nonNull(Type::boolean()),
                            'description' => 'Included when true.',
                        ]),
                    ],
                ]),
                'skip'       => new self([
                    'name'        => self::SKIP_NAME,
                    'description' => 'Directs the executor to skip this field or fragment when the `if` argument is true.',
                    'locations'   => [
                        DirectiveLocation::FIELD,
                        DirectiveLocation::FRAGMENT_SPREAD,
                        DirectiveLocation::INLINE_FRAGMENT,
                    ],
                    'args'        => [
                        new FieldArgument([
                            'name'        => self::IF_ARGUMENT_NAME,
                            'type'        => Type::nonNull(Type::boolean()),
                            'description' => 'Skipped when true.',
                        ]),
                    ],
                ]),
                'deprecated' => new self([
                    'name'        => self::DEPRECATED_NAME,
                    'description' => 'Marks an element of a GraphQL schema as no longer supported.',
                    'locations'   => [
                        DirectiveLocation::FIELD_DEFINITION,
                        DirectiveLocation::ENUM_VALUE,
                    ],
                    'args'        => [
                        new FieldArgument([
                            'name'         => self::REASON_ARGUMENT_NAME,
                            'type'         => Type::string(),
                            'description'  =>
                            'Explains why this element was deprecated, usually also including a ' .
                            'suggestion for how to access supported similar data. Formatted using ' .
                            'the Markdown syntax (as specified by [CommonMark](https://commonmark.org/).',
                            'defaultValue' => self::DEFAULT_DEPRECATION_REASON,
                        ]),
                    ],
                ]),
            ];
        }

        return self::$internalDirectives;
    }

    /**
     * @return Directive
     */
    public static function skipDirective()
    {
        $internal = self::getInternalDirectives();

        return $internal['skip'];
    }

    /**
     * @return Directive
     */
    public static function deprecatedDirective()
    {
        $internal = self::getInternalDirectives();

        return $internal['deprecated'];
    }

    /**
     * @return bool
     */
    public static function isSpecifiedDirective(Directive $directive)
    {
        return array_key_exists($directive->name, self::getInternalDirectives());
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\EnumType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use ArrayObject;
use Exception;
use GraphQL\Error\Error;
use GraphQL\Error\InvariantViolation;
use GraphQL\Language\AST\EnumTypeDefinitionNode;
use GraphQL\Language\AST\EnumTypeExtensionNode;
use GraphQL\Language\AST\EnumValueNode;
use GraphQL\Language\AST\Node;
use GraphQL\Utils\MixedStore;
use GraphQL\Utils\Utils;
use function is_array;
use function is_int;
use function is_string;
use function sprintf;

class EnumType extends Type implements InputType, OutputType, LeafType, NullableType, NamedType
{
    /** @var EnumTypeDefinitionNode|null */
    public $astNode;

    /**
     * Lazily initialized.
     *
     * @var EnumValueDefinition[]
     */
    private $values;

    /**
     * Lazily initialized.
     *
     * Actually a MixedStore<mixed, EnumValueDefinition>, PHPStan won't let us type it that way.
     *
     * @var MixedStore
     */
    private $valueLookup;

    /** @var ArrayObject<string, EnumValueDefinition> */
    private $nameLookup;

    /** @var EnumTypeExtensionNode[] */
    public $extensionASTNodes;

    public function __construct($config)
    {
        if (! isset($config['name'])) {
            $config['name'] = $this->tryInferName();
        }

        Utils::invariant(is_string($config['name']), 'Must provide name.');

        $this->name              = $config['name'];
        $this->description       = $config['description'] ?? null;
        $this->astNode           = $config['astNode'] ?? null;
        $this->extensionASTNodes = $config['extensionASTNodes'] ?? null;
        $this->config            = $config;
    }

    /**
     * @param string|mixed[] $name
     *
     * @return EnumValueDefinition|null
     */
    public function getValue($name)
    {
        $lookup = $this->getNameLookup();

        if (! is_string($name)) {
            return null;
        }

        return $lookup[$name] ?? null;
    }

    private function getNameLookup() : ArrayObject
    {
        if (! $this->nameLookup) {
            /** @var ArrayObject<string, EnumValueDefinition> $lookup */
            $lookup = new ArrayObject();
            foreach ($this->getValues() as $value) {
                $lookup[$value->name] = $value;
            }
            $this->nameLookup = $lookup;
        }

        return $this->nameLookup;
    }

    /**
     * @return EnumValueDefinition[]
     */
    public function getValues() : array
    {
        if (! isset($this->values)) {
            $this->values = [];
            $config       = $this->config;

            if (isset($config['values'])) {
                if (! is_array($config['values'])) {
                    throw new InvariantViolation(sprintf('%s values must be an array', $this->name));
                }
                foreach ($config['values'] as $name => $value) {
                    if (is_string($name)) {
                        if (is_array($value)) {
                            $value += ['name' => $name, 'value' => $name];
                        } else {
                            $value = ['name' => $name, 'value' => $value];
                        }
                    } elseif (is_int($name) && is_string($value)) {
                        $value = ['name' => $value, 'value' => $value];
                    } else {
                        throw new InvariantViolation(
                            sprintf(
                                '%s values must be an array with value names as keys.',
                                $this->name
                            )
                        );
                    }
                    $this->values[] = new EnumValueDefinition($value);
                }
            }
        }

        return $this->values;
    }

    /**
     * @param mixed $value
     *
     * @return mixed
     *
     * @throws Error
     */
    public function serialize($value)
    {
        $lookup = $this->getValueLookup();
        if (isset($lookup[$value])) {
            return $lookup[$value]->name;
        }

        throw new Error('Cannot serialize value as enum: ' . Utils::printSafe($value));
    }

    /**
     * Actually returns a MixedStore<mixed, EnumValueDefinition>, PHPStan won't let us type it that way
     */
    private function getValueLookup() : MixedStore
    {
        if (! isset($this->valueLookup)) {
            $this->valueLookup = new MixedStore();

            foreach ($this->getValues() as $valueName => $value) {
                $this->valueLookup->offsetSet($value->value, $value);
            }
        }

        return $this->valueLookup;
    }

    /**
     * @param mixed $value
     *
     * @return mixed
     *
     * @throws Error
     */
    public function parseValue($value)
    {
        $lookup = $this->getNameLookup();
        if (isset($lookup[$value])) {
            return $lookup[$value]->value;
        }

        throw new Error('Cannot represent value as enum: ' . Utils::printSafe($value));
    }

    /**
     * @param mixed[]|null $variables
     *
     * @return null
     *
     * @throws Exception
     */
    public function parseLiteral(Node $valueNode, ?array $variables = null)
    {
        if ($valueNode instanceof EnumValueNode) {
            $lookup = $this->getNameLookup();
            if (isset($lookup[$valueNode->value])) {
                $enumValue = $lookup[$valueNode->value];
                if ($enumValue !== null) {
                    return $enumValue->value;
                }
            }
        }

        // Intentionally without message, as all information already in wrapped Exception
        throw new Error();
    }

    /**
     * @throws InvariantViolation
     */
    public function assertValid()
    {
        parent::assertValid();

        Utils::invariant(
            isset($this->config['values']),
            sprintf('%s values must be an array.', $this->name)
        );

        $values = $this->getValues();
        foreach ($values as $value) {
            Utils::invariant(
                ! isset($value->config['isDeprecated']),
                sprintf(
                    '%s.%s should provide "deprecationReason" instead of "isDeprecated".',
                    $this->name,
                    $value->name
                )
            );
        }
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\EnumValueDefinition.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use GraphQL\Language\AST\EnumValueDefinitionNode;

class EnumValueDefinition
{
    /** @var string */
    public $name;

    /** @var mixed */
    public $value;

    /** @var string|null */
    public $deprecationReason;

    /** @var string|null */
    public $description;

    /** @var EnumValueDefinitionNode|null */
    public $astNode;

    /** @var mixed[] */
    public $config;

    /**
     * @param mixed[] $config
     */
    public function __construct(array $config)
    {
        $this->name              = $config['name'] ?? null;
        $this->value             = $config['value'] ?? null;
        $this->deprecationReason = $config['deprecationReason'] ?? null;
        $this->description       = $config['description'] ?? null;
        $this->astNode           = $config['astNode'] ?? null;

        $this->config = $config;
    }

    /**
     * @return bool
     */
    public function isDeprecated()
    {
        return (bool) $this->deprecationReason;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\FieldArgument.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use GraphQL\Error\InvariantViolation;
use GraphQL\Language\AST\InputValueDefinitionNode;
use GraphQL\Type\Schema;
use GraphQL\Utils\Utils;
use function array_key_exists;
use function is_array;
use function is_string;
use function sprintf;

class FieldArgument
{
    /** @var string */
    public $name;

    /** @var mixed */
    public $defaultValue;

    /** @var string|null */
    public $description;

    /** @var InputValueDefinitionNode|null */
    public $astNode;

    /** @var mixed[] */
    public $config;

    /** @var Type&InputType */
    private $type;

    /** @param mixed[] $def */
    public function __construct(array $def)
    {
        foreach ($def as $key => $value) {
            switch ($key) {
                case 'name':
                    $this->name = $value;
                    break;
                case 'defaultValue':
                    $this->defaultValue = $value;
                    break;
                case 'description':
                    $this->description = $value;
                    break;
                case 'astNode':
                    $this->astNode = $value;
                    break;
            }
        }
        $this->config = $def;
    }

    /**
     * @param mixed[] $config
     *
     * @return FieldArgument[]
     */
    public static function createMap(array $config) : array
    {
        $map = [];
        foreach ($config as $name => $argConfig) {
            if (! is_array($argConfig)) {
                $argConfig = ['type' => $argConfig];
            }
            $map[] = new self($argConfig + ['name' => $name]);
        }

        return $map;
    }

    public function getType() : Type
    {
        if (! isset($this->type)) {
            /**
             * TODO: replace this phpstan cast with native assert
             *
             * @var Type&InputType
             */
            $type       = Schema::resolveType($this->config['type']);
            $this->type = $type;
        }

        return $this->type;
    }

    public function defaultValueExists() : bool
    {
        return array_key_exists('defaultValue', $this->config);
    }

    public function isRequired() : bool
    {
        return $this->getType() instanceof NonNull && ! $this->defaultValueExists();
    }

    public function assertValid(FieldDefinition $parentField, Type $parentType)
    {
        try {
            Utils::assertValidName($this->name);
        } catch (InvariantViolation $e) {
            throw new InvariantViolation(
                sprintf('%s.%s(%s:) %s', $parentType->name, $parentField->name, $this->name, $e->getMessage())
            );
        }
        $type = $this->getType();
        if ($type instanceof WrappingType) {
            $type = $type->getWrappedType(true);
        }
        Utils::invariant(
            $type instanceof InputType,
            sprintf(
                '%s.%s(%s): argument type must be Input Type but got: %s',
                $parentType->name,
                $parentField->name,
                $this->name,
                Utils::printSafe($this->type)
            )
        );
        Utils::invariant(
            $this->description === null || is_string($this->description),
            sprintf(
                '%s.%s(%s): argument description type must be string but got: %s',
                $parentType->name,
                $parentField->name,
                $this->name,
                Utils::printSafe($this->description)
            )
        );
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\FieldDefinition.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use GraphQL\Error\Error;
use GraphQL\Error\InvariantViolation;
use GraphQL\Error\Warning;
use GraphQL\Language\AST\FieldDefinitionNode;
use GraphQL\Type\Schema;
use GraphQL\Utils\Utils;
use function is_array;
use function is_callable;
use function is_iterable;
use function is_string;
use function sprintf;

/**
 * @todo Move complexity-related code to it's own place
 */
#[\AllowDynamicProperties]
class FieldDefinition
{
    public const DEFAULT_COMPLEXITY_FN = 'GraphQL\Type\Definition\FieldDefinition::defaultComplexity';

    /** @var string */
    public $name;

    /** @var FieldArgument[] */
    public $args;

    /**
     * Callback for resolving field value given parent value.
     * Mutually exclusive with `map`
     *
     * @var callable|null
     */
    public $resolveFn;

    /**
     * Callback for mapping list of parent values to list of field values.
     * Mutually exclusive with `resolve`
     *
     * @var callable|null
     */
    public $mapFn;

    /** @var string|null */
    public $description;

    /** @var string|null */
    public $deprecationReason;

    /** @var FieldDefinitionNode|null */
    public $astNode;

    /**
     * Original field definition config
     *
     * @var mixed[]
     */
    public $config;

    /** @var OutputType&Type */
    private $type;

    /** @var callable|string */
    private $complexityFn;

    /**
     * @param mixed[] $config
     */
    protected function __construct(array $config)
    {
        $this->name      = $config['name'];
        $this->resolveFn = $config['resolve'] ?? null;
        $this->mapFn     = $config['map'] ?? null;
        $this->args      = isset($config['args']) ? FieldArgument::createMap($config['args']) : [];

        $this->description       = $config['description'] ?? null;
        $this->deprecationReason = $config['deprecationReason'] ?? null;
        $this->astNode           = $config['astNode'] ?? null;

        $this->config = $config;

        $this->complexityFn = $config['complexity'] ?? self::DEFAULT_COMPLEXITY_FN;
    }

    /**
     * @param (callable():mixed[])|mixed[] $fields
     *
     * @return array<string, self>
     */
    public static function defineFieldMap(Type $type, $fields) : array
    {
        if (is_callable($fields)) {
            $fields = $fields();
        }
        if (! is_iterable($fields)) {
            throw new InvariantViolation(
                sprintf('%s fields must be an iterable or a callable which returns such an iterable.', $type->name)
            );
        }
        $map = [];
        foreach ($fields as $name => $field) {
            if (is_array($field)) {
                if (! isset($field['name'])) {
                    if (! is_string($name)) {
                        throw new InvariantViolation(
                            sprintf(
                                '%s fields must be an associative array with field names as keys or a function which returns such an array.',
                                $type->name
                            )
                        );
                    }

                    $field['name'] = $name;
                }
                if (isset($field['args']) && ! is_array($field['args'])) {
                    throw new InvariantViolation(
                        sprintf('%s.%s args must be an array.', $type->name, $name)
                    );
                }
                $fieldDef = self::create($field);
            } elseif ($field instanceof self) {
                $fieldDef = $field;
            } elseif (is_callable($field)) {
                if (! is_string($name)) {
                    throw new InvariantViolation(
                        sprintf(
                            '%s lazy fields must be an associative array with field names as keys.',
                            $type->name
                        )
                    );
                }

                $fieldDef = new UnresolvedFieldDefinition($type, $name, $field);
            } else {
                if (! is_string($name) || ! $field) {
                    throw new InvariantViolation(
                        sprintf(
                            '%s.%s field config must be an array, but got: %s',
                            $type->name,
                            $name,
                            Utils::printSafe($field)
                        )
                    );
                }

                $fieldDef = self::create(['name' => $name, 'type' => $field]);
            }

            $map[$fieldDef->getName()] = $fieldDef;
        }

        return $map;
    }

    /**
     * @param mixed[] $field
     *
     * @return FieldDefinition
     */
    public static function create($field)
    {
        return new self($field);
    }

    /**
     * @param int $childrenComplexity
     *
     * @return mixed
     */
    public static function defaultComplexity($childrenComplexity)
    {
        return $childrenComplexity + 1;
    }

    /**
     * @param string $name
     *
     * @return FieldArgument|null
     */
    public function getArg($name)
    {
        foreach ($this->args ?? [] as $arg) {
            /** @var FieldArgument $arg */
            if ($arg->name === $name) {
                return $arg;
            }
        }

        return null;
    }

    public function getName() : string
    {
        return $this->name;
    }

    public function getType() : Type
    {
        if (! isset($this->type)) {
            /**
             * TODO: replace this phpstan cast with native assert
             *
             * @var Type&OutputType
             */
            $type       = Schema::resolveType($this->config['type']);
            $this->type = $type;
        }

        return $this->type;
    }

    public function __isset(string $name) : bool
    {
        switch ($name) {
            case 'type':
                Warning::warnOnce(
                    "The public getter for 'type' on FieldDefinition has been deprecated and will be removed" .
                    " in the next major version. Please update your code to use the 'getType' method.",
                    Warning::WARNING_CONFIG_DEPRECATION
                );

                return isset($this->type);
        }

        return isset($this->$name);
    }

    public function __get(string $name)
    {
        switch ($name) {
            case 'type':
                Warning::warnOnce(
                    "The public getter for 'type' on FieldDefinition has been deprecated and will be removed" .
                    " in the next major version. Please update your code to use the 'getType' method.",
                    Warning::WARNING_CONFIG_DEPRECATION
                );

                return $this->getType();
            default:
                return $this->$name;
        }

        return null;
    }

    public function __set(string $name, $value)
    {
        switch ($name) {
            case 'type':
                Warning::warnOnce(
                    "The public setter for 'type' on FieldDefinition has been deprecated and will be removed" .
                    ' in the next major version.',
                    Warning::WARNING_CONFIG_DEPRECATION
                );
                $this->type = $value;
                break;

            default:
                $this->$name = $value;
                break;
        }
    }

    /**
     * @return bool
     */
    public function isDeprecated()
    {
        return (bool) $this->deprecationReason;
    }

    /**
     * @return callable|callable
     */
    public function getComplexityFn()
    {
        return $this->complexityFn;
    }

    /**
     * @throws InvariantViolation
     */
    public function assertValid(Type $parentType)
    {
        try {
            Utils::assertValidName($this->name);
        } catch (Error $e) {
            throw new InvariantViolation(sprintf('%s.%s: %s', $parentType->name, $this->name, $e->getMessage()));
        }
        Utils::invariant(
            ! isset($this->config['isDeprecated']),
            sprintf(
                '%s.%s should provide "deprecationReason" instead of "isDeprecated".',
                $parentType->name,
                $this->name
            )
        );

        $type = $this->getType();
        if ($type instanceof WrappingType) {
            $type = $type->getWrappedType(true);
        }
        Utils::invariant(
            $type instanceof OutputType,
            sprintf(
                '%s.%s field type must be Output Type but got: %s',
                $parentType->name,
                $this->name,
                Utils::printSafe($this->type)
            )
        );
        Utils::invariant(
            $this->resolveFn === null || is_callable($this->resolveFn),
            sprintf(
                '%s.%s field resolver must be a function if provided, but got: %s',
                $parentType->name,
                $this->name,
                Utils::printSafe($this->resolveFn)
            )
        );

        foreach ($this->args as $fieldArgument) {
            $fieldArgument->assertValid($this, $type);
        }
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\FloatType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use Exception;
use GraphQL\Error\Error;
use GraphQL\Language\AST\FloatValueNode;
use GraphQL\Language\AST\IntValueNode;
use GraphQL\Language\AST\Node;
use GraphQL\Utils\Utils;
use function floatval;
use function is_bool;
use function is_finite;
use function is_float;
use function is_int;
use function is_numeric;

class FloatType extends ScalarType
{
    /** @var string */
    public $name = Type::FLOAT;

    /** @var string */
    public $description =
        'The `Float` scalar type represents signed double-precision fractional
values as specified by
[IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). ';

    /**
     * @param mixed $value
     *
     * @throws Error
     */
    public function serialize($value) : float
    {
        $float = is_numeric($value) || is_bool($value)
            ? (float) $value
            : null;

        if ($float === null || ! is_finite($float)) {
            throw new Error(
                'Float cannot represent non numeric value: ' .
                Utils::printSafe($value)
            );
        }

        return $float;
    }

    /**
     * @param mixed $value
     *
     * @throws Error
     */
    public function parseValue($value) : float
    {
        $float = is_float($value) || is_int($value)
            ? (float) $value
            : null;

        if ($float === null || ! is_finite($float)) {
            throw new Error(
                'Float cannot represent non numeric value: ' .
                Utils::printSafe($value)
            );
        }

        return $float;
    }

    /**
     * @param mixed[]|null $variables
     *
     * @return float
     *
     * @throws Exception
     */
    public function parseLiteral(Node $valueNode, ?array $variables = null)
    {
        if ($valueNode instanceof FloatValueNode || $valueNode instanceof IntValueNode) {
            return (float) $valueNode->value;
        }

        // Intentionally without message, as all information already in wrapped Exception
        throw new Error();
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\HasFieldsType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use GraphQL\Error\InvariantViolation;

interface HasFieldsType
{
    /**
     * @throws InvariantViolation
     */
    public function getField(string $name) : FieldDefinition;

    public function hasField(string $name) : bool;

    public function findField(string $name) : ?FieldDefinition;

    /**
     * @return array<string, FieldDefinition>
     *
     * @throws InvariantViolation
     */
    public function getFields() : array;

    /**
     * @return array<int, string>
     *
     * @throws InvariantViolation
     */
    public function getFieldNames() : array;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\IDType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use Exception;
use GraphQL\Error\Error;
use GraphQL\Language\AST\IntValueNode;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\StringValueNode;
use GraphQL\Utils\Utils;
use function is_int;
use function is_object;
use function is_string;
use function method_exists;

class IDType extends ScalarType
{
    /** @var string */
    public $name = 'ID';

    /** @var string */
    public $description =
        'The `ID` scalar type represents a unique identifier, often used to
refetch an object or as key for a cache. The ID type appears in a JSON
response as a String; however, it is not intended to be human-readable.
When expected as an input type, any string (such as `"4"`) or integer
(such as `4`) input value will be accepted as an ID.';

    /**
     * @param mixed $value
     *
     * @return string
     *
     * @throws Error
     */
    public function serialize($value)
    {
        $canCast = is_string($value)
            || is_int($value)
            || (is_object($value) && method_exists($value, '__toString'));

        if (! $canCast) {
            throw new Error('ID cannot represent value: ' . Utils::printSafe($value));
        }

        return (string) $value;
    }

    /**
     * @param mixed $value
     *
     * @throws Error
     */
    public function parseValue($value) : string
    {
        if (is_string($value) || is_int($value)) {
            return (string) $value;
        }
        throw new Error('ID cannot represent value: ' . Utils::printSafe($value));
    }

    /**
     * @param mixed[]|null $variables
     *
     * @return string
     *
     * @throws Exception
     */
    public function parseLiteral(Node $valueNode, ?array $variables = null)
    {
        if ($valueNode instanceof StringValueNode || $valueNode instanceof IntValueNode) {
            return $valueNode->value;
        }

        // Intentionally without message, as all information already in wrapped Exception
        throw new Error();
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\ImplementingType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

/**
export type GraphQLImplementingType =
GraphQLObjectType |
GraphQLInterfaceType;
 */
interface ImplementingType
{
    public function implementsInterface(InterfaceType $interfaceType) : bool;

    /**
     * @return array<int, InterfaceType>
     */
    public function getInterfaces() : array;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\InputObjectField.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use GraphQL\Error\Error;
use GraphQL\Error\InvariantViolation;
use GraphQL\Error\Warning;
use GraphQL\Language\AST\InputValueDefinitionNode;
use GraphQL\Type\Schema;
use GraphQL\Utils\Utils;
use function array_key_exists;
use function sprintf;

#[\AllowDynamicProperties]
class InputObjectField
{
    /** @var string */
    public $name;

    /** @var mixed|null */
    public $defaultValue;

    /** @var string|null */
    public $description;

    /** @var Type&InputType */
    private $type;

    /** @var InputValueDefinitionNode|null */
    public $astNode;

    /** @var mixed[] */
    public $config;

    /**
     * @param mixed[] $opts
     */
    public function __construct(array $opts)
    {
        foreach ($opts as $k => $v) {
            switch ($k) {
                case 'defaultValue':
                    $this->defaultValue = $v;
                    break;
                case 'defaultValueExists':
                    break;
                case 'type':
                    // do nothing; type is lazy loaded in getType
                    break;
                default:
                    $this->{$k} = $v;
            }
        }
        $this->config = $opts;
    }

    public function __isset(string $name) : bool
    {
        switch ($name) {
            case 'type':
                Warning::warnOnce(
                    "The public getter for 'type' on InputObjectField has been deprecated and will be removed" .
                    " in the next major version. Please update your code to use the 'getType' method.",
                    Warning::WARNING_CONFIG_DEPRECATION
                );

                return isset($this->type);
        }

        return isset($this->$name);
    }

    public function __get(string $name)
    {
        switch ($name) {
            case 'type':
                Warning::warnOnce(
                    "The public getter for 'type' on InputObjectField has been deprecated and will be removed" .
                    " in the next major version. Please update your code to use the 'getType' method.",
                    Warning::WARNING_CONFIG_DEPRECATION
                );

                return $this->getType();
            default:
                return $this->$name;
        }

        return null;
    }

    public function __set(string $name, $value)
    {
        switch ($name) {
            case 'type':
                Warning::warnOnce(
                    "The public setter for 'type' on InputObjectField has been deprecated and will be removed" .
                    ' in the next major version.',
                    Warning::WARNING_CONFIG_DEPRECATION
                );
                $this->type = $value;
                break;

            default:
                $this->$name = $value;
                break;
        }
    }

    /**
     * @return Type&InputType
     */
    public function getType() : Type
    {
        if (! isset($this->type)) {
            /**
             * TODO: replace this phpstan cast with native assert
             *
             * @var Type&InputType
             */
            $type       = Schema::resolveType($this->config['type']);
            $this->type = $type;
        }

        return $this->type;
    }

    public function defaultValueExists() : bool
    {
        return array_key_exists('defaultValue', $this->config);
    }

    public function isRequired() : bool
    {
        return $this->getType() instanceof NonNull && ! $this->defaultValueExists();
    }

    /**
     * @throws InvariantViolation
     */
    public function assertValid(Type $parentType)
    {
        try {
            Utils::assertValidName($this->name);
        } catch (Error $e) {
            throw new InvariantViolation(sprintf('%s.%s: %s', $parentType->name, $this->name, $e->getMessage()));
        }
        $type = $this->getType();
        if ($type instanceof WrappingType) {
            $type = $type->getWrappedType(true);
        }
        Utils::invariant(
            $type instanceof InputType,
            sprintf(
                '%s.%s field type must be Input Type but got: %s',
                $parentType->name,
                $this->name,
                Utils::printSafe($this->type)
            )
        );
        Utils::invariant(
            ! array_key_exists('resolve', $this->config),
            sprintf(
                '%s.%s field has a resolve property, but Input Types cannot define resolvers.',
                $parentType->name,
                $this->name
            )
        );
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\InputObjectType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use GraphQL\Error\InvariantViolation;
use GraphQL\Language\AST\InputObjectTypeDefinitionNode;
use GraphQL\Language\AST\InputObjectTypeExtensionNode;
use GraphQL\Utils\Utils;
use function count;
use function is_array;
use function is_callable;
use function is_iterable;
use function is_string;
use function sprintf;

class InputObjectType extends Type implements InputType, NullableType, NamedType
{
    /** @var InputObjectTypeDefinitionNode|null */
    public $astNode;

    /**
     * Lazily initialized.
     *
     * @var InputObjectField[]
     */
    private $fields;

    /** @var InputObjectTypeExtensionNode[] */
    public $extensionASTNodes;

    /**
     * @param mixed[] $config
     */
    public function __construct(array $config)
    {
        if (! isset($config['name'])) {
            $config['name'] = $this->tryInferName();
        }

        Utils::invariant(is_string($config['name']), 'Must provide name.');

        $this->config            = $config;
        $this->name              = $config['name'];
        $this->astNode           = $config['astNode'] ?? null;
        $this->description       = $config['description'] ?? null;
        $this->extensionASTNodes = $config['extensionASTNodes'] ?? null;
    }

    /**
     * @throws InvariantViolation
     */
    public function getField(string $name) : InputObjectField
    {
        if (! isset($this->fields)) {
            $this->initializeFields();
        }
        Utils::invariant(isset($this->fields[$name]), "Field '%s' is not defined for type '%s'", $name, $this->name);

        return $this->fields[$name];
    }

    /**
     * @return InputObjectField[]
     */
    public function getFields() : array
    {
        if (! isset($this->fields)) {
            $this->initializeFields();
        }

        return $this->fields;
    }

    protected function initializeFields() : void
    {
        $this->fields = [];
        $fields       = $this->config['fields'] ?? [];
        if (is_callable($fields)) {
            $fields = $fields();
        }

        if (! is_iterable($fields)) {
            throw new InvariantViolation(
                sprintf('%s fields must be an iterable or a callable which returns such an iterable.', $this->name)
            );
        }

        foreach ($fields as $name => $field) {
            if ($field instanceof Type || is_callable($field)) {
                $field = ['type' => $field];
            }
            $field                      = new InputObjectField($field + ['name' => $name]);
            $this->fields[$field->name] = $field;
        }
    }

    /**
     * Validates type config and throws if one of type options is invalid.
     * Note: this method is shallow, it won't validate object fields and their arguments.
     *
     * @throws InvariantViolation
     */
    public function assertValid() : void
    {
        parent::assertValid();

        Utils::invariant(
            count($this->getFields()) > 0,
            sprintf(
                '%s fields must be an associative array with field names as keys or a callable which returns such an array.',
                $this->name
            )
        );

        foreach ($this->getFields() as $field) {
            $field->assertValid($this);
        }
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\InputType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

/**
export type InputType =
  | ScalarType
  | EnumType
  | InputObjectType
  | ListOfType<InputType>
  | NonNull<
      | ScalarType
      | EnumType
      | InputObjectType
      | ListOfType<InputType>,
    >;
 */
interface InputType
{
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\InterfaceType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use GraphQL\Error\InvariantViolation;
use GraphQL\Language\AST\InterfaceTypeDefinitionNode;
use GraphQL\Language\AST\InterfaceTypeExtensionNode;
use GraphQL\Type\Schema;
use GraphQL\Utils\Utils;
use function array_map;
use function is_array;
use function is_callable;
use function is_string;
use function sprintf;

class InterfaceType extends TypeWithFields implements AbstractType, OutputType, CompositeType, NullableType, NamedType, ImplementingType
{
    /** @var InterfaceTypeDefinitionNode|null */
    public $astNode;

    /** @var array<int, InterfaceTypeExtensionNode> */
    public $extensionASTNodes;

    /**
     * Lazily initialized.
     *
     * @var array<int, InterfaceType>
     */
    private $interfaces;

    /**
     * Lazily initialized.
     *
     * @var array<string, InterfaceType>
     */
    private $interfaceMap;

    /**
     * @param mixed[] $config
     */
    public function __construct(array $config)
    {
        if (! isset($config['name'])) {
            $config['name'] = $this->tryInferName();
        }

        Utils::invariant(is_string($config['name']), 'Must provide name.');

        $this->name              = $config['name'];
        $this->description       = $config['description'] ?? null;
        $this->astNode           = $config['astNode'] ?? null;
        $this->extensionASTNodes = $config['extensionASTNodes'] ?? null;
        $this->config            = $config;
    }

    /**
     * @param mixed $type
     *
     * @return $this
     *
     * @throws InvariantViolation
     */
    public static function assertInterfaceType($type) : self
    {
        Utils::invariant(
            $type instanceof self,
            'Expected ' . Utils::printSafe($type) . ' to be a GraphQL Interface type.'
        );

        return $type;
    }

    public function implementsInterface(InterfaceType $interfaceType) : bool
    {
        if (! isset($this->interfaceMap)) {
            $this->interfaceMap = [];
            foreach ($this->getInterfaces() as $interface) {
                /** @var Type&InterfaceType $interface */
                $interface                            = Schema::resolveType($interface);
                $this->interfaceMap[$interface->name] = $interface;
            }
        }

        return isset($this->interfaceMap[$interfaceType->name]);
    }

    /**
     * @return array<int, InterfaceType>
     */
    public function getInterfaces() : array
    {
        if (! isset($this->interfaces)) {
            $interfaces = $this->config['interfaces'] ?? [];
            if (is_callable($interfaces)) {
                $interfaces = $interfaces();
            }

            if ($interfaces !== null && ! is_array($interfaces)) {
                throw new InvariantViolation(
                    sprintf('%s interfaces must be an Array or a callable which returns an Array.', $this->name)
                );
            }

            /** @var array<int, InterfaceType> $interfaces */
            $interfaces = $interfaces === null
                ? []
                : array_map([Schema::class, 'resolveType'], $interfaces);

            $this->interfaces = $interfaces;
        }

        return $this->interfaces;
    }

    /**
     * Resolves concrete ObjectType for given object value
     *
     * @param object $objectValue
     * @param mixed  $context
     *
     * @return Type|null
     */
    public function resolveType($objectValue, $context, ResolveInfo $info)
    {
        if (isset($this->config['resolveType'])) {
            $fn = $this->config['resolveType'];

            return $fn($objectValue, $context, $info);
        }

        return null;
    }

    /**
     * @throws InvariantViolation
     */
    public function assertValid() : void
    {
        parent::assertValid();

        $resolveType = $this->config['resolveType'] ?? null;

        Utils::invariant(
            ! isset($resolveType) || is_callable($resolveType),
            sprintf(
                '%s must provide "resolveType" as a function, but got: %s',
                $this->name,
                Utils::printSafe($resolveType)
            )
        );
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\IntType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use Exception;
use GraphQL\Error\Error;
use GraphQL\Language\AST\IntValueNode;
use GraphQL\Language\AST\Node;
use GraphQL\Utils\Utils;
use function floatval;
use function floor;
use function intval;
use function is_bool;
use function is_float;
use function is_int;
use function is_numeric;

class IntType extends ScalarType
{
    // As per the GraphQL Spec, Integers are only treated as valid when a valid
    // 32-bit signed integer, providing the broadest support across platforms.
    //
    // n.b. JavaScript's integers are safe between -(2^53 - 1) and 2^53 - 1 because
    // they are internally represented as IEEE 754 doubles.
    public const MAX_INT = 2147483647;
    public const MIN_INT = -2147483648;

    /** @var string */
    public $name = Type::INT;

    /** @var string */
    public $description =
        'The `Int` scalar type represents non-fractional signed whole numeric
values. Int can represent values between -(2^31) and 2^31 - 1. ';

    /**
     * @param mixed $value
     *
     * @return int|null
     *
     * @throws Error
     */
    public function serialize($value)
    {
        // Fast path for 90+% of cases:
        if (is_int($value) && $value <= self::MAX_INT && $value >= self::MIN_INT) {
            return $value;
        }

        $float = is_numeric($value) || is_bool($value)
            ? (float) $value
            : null;

        if ($float === null || floor($float) !== $float) {
            throw new Error(
                'Int cannot represent non-integer value: ' .
                Utils::printSafe($value)
            );
        }

        if ($float > self::MAX_INT || $float < self::MIN_INT) {
            throw new Error(
                'Int cannot represent non 32-bit signed integer value: ' .
                Utils::printSafe($value)
            );
        }

        return (int) $float;
    }

    /**
     * @param mixed $value
     *
     * @throws Error
     */
    public function parseValue($value) : int
    {
        $isInt = is_int($value) || (is_float($value) && floor($value) === $value);

        if (! $isInt) {
            throw new Error(
                'Int cannot represent non-integer value: ' .
                Utils::printSafe($value)
            );
        }

        if ($value > self::MAX_INT || $value < self::MIN_INT) {
            throw new Error(
                'Int cannot represent non 32-bit signed integer value: ' .
                Utils::printSafe($value)
            );
        }

        return (int) $value;
    }

    /**
     * @param mixed[]|null $variables
     *
     * @return int
     *
     * @throws Exception
     */
    public function parseLiteral(Node $valueNode, ?array $variables = null)
    {
        if ($valueNode instanceof IntValueNode) {
            $val = (int) $valueNode->value;
            if ($valueNode->value === (string) $val && self::MIN_INT <= $val && $val <= self::MAX_INT) {
                return $val;
            }
        }

        // Intentionally without message, as all information already in wrapped Exception
        throw new Error();
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\LeafType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use Exception;
use GraphQL\Error\Error;
use GraphQL\Language\AST\BooleanValueNode;
use GraphQL\Language\AST\FloatValueNode;
use GraphQL\Language\AST\IntValueNode;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\NullValueNode;
use GraphQL\Language\AST\StringValueNode;

/*
export type GraphQLLeafType =
GraphQLScalarType |
GraphQLEnumType;
*/

interface LeafType
{
    /**
     * Serializes an internal value to include in a response.
     *
     * @param mixed $value
     *
     * @return mixed
     *
     * @throws Error
     */
    public function serialize($value);

    /**
     * Parses an externally provided value (query variable) to use as an input
     *
     * In the case of an invalid value this method must throw an Exception
     *
     * @param mixed $value
     *
     * @return mixed
     *
     * @throws Error
     */
    public function parseValue($value);

    /**
     * Parses an externally provided literal value (hardcoded in GraphQL query) to use as an input
     *
     * In the case of an invalid node or value this method must throw an Exception
     *
     * @param IntValueNode|FloatValueNode|StringValueNode|BooleanValueNode|NullValueNode $valueNode
     * @param mixed[]|null                                                               $variables
     *
     * @return mixed
     *
     * @throws Exception
     */
    public function parseLiteral(Node $valueNode, ?array $variables = null);
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\ListOfType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use GraphQL\Type\Schema;
use function is_callable;

class ListOfType extends Type implements WrappingType, OutputType, NullableType, InputType
{
    /** @var callable():Type|Type */
    public $ofType;

    /**
     * @param callable():Type|Type $type
     */
    public function __construct($type)
    {
        $this->ofType = is_callable($type) ? $type : Type::assertType($type);
    }

    public function toString() : string
    {
        return '[' . $this->getOfType()->toString() . ']';
    }

    public function getOfType()
    {
        return Schema::resolveType($this->ofType);
    }

    public function getWrappedType(bool $recurse = false) : Type
    {
        $type = $this->getOfType();

        return $recurse && $type instanceof WrappingType
            ? $type->getWrappedType($recurse)
            : $type;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\NamedType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

/**
export type NamedType =
  | ScalarType
  | ObjectType
  | InterfaceType
  | UnionType
  | EnumType
  | InputObjectType;
 */
interface NamedType
{
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\NonNull.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use GraphQL\Type\Schema;

class NonNull extends Type implements WrappingType, OutputType, InputType
{
    /** @var callable():(NullableType&Type)|(NullableType&Type) */
    private $ofType;

    /**
     * code sniffer doesn't understand this syntax. Pr with a fix here: waiting on https://github.com/squizlabs/PHP_CodeSniffer/pull/2919
     * @param callable():(NullableType&Type)|(NullableType&Type) $type
     */
    public function __construct($type)
    {
        $this->ofType = $type;
    }

    public function toString() : string
    {
        return $this->getWrappedType()->toString() . '!';
    }

    public function getOfType()
    {
        return Schema::resolveType($this->ofType);
    }

    /**
     * @return (NullableType&Type)
     */
    public function getWrappedType(bool $recurse = false) : Type
    {
        $type = $this->getOfType();

        return $recurse && $type instanceof WrappingType
            ? $type->getWrappedType($recurse)
            : $type;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\NullableType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

/*
export type GraphQLNullableType =
  | GraphQLScalarType
  | GraphQLObjectType
  | GraphQLInterfaceType
  | GraphQLUnionType
  | GraphQLEnumType
  | GraphQLInputObjectType
  | GraphQLList<any>;
 */

interface NullableType
{
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\ObjectType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use GraphQL\Deferred;
use GraphQL\Error\InvariantViolation;
use GraphQL\Language\AST\ObjectTypeDefinitionNode;
use GraphQL\Language\AST\ObjectTypeExtensionNode;
use GraphQL\Type\Schema;
use GraphQL\Utils\Utils;
use function array_map;
use function is_array;
use function is_callable;
use function is_string;
use function sprintf;

/**
 * Object Type Definition
 *
 * Almost all of the GraphQL types you define will be object types. Object types
 * have a name, but most importantly describe their fields.
 *
 * Example:
 *
 *     $AddressType = new ObjectType([
 *       'name' => 'Address',
 *       'fields' => [
 *         'street' => [ 'type' => GraphQL\Type\Definition\Type::string() ],
 *         'number' => [ 'type' => GraphQL\Type\Definition\Type::int() ],
 *         'formatted' => [
 *           'type' => GraphQL\Type\Definition\Type::string(),
 *           'resolve' => function($obj) {
 *             return $obj->number . ' ' . $obj->street;
 *           }
 *         ]
 *       ]
 *     ]);
 *
 * When two types need to refer to each other, or a type needs to refer to
 * itself in a field, you can use a function expression (aka a closure or a
 * thunk) to supply the fields lazily.
 *
 * Example:
 *
 *     $PersonType = null;
 *     $PersonType = new ObjectType([
 *       'name' => 'Person',
 *       'fields' => function() use (&$PersonType) {
 *          return [
 *              'name' => ['type' => GraphQL\Type\Definition\Type::string() ],
 *              'bestFriend' => [ 'type' => $PersonType ],
 *          ];
 *        }
 *     ]);
 */
class ObjectType extends TypeWithFields implements OutputType, CompositeType, NullableType, NamedType, ImplementingType
{
    /** @var ObjectTypeDefinitionNode|null */
    public $astNode;

    /** @var ObjectTypeExtensionNode[] */
    public $extensionASTNodes;

    /** @var ?callable */
    public $resolveFieldFn;

    /**
     * Lazily initialized.
     *
     * @var array<int, InterfaceType>
     */
    private $interfaces;

    /**
     * Lazily initialized.
     *
     * @var array<string, InterfaceType>
     */
    private $interfaceMap;

    /**
     * @param mixed[] $config
     */
    public function __construct(array $config)
    {
        if (! isset($config['name'])) {
            $config['name'] = $this->tryInferName();
        }

        Utils::invariant(is_string($config['name']), 'Must provide name.');

        $this->name              = $config['name'];
        $this->description       = $config['description'] ?? null;
        $this->resolveFieldFn    = $config['resolveField'] ?? null;
        $this->astNode           = $config['astNode'] ?? null;
        $this->extensionASTNodes = $config['extensionASTNodes'] ?? [];
        $this->config            = $config;
    }

    /**
     * @param mixed $type
     *
     * @return $this
     *
     * @throws InvariantViolation
     */
    public static function assertObjectType($type) : self
    {
        Utils::invariant(
            $type instanceof self,
            'Expected ' . Utils::printSafe($type) . ' to be a GraphQL Object type.'
        );

        return $type;
    }

    public function implementsInterface(InterfaceType $interfaceType) : bool
    {
        if (! isset($this->interfaceMap)) {
            $this->interfaceMap = [];
            foreach ($this->getInterfaces() as $interface) {
                /** @var Type&InterfaceType $interface */
                $interface                            = Schema::resolveType($interface);
                $this->interfaceMap[$interface->name] = $interface;
            }
        }

        return isset($this->interfaceMap[$interfaceType->name]);
    }

    /**
     * @return array<int, InterfaceType>
     */
    public function getInterfaces() : array
    {
        if (! isset($this->interfaces)) {
            $interfaces = $this->config['interfaces'] ?? [];
            if (is_callable($interfaces)) {
                $interfaces = $interfaces();
            }

            if ($interfaces !== null && ! is_array($interfaces)) {
                throw new InvariantViolation(
                    sprintf('%s interfaces must be an Array or a callable which returns an Array.', $this->name)
                );
            }

            /** @var InterfaceType[] $interfaces */
            $interfaces = array_map([Schema::class, 'resolveType'], $interfaces ?? []);

            $this->interfaces = $interfaces;
        }

        return $this->interfaces;
    }

    /**
     * @param mixed $value
     * @param mixed $context
     *
     * @return bool|Deferred|null
     */
    public function isTypeOf($value, $context, ResolveInfo $info)
    {
        return isset($this->config['isTypeOf'])
            ? $this->config['isTypeOf'](
                $value,
                $context,
                $info
            )
            : null;
    }

    /**
     * Validates type config and throws if one of type options is invalid.
     * Note: this method is shallow, it won't validate object fields and their arguments.
     *
     * @throws InvariantViolation
     */
    public function assertValid() : void
    {
        parent::assertValid();

        Utils::invariant(
            $this->description === null || is_string($this->description),
            sprintf(
                '%s description must be string if set, but it is: %s',
                $this->name,
                Utils::printSafe($this->description)
            )
        );

        $isTypeOf = $this->config['isTypeOf'] ?? null;

        Utils::invariant(
            $isTypeOf === null || is_callable($isTypeOf),
            sprintf('%s must provide "isTypeOf" as a function, but got: %s', $this->name, Utils::printSafe($isTypeOf))
        );

        foreach ($this->getFields() as $field) {
            $field->assertValid($this);
        }
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\OutputType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

/*
GraphQLScalarType |
GraphQLObjectType |
GraphQLInterfaceType |
GraphQLUnionType |
GraphQLEnumType |
GraphQLList |
GraphQLNonNull;
*/

interface OutputType
{
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\QueryPlan.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use GraphQL\Error\Error;
use GraphQL\Executor\Values;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\FragmentDefinitionNode;
use GraphQL\Language\AST\FragmentSpreadNode;
use GraphQL\Language\AST\InlineFragmentNode;
use GraphQL\Language\AST\SelectionSetNode;
use GraphQL\Type\Introspection;
use GraphQL\Type\Schema;
use function array_diff_key;
use function array_filter;
use function array_intersect_key;
use function array_key_exists;
use function array_keys;
use function array_merge;
use function array_merge_recursive;
use function array_unique;
use function array_values;
use function count;
use function in_array;
use function is_array;
use function is_numeric;

class QueryPlan
{
    /** @var string[][] */
    private $types = [];

    /** @var Schema */
    private $schema;

    /** @var array<string, mixed> */
    private $queryPlan = [];

    /** @var mixed[] */
    private $variableValues;

    /** @var FragmentDefinitionNode[] */
    private $fragments;

    /** @var bool */
    private $groupImplementorFields;

    /**
     * @param FieldNode[]              $fieldNodes
     * @param mixed[]                  $variableValues
     * @param FragmentDefinitionNode[] $fragments
     * @param mixed[]                  $options
     */
    public function __construct(ObjectType $parentType, Schema $schema, iterable $fieldNodes, array $variableValues, array $fragments, array $options = [])
    {
        $this->schema                 = $schema;
        $this->variableValues         = $variableValues;
        $this->fragments              = $fragments;
        $this->groupImplementorFields = in_array('group-implementor-fields', $options, true);
        $this->analyzeQueryPlan($parentType, $fieldNodes);
    }

    /**
     * @return mixed[]
     */
    public function queryPlan() : array
    {
        return $this->queryPlan;
    }

    /**
     * @return string[]
     */
    public function getReferencedTypes() : array
    {
        return array_keys($this->types);
    }

    public function hasType(string $type) : bool
    {
        return count(array_filter($this->getReferencedTypes(), static function (string $referencedType) use ($type) : bool {
                return $type === $referencedType;
        })) > 0;
    }

    /**
     * @return string[]
     */
    public function getReferencedFields() : array
    {
        return array_values(array_unique(array_merge(...array_values($this->types))));
    }

    public function hasField(string $field) : bool
    {
        return count(array_filter($this->getReferencedFields(), static function (string $referencedField) use ($field) : bool {
            return $field === $referencedField;
        })) > 0;
    }

    /**
     * @return string[]
     */
    public function subFields(string $typename) : array
    {
        if (! array_key_exists($typename, $this->types)) {
            return [];
        }

        return $this->types[$typename];
    }

    /**
     * @param FieldNode[] $fieldNodes
     */
    private function analyzeQueryPlan(ObjectType $parentType, iterable $fieldNodes) : void
    {
        $queryPlan    = [];
        $implementors = [];
        /** @var FieldNode $fieldNode */
        foreach ($fieldNodes as $fieldNode) {
            if (! $fieldNode->selectionSet) {
                continue;
            }

            $type = $parentType->getField($fieldNode->name->value)->getType();
            if ($type instanceof WrappingType) {
                $type = $type->getWrappedType(true);
            }

            $subfields = $this->analyzeSelectionSet($fieldNode->selectionSet, $type, $implementors);

            $this->types[$type->name] = array_unique(array_merge(
                array_key_exists($type->name, $this->types) ? $this->types[$type->name] : [],
                array_keys($subfields)
            ));

            $queryPlan = array_merge_recursive(
                $queryPlan,
                $subfields
            );
        }

        if ($this->groupImplementorFields) {
            $this->queryPlan = ['fields' => $queryPlan];

            if ($implementors) {
                $this->queryPlan['implementors'] = $implementors;
            }
        } else {
            $this->queryPlan = $queryPlan;
        }
    }

    /**
     * @param InterfaceType|ObjectType $parentType
     * @param mixed[]                  $implementors
     *
     * @return mixed[]
     *
     * @throws Error
     */
    private function analyzeSelectionSet(SelectionSetNode $selectionSet, Type $parentType, array &$implementors) : array
    {
        $fields       = [];
        $implementors = [];
        foreach ($selectionSet->selections as $selectionNode) {
            if ($selectionNode instanceof FieldNode) {
                $fieldName = $selectionNode->name->value;

                if ($fieldName === Introspection::TYPE_NAME_FIELD_NAME) {
                    continue;
                }

                $type          = $parentType->getField($fieldName);
                $selectionType = $type->getType();

                $subfields       = [];
                $subImplementors = [];
                if ($selectionNode->selectionSet) {
                    $subfields = $this->analyzeSubFields($selectionType, $selectionNode->selectionSet, $subImplementors);
                }

                $fields[$fieldName] = [
                    'type' => $selectionType,
                    'fields' => $subfields ?? [],
                    'args' => Values::getArgumentValues($type, $selectionNode, $this->variableValues),
                ];
                if ($this->groupImplementorFields && $subImplementors) {
                    $fields[$fieldName]['implementors'] = $subImplementors;
                }
            } elseif ($selectionNode instanceof FragmentSpreadNode) {
                $spreadName = $selectionNode->name->value;
                if (isset($this->fragments[$spreadName])) {
                    $fragment  = $this->fragments[$spreadName];
                    $type      = $this->schema->getType($fragment->typeCondition->name->value);
                    $subfields = $this->analyzeSubFields($type, $fragment->selectionSet);
                    $fields    = $this->mergeFields($parentType, $type, $fields, $subfields, $implementors);
                }
            } elseif ($selectionNode instanceof InlineFragmentNode) {
                $type      = $this->schema->getType($selectionNode->typeCondition->name->value);
                $subfields = $this->analyzeSubFields($type, $selectionNode->selectionSet);
                $fields    = $this->mergeFields($parentType, $type, $fields, $subfields, $implementors);
            }
        }

        return $fields;
    }

    /**
     * @param mixed[] $implementors
     *
     * @return mixed[]
     */
    private function analyzeSubFields(Type $type, SelectionSetNode $selectionSet, array &$implementors = []) : array
    {
        if ($type instanceof WrappingType) {
            $type = $type->getWrappedType(true);
        }

        $subfields = [];
        if ($type instanceof ObjectType || $type instanceof AbstractType) {
            $subfields                = $this->analyzeSelectionSet($selectionSet, $type, $implementors);
            $this->types[$type->name] = array_unique(array_merge(
                array_key_exists($type->name, $this->types) ? $this->types[$type->name] : [],
                array_keys($subfields)
            ));
        }

        return $subfields;
    }

    /**
     * @param mixed[] $fields
     * @param mixed[] $subfields
     * @param mixed[] $implementors
     *
     * @return mixed[]
     */
    private function mergeFields(Type $parentType, Type $type, array $fields, array $subfields, array &$implementors) : array
    {
        if ($this->groupImplementorFields && $parentType instanceof AbstractType && ! $type instanceof AbstractType) {
            $implementors[$type->name] = [
                'type'   => $type,
                'fields' => $this->arrayMergeDeep(
                    $implementors[$type->name]['fields'] ?? [],
                    array_diff_key($subfields, $fields)
                ),
            ];

            $fields = $this->arrayMergeDeep(
                $fields,
                array_intersect_key($subfields, $fields)
            );
        } else {
            $fields = $this->arrayMergeDeep(
                $subfields,
                $fields
            );
        }

        return $fields;
    }

    /**
     * similar to array_merge_recursive this merges nested arrays, but handles non array values differently
     * while array_merge_recursive tries to merge non array values, in this implementation they will be overwritten
     *
     * @see https://stackoverflow.com/a/25712428
     *
     * @param mixed[] $array1
     * @param mixed[] $array2
     *
     * @return mixed[]
     */
    private function arrayMergeDeep(array $array1, array $array2) : array
    {
        $merged = $array1;

        foreach ($array2 as $key => & $value) {
            if (is_numeric($key)) {
                if (! in_array($value, $merged, true)) {
                    $merged[] = $value;
                }
            } elseif (is_array($value) && isset($merged[$key]) && is_array($merged[$key])) {
                $merged[$key] = $this->arrayMergeDeep($merged[$key], $value);
            } else {
                $merged[$key] = $value;
            }
        }

        return $merged;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\ResolveInfo.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\FragmentDefinitionNode;
use GraphQL\Language\AST\FragmentSpreadNode;
use GraphQL\Language\AST\InlineFragmentNode;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Language\AST\SelectionSetNode;
use GraphQL\Type\Schema;
use function array_merge_recursive;

/**
 * Structure containing information useful for field resolution process.
 *
 * Passed as 4th argument to every field resolver. See [docs on field resolving (data fetching)](data-fetching.md).
 */
class ResolveInfo
{
    /**
     * The definition of the field being resolved.
     *
     * @api
     * @var FieldDefinition
     */
    public $fieldDefinition;

    /**
     * The name of the field being resolved.
     *
     * @api
     * @var string
     */
    public $fieldName;

    /**
     * Expected return type of the field being resolved.
     *
     * @api
     * @var Type
     */
    public $returnType;

    /**
     * AST of all nodes referencing this field in the query.
     *
     * @api
     * @var FieldNode[]
     */
    public $fieldNodes = [];

    /**
     * Parent type of the field being resolved.
     *
     * @api
     * @var ObjectType
     */
    public $parentType;

    /**
     * Path to this field from the very root value.
     *
     * @api
     * @var string[]
     */
    public $path;

    /**
     * Instance of a schema used for execution.
     *
     * @api
     * @var Schema
     */
    public $schema;

    /**
     * AST of all fragments defined in query.
     *
     * @api
     * @var FragmentDefinitionNode[]
     */
    public $fragments = [];

    /**
     * Root value passed to query execution.
     *
     * @api
     * @var mixed
     */
    public $rootValue;

    /**
     * AST of operation definition node (query, mutation).
     *
     * @api
     * @var OperationDefinitionNode|null
     */
    public $operation;

    /**
     * Array of variables passed to query execution.
     *
     * @api
     * @var mixed[]
     */
    public $variableValues = [];

    /**
     * Lazily initialized.
     *
     * @var QueryPlan
     */
    private $queryPlan;

    /**
     * @param FieldNode[]              $fieldNodes
     * @param string[]                 $path
     * @param FragmentDefinitionNode[] $fragments
     * @param mixed|null               $rootValue
     * @param mixed[]                  $variableValues
     */
    public function __construct(
        FieldDefinition $fieldDefinition,
        iterable $fieldNodes,
        ObjectType $parentType,
        array $path,
        Schema $schema,
        array $fragments,
        $rootValue,
        ?OperationDefinitionNode $operation,
        array $variableValues
    ) {
        $this->fieldDefinition = $fieldDefinition;
        $this->fieldName       = $fieldDefinition->name;
        $this->returnType      = $fieldDefinition->getType();
        $this->fieldNodes      = $fieldNodes;
        $this->parentType      = $parentType;
        $this->path            = $path;
        $this->schema          = $schema;
        $this->fragments       = $fragments;
        $this->rootValue       = $rootValue;
        $this->operation       = $operation;
        $this->variableValues  = $variableValues;
    }

    /**
     * Helper method that returns names of all fields selected in query for
     * $this->fieldName up to $depth levels.
     *
     * Example:
     * query MyQuery{
     * {
     *   root {
     *     id,
     *     nested {
     *      nested1
     *      nested2 {
     *        nested3
     *      }
     *     }
     *   }
     * }
     *
     * Given this ResolveInfo instance is a part of "root" field resolution, and $depth === 1,
     * method will return:
     * [
     *     'id' => true,
     *     'nested' => [
     *         nested1 => true,
     *         nested2 => true
     *     ]
     * ]
     *
     * Warning: this method it is a naive implementation which does not take into account
     * conditional typed fragments. So use it with care for fields of interface and union types.
     *
     * @param int $depth How many levels to include in output
     *
     * @return array<string, mixed>
     *
     * @api
     */
    public function getFieldSelection($depth = 0)
    {
        $fields = [];

        /** @var FieldNode $fieldNode */
        foreach ($this->fieldNodes as $fieldNode) {
            if ($fieldNode->selectionSet === null) {
                continue;
            }

            $fields = array_merge_recursive(
                $fields,
                $this->foldSelectionSet($fieldNode->selectionSet, $depth)
            );
        }

        return $fields;
    }

    /**
     * @param mixed[] $options
     */
    public function lookAhead(array $options = []) : QueryPlan
    {
        if (! isset($this->queryPlan)) {
            $this->queryPlan = new QueryPlan(
                $this->parentType,
                $this->schema,
                $this->fieldNodes,
                $this->variableValues,
                $this->fragments,
                $options
            );
        }

        return $this->queryPlan;
    }

    /**
     * @return bool[]
     */
    private function foldSelectionSet(SelectionSetNode $selectionSet, int $descend) : array
    {
        $fields = [];
        foreach ($selectionSet->selections as $selectionNode) {
            if ($selectionNode instanceof FieldNode) {
                $fields[$selectionNode->name->value] = $descend > 0 && $selectionNode->selectionSet !== null
                    ? $this->foldSelectionSet($selectionNode->selectionSet, $descend - 1)
                    : true;
            } elseif ($selectionNode instanceof FragmentSpreadNode) {
                $spreadName = $selectionNode->name->value;
                if (isset($this->fragments[$spreadName])) {
                    /** @var FragmentDefinitionNode $fragment */
                    $fragment = $this->fragments[$spreadName];
                    $fields   = array_merge_recursive(
                        $this->foldSelectionSet($fragment->selectionSet, $descend),
                        $fields
                    );
                }
            } elseif ($selectionNode instanceof InlineFragmentNode) {
                $fields = array_merge_recursive(
                    $this->foldSelectionSet($selectionNode->selectionSet, $descend),
                    $fields
                );
            }
        }

        return $fields;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\ScalarType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use GraphQL\Language\AST\ScalarTypeDefinitionNode;
use GraphQL\Language\AST\ScalarTypeExtensionNode;
use GraphQL\Utils\Utils;
use function is_string;

/**
 * Scalar Type Definition
 *
 * The leaf values of any request and input values to arguments are
 * Scalars (or Enums) and are defined with a name and a series of coercion
 * functions used to ensure validity.
 *
 * Example:
 *
 * class OddType extends ScalarType
 * {
 *     public $name = 'Odd',
 *     public function serialize($value)
 *     {
 *         return $value % 2 === 1 ? $value : null;
 *     }
 * }
 */
abstract class ScalarType extends Type implements OutputType, InputType, LeafType, NullableType, NamedType
{
    /** @var ScalarTypeDefinitionNode|null */
    public $astNode;

    /** @var ScalarTypeExtensionNode[] */
    public $extensionASTNodes;

    /**
     * @param mixed[] $config
     */
    public function __construct(array $config = [])
    {
        $this->name              = $config['name'] ?? $this->tryInferName();
        $this->description       = $config['description'] ?? $this->description;
        $this->astNode           = $config['astNode'] ?? null;
        $this->extensionASTNodes = $config['extensionASTNodes'] ?? null;
        $this->config            = $config;

        Utils::invariant(is_string($this->name), 'Must provide name.');
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\StringType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use Exception;
use GraphQL\Error\Error;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\StringValueNode;
use GraphQL\Utils\Utils;
use function is_object;
use function is_scalar;
use function is_string;
use function method_exists;

class StringType extends ScalarType
{
    /** @var string */
    public $name = Type::STRING;

    /** @var string */
    public $description =
        'The `String` scalar type represents textual data, represented as UTF-8
character sequences. The String type is most often used by GraphQL to
represent free-form human-readable text.';

    /**
     * @param mixed $value
     *
     * @return mixed|string
     *
     * @throws Error
     */
    public function serialize($value)
    {
        $canCast = is_scalar($value)
            || (is_object($value) && method_exists($value, '__toString'))
            || $value === null;

        if (! $canCast) {
            throw new Error(
                'String cannot represent value: ' . Utils::printSafe($value)
            );
        }

        return (string) $value;
    }

    /**
     * @param mixed $value
     *
     * @return string
     *
     * @throws Error
     */
    public function parseValue($value)
    {
        if (! is_string($value)) {
            throw new Error(
                'String cannot represent a non string value: ' . Utils::printSafe($value)
            );
        }

        return $value;
    }

    /**
     * @param mixed[]|null $variables
     *
     * @return string
     *
     * @throws Exception
     */
    public function parseLiteral(Node $valueNode, ?array $variables = null)
    {
        if ($valueNode instanceof StringValueNode) {
            return $valueNode->value;
        }

        // Intentionally without message, as all information already in wrapped Exception
        throw new Error();
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\Type.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use GraphQL\Error\InvariantViolation;
use GraphQL\Language\AST\TypeDefinitionNode;
use GraphQL\Language\AST\TypeExtensionNode;
use GraphQL\Type\Introspection;
use GraphQL\Utils\Utils;
use JsonSerializable;
use ReflectionClass;
use ReturnTypeWillChange;
use function array_keys;
use function array_merge;
use function assert;
use function implode;
use function in_array;
use function preg_replace;
use function trigger_error;
use const E_USER_DEPRECATED;

/**
 * Registry of standard GraphQL types
 * and a base class for all other types.
 */
abstract class Type implements JsonSerializable
{
    public const STRING  = 'String';
    public const INT     = 'Int';
    public const BOOLEAN = 'Boolean';
    public const FLOAT   = 'Float';
    public const ID      = 'ID';

    /** @var array<string, ScalarType> */
    protected static $standardTypes;

    /** @var Type[] */
    private static $builtInTypes;

    /** @var string */
    public $name;

    /** @var string|null */
    public $description;

    /** @var TypeDefinitionNode|null */
    public $astNode;

    /** @var mixed[] */
    public $config;

    /** @var TypeExtensionNode[] */
    public $extensionASTNodes;

    /**
     * @api
     */
    public static function id() : ScalarType
    {
        if (! isset(static::$standardTypes[self::ID])) {
            static::$standardTypes[self::ID] = new IDType();
        }

        return static::$standardTypes[self::ID];
    }

    /**
     * @api
     */
    public static function string() : ScalarType
    {
        if (! isset(static::$standardTypes[self::STRING])) {
            static::$standardTypes[self::STRING] = new StringType();
        }

        return static::$standardTypes[self::STRING];
    }

    /**
     * @api
     */
    public static function boolean() : ScalarType
    {
        if (! isset(static::$standardTypes[self::BOOLEAN])) {
            static::$standardTypes[self::BOOLEAN] = new BooleanType();
        }

        return static::$standardTypes[self::BOOLEAN];
    }

    /**
     * @api
     */
    public static function int() : ScalarType
    {
        if (! isset(static::$standardTypes[self::INT])) {
            static::$standardTypes[self::INT] = new IntType();
        }

        return static::$standardTypes[self::INT];
    }

    /**
     * @api
     */
    public static function float() : ScalarType
    {
        if (! isset(static::$standardTypes[self::FLOAT])) {
            static::$standardTypes[self::FLOAT] = new FloatType();
        }

        return static::$standardTypes[self::FLOAT];
    }

    /**
     * @api
     */
    public static function listOf(Type $wrappedType) : ListOfType
    {
        return new ListOfType($wrappedType);
    }

    /**
     * @param callable|NullableType $wrappedType
     *
     * @api
     */
    public static function nonNull($wrappedType) : NonNull
    {
        return new NonNull($wrappedType);
    }

    /**
     * Checks if the type is a builtin type
     */
    public static function isBuiltInType(Type $type) : bool
    {
        return in_array($type->name, array_keys(self::getAllBuiltInTypes()), true);
    }

    /**
     * Returns all builtin in types including base scalar and
     * introspection types
     *
     * @return Type[]
     */
    public static function getAllBuiltInTypes()
    {
        if (self::$builtInTypes === null) {
            self::$builtInTypes = array_merge(
                Introspection::getTypes(),
                self::getStandardTypes()
            );
        }

        return self::$builtInTypes;
    }

    /**
     * Returns all builtin scalar types
     *
     * @return ScalarType[]
     */
    public static function getStandardTypes()
    {
        return [
            self::ID => static::id(),
            self::STRING => static::string(),
            self::FLOAT => static::float(),
            self::INT => static::int(),
            self::BOOLEAN => static::boolean(),
        ];
    }

    /**
     * @deprecated Use method getStandardTypes() instead
     *
     * @return Type[]
     *
     * @codeCoverageIgnore
     */
    public static function getInternalTypes()
    {
        trigger_error(__METHOD__ . ' is deprecated. Use Type::getStandardTypes() instead', E_USER_DEPRECATED);

        return self::getStandardTypes();
    }

    /**
     * @param array<string, ScalarType> $types
     */
    public static function overrideStandardTypes(array $types)
    {
        $standardTypes = self::getStandardTypes();
        foreach ($types as $type) {
            Utils::invariant(
                $type instanceof Type,
                'Expecting instance of %s, got %s',
                self::class,
                Utils::printSafe($type)
            );
            Utils::invariant(
                isset($type->name, $standardTypes[$type->name]),
                'Expecting one of the following names for a standard type: %s, got %s',
                implode(', ', array_keys($standardTypes)),
                Utils::printSafe($type->name ?? null)
            );
            static::$standardTypes[$type->name] = $type;
        }
    }

    /**
     * @param Type $type
     *
     * @api
     */
    public static function isInputType($type) : bool
    {
        return self::getNamedType($type) instanceof InputType;
    }

    /**
     * @param Type $type
     *
     * @api
     */
    public static function getNamedType($type) : ?Type
    {
        if ($type === null) {
            return null;
        }
        while ($type instanceof WrappingType) {
            $type = $type->getWrappedType();
        }

        return $type;
    }

    /**
     * @param Type $type
     *
     * @api
     */
    public static function isOutputType($type) : bool
    {
        return self::getNamedType($type) instanceof OutputType;
    }

    /**
     * @param Type $type
     *
     * @api
     */
    public static function isLeafType($type) : bool
    {
        return $type instanceof LeafType;
    }

    /**
     * @param Type $type
     *
     * @api
     */
    public static function isCompositeType($type) : bool
    {
        return $type instanceof CompositeType;
    }

    /**
     * @param Type $type
     *
     * @api
     */
    public static function isAbstractType($type) : bool
    {
        return $type instanceof AbstractType;
    }

    /**
     * @param mixed $type
     */
    public static function assertType($type) : Type
    {
        assert($type instanceof Type, new InvariantViolation('Expected ' . Utils::printSafe($type) . ' to be a GraphQL type.'));

        return $type;
    }

    /**
     * @api
     */
    public static function getNullableType(Type $type) : Type
    {
        return $type instanceof NonNull
            ? $type->getWrappedType()
            : $type;
    }

    /**
     * @throws InvariantViolation
     */
    public function assertValid()
    {
        Utils::assertValidName($this->name);
    }

    /**
     * @return string
     */
    #[ReturnTypeWillChange]
    public function jsonSerialize()
    {
        return $this->toString();
    }

    /**
     * @return string
     */
    public function toString()
    {
        return $this->name;
    }

    /**
     * @return string
     */
    public function __toString()
    {
        return $this->toString();
    }

    /**
     * @return string|null
     */
    protected function tryInferName()
    {
        if ($this->name) {
            return $this->name;
        }

        // If class is extended - infer name from className
        // QueryType -> Type
        // SomeOtherType -> SomeOther
        $tmp  = new ReflectionClass($this);
        $name = $tmp->getShortName();

        if ($tmp->getNamespaceName() !== __NAMESPACE__) {
            return preg_replace('~Type$~', '', $name);
        }

        return null;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\TypeWithFields.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use GraphQL\Utils\Utils;
use function array_keys;

abstract class TypeWithFields extends Type implements HasFieldsType
{
    /**
     * Lazily initialized.
     *
     * @var array<string, FieldDefinition>
     */
    private $fields;

    private function initializeFields() : void
    {
        if (isset($this->fields)) {
            return;
        }

        $fields       = $this->config['fields'] ?? [];
        $this->fields = FieldDefinition::defineFieldMap($this, $fields);
    }

    public function getField(string $name) : FieldDefinition
    {
        Utils::invariant($this->hasField($name), 'Field "%s" is not defined for type "%s"', $name, $this->name);

        return $this->findField($name);
    }

    public function findField(string $name) : ?FieldDefinition
    {
        $this->initializeFields();

        if (! isset($this->fields[$name])) {
            return null;
        }

        if ($this->fields[$name] instanceof UnresolvedFieldDefinition) {
            $this->fields[$name] = $this->fields[$name]->resolve();
        }

        return $this->fields[$name];
    }

    public function hasField(string $name) : bool
    {
        $this->initializeFields();

        return isset($this->fields[$name]);
    }

    /** @inheritDoc */
    public function getFields() : array
    {
        $this->initializeFields();

        foreach ($this->fields as $name => $field) {
            if (! ($field instanceof UnresolvedFieldDefinition)) {
                continue;
            }

            $this->fields[$name] = $field->resolve();
        }

        return $this->fields;
    }

    /** @inheritDoc */
    public function getFieldNames() : array
    {
        $this->initializeFields();

        return array_keys($this->fields);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\UnionType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use GraphQL\Error\InvariantViolation;
use GraphQL\Language\AST\UnionTypeDefinitionNode;
use GraphQL\Language\AST\UnionTypeExtensionNode;
use GraphQL\Type\Schema;
use GraphQL\Utils\Utils;
use function is_array;
use function is_callable;
use function is_string;
use function sprintf;

class UnionType extends Type implements AbstractType, OutputType, CompositeType, NullableType, NamedType
{
    /** @var UnionTypeDefinitionNode */
    public $astNode;

    /**
     * Lazily initialized.
     *
     * @var ObjectType[]
     */
    private $types;

    /**
     * Lazily initialized.
     *
     * @var array<string, bool>
     */
    private $possibleTypeNames;

    /** @var UnionTypeExtensionNode[] */
    public $extensionASTNodes;

    /**
     * @param mixed[] $config
     */
    public function __construct(array $config)
    {
        if (! isset($config['name'])) {
            $config['name'] = $this->tryInferName();
        }

        Utils::invariant(is_string($config['name']), 'Must provide name.');

        /**
         * Optionally provide a custom type resolver function. If one is not provided,
         * the default implementation will call `isTypeOf` on each implementing
         * Object type.
         */
        $this->name              = $config['name'];
        $this->description       = $config['description'] ?? null;
        $this->astNode           = $config['astNode'] ?? null;
        $this->extensionASTNodes = $config['extensionASTNodes'] ?? null;
        $this->config            = $config;
    }

    public function isPossibleType(Type $type) : bool
    {
        if (! $type instanceof ObjectType) {
            return false;
        }

        if (! isset($this->possibleTypeNames)) {
            $this->possibleTypeNames = [];
            foreach ($this->getTypes() as $possibleType) {
                $this->possibleTypeNames[$possibleType->name] = true;
            }
        }

        return isset($this->possibleTypeNames[$type->name]);
    }

    /**
     * @return ObjectType[]
     *
     * @throws InvariantViolation
     */
    public function getTypes() : array
    {
        if (! isset($this->types)) {
            $types = $this->config['types'] ?? null;
            if (is_callable($types)) {
                $types = $types();
            }

            if (! is_array($types)) {
                throw new InvariantViolation(
                    sprintf(
                        'Must provide Array of types or a callable which returns such an array for Union %s',
                        $this->name
                    )
                );
            }

            $rawTypes = $types;
            foreach ($rawTypes as $i => $rawType) {
                $rawTypes[$i] = Schema::resolveType($rawType);
            }

            $this->types = $rawTypes;
        }

        return $this->types;
    }

    /**
     * Resolves concrete ObjectType for given object value
     *
     * @param object $objectValue
     * @param mixed  $context
     *
     * @return callable|null
     */
    public function resolveType($objectValue, $context, ResolveInfo $info)
    {
        if (isset($this->config['resolveType'])) {
            $fn = $this->config['resolveType'];

            return $fn($objectValue, $context, $info);
        }

        return null;
    }

    /**
     * @throws InvariantViolation
     */
    public function assertValid() : void
    {
        parent::assertValid();

        if (! isset($this->config['resolveType'])) {
            return;
        }

        Utils::invariant(
            is_callable($this->config['resolveType']),
            sprintf(
                '%s must provide "resolveType" as a function, but got: %s',
                $this->name,
                Utils::printSafe($this->config['resolveType'])
            )
        );
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\UnmodifiedType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

/*
export type GraphQLUnmodifiedType =
GraphQLScalarType |
GraphQLObjectType |
GraphQLInterfaceType |
GraphQLUnionType |
GraphQLEnumType |
GraphQLInputObjectType;
*/

interface UnmodifiedType
{
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\UnresolvedFieldDefinition.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

use GraphQL\Error\InvariantViolation;
use function is_array;
use function sprintf;

class UnresolvedFieldDefinition
{
    /** @var Type $type */
    private $type;

    /** @var string $name */
    private $name;

    /** @var callable(): (FieldDefinition|array<string, mixed>|Type) $resolver */
    private $resolver;

    /**
     * @param callable(): (FieldDefinition|array<string, mixed>|Type) $resolver
     */
    public function __construct(Type $type, string $name, callable $resolver)
    {
        $this->type     = $type;
        $this->name     = $name;
        $this->resolver = $resolver;
    }

    public function getName() : string
    {
        return $this->name;
    }

    public function resolve() : FieldDefinition
    {
        $field = ($this->resolver)();

        if ($field instanceof FieldDefinition) {
            if ($field->name !== $this->name) {
                throw new InvariantViolation(
                    sprintf('%s.%s should not dynamically change its name when resolved lazily.', $this->type->name, $this->name)
                );
            }

            return $field;
        }

        if (! is_array($field)) {
            return FieldDefinition::create(['name' => $this->name, 'type' => $field]);
        }

        if (! isset($field['name'])) {
            $field['name'] = $this->name;
        } elseif ($field['name'] !== $this->name) {
            throw new InvariantViolation(
                sprintf('%s.%s should not dynamically change its name when resolved lazily.', $this->type->name, $this->name)
            );
        }

        if (isset($field['args']) && ! is_array($field['args'])) {
            throw new InvariantViolation(
                sprintf('%s.%s args must be an array.', $this->type->name, $this->name)
            );
        }

        return FieldDefinition::create($field);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Definition\WrappingType.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Definition;

interface WrappingType
{
    public function getWrappedType(bool $recurse = false) : Type;
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Type\Validation\InputObjectCircularRefs.php
<?php

declare(strict_types=1);

namespace GraphQL\Type\Validation;

use GraphQL\Language\AST\InputValueDefinitionNode;
use GraphQL\Type\Definition\InputObjectField;
use GraphQL\Type\Definition\InputObjectType;
use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\SchemaValidationContext;
use function array_map;
use function array_pop;
use function array_slice;
use function count;
use function implode;

class InputObjectCircularRefs
{
    /** @var SchemaValidationContext */
    private $schemaValidationContext;

    /**
     * Tracks already visited types to maintain O(N) and to ensure that cycles
     * are not redundantly reported.
     *
     * @var array<string, bool>
     */
    private $visitedTypes = [];

    /** @var InputObjectField[] */
    private $fieldPath = [];

    /**
     * Position in the type path.
     *
     * [string $typeName => int $index]
     *
     * @var int[]
     */
    private $fieldPathIndexByTypeName = [];

    public function __construct(SchemaValidationContext $schemaValidationContext)
    {
        $this->schemaValidationContext = $schemaValidationContext;
    }

    /**
     * This does a straight-forward DFS to find cycles.
     * It does not terminate when a cycle was found but continues to explore
     * the graph to find all possible cycles.
     */
    public function validate(InputObjectType $inputObj) : void
    {
        if (isset($this->visitedTypes[$inputObj->name])) {
            return;
        }

        $this->visitedTypes[$inputObj->name]             = true;
        $this->fieldPathIndexByTypeName[$inputObj->name] = count($this->fieldPath);

        $fieldMap = $inputObj->getFields();
        foreach ($fieldMap as $fieldName => $field) {
            $type = $field->getType();

            if ($type instanceof NonNull) {
                $fieldType = $type->getWrappedType();

                // If the type of the field is anything else then a non-nullable input object,
                // there is no chance of an unbreakable cycle
                if ($fieldType instanceof InputObjectType) {
                    $this->fieldPath[] = $field;

                    if (! isset($this->fieldPathIndexByTypeName[$fieldType->name])) {
                        $this->validate($fieldType);
                    } else {
                        $cycleIndex = $this->fieldPathIndexByTypeName[$fieldType->name];
                        $cyclePath  = array_slice($this->fieldPath, $cycleIndex);
                        $fieldNames = array_map(
                            static function (InputObjectField $field) : string {
                                return $field->name;
                            },
                            $cyclePath
                        );

                        $this->schemaValidationContext->reportError(
                            'Cannot reference Input Object "' . $fieldType->name . '" within itself '
                            . 'through a series of non-null fields: "' . implode('.', $fieldNames) . '".',
                            array_map(
                                static function (InputObjectField $field) : ?InputValueDefinitionNode {
                                    return $field->astNode;
                                },
                                $cyclePath
                            )
                        );
                    }
                }
            }

            array_pop($this->fieldPath);
        }

        unset($this->fieldPathIndexByTypeName[$inputObj->name]);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Utils\AST.php
<?php

declare(strict_types=1);

namespace GraphQL\Utils;

use ArrayAccess;
use Exception;
use GraphQL\Error\DebugFlag;
use GraphQL\Error\Error;
use GraphQL\Error\InvariantViolation;
use GraphQL\Language\AST\BooleanValueNode;
use GraphQL\Language\AST\DocumentNode;
use GraphQL\Language\AST\EnumValueNode;
use GraphQL\Language\AST\FloatValueNode;
use GraphQL\Language\AST\IntValueNode;
use GraphQL\Language\AST\ListTypeNode;
use GraphQL\Language\AST\ListValueNode;
use GraphQL\Language\AST\Location;
use GraphQL\Language\AST\NamedTypeNode;
use GraphQL\Language\AST\NameNode;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\NodeList;
use GraphQL\Language\AST\NonNullTypeNode;
use GraphQL\Language\AST\NullValueNode;
use GraphQL\Language\AST\ObjectFieldNode;
use GraphQL\Language\AST\ObjectValueNode;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Language\AST\StringValueNode;
use GraphQL\Language\AST\ValueNode;
use GraphQL\Language\AST\VariableNode;
use GraphQL\Type\Definition\EnumType;
use GraphQL\Type\Definition\IDType;
use GraphQL\Type\Definition\InputObjectType;
use GraphQL\Type\Definition\InputType;
use GraphQL\Type\Definition\ListOfType;
use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\Definition\ScalarType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Schema;
use stdClass;
use Throwable;
use Traversable;
use function array_combine;
use function array_key_exists;
use function array_map;
use function count;
use function floatval;
use function intval;
use function is_array;
use function is_bool;
use function is_float;
use function is_int;
use function is_object;
use function is_string;
use function iterator_to_array;
use function property_exists;

/**
 * Various utilities dealing with AST
 */
class AST
{
    /**
     * Convert representation of AST as an associative array to instance of GraphQL\Language\AST\Node.
     *
     * For example:
     *
     * ```php
     * AST::fromArray([
     *     'kind' => 'ListValue',
     *     'values' => [
     *         ['kind' => 'StringValue', 'value' => 'my str'],
     *         ['kind' => 'StringValue', 'value' => 'my other str']
     *     ],
     *     'loc' => ['start' => 21, 'end' => 25]
     * ]);
     * ```
     *
     * Will produce instance of `ListValueNode` where `values` prop is a lazily-evaluated `NodeList`
     * returning instances of `StringValueNode` on access.
     *
     * This is a reverse operation for AST::toArray($node)
     *
     * @param mixed[] $node
     *
     * @api
     */
    public static function fromArray(array $node) : Node
    {
        if (! isset($node['kind']) || ! isset(NodeKind::$classMap[$node['kind']])) {
            throw new InvariantViolation('Unexpected node structure: ' . Utils::printSafeJson($node));
        }

        $kind     = $node['kind'] ?? null;
        $class    = NodeKind::$classMap[$kind];
        $instance = new $class([]);

        if (isset($node['loc'], $node['loc']['start'], $node['loc']['end'])) {
            $instance->loc = Location::create($node['loc']['start'], $node['loc']['end']);
        }

        foreach ($node as $key => $value) {
            if ($key === 'loc' || $key === 'kind') {
                continue;
            }
            if (is_array($value)) {
                if (isset($value[0]) || count($value) === 0) {
                    $value = new NodeList($value);
                } else {
                    $value = self::fromArray($value);
                }
            }
            $instance->{$key} = $value;
        }

        return $instance;
    }

    /**
     * Convert AST node to serializable array
     *
     * @return mixed[]
     *
     * @api
     */
    public static function toArray(Node $node) : array
    {
        return $node->toArray(true);
    }

    /**
     * Produces a GraphQL Value AST given a PHP value.
     *
     * Optionally, a GraphQL type may be provided, which will be used to
     * disambiguate between value primitives.
     *
     * | PHP Value     | GraphQL Value        |
     * | ------------- | -------------------- |
     * | Object        | Input Object         |
     * | Assoc Array   | Input Object         |
     * | Array         | List                 |
     * | Boolean       | Boolean              |
     * | String        | String / Enum Value  |
     * | Int           | Int                  |
     * | Float         | Int / Float          |
     * | Mixed         | Enum Value           |
     * | null          | NullValue            |
     *
     * @param Type|mixed|null $value
     *
     * @return ObjectValueNode|ListValueNode|BooleanValueNode|IntValueNode|FloatValueNode|EnumValueNode|StringValueNode|NullValueNode|null
     *
     * @api
     */
    public static function astFromValue($value, InputType $type)
    {
        if ($type instanceof NonNull) {
            $astValue = self::astFromValue($value, $type->getWrappedType());
            if ($astValue instanceof NullValueNode) {
                return null;
            }

            return $astValue;
        }

        if ($value === null) {
            return new NullValueNode([]);
        }

        // Convert PHP array to GraphQL list. If the GraphQLType is a list, but
        // the value is not an array, convert the value using the list's item type.
        if ($type instanceof ListOfType) {
            $itemType = $type->getWrappedType();
            if (is_array($value) || ($value instanceof Traversable)) {
                $valuesNodes = [];
                foreach ($value as $item) {
                    $itemNode = self::astFromValue($item, $itemType);
                    if (! $itemNode) {
                        continue;
                    }

                    $valuesNodes[] = $itemNode;
                }

                return new ListValueNode(['values' => new NodeList($valuesNodes)]);
            }

            return self::astFromValue($value, $itemType);
        }

        // Populate the fields of the input object by creating ASTs from each value
        // in the PHP object according to the fields in the input type.
        if ($type instanceof InputObjectType) {
            $isArray     = is_array($value);
            $isArrayLike = $isArray || $value instanceof ArrayAccess;
            if ($value === null || (! $isArrayLike && ! is_object($value))) {
                return null;
            }
            $fields     = $type->getFields();
            $fieldNodes = [];
            foreach ($fields as $fieldName => $field) {
                if ($isArrayLike) {
                    $fieldValue = $value[$fieldName] ?? null;
                } else {
                    $fieldValue = $value->{$fieldName} ?? null;
                }

                // Have to check additionally if key exists, since we differentiate between
                // "no key" and "value is null":
                if ($fieldValue !== null) {
                    $fieldExists = true;
                } elseif ($isArray) {
                    $fieldExists = array_key_exists($fieldName, $value);
                } elseif ($isArrayLike) {
                    $fieldExists = $value->offsetExists($fieldName);
                } else {
                    $fieldExists = property_exists($value, $fieldName);
                }

                if (! $fieldExists) {
                    continue;
                }

                $fieldNode = self::astFromValue($fieldValue, $field->getType());

                if (! $fieldNode) {
                    continue;
                }

                $fieldNodes[] = new ObjectFieldNode([
                    'name'  => new NameNode(['value' => $fieldName]),
                    'value' => $fieldNode,
                ]);
            }

            return new ObjectValueNode(['fields' => new NodeList($fieldNodes)]);
        }

        if ($type instanceof ScalarType || $type instanceof EnumType) {
            // Since value is an internally represented value, it must be serialized
            // to an externally represented value before converting into an AST.
            try {
                $serialized = $type->serialize($value);
            } catch (Throwable $error) {
                if ($error instanceof Error && $type instanceof EnumType) {
                    return null;
                }
                throw $error;
            }

            // Others serialize based on their corresponding PHP scalar types.
            if (is_bool($serialized)) {
                return new BooleanValueNode(['value' => $serialized]);
            }
            if (is_int($serialized)) {
                return new IntValueNode(['value' => (string) $serialized]);
            }
            if (is_float($serialized)) {
                // int cast with == used for performance reasons
                if ((int) $serialized == $serialized) {
                    return new IntValueNode(['value' => (string) $serialized]);
                }

                return new FloatValueNode(['value' => (string) $serialized]);
            }
            if (is_string($serialized)) {
                // Enum types use Enum literals.
                if ($type instanceof EnumType) {
                    return new EnumValueNode(['value' => $serialized]);
                }

                // ID types can use Int literals.
                $asInt = (int) $serialized;
                if ($type instanceof IDType && (string) $asInt === $serialized) {
                    return new IntValueNode(['value' => $serialized]);
                }

                // Use json_encode, which uses the same string encoding as GraphQL,
                // then remove the quotes.
                return new StringValueNode(['value' => $serialized]);
            }

            throw new InvariantViolation('Cannot convert value to AST: ' . Utils::printSafe($serialized));
        }

        throw new Error('Unknown type: ' . Utils::printSafe($type) . '.');
    }

    /**
     * Produces a PHP value given a GraphQL Value AST.
     *
     * A GraphQL type must be provided, which will be used to interpret different
     * GraphQL Value literals.
     *
     * Returns `null` when the value could not be validly coerced according to
     * the provided type.
     *
     * | GraphQL Value        | PHP Value     |
     * | -------------------- | ------------- |
     * | Input Object         | Assoc Array   |
     * | List                 | Array         |
     * | Boolean              | Boolean       |
     * | String               | String        |
     * | Int / Float          | Int / Float   |
     * | Enum Value           | Mixed         |
     * | Null Value           | null          |
     *
     * @param VariableNode|NullValueNode|IntValueNode|FloatValueNode|StringValueNode|BooleanValueNode|EnumValueNode|ListValueNode|ObjectValueNode|null $valueNode
     * @param mixed[]|null                                                                                                                             $variables
     *
     * @return mixed[]|stdClass|null
     *
     * @throws Exception
     *
     * @api
     */
    public static function valueFromAST(?ValueNode $valueNode, Type $type, ?array $variables = null)
    {
        $undefined = Utils::undefined();

        if ($valueNode === null) {
            // When there is no AST, then there is also no value.
            // Importantly, this is different from returning the GraphQL null value.
            return $undefined;
        }

        if ($type instanceof NonNull) {
            if ($valueNode instanceof NullValueNode) {
                // Invalid: intentionally return no value.
                return $undefined;
            }

            return self::valueFromAST($valueNode, $type->getWrappedType(), $variables);
        }

        if ($valueNode instanceof NullValueNode) {
            // This is explicitly returning the value null.
            return null;
        }

        if ($valueNode instanceof VariableNode) {
            $variableName = $valueNode->name->value;

            if (! $variables || ! array_key_exists($variableName, $variables)) {
                // No valid return value.
                return $undefined;
            }

            $variableValue = $variables[$variableName] ?? null;
            if ($variableValue === null && $type instanceof NonNull) {
                return $undefined; // Invalid: intentionally return no value.
            }

            // Note: This does no further checking that this variable is correct.
            // This assumes that this query has been validated and the variable
            // usage here is of the correct type.
            return $variables[$variableName];
        }

        if ($type instanceof ListOfType) {
            $itemType = $type->getWrappedType();

            if ($valueNode instanceof ListValueNode) {
                $coercedValues = [];
                $itemNodes     = $valueNode->values;
                foreach ($itemNodes as $itemNode) {
                    if (self::isMissingVariable($itemNode, $variables)) {
                        // If an array contains a missing variable, it is either coerced to
                        // null or if the item type is non-null, it considered invalid.
                        if ($itemType instanceof NonNull) {
                            // Invalid: intentionally return no value.
                            return $undefined;
                        }
                        $coercedValues[] = null;
                    } else {
                        $itemValue = self::valueFromAST($itemNode, $itemType, $variables);
                        if ($undefined === $itemValue) {
                            // Invalid: intentionally return no value.
                            return $undefined;
                        }
                        $coercedValues[] = $itemValue;
                    }
                }

                return $coercedValues;
            }
            $coercedValue = self::valueFromAST($valueNode, $itemType, $variables);
            if ($undefined === $coercedValue) {
                // Invalid: intentionally return no value.
                return $undefined;
            }

            return [$coercedValue];
        }

        if ($type instanceof InputObjectType) {
            if (! $valueNode instanceof ObjectValueNode) {
                // Invalid: intentionally return no value.
                return $undefined;
            }

            $coercedObj = [];
            $fields     = $type->getFields();
            $fieldNodes = Utils::keyMap(
                $valueNode->fields,
                static function ($field) {
                    return $field->name->value;
                }
            );
            foreach ($fields as $field) {
                $fieldName = $field->name;
                /** @var VariableNode|NullValueNode|IntValueNode|FloatValueNode|StringValueNode|BooleanValueNode|EnumValueNode|ListValueNode|ObjectValueNode $fieldNode */
                $fieldNode = $fieldNodes[$fieldName] ?? null;

                if ($fieldNode === null || self::isMissingVariable($fieldNode->value, $variables)) {
                    if ($field->defaultValueExists()) {
                        $coercedObj[$fieldName] = $field->defaultValue;
                    } elseif ($field->getType() instanceof NonNull) {
                        // Invalid: intentionally return no value.
                        return $undefined;
                    }
                    continue;
                }

                $fieldValue = self::valueFromAST(
                    $fieldNode !== null ? $fieldNode->value : null,
                    $field->getType(),
                    $variables
                );

                if ($undefined === $fieldValue) {
                    // Invalid: intentionally return no value.
                    return $undefined;
                }
                $coercedObj[$fieldName] = $fieldValue;
            }

            return $coercedObj;
        }

        if ($type instanceof EnumType) {
            if (! $valueNode instanceof EnumValueNode) {
                return $undefined;
            }
            $enumValue = $type->getValue($valueNode->value);
            if (! $enumValue) {
                return $undefined;
            }

            return $enumValue->value;
        }

        if ($type instanceof ScalarType) {
            // Scalars fulfill parsing a literal value via parseLiteral().
            // Invalid values represent a failure to parse correctly, in which case
            // no value is returned.
            try {
                return $type->parseLiteral($valueNode, $variables);
            } catch (Throwable $error) {
                return $undefined;
            }
        }

        throw new Error('Unknown type: ' . Utils::printSafe($type) . '.');
    }

    /**
     * Returns true if the provided valueNode is a variable which is not defined
     * in the set of variables.
     *
     * @param VariableNode|NullValueNode|IntValueNode|FloatValueNode|StringValueNode|BooleanValueNode|EnumValueNode|ListValueNode|ObjectValueNode $valueNode
     * @param mixed[]                                                                                                                             $variables
     *
     * @return bool
     */
    private static function isMissingVariable(ValueNode $valueNode, $variables)
    {
        return $valueNode instanceof VariableNode &&
            (count($variables) === 0 || ! array_key_exists($valueNode->name->value, $variables));
    }

    /**
     * Produces a PHP value given a GraphQL Value AST.
     *
     * Unlike `valueFromAST()`, no type is provided. The resulting PHP value
     * will reflect the provided GraphQL value AST.
     *
     * | GraphQL Value        | PHP Value     |
     * | -------------------- | ------------- |
     * | Input Object         | Assoc Array   |
     * | List                 | Array         |
     * | Boolean              | Boolean       |
     * | String               | String        |
     * | Int / Float          | Int / Float   |
     * | Enum                 | Mixed         |
     * | Null                 | null          |
     *
     * @param Node         $valueNode
     * @param mixed[]|null $variables
     *
     * @return mixed
     *
     * @throws Exception
     *
     * @api
     */
    public static function valueFromASTUntyped($valueNode, ?array $variables = null)
    {
        switch (true) {
            case $valueNode instanceof NullValueNode:
                return null;
            case $valueNode instanceof IntValueNode:
                return (int) $valueNode->value;
            case $valueNode instanceof FloatValueNode:
                return (float) $valueNode->value;
            case $valueNode instanceof StringValueNode:
            case $valueNode instanceof EnumValueNode:
            case $valueNode instanceof BooleanValueNode:
                return $valueNode->value;
            case $valueNode instanceof ListValueNode:
                return array_map(
                    static function ($node) use ($variables) {
                        return self::valueFromASTUntyped($node, $variables);
                    },
                    iterator_to_array($valueNode->values)
                );
            case $valueNode instanceof ObjectValueNode:
                return array_combine(
                    array_map(
                        static function ($field) : string {
                            return $field->name->value;
                        },
                        iterator_to_array($valueNode->fields)
                    ),
                    array_map(
                        static function ($field) use ($variables) {
                            return self::valueFromASTUntyped($field->value, $variables);
                        },
                        iterator_to_array($valueNode->fields)
                    )
                );
            case $valueNode instanceof VariableNode:
                $variableName = $valueNode->name->value;

                return $variables && isset($variables[$variableName])
                    ? $variables[$variableName]
                    : null;
        }

        throw new Error('Unexpected value kind: ' . $valueNode->kind . '.');
    }

    /**
     * Returns type definition for given AST Type node
     *
     * @param NamedTypeNode|ListTypeNode|NonNullTypeNode $inputTypeNode
     *
     * @return Type|null
     *
     * @throws Exception
     *
     * @api
     */
    public static function typeFromAST(Schema $schema, $inputTypeNode)
    {
        if ($inputTypeNode instanceof ListTypeNode) {
            $innerType = self::typeFromAST($schema, $inputTypeNode->type);

            return $innerType ? new ListOfType($innerType) : null;
        }
        if ($inputTypeNode instanceof NonNullTypeNode) {
            $innerType = self::typeFromAST($schema, $inputTypeNode->type);

            return $innerType ? new NonNull($innerType) : null;
        }
        if ($inputTypeNode instanceof NamedTypeNode) {
            return $schema->getType($inputTypeNode->name->value);
        }

        throw new Error('Unexpected type kind: ' . $inputTypeNode->kind . '.');
    }

    /**
     * @deprecated use getOperationAST instead.
     *
     * Returns operation type ("query", "mutation" or "subscription") given a document and operation name
     *
     * @param string $operationName
     *
     * @return bool|string
     *
     * @api
     */
    public static function getOperation(DocumentNode $document, $operationName = null)
    {
        if ($document->definitions) {
            foreach ($document->definitions as $def) {
                if (! ($def instanceof OperationDefinitionNode)) {
                    continue;
                }

                if (! $operationName || (isset($def->name->value) && $def->name->value === $operationName)) {
                    return $def->operation;
                }
            }
        }

        return false;
    }

    /**
     * Returns the operation within a document by name.
     *
     * If a name is not provided, an operation is only returned if the document has exactly one.
     *
     * @api
     */
    public static function getOperationAST(DocumentNode $document, ?string $operationName = null) : ?OperationDefinitionNode
    {
        $operation = null;
        foreach ($document->definitions->getIterator() as $node) {
            if (! $node instanceof OperationDefinitionNode) {
                continue;
            }

            if ($operationName === null) {
                // We found a second operation, so we bail instead of returning an ambiguous result.
                if ($operation !== null) {
                    return null;
                }
                $operation = $node;
            } elseif ($node->name instanceof NameNode && $node->name->value === $operationName) {
                return $node;
            }
        }

        return $operation;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Utils\ASTDefinitionBuilder.php
<?php

declare(strict_types=1);

namespace GraphQL\Utils;

use GraphQL\Error\Error;
use GraphQL\Executor\Values;
use GraphQL\Language\AST\DirectiveDefinitionNode;
use GraphQL\Language\AST\EnumTypeDefinitionNode;
use GraphQL\Language\AST\EnumValueDefinitionNode;
use GraphQL\Language\AST\FieldDefinitionNode;
use GraphQL\Language\AST\InputObjectTypeDefinitionNode;
use GraphQL\Language\AST\InputValueDefinitionNode;
use GraphQL\Language\AST\InterfaceTypeDefinitionNode;
use GraphQL\Language\AST\ListTypeNode;
use GraphQL\Language\AST\NamedTypeNode;
use GraphQL\Language\AST\NameNode;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\NodeList;
use GraphQL\Language\AST\NonNullTypeNode;
use GraphQL\Language\AST\ObjectTypeDefinitionNode;
use GraphQL\Language\AST\ScalarTypeDefinitionNode;
use GraphQL\Language\AST\TypeDefinitionNode;
use GraphQL\Language\AST\TypeNode;
use GraphQL\Language\AST\UnionTypeDefinitionNode;
use GraphQL\Language\Token;
use GraphQL\Type\Definition\CustomScalarType;
use GraphQL\Type\Definition\Directive;
use GraphQL\Type\Definition\EnumType;
use GraphQL\Type\Definition\FieldArgument;
use GraphQL\Type\Definition\InputObjectType;
use GraphQL\Type\Definition\InterfaceType;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Definition\UnionType;
use Throwable;
use function array_reverse;
use function implode;
use function is_array;
use function is_string;
use function sprintf;

class ASTDefinitionBuilder
{
    /** @var array<string, Node&TypeDefinitionNode> */
    private $typeDefinitionsMap;

    /** @var callable */
    private $typeConfigDecorator;

    /** @var array<string, bool> */
    private $options;

    /** @var callable */
    private $resolveType;

    /** @var array<string, Type> */
    private $cache;

    /**
     * code sniffer doesn't understand this syntax. Pr with a fix here: waiting on https://github.com/squizlabs/PHP_CodeSniffer/pull/2919
     * @param array<string, Node&TypeDefinitionNode> $typeDefinitionsMap
     * @param array<string, bool> $options
     */
    public function __construct(
        array $typeDefinitionsMap,
        array $options,
        callable $resolveType,
        ?callable $typeConfigDecorator = null
    ) {
        $this->typeDefinitionsMap  = $typeDefinitionsMap;
        $this->typeConfigDecorator = $typeConfigDecorator;
        $this->options             = $options;
        $this->resolveType         = $resolveType;

        $this->cache = Type::getAllBuiltInTypes();
    }

    public function buildDirective(DirectiveDefinitionNode $directiveNode) : Directive
    {
        return new Directive([
            'name'         => $directiveNode->name->value,
            'description'  => $this->getDescription($directiveNode),
            'args'         => FieldArgument::createMap($this->makeInputValues($directiveNode->arguments)),
            'isRepeatable' => $directiveNode->repeatable,
            'locations'    => Utils::map(
                $directiveNode->locations,
                static function (NameNode $node) : string {
                    return $node->value;
                }
            ),
            'astNode'      => $directiveNode,
        ]);
    }

    /**
     * Given an ast node, returns its string description.
     */
    private function getDescription(Node $node) : ?string
    {
        if (isset($node->description)) {
            return $node->description->value;
        }

        if (isset($this->options['commentDescriptions'])) {
            $rawValue = $this->getLeadingCommentBlock($node);
            if ($rawValue !== null) {
                return BlockString::value("\n" . $rawValue);
            }
        }

        return null;
    }

    private function getLeadingCommentBlock(Node $node) : ?string
    {
        $loc = $node->loc;
        if ($loc === null || $loc->startToken === null) {
            return null;
        }

        $comments = [];
        $token    = $loc->startToken->prev;
        while ($token !== null
            && $token->kind === Token::COMMENT
            && $token->next !== null
            && $token->prev !== null
            && $token->line + 1 === $token->next->line
            && $token->line !== $token->prev->line
        ) {
            $value      = $token->value;
            $comments[] = $value;
            $token      = $token->prev;
        }

        return implode("\n", array_reverse($comments));
    }

    /**
     * @return array<string, array<string, mixed>>
     */
    private function makeInputValues(NodeList $values) : array
    {
        return Utils::keyValMap(
            $values,
            static function (InputValueDefinitionNode $value) : string {
                return $value->name->value;
            },
            function (InputValueDefinitionNode $value) : array {
                // Note: While this could make assertions to get the correctly typed
                // value, that would throw immediately while type system validation
                // with validateSchema() will produce more actionable results.
                $type = $this->buildWrappedType($value->type);

                $config = [
                    'name'        => $value->name->value,
                    'type'        => $type,
                    'description' => $this->getDescription($value),
                    'astNode'     => $value,
                ];
                if (isset($value->defaultValue)) {
                    $config['defaultValue'] = AST::valueFromAST($value->defaultValue, $type);
                }

                return $config;
            }
        );
    }

    private function buildWrappedType(TypeNode $typeNode) : Type
    {
        if ($typeNode instanceof ListTypeNode) {
            return Type::listOf($this->buildWrappedType($typeNode->type));
        }

        if ($typeNode instanceof NonNullTypeNode) {
            return Type::nonNull($this->buildWrappedType($typeNode->type));
        }

        return $this->buildType($typeNode);
    }

    /**
     * @param string|(Node &NamedTypeNode)|(Node&TypeDefinitionNode) $ref
     */
    public function buildType($ref) : Type
    {
        if (is_string($ref)) {
            return $this->internalBuildType($ref);
        }

        return $this->internalBuildType($ref->name->value, $ref);
    }

    /**
     * @param (Node &NamedTypeNode)|(Node&TypeDefinitionNode)|null $typeNode
     *
     * @throws Error
     */
    private function internalBuildType(string $typeName, ?Node $typeNode = null) : Type
    {
        if (! isset($this->cache[$typeName])) {
            if (isset($this->typeDefinitionsMap[$typeName])) {
                $type = $this->makeSchemaDef($this->typeDefinitionsMap[$typeName]);
                if ($this->typeConfigDecorator) {
                    $fn = $this->typeConfigDecorator;
                    try {
                        $config = $fn($type->config, $this->typeDefinitionsMap[$typeName], $this->typeDefinitionsMap);
                    } catch (Throwable $e) {
                        throw new Error(
                            sprintf('Type config decorator passed to %s threw an error ', static::class) .
                            sprintf('when building %s type: %s', $typeName, $e->getMessage()),
                            null,
                            null,
                            [],
                            null,
                            $e
                        );
                    }
                    if (! is_array($config) || isset($config[0])) {
                        throw new Error(
                            sprintf(
                                'Type config decorator passed to %s is expected to return an array, but got %s',
                                static::class,
                                Utils::getVariableType($config)
                            )
                        );
                    }
                    $type = $this->makeSchemaDefFromConfig($this->typeDefinitionsMap[$typeName], $config);
                }
                $this->cache[$typeName] = $type;
            } else {
                $fn                     = $this->resolveType;
                $this->cache[$typeName] = $fn($typeName, $typeNode);
            }
        }

        return $this->cache[$typeName];
    }

    /**
     * @param ObjectTypeDefinitionNode|InterfaceTypeDefinitionNode|EnumTypeDefinitionNode|ScalarTypeDefinitionNode|InputObjectTypeDefinitionNode|UnionTypeDefinitionNode $def
     *
     * @return CustomScalarType|EnumType|InputObjectType|InterfaceType|ObjectType|UnionType
     *
     * @throws Error
     */
    private function makeSchemaDef(Node $def) : Type
    {
        switch (true) {
            case $def instanceof ObjectTypeDefinitionNode:
                return $this->makeTypeDef($def);
            case $def instanceof InterfaceTypeDefinitionNode:
                return $this->makeInterfaceDef($def);
            case $def instanceof EnumTypeDefinitionNode:
                return $this->makeEnumDef($def);
            case $def instanceof UnionTypeDefinitionNode:
                return $this->makeUnionDef($def);
            case $def instanceof ScalarTypeDefinitionNode:
                return $this->makeScalarDef($def);
            case $def instanceof InputObjectTypeDefinitionNode:
                return $this->makeInputObjectDef($def);
            default:
                throw new Error(sprintf('Type kind of %s not supported.', $def->kind));
        }
    }

    private function makeTypeDef(ObjectTypeDefinitionNode $def) : ObjectType
    {
        return new ObjectType([
            'name'        => $def->name->value,
            'description' => $this->getDescription($def),
            'fields'      => function () use ($def) : array {
                return $this->makeFieldDefMap($def);
            },
            'interfaces'  => function () use ($def) : array {
                return $this->makeImplementedInterfaces($def);
            },
            'astNode'     => $def,
        ]);
    }

    /**
     * @param ObjectTypeDefinitionNode|InterfaceTypeDefinitionNode $def
     *
     * @return array<string, array<string, mixed>>
     */
    private function makeFieldDefMap(Node $def) : array
    {
        return Utils::keyValMap(
            $def->fields,
            static function (FieldDefinitionNode $field) : string {
                return $field->name->value;
            },
            function (FieldDefinitionNode $field) : array {
                return $this->buildField($field);
            }
        );
    }

    /**
     * @return array<string, mixed>
     */
    public function buildField(FieldDefinitionNode $field) : array
    {
        return [
            // Note: While this could make assertions to get the correctly typed
            // value, that would throw immediately while type system validation
            // with validateSchema() will produce more actionable results.
            'type'              => $this->buildWrappedType($field->type),
            'description'       => $this->getDescription($field),
            'args'              => $this->makeInputValues($field->arguments),
            'deprecationReason' => $this->getDeprecationReason($field),
            'astNode'           => $field,
        ];
    }

    /**
     * Given a collection of directives, returns the string value for the
     * deprecation reason.
     *
     * @param EnumValueDefinitionNode|FieldDefinitionNode $node
     */
    private function getDeprecationReason(Node $node) : ?string
    {
        $deprecated = Values::getDirectiveValues(
            Directive::deprecatedDirective(),
            $node
        );

        return $deprecated['reason'] ?? null;
    }

    /**
     * @param ObjectTypeDefinitionNode|InterfaceTypeDefinitionNode $def
     *
     * @return array<int, Type>
     */
    private function makeImplementedInterfaces($def) : array
    {
        // Note: While this could make early assertions to get the correctly
        // typed values, that would throw immediately while type system
        // validation with validateSchema() will produce more actionable results.
        return Utils::map(
            $def->interfaces,
            function (NamedTypeNode $iface) : Type {
                return $this->buildType($iface);
            }
        );
    }

    private function makeInterfaceDef(InterfaceTypeDefinitionNode $def) : InterfaceType
    {
        return new InterfaceType([
            'name'        => $def->name->value,
            'description' => $this->getDescription($def),
            'fields'      => function () use ($def) : array {
                return $this->makeFieldDefMap($def);
            },
            'interfaces'  => function () use ($def) : array {
                return $this->makeImplementedInterfaces($def);
            },
            'astNode'     => $def,
        ]);
    }

    private function makeEnumDef(EnumTypeDefinitionNode $def) : EnumType
    {
        return new EnumType([
            'name'        => $def->name->value,
            'description' => $this->getDescription($def),
            'values'      => Utils::keyValMap(
                $def->values,
                static function ($enumValue) {
                    return $enumValue->name->value;
                },
                function ($enumValue) : array {
                    return [
                        'description'       => $this->getDescription($enumValue),
                        'deprecationReason' => $this->getDeprecationReason($enumValue),
                        'astNode'           => $enumValue,
                    ];
                }
            ),
            'astNode'     => $def,
        ]);
    }

    private function makeUnionDef(UnionTypeDefinitionNode $def) : UnionType
    {
        return new UnionType([
            'name'        => $def->name->value,
            'description' => $this->getDescription($def),
            // Note: While this could make assertions to get the correctly typed
            // values below, that would throw immediately while type system
            // validation with validateSchema() will produce more actionable results.
            'types'       => function () use ($def) : array {
                return Utils::map(
                    $def->types,
                    function ($typeNode) : Type {
                        return $this->buildType($typeNode);
                    }
                );
            },
            'astNode'     => $def,
        ]);
    }

    private function makeScalarDef(ScalarTypeDefinitionNode $def) : CustomScalarType
    {
        return new CustomScalarType([
            'name'        => $def->name->value,
            'description' => $this->getDescription($def),
            'astNode'     => $def,
            'serialize'   => static function ($value) {
                return $value;
            },
        ]);
    }

    private function makeInputObjectDef(InputObjectTypeDefinitionNode $def) : InputObjectType
    {
        return new InputObjectType([
            'name'        => $def->name->value,
            'description' => $this->getDescription($def),
            'fields'      => function () use ($def) : array {
                return $this->makeInputValues($def->fields);
            },
            'astNode'     => $def,
        ]);
    }

    /**
     * @param array<string, mixed> $config
     *
     * @return CustomScalarType|EnumType|InputObjectType|InterfaceType|ObjectType|UnionType
     *
     * @throws Error
     */
    private function makeSchemaDefFromConfig(Node $def, array $config) : Type
    {
        switch (true) {
            case $def instanceof ObjectTypeDefinitionNode:
                return new ObjectType($config);
            case $def instanceof InterfaceTypeDefinitionNode:
                return new InterfaceType($config);
            case $def instanceof EnumTypeDefinitionNode:
                return new EnumType($config);
            case $def instanceof UnionTypeDefinitionNode:
                return new UnionType($config);
            case $def instanceof ScalarTypeDefinitionNode:
                return new CustomScalarType($config);
            case $def instanceof InputObjectTypeDefinitionNode:
                return new InputObjectType($config);
            default:
                throw new Error(sprintf('Type kind of %s not supported.', $def->kind));
        }
    }

    /**
     * @return array<string, mixed>
     */
    public function buildInputField(InputValueDefinitionNode $value) : array
    {
        $type = $this->buildWrappedType($value->type);

        $config = [
            'name' => $value->name->value,
            'type' => $type,
            'description' => $this->getDescription($value),
            'astNode' => $value,
        ];

        if ($value->defaultValue !== null) {
            $config['defaultValue'] = $value->defaultValue;
        }

        return $config;
    }

    /**
     * @return array<string, mixed>
     */
    public function buildEnumValue(EnumValueDefinitionNode $value) : array
    {
        return [
            'description' => $this->getDescription($value),
            'deprecationReason' => $this->getDeprecationReason($value),
            'astNode' => $value,
        ];
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Utils\BlockString.php
<?php

declare(strict_types=1);

namespace GraphQL\Utils;

use function array_pop;
use function array_shift;
use function count;
use function implode;
use function mb_strlen;
use function mb_substr;
use function preg_split;
use function trim;

class BlockString
{
    /**
     * Produces the value of a block string from its parsed raw value, similar to
     * Coffeescript's block string, Python's docstring trim or Ruby's strip_heredoc.
     *
     * This implements the GraphQL spec's BlockStringValue() static algorithm.
     */
    public static function value($rawString)
    {
        // Expand a block string's raw value into independent lines.
        $lines = preg_split("/\\r\\n|[\\n\\r]/", $rawString);

        // Remove common indentation from all lines but first.
        $commonIndent = null;
        $linesLength  = count($lines);

        for ($i = 1; $i < $linesLength; $i++) {
            $line   = $lines[$i];
            $indent = self::leadingWhitespace($line);

            if ($indent >= mb_strlen($line) ||
                ($commonIndent !== null && $indent >= $commonIndent)
            ) {
                continue;
            }

            $commonIndent = $indent;
            if ($commonIndent === 0) {
                break;
            }
        }

        if ($commonIndent) {
            for ($i = 1; $i < $linesLength; $i++) {
                $line      = $lines[$i];
                $lines[$i] = mb_substr($line, $commonIndent);
            }
        }

        // Remove leading and trailing blank lines.
        while (count($lines) > 0 && trim($lines[0], " \t") === '') {
            array_shift($lines);
        }
        while (count($lines) > 0 && trim($lines[count($lines) - 1], " \t") === '') {
            array_pop($lines);
        }

        // Return a string of the lines joined with U+000A.
        return implode("\n", $lines);
    }

    private static function leadingWhitespace($str)
    {
        $i = 0;
        while ($i < mb_strlen($str) && ($str[$i] === ' ' || $str[$i] === '\t')) {
            $i++;
        }

        return $i;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Utils\BreakingChangesFinder.php
<?php

declare(strict_types=1);

/**
 * Utility for finding breaking/dangerous changes between two schemas.
 */

namespace GraphQL\Utils;

use GraphQL\Type\Definition\Directive;
use GraphQL\Type\Definition\EnumType;
use GraphQL\Type\Definition\FieldArgument;
use GraphQL\Type\Definition\ImplementingType;
use GraphQL\Type\Definition\InputObjectType;
use GraphQL\Type\Definition\InterfaceType;
use GraphQL\Type\Definition\ListOfType;
use GraphQL\Type\Definition\NamedType;
use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\ScalarType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Definition\UnionType;
use GraphQL\Type\Schema;
use TypeError;
use function array_flip;
use function array_key_exists;
use function array_keys;
use function array_merge;
use function class_alias;
use function sprintf;

class BreakingChangesFinder
{
    public const BREAKING_CHANGE_FIELD_CHANGED_KIND            = 'FIELD_CHANGED_KIND';
    public const BREAKING_CHANGE_FIELD_REMOVED                 = 'FIELD_REMOVED';
    public const BREAKING_CHANGE_TYPE_CHANGED_KIND             = 'TYPE_CHANGED_KIND';
    public const BREAKING_CHANGE_TYPE_REMOVED                  = 'TYPE_REMOVED';
    public const BREAKING_CHANGE_TYPE_REMOVED_FROM_UNION       = 'TYPE_REMOVED_FROM_UNION';
    public const BREAKING_CHANGE_VALUE_REMOVED_FROM_ENUM       = 'VALUE_REMOVED_FROM_ENUM';
    public const BREAKING_CHANGE_ARG_REMOVED                   = 'ARG_REMOVED';
    public const BREAKING_CHANGE_ARG_CHANGED_KIND              = 'ARG_CHANGED_KIND';
    public const BREAKING_CHANGE_REQUIRED_ARG_ADDED            = 'REQUIRED_ARG_ADDED';
    public const BREAKING_CHANGE_REQUIRED_INPUT_FIELD_ADDED    = 'REQUIRED_INPUT_FIELD_ADDED';
    public const BREAKING_CHANGE_IMPLEMENTED_INTERFACE_REMOVED = 'IMPLEMENTED_INTERFACE_REMOVED';
    public const BREAKING_CHANGE_DIRECTIVE_REMOVED             = 'DIRECTIVE_REMOVED';
    public const BREAKING_CHANGE_DIRECTIVE_ARG_REMOVED         = 'DIRECTIVE_ARG_REMOVED';
    public const BREAKING_CHANGE_DIRECTIVE_LOCATION_REMOVED    = 'DIRECTIVE_LOCATION_REMOVED';
    public const BREAKING_CHANGE_REQUIRED_DIRECTIVE_ARG_ADDED  = 'REQUIRED_DIRECTIVE_ARG_ADDED';
    public const DANGEROUS_CHANGE_ARG_DEFAULT_VALUE_CHANGED    = 'ARG_DEFAULT_VALUE_CHANGE';
    public const DANGEROUS_CHANGE_VALUE_ADDED_TO_ENUM          = 'VALUE_ADDED_TO_ENUM';
    public const DANGEROUS_CHANGE_IMPLEMENTED_INTERFACE_ADDED  = 'IMPLEMENTED_INTERFACE_ADDED';
    public const DANGEROUS_CHANGE_TYPE_ADDED_TO_UNION          = 'TYPE_ADDED_TO_UNION';
    public const DANGEROUS_CHANGE_OPTIONAL_INPUT_FIELD_ADDED   = 'OPTIONAL_INPUT_FIELD_ADDED';
    public const DANGEROUS_CHANGE_OPTIONAL_ARG_ADDED           = 'OPTIONAL_ARG_ADDED';
    /** @deprecated use BREAKING_CHANGE_IMPLEMENTED_INTERFACE_REMOVED instead, will be removed in v15.0.0. */
    public const BREAKING_CHANGE_INTERFACE_REMOVED_FROM_OBJECT = 'IMPLEMENTED_INTERFACE_REMOVED';
    /** @deprecated use DANGEROUS_CHANGE_IMPLEMENTED_INTERFACE_ADDED instead, will be removed in v15.0.0. */
    public const DANGEROUS_CHANGE_INTERFACE_ADDED_TO_OBJECT = 'IMPLEMENTED_INTERFACE_ADDED';

    /**
     * Given two schemas, returns an Array containing descriptions of all the types
     * of breaking changes covered by the other functions down below.
     *
     * @return string[][]
     */
    public static function findBreakingChanges(Schema $oldSchema, Schema $newSchema)
    {
        return array_merge(
            self::findRemovedTypes($oldSchema, $newSchema),
            self::findTypesThatChangedKind($oldSchema, $newSchema),
            self::findFieldsThatChangedTypeOnObjectOrInterfaceTypes($oldSchema, $newSchema),
            self::findFieldsThatChangedTypeOnInputObjectTypes($oldSchema, $newSchema)['breakingChanges'],
            self::findTypesRemovedFromUnions($oldSchema, $newSchema),
            self::findValuesRemovedFromEnums($oldSchema, $newSchema),
            self::findArgChanges($oldSchema, $newSchema)['breakingChanges'],
            self::findInterfacesRemovedFromObjectTypes($oldSchema, $newSchema),
            self::findRemovedDirectives($oldSchema, $newSchema),
            self::findRemovedDirectiveArgs($oldSchema, $newSchema),
            self::findAddedNonNullDirectiveArgs($oldSchema, $newSchema),
            self::findRemovedDirectiveLocations($oldSchema, $newSchema)
        );
    }

    /**
     * Given two schemas, returns an Array containing descriptions of any breaking
     * changes in the newSchema related to removing an entire type.
     *
     * @return string[][]
     */
    public static function findRemovedTypes(
        Schema $oldSchema,
        Schema $newSchema
    ) {
        $oldTypeMap = $oldSchema->getTypeMap();
        $newTypeMap = $newSchema->getTypeMap();

        $breakingChanges = [];
        foreach (array_keys($oldTypeMap) as $typeName) {
            if (isset($newTypeMap[$typeName])) {
                continue;
            }

            $breakingChanges[] = [
                'type'        => self::BREAKING_CHANGE_TYPE_REMOVED,
                'description' => $typeName . ' was removed.',
            ];
        }

        return $breakingChanges;
    }

    /**
     * Given two schemas, returns an Array containing descriptions of any breaking
     * changes in the newSchema related to changing the type of a type.
     *
     * @return string[][]
     */
    public static function findTypesThatChangedKind(
        Schema $schemaA,
        Schema $schemaB
    ) : iterable {
        $schemaATypeMap = $schemaA->getTypeMap();
        $schemaBTypeMap = $schemaB->getTypeMap();

        $breakingChanges = [];
        foreach ($schemaATypeMap as $typeName => $schemaAType) {
            if (! isset($schemaBTypeMap[$typeName])) {
                continue;
            }
            $schemaBType = $schemaBTypeMap[$typeName];
            if ($schemaAType instanceof $schemaBType) {
                continue;
            }

            if ($schemaBType instanceof $schemaAType) {
                continue;
            }

            $schemaATypeKindName = self::typeKindName($schemaAType);
            $schemaBTypeKindName = self::typeKindName($schemaBType);
            $breakingChanges[]   = [
                'type'        => self::BREAKING_CHANGE_TYPE_CHANGED_KIND,
                'description' => $typeName . ' changed from ' . $schemaATypeKindName . ' to ' . $schemaBTypeKindName . '.',
            ];
        }

        return $breakingChanges;
    }

    /**
     * @return string
     *
     * @throws TypeError
     */
    private static function typeKindName(Type $type)
    {
        if ($type instanceof ScalarType) {
            return 'a Scalar type';
        }

        if ($type instanceof ObjectType) {
            return 'an Object type';
        }

        if ($type instanceof InterfaceType) {
            return 'an Interface type';
        }

        if ($type instanceof UnionType) {
            return 'a Union type';
        }

        if ($type instanceof EnumType) {
            return 'an Enum type';
        }

        if ($type instanceof InputObjectType) {
            return 'an Input type';
        }

        throw new TypeError('unknown type ' . $type->name);
    }

    /**
     * @return string[][]
     */
    public static function findFieldsThatChangedTypeOnObjectOrInterfaceTypes(
        Schema $oldSchema,
        Schema $newSchema
    ) {
        $oldTypeMap = $oldSchema->getTypeMap();
        $newTypeMap = $newSchema->getTypeMap();

        $breakingChanges = [];
        foreach ($oldTypeMap as $typeName => $oldType) {
            $newType = $newTypeMap[$typeName] ?? null;
            if (! ($oldType instanceof ObjectType || $oldType instanceof InterfaceType) ||
                ! ($newType instanceof ObjectType || $newType instanceof InterfaceType) ||
                ! ($newType instanceof $oldType)
            ) {
                continue;
            }

            $oldTypeFieldsDef = $oldType->getFields();
            $newTypeFieldsDef = $newType->getFields();
            foreach ($oldTypeFieldsDef as $fieldName => $fieldDefinition) {
                // Check if the field is missing on the type in the new schema.
                if (! isset($newTypeFieldsDef[$fieldName])) {
                    $breakingChanges[] = [
                        'type'        => self::BREAKING_CHANGE_FIELD_REMOVED,
                        'description' => $typeName . '.' . $fieldName . ' was removed.',
                    ];
                } else {
                    $oldFieldType = $oldTypeFieldsDef[$fieldName]->getType();
                    $newFieldType = $newTypeFieldsDef[$fieldName]->getType();
                    $isSafe       = self::isChangeSafeForObjectOrInterfaceField(
                        $oldFieldType,
                        $newFieldType
                    );
                    if (! $isSafe) {
                        $oldFieldTypeString = $oldFieldType instanceof NamedType && $oldFieldType instanceof Type
                            ? $oldFieldType->name
                            : $oldFieldType;
                        $newFieldTypeString = $newFieldType instanceof NamedType && $newFieldType instanceof Type
                            ? $newFieldType->name
                            : $newFieldType;
                        $breakingChanges[]  = [
                            'type'        => self::BREAKING_CHANGE_FIELD_CHANGED_KIND,
                            'description' => $typeName . '.' . $fieldName . ' changed type from ' . $oldFieldTypeString . ' to ' . $newFieldTypeString . '.',
                        ];
                    }
                }
            }
        }

        return $breakingChanges;
    }

    /**
     * @return bool
     */
    private static function isChangeSafeForObjectOrInterfaceField(
        Type $oldType,
        Type $newType
    ) {
        if ($oldType instanceof NamedType) {
            return // if they're both named types, see if their names are equivalent
                ($newType instanceof NamedType && $oldType->name === $newType->name) ||
                // moving from nullable to non-null of the same underlying type is safe
                ($newType instanceof NonNull &&
                    self::isChangeSafeForObjectOrInterfaceField($oldType, $newType->getWrappedType())
                );
        }

        if ($oldType instanceof ListOfType) {
            return // if they're both lists, make sure the underlying types are compatible
                ($newType instanceof ListOfType &&
                    self::isChangeSafeForObjectOrInterfaceField(
                        $oldType->getWrappedType(),
                        $newType->getWrappedType()
                    )) ||
                // moving from nullable to non-null of the same underlying type is safe
                ($newType instanceof NonNull &&
                    self::isChangeSafeForObjectOrInterfaceField($oldType, $newType->getWrappedType()));
        }

        if ($oldType instanceof NonNull) {
            // if they're both non-null, make sure the underlying types are compatible
            return $newType instanceof NonNull &&
                self::isChangeSafeForObjectOrInterfaceField($oldType->getWrappedType(), $newType->getWrappedType());
        }

        return false;
    }

    /**
     * @return array<string, array<int, array<string, string>>>
     */
    public static function findFieldsThatChangedTypeOnInputObjectTypes(
        Schema $oldSchema,
        Schema $newSchema
    ) {
        $oldTypeMap = $oldSchema->getTypeMap();
        $newTypeMap = $newSchema->getTypeMap();

        $breakingChanges  = [];
        $dangerousChanges = [];
        foreach ($oldTypeMap as $typeName => $oldType) {
            $newType = $newTypeMap[$typeName] ?? null;
            if (! ($oldType instanceof InputObjectType) || ! ($newType instanceof InputObjectType)) {
                continue;
            }

            $oldTypeFieldsDef = $oldType->getFields();
            $newTypeFieldsDef = $newType->getFields();
            foreach (array_keys($oldTypeFieldsDef) as $fieldName) {
                if (! isset($newTypeFieldsDef[$fieldName])) {
                    $breakingChanges[] = [
                        'type'        => self::BREAKING_CHANGE_FIELD_REMOVED,
                        'description' => $typeName . '.' . $fieldName . ' was removed.',
                    ];
                } else {
                    $oldFieldType = $oldTypeFieldsDef[$fieldName]->getType();
                    $newFieldType = $newTypeFieldsDef[$fieldName]->getType();

                    $isSafe = self::isChangeSafeForInputObjectFieldOrFieldArg(
                        $oldFieldType,
                        $newFieldType
                    );
                    if (! $isSafe) {
                        if ($oldFieldType instanceof NamedType) {
                            $oldFieldTypeString = $oldFieldType->name;
                        } else {
                            $oldFieldTypeString = $oldFieldType;
                        }
                        if ($newFieldType instanceof NamedType) {
                            $newFieldTypeString = $newFieldType->name;
                        } else {
                            $newFieldTypeString = $newFieldType;
                        }
                        $breakingChanges[] = [
                            'type'        => self::BREAKING_CHANGE_FIELD_CHANGED_KIND,
                            'description' => $typeName . '.' . $fieldName . ' changed type from ' . $oldFieldTypeString . ' to ' . $newFieldTypeString . '.',
                        ];
                    }
                }
            }
            // Check if a field was added to the input object type
            foreach ($newTypeFieldsDef as $fieldName => $fieldDef) {
                if (isset($oldTypeFieldsDef[$fieldName])) {
                    continue;
                }

                $newTypeName = $newType->name;
                if ($fieldDef->isRequired()) {
                    $breakingChanges[] = [
                        'type'        => self::BREAKING_CHANGE_REQUIRED_INPUT_FIELD_ADDED,
                        'description' => 'A required field ' . $fieldName . ' on input type ' . $newTypeName . ' was added.',
                    ];
                } else {
                    $dangerousChanges[] = [
                        'type'        => self::DANGEROUS_CHANGE_OPTIONAL_INPUT_FIELD_ADDED,
                        'description' => 'An optional field ' . $fieldName . ' on input type ' . $newTypeName . ' was added.',
                    ];
                }
            }
        }

        return [
            'breakingChanges'  => $breakingChanges,
            'dangerousChanges' => $dangerousChanges,
        ];
    }

    /**
     * @return bool
     */
    private static function isChangeSafeForInputObjectFieldOrFieldArg(
        Type $oldType,
        Type $newType
    ) {
        if ($oldType instanceof NamedType) {
            if (! $newType instanceof NamedType) {
                return false;
            }

            // if they're both named types, see if their names are equivalent
            return $oldType->name === $newType->name;
        }

        if ($oldType instanceof ListOfType) {
            // if they're both lists, make sure the underlying types are compatible
            return $newType instanceof ListOfType &&
                self::isChangeSafeForInputObjectFieldOrFieldArg(
                    $oldType->getWrappedType(),
                    $newType->getWrappedType()
                );
        }

        if ($oldType instanceof NonNull) {
            return // if they're both non-null, make sure the underlying types are
                // compatible
                ($newType instanceof NonNull &&
                    self::isChangeSafeForInputObjectFieldOrFieldArg(
                        $oldType->getWrappedType(),
                        $newType->getWrappedType()
                    )) ||
                // moving from non-null to nullable of the same underlying type is safe
                ! ($newType instanceof NonNull) &&
                self::isChangeSafeForInputObjectFieldOrFieldArg($oldType->getWrappedType(), $newType);
        }

        return false;
    }

    /**
     * Given two schemas, returns an Array containing descriptions of any breaking
     * changes in the newSchema related to removing types from a union type.
     *
     * @return string[][]
     */
    public static function findTypesRemovedFromUnions(
        Schema $oldSchema,
        Schema $newSchema
    ) {
        $oldTypeMap = $oldSchema->getTypeMap();
        $newTypeMap = $newSchema->getTypeMap();

        $typesRemovedFromUnion = [];
        foreach ($oldTypeMap as $typeName => $oldType) {
            $newType = $newTypeMap[$typeName] ?? null;
            if (! ($oldType instanceof UnionType) || ! ($newType instanceof UnionType)) {
                continue;
            }
            $typeNamesInNewUnion = [];
            foreach ($newType->getTypes() as $type) {
                $typeNamesInNewUnion[$type->name] = true;
            }
            foreach ($oldType->getTypes() as $type) {
                if (isset($typeNamesInNewUnion[$type->name])) {
                    continue;
                }

                $typesRemovedFromUnion[] = [
                    'type'        => self::BREAKING_CHANGE_TYPE_REMOVED_FROM_UNION,
                    'description' => sprintf('%s was removed from union type %s.', $type->name, $typeName),
                ];
            }
        }

        return $typesRemovedFromUnion;
    }

    /**
     * Given two schemas, returns an Array containing descriptions of any breaking
     * changes in the newSchema related to removing values from an enum type.
     *
     * @return string[][]
     */
    public static function findValuesRemovedFromEnums(
        Schema $oldSchema,
        Schema $newSchema
    ) {
        $oldTypeMap = $oldSchema->getTypeMap();
        $newTypeMap = $newSchema->getTypeMap();

        $valuesRemovedFromEnums = [];
        foreach ($oldTypeMap as $typeName => $oldType) {
            $newType = $newTypeMap[$typeName] ?? null;
            if (! ($oldType instanceof EnumType) || ! ($newType instanceof EnumType)) {
                continue;
            }
            $valuesInNewEnum = [];
            foreach ($newType->getValues() as $value) {
                $valuesInNewEnum[$value->name] = true;
            }
            foreach ($oldType->getValues() as $value) {
                if (isset($valuesInNewEnum[$value->name])) {
                    continue;
                }

                $valuesRemovedFromEnums[] = [
                    'type'        => self::BREAKING_CHANGE_VALUE_REMOVED_FROM_ENUM,
                    'description' => sprintf('%s was removed from enum type %s.', $value->name, $typeName),
                ];
            }
        }

        return $valuesRemovedFromEnums;
    }

    /**
     * Given two schemas, returns an Array containing descriptions of any
     * breaking or dangerous changes in the newSchema related to arguments
     * (such as removal or change of type of an argument, or a change in an
     * argument's default value).
     *
     * @return array<string, array<int,array<string, string>>>
     */
    public static function findArgChanges(
        Schema $oldSchema,
        Schema $newSchema
    ) {
        $oldTypeMap = $oldSchema->getTypeMap();
        $newTypeMap = $newSchema->getTypeMap();

        $breakingChanges  = [];
        $dangerousChanges = [];

        foreach ($oldTypeMap as $typeName => $oldType) {
            $newType = $newTypeMap[$typeName] ?? null;
            if (! ($oldType instanceof ObjectType || $oldType instanceof InterfaceType) ||
                ! ($newType instanceof ObjectType || $newType instanceof InterfaceType) ||
                ! ($newType instanceof $oldType)
            ) {
                continue;
            }

            $oldTypeFields = $oldType->getFields();
            $newTypeFields = $newType->getFields();

            foreach ($oldTypeFields as $fieldName => $oldField) {
                if (! isset($newTypeFields[$fieldName])) {
                    continue;
                }

                foreach ($oldField->args as $oldArgDef) {
                    $newArgs   = $newTypeFields[$fieldName]->args;
                    $newArgDef = Utils::find(
                        $newArgs,
                        static function ($arg) use ($oldArgDef) : bool {
                            return $arg->name === $oldArgDef->name;
                        }
                    );
                    if ($newArgDef !== null) {
                        $isSafe = self::isChangeSafeForInputObjectFieldOrFieldArg(
                            $oldArgDef->getType(),
                            $newArgDef->getType()
                        );
                        /** @var ScalarType|EnumType|InputObjectType|ListOfType|NonNull $oldArgType */
                        $oldArgType = $oldArgDef->getType();
                        $oldArgName = $oldArgDef->name;
                        if (! $isSafe) {
                            $newArgType        = $newArgDef->getType();
                            $breakingChanges[] = [
                                'type'        => self::BREAKING_CHANGE_ARG_CHANGED_KIND,
                                'description' => $typeName . '.' . $fieldName . ' arg ' . $oldArgName . ' has changed type from ' . $oldArgType . ' to ' . $newArgType,
                            ];
                        } elseif ($oldArgDef->defaultValueExists() && $oldArgDef->defaultValue !== $newArgDef->defaultValue) {
                            $dangerousChanges[] = [
                                'type'        => self::DANGEROUS_CHANGE_ARG_DEFAULT_VALUE_CHANGED,
                                'description' => $typeName . '.' . $fieldName . ' arg ' . $oldArgName . ' has changed defaultValue',
                            ];
                        }
                    } else {
                        $breakingChanges[] = [
                            'type'        => self::BREAKING_CHANGE_ARG_REMOVED,
                            'description' => sprintf(
                                '%s.%s arg %s was removed',
                                $typeName,
                                $fieldName,
                                $oldArgDef->name
                            ),
                        ];
                    }
                    // Check if arg was added to the field
                    foreach ($newTypeFields[$fieldName]->args as $newTypeFieldArgDef) {
                        $oldArgs   = $oldTypeFields[$fieldName]->args;
                        $oldArgDef = Utils::find(
                            $oldArgs,
                            static function ($arg) use ($newTypeFieldArgDef) : bool {
                                return $arg->name === $newTypeFieldArgDef->name;
                            }
                        );

                        if ($oldArgDef !== null) {
                            continue;
                        }

                        $newTypeName = $newType->name;
                        $newArgName  = $newTypeFieldArgDef->name;
                        if ($newTypeFieldArgDef->isRequired()) {
                            $breakingChanges[] = [
                                'type'        => self::BREAKING_CHANGE_REQUIRED_ARG_ADDED,
                                'description' => 'A required arg ' . $newArgName . ' on ' . $newTypeName . '.' . $fieldName . ' was added',
                            ];
                        } else {
                            $dangerousChanges[] = [
                                'type'        => self::DANGEROUS_CHANGE_OPTIONAL_ARG_ADDED,
                                'description' => 'An optional arg ' . $newArgName . ' on ' . $newTypeName . '.' . $fieldName . ' was added',
                            ];
                        }
                    }
                }
            }
        }

        return [
            'breakingChanges'  => $breakingChanges,
            'dangerousChanges' => $dangerousChanges,
        ];
    }

    /**
     * @return string[][]
     */
    public static function findInterfacesRemovedFromObjectTypes(
        Schema $oldSchema,
        Schema $newSchema
    ) {
        $oldTypeMap      = $oldSchema->getTypeMap();
        $newTypeMap      = $newSchema->getTypeMap();
        $breakingChanges = [];

        foreach ($oldTypeMap as $typeName => $oldType) {
            $newType = $newTypeMap[$typeName] ?? null;
            if (! ($oldType instanceof ImplementingType) || ! ($newType instanceof ImplementingType)) {
                continue;
            }

            $oldInterfaces = $oldType->getInterfaces();
            $newInterfaces = $newType->getInterfaces();
            foreach ($oldInterfaces as $oldInterface) {
                $interface = Utils::find(
                    $newInterfaces,
                    static function (InterfaceType $interface) use ($oldInterface) : bool {
                        return $interface->name === $oldInterface->name;
                    }
                );
                if ($interface !== null) {
                    continue;
                }

                $breakingChanges[] = [
                    'type'        => self::BREAKING_CHANGE_IMPLEMENTED_INTERFACE_REMOVED,
                    'description' => sprintf('%s no longer implements interface %s.', $typeName, $oldInterface->name),
                ];
            }
        }

        return $breakingChanges;
    }

    /**
     * @return string[][]
     */
    public static function findRemovedDirectives(Schema $oldSchema, Schema $newSchema)
    {
        $removedDirectives = [];

        $newSchemaDirectiveMap = self::getDirectiveMapForSchema($newSchema);
        foreach ($oldSchema->getDirectives() as $directive) {
            if (isset($newSchemaDirectiveMap[$directive->name])) {
                continue;
            }

            $removedDirectives[] = [
                'type'        => self::BREAKING_CHANGE_DIRECTIVE_REMOVED,
                'description' => sprintf('%s was removed', $directive->name),
            ];
        }

        return $removedDirectives;
    }

    private static function getDirectiveMapForSchema(Schema $schema)
    {
        return Utils::keyMap(
            $schema->getDirectives(),
            static function ($dir) {
                return $dir->name;
            }
        );
    }

    public static function findRemovedDirectiveArgs(Schema $oldSchema, Schema $newSchema)
    {
        $removedDirectiveArgs  = [];
        $oldSchemaDirectiveMap = self::getDirectiveMapForSchema($oldSchema);

        foreach ($newSchema->getDirectives() as $newDirective) {
            if (! isset($oldSchemaDirectiveMap[$newDirective->name])) {
                continue;
            }

            foreach (self::findRemovedArgsForDirectives(
                $oldSchemaDirectiveMap[$newDirective->name],
                $newDirective
            ) as $arg) {
                $removedDirectiveArgs[] = [
                    'type'        => self::BREAKING_CHANGE_DIRECTIVE_ARG_REMOVED,
                    'description' => sprintf('%s was removed from %s', $arg->name, $newDirective->name),
                ];
            }
        }

        return $removedDirectiveArgs;
    }

    public static function findRemovedArgsForDirectives(Directive $oldDirective, Directive $newDirective)
    {
        $removedArgs = [];
        $newArgMap   = self::getArgumentMapForDirective($newDirective);
        foreach ($oldDirective->args as $arg) {
            if (isset($newArgMap[$arg->name])) {
                continue;
            }

            $removedArgs[] = $arg;
        }

        return $removedArgs;
    }

    private static function getArgumentMapForDirective(Directive $directive)
    {
        return Utils::keyMap(
            $directive->args ?? [],
            static function ($arg) {
                return $arg->name;
            }
        );
    }

    public static function findAddedNonNullDirectiveArgs(Schema $oldSchema, Schema $newSchema)
    {
        $addedNonNullableArgs  = [];
        $oldSchemaDirectiveMap = self::getDirectiveMapForSchema($oldSchema);

        foreach ($newSchema->getDirectives() as $newDirective) {
            if (! isset($oldSchemaDirectiveMap[$newDirective->name])) {
                continue;
            }

            foreach (self::findAddedArgsForDirective(
                $oldSchemaDirectiveMap[$newDirective->name],
                $newDirective
            ) as $arg) {
                if (! $arg->isRequired()) {
                    continue;
                }
                $addedNonNullableArgs[] = [
                    'type'        => self::BREAKING_CHANGE_REQUIRED_DIRECTIVE_ARG_ADDED,
                    'description' => sprintf(
                        'A required arg %s on directive %s was added',
                        $arg->name,
                        $newDirective->name
                    ),
                ];
            }
        }

        return $addedNonNullableArgs;
    }

    /**
     * @return FieldArgument[]
     */
    public static function findAddedArgsForDirective(Directive $oldDirective, Directive $newDirective)
    {
        $addedArgs = [];
        $oldArgMap = self::getArgumentMapForDirective($oldDirective);
        foreach ($newDirective->args as $arg) {
            if (isset($oldArgMap[$arg->name])) {
                continue;
            }

            $addedArgs[] = $arg;
        }

        return $addedArgs;
    }

    /**
     * @return string[][]
     */
    public static function findRemovedDirectiveLocations(Schema $oldSchema, Schema $newSchema)
    {
        $removedLocations      = [];
        $oldSchemaDirectiveMap = self::getDirectiveMapForSchema($oldSchema);

        foreach ($newSchema->getDirectives() as $newDirective) {
            if (! isset($oldSchemaDirectiveMap[$newDirective->name])) {
                continue;
            }

            foreach (self::findRemovedLocationsForDirective(
                $oldSchemaDirectiveMap[$newDirective->name],
                $newDirective
            ) as $location) {
                $removedLocations[] = [
                    'type'        => self::BREAKING_CHANGE_DIRECTIVE_LOCATION_REMOVED,
                    'description' => sprintf('%s was removed from %s', $location, $newDirective->name),
                ];
            }
        }

        return $removedLocations;
    }

    public static function findRemovedLocationsForDirective(Directive $oldDirective, Directive $newDirective)
    {
        $removedLocations = [];
        $newLocationSet   = array_flip($newDirective->locations);
        foreach ($oldDirective->locations as $oldLocation) {
            if (array_key_exists($oldLocation, $newLocationSet)) {
                continue;
            }

            $removedLocations[] = $oldLocation;
        }

        return $removedLocations;
    }

    /**
     * Given two schemas, returns an Array containing descriptions of all the types
     * of potentially dangerous changes covered by the other functions down below.
     *
     * @return string[][]
     */
    public static function findDangerousChanges(Schema $oldSchema, Schema $newSchema)
    {
        return array_merge(
            self::findArgChanges($oldSchema, $newSchema)['dangerousChanges'],
            self::findValuesAddedToEnums($oldSchema, $newSchema),
            self::findInterfacesAddedToObjectTypes($oldSchema, $newSchema),
            self::findTypesAddedToUnions($oldSchema, $newSchema),
            self::findFieldsThatChangedTypeOnInputObjectTypes($oldSchema, $newSchema)['dangerousChanges']
        );
    }

    /**
     * Given two schemas, returns an Array containing descriptions of any dangerous
     * changes in the newSchema related to adding values to an enum type.
     *
     * @return string[][]
     */
    public static function findValuesAddedToEnums(
        Schema $oldSchema,
        Schema $newSchema
    ) {
        $oldTypeMap = $oldSchema->getTypeMap();
        $newTypeMap = $newSchema->getTypeMap();

        $valuesAddedToEnums = [];
        foreach ($oldTypeMap as $typeName => $oldType) {
            $newType = $newTypeMap[$typeName] ?? null;
            if (! ($oldType instanceof EnumType) || ! ($newType instanceof EnumType)) {
                continue;
            }
            $valuesInOldEnum = [];
            foreach ($oldType->getValues() as $value) {
                $valuesInOldEnum[$value->name] = true;
            }
            foreach ($newType->getValues() as $value) {
                if (isset($valuesInOldEnum[$value->name])) {
                    continue;
                }

                $valuesAddedToEnums[] = [
                    'type'        => self::DANGEROUS_CHANGE_VALUE_ADDED_TO_ENUM,
                    'description' => sprintf('%s was added to enum type %s.', $value->name, $typeName),
                ];
            }
        }

        return $valuesAddedToEnums;
    }

    /**
     * @return string[][]
     */
    public static function findInterfacesAddedToObjectTypes(
        Schema $oldSchema,
        Schema $newSchema
    ) {
        $oldTypeMap                   = $oldSchema->getTypeMap();
        $newTypeMap                   = $newSchema->getTypeMap();
        $interfacesAddedToObjectTypes = [];

        foreach ($newTypeMap as $typeName => $newType) {
            $oldType = $oldTypeMap[$typeName] ?? null;
            if (! ($oldType instanceof ObjectType || $oldType instanceof InterfaceType)
                || ! ($newType instanceof ObjectType || $newType instanceof InterfaceType)) {
                continue;
            }

            $oldInterfaces = $oldType->getInterfaces();
            $newInterfaces = $newType->getInterfaces();
            foreach ($newInterfaces as $newInterface) {
                $interface = Utils::find(
                    $oldInterfaces,
                    static function (InterfaceType $interface) use ($newInterface) : bool {
                        return $interface->name === $newInterface->name;
                    }
                );

                if ($interface !== null) {
                    continue;
                }

                $interfacesAddedToObjectTypes[] = [
                    'type'        => self::DANGEROUS_CHANGE_IMPLEMENTED_INTERFACE_ADDED,
                    'description' => sprintf(
                        '%s added to interfaces implemented by %s.',
                        $newInterface->name,
                        $typeName
                    ),
                ];
            }
        }

        return $interfacesAddedToObjectTypes;
    }

    /**
     * Given two schemas, returns an Array containing descriptions of any dangerous
     * changes in the newSchema related to adding types to a union type.
     *
     * @return string[][]
     */
    public static function findTypesAddedToUnions(
        Schema $oldSchema,
        Schema $newSchema
    ) {
        $oldTypeMap = $oldSchema->getTypeMap();
        $newTypeMap = $newSchema->getTypeMap();

        $typesAddedToUnion = [];
        foreach ($newTypeMap as $typeName => $newType) {
            $oldType = $oldTypeMap[$typeName] ?? null;
            if (! ($oldType instanceof UnionType) || ! ($newType instanceof UnionType)) {
                continue;
            }

            $typeNamesInOldUnion = [];
            foreach ($oldType->getTypes() as $type) {
                $typeNamesInOldUnion[$type->name] = true;
            }
            foreach ($newType->getTypes() as $type) {
                if (isset($typeNamesInOldUnion[$type->name])) {
                    continue;
                }

                $typesAddedToUnion[] = [
                    'type'        => self::DANGEROUS_CHANGE_TYPE_ADDED_TO_UNION,
                    'description' => sprintf('%s was added to union type %s.', $type->name, $typeName),
                ];
            }
        }

        return $typesAddedToUnion;
    }
}

class_alias(BreakingChangesFinder::class, 'GraphQL\Utils\FindBreakingChanges');


// File: wp-graphql\vendor\webonyx\graphql-php\src\Utils\BuildClientSchema.php
<?php

declare(strict_types=1);

namespace GraphQL\Utils;

use GraphQL\Error\InvariantViolation;
use GraphQL\Language\Parser;
use GraphQL\Type\Definition\CustomScalarType;
use GraphQL\Type\Definition\Directive;
use GraphQL\Type\Definition\EnumType;
use GraphQL\Type\Definition\InputObjectType;
use GraphQL\Type\Definition\InputType;
use GraphQL\Type\Definition\InterfaceType;
use GraphQL\Type\Definition\ListOfType;
use GraphQL\Type\Definition\NamedType;
use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\Definition\NullableType;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\OutputType;
use GraphQL\Type\Definition\ScalarType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Definition\UnionType;
use GraphQL\Type\Introspection;
use GraphQL\Type\Schema;
use GraphQL\Type\SchemaConfig;
use GraphQL\Type\TypeKind;
use function array_key_exists;
use function array_map;
use function array_merge;
use function json_encode;

class BuildClientSchema
{
    /** @var array<string, mixed[]> */
    private $introspection;

    /** @var array<string, bool> */
    private $options;

    /** @var array<string, NamedType&Type> */
    private $typeMap;

    /**
     * @param array<string, mixed[]> $introspectionQuery
     * @param array<string, bool>    $options
     */
    public function __construct(array $introspectionQuery, array $options = [])
    {
        $this->introspection = $introspectionQuery;
        $this->options       = $options;
    }

    /**
     * Build a schema for use by client tools.
     *
     * Given the result of a client running the introspection query, creates and
     * returns a \GraphQL\Type\Schema instance which can be then used with all graphql-php
     * tools, but cannot be used to execute a query, as introspection does not
     * represent the "resolver", "parse" or "serialize" functions or any other
     * server-internal mechanisms.
     *
     * This function expects a complete introspection result. Don't forget to check
     * the "errors" field of a server response before calling this function.
     *
     * Accepts options as a third argument:
     *
     *    - assumeValid:
     *          When building a schema from a GraphQL service's introspection result, it
     *          might be safe to assume the schema is valid. Set to true to assume the
     *          produced schema is valid.
     *
     *          Default: false
     *
     * @param array<string, mixed[]> $introspectionQuery
     * @param array<string, bool>    $options
     *
     * @api
     */
    public static function build(array $introspectionQuery, array $options = []) : Schema
    {
        $builder = new self($introspectionQuery, $options);

        return $builder->buildSchema();
    }

    public function buildSchema() : Schema
    {
        if (! array_key_exists('__schema', $this->introspection)) {
            throw new InvariantViolation('Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ' . json_encode($this->introspection) . '.');
        }

        $schemaIntrospection = $this->introspection['__schema'];

        $this->typeMap = Utils::keyValMap(
            $schemaIntrospection['types'],
            static function (array $typeIntrospection) {
                return $typeIntrospection['name'];
            },
            function (array $typeIntrospection) : NamedType {
                return $this->buildType($typeIntrospection);
            }
        );

        $builtInTypes = array_merge(
            Type::getStandardTypes(),
            Introspection::getTypes()
        );
        foreach ($builtInTypes as $name => $type) {
            if (! isset($this->typeMap[$name])) {
                continue;
            }

            $this->typeMap[$name] = $type;
        }

        $queryType = isset($schemaIntrospection['queryType'])
            ? $this->getObjectType($schemaIntrospection['queryType'])
            : null;

        $mutationType = isset($schemaIntrospection['mutationType'])
            ? $this->getObjectType($schemaIntrospection['mutationType'])
            : null;

        $subscriptionType = isset($schemaIntrospection['subscriptionType'])
            ? $this->getObjectType($schemaIntrospection['subscriptionType'])
            : null;

        $directives = isset($schemaIntrospection['directives'])
            ? array_map(
                [$this, 'buildDirective'],
                $schemaIntrospection['directives']
            )
            : [];

        $schemaConfig = new SchemaConfig();
        $schemaConfig->setQuery($queryType)
            ->setMutation($mutationType)
            ->setSubscription($subscriptionType)
            ->setTypes($this->typeMap)
            ->setDirectives($directives)
            ->setAssumeValid(
                isset($this->options)
                && isset($this->options['assumeValid'])
                && $this->options['assumeValid']
            );

        return new Schema($schemaConfig);
    }

    /**
     * @param array<string, mixed> $typeRef
     */
    private function getType(array $typeRef) : Type
    {
        if (isset($typeRef['kind'])) {
            if ($typeRef['kind'] === TypeKind::LIST) {
                if (! isset($typeRef['ofType'])) {
                    throw new InvariantViolation('Decorated type deeper than introspection query.');
                }

                return new ListOfType($this->getType($typeRef['ofType']));
            }

            if ($typeRef['kind'] === TypeKind::NON_NULL) {
                if (! isset($typeRef['ofType'])) {
                    throw new InvariantViolation('Decorated type deeper than introspection query.');
                }
                /** @var NullableType $nullableType */
                $nullableType = $this->getType($typeRef['ofType']);

                return new NonNull($nullableType);
            }
        }

        if (! isset($typeRef['name'])) {
            throw new InvariantViolation('Unknown type reference: ' . json_encode($typeRef) . '.');
        }

        return $this->getNamedType($typeRef['name']);
    }

    /**
     * @return NamedType&Type
     */
    private function getNamedType(string $typeName) : NamedType
    {
        if (! isset($this->typeMap[$typeName])) {
            throw new InvariantViolation(
                'Invalid or incomplete schema, unknown type: ' . $typeName . '. Ensure that a full introspection query is used in order to build a client schema.'
            );
        }

        return $this->typeMap[$typeName];
    }

    /**
     * @param array<string, mixed> $typeRef
     */
    private function getInputType(array $typeRef) : InputType
    {
        $type = $this->getType($typeRef);

        if ($type instanceof InputType) {
            return $type;
        }

        throw new InvariantViolation('Introspection must provide input type for arguments, but received: ' . json_encode($type) . '.');
    }

    /**
     * @param array<string, mixed> $typeRef
     */
    private function getOutputType(array $typeRef) : OutputType
    {
        $type = $this->getType($typeRef);

        if ($type instanceof OutputType) {
            return $type;
        }

        throw new InvariantViolation('Introspection must provide output type for fields, but received: ' . json_encode($type) . '.');
    }

    /**
     * @param array<string, mixed> $typeRef
     */
    private function getObjectType(array $typeRef) : ObjectType
    {
        $type = $this->getType($typeRef);

        return ObjectType::assertObjectType($type);
    }

    /**
     * @param array<string, mixed> $typeRef
     */
    public function getInterfaceType(array $typeRef) : InterfaceType
    {
        $type = $this->getType($typeRef);

        return InterfaceType::assertInterfaceType($type);
    }

    /**
     * @param array<string, mixed> $type
     */
    private function buildType(array $type) : NamedType
    {
        if (array_key_exists('name', $type) && array_key_exists('kind', $type)) {
            switch ($type['kind']) {
                case TypeKind::SCALAR:
                    return $this->buildScalarDef($type);
                case TypeKind::OBJECT:
                    return $this->buildObjectDef($type);
                case TypeKind::INTERFACE:
                    return $this->buildInterfaceDef($type);
                case TypeKind::UNION:
                    return $this->buildUnionDef($type);
                case TypeKind::ENUM:
                    return $this->buildEnumDef($type);
                case TypeKind::INPUT_OBJECT:
                    return $this->buildInputObjectDef($type);
            }
        }

        throw new InvariantViolation(
            'Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ' . json_encode($type) . '.'
        );
    }

    /**
     * @param array<string, string> $scalar
     */
    private function buildScalarDef(array $scalar) : ScalarType
    {
        return new CustomScalarType([
            'name' => $scalar['name'],
            'description' => $scalar['description'],
            'serialize' => static function ($value) : string {
                return (string) $value;
            },
        ]);
    }

    /**
     * @param array<string, mixed> $implementingIntrospection
     *
     * @return array<int, InterfaceType>
     */
    private function buildImplementationsList(array $implementingIntrospection) : array
    {
        // TODO: Temporary workaround until GraphQL ecosystem will fully support 'interfaces' on interface types.
        if (array_key_exists('interfaces', $implementingIntrospection) &&
            $implementingIntrospection['interfaces'] === null &&
            $implementingIntrospection['kind'] === TypeKind::INTERFACE) {
            return [];
        }

        if (! array_key_exists('interfaces', $implementingIntrospection)) {
            throw new InvariantViolation('Introspection result missing interfaces: ' . json_encode($implementingIntrospection) . '.');
        }

        return array_map([$this, 'getInterfaceType'], $implementingIntrospection['interfaces']);
    }

    /**
     * @param array<string, mixed> $object
     */
    private function buildObjectDef(array $object) : ObjectType
    {
        return new ObjectType([
            'name' => $object['name'],
            'description' => $object['description'],
            'interfaces' => function () use ($object) : array {
                return $this->buildImplementationsList($object);
            },
            'fields' => function () use ($object) {
                return $this->buildFieldDefMap($object);
            },
        ]);
    }

    /**
     * @param array<string, mixed> $interface
     */
    private function buildInterfaceDef(array $interface) : InterfaceType
    {
        return new InterfaceType([
            'name' => $interface['name'],
            'description' => $interface['description'],
            'fields' => function () use ($interface) {
                return $this->buildFieldDefMap($interface);
            },
            'interfaces' => function () use ($interface) : array {
                return $this->buildImplementationsList($interface);
            },
        ]);
    }

    /**
     * @param array<string, string|array<string>> $union
     */
    private function buildUnionDef(array $union) : UnionType
    {
        if (! array_key_exists('possibleTypes', $union)) {
            throw new InvariantViolation('Introspection result missing possibleTypes: ' . json_encode($union) . '.');
        }

        return new UnionType([
            'name' => $union['name'],
            'description' => $union['description'],
            'types' => function () use ($union) : array {
                return array_map(
                    [$this, 'getObjectType'],
                    $union['possibleTypes']
                );
            },
        ]);
    }

    /**
     * @param array<string, string|array<string, string>> $enum
     */
    private function buildEnumDef(array $enum) : EnumType
    {
        if (! array_key_exists('enumValues', $enum)) {
            throw new InvariantViolation('Introspection result missing enumValues: ' . json_encode($enum) . '.');
        }

        return new EnumType([
            'name' => $enum['name'],
            'description' => $enum['description'],
            'values' => Utils::keyValMap(
                $enum['enumValues'],
                static function (array $enumValue) : string {
                    return $enumValue['name'];
                },
                static function (array $enumValue) : array {
                    return [
                        'description' => $enumValue['description'],
                        'deprecationReason' => $enumValue['deprecationReason'],
                    ];
                }
            ),
        ]);
    }

    /**
     * @param array<string, mixed> $inputObject
     */
    private function buildInputObjectDef(array $inputObject) : InputObjectType
    {
        if (! array_key_exists('inputFields', $inputObject)) {
            throw new InvariantViolation('Introspection result missing inputFields: ' . json_encode($inputObject) . '.');
        }

        return new InputObjectType([
            'name' => $inputObject['name'],
            'description' => $inputObject['description'],
            'fields' => function () use ($inputObject) : array {
                return $this->buildInputValueDefMap($inputObject['inputFields']);
            },
        ]);
    }

    /**
     * @param array<string, mixed> $typeIntrospection
     */
    private function buildFieldDefMap(array $typeIntrospection)
    {
        if (! array_key_exists('fields', $typeIntrospection)) {
            throw new InvariantViolation('Introspection result missing fields: ' . json_encode($typeIntrospection) . '.');
        }

        return Utils::keyValMap(
            $typeIntrospection['fields'],
            static function (array $fieldIntrospection) : string {
                return $fieldIntrospection['name'];
            },
            function (array $fieldIntrospection) : array {
                if (! array_key_exists('args', $fieldIntrospection)) {
                    throw new InvariantViolation('Introspection result missing field args: ' . json_encode($fieldIntrospection) . '.');
                }

                return [
                    'description' => $fieldIntrospection['description'],
                    'deprecationReason' => $fieldIntrospection['deprecationReason'],
                    'type' => $this->getOutputType($fieldIntrospection['type']),
                    'args' => $this->buildInputValueDefMap($fieldIntrospection['args']),
                ];
            }
        );
    }

    /**
     * @param array<int, array<string, mixed>> $inputValueIntrospections
     *
     * @return array<string, array<string, mixed>>
     */
    private function buildInputValueDefMap(array $inputValueIntrospections) : array
    {
        return Utils::keyValMap(
            $inputValueIntrospections,
            static function (array $inputValue) : string {
                return $inputValue['name'];
            },
            [$this, 'buildInputValue']
        );
    }

    /**
     * @param array<string, mixed> $inputValueIntrospection
     *
     * @return array<string, mixed>
     */
    public function buildInputValue(array $inputValueIntrospection) : array
    {
        $type = $this->getInputType($inputValueIntrospection['type']);

        $inputValue = [
            'description' => $inputValueIntrospection['description'],
            'type' => $type,
        ];

        if (isset($inputValueIntrospection['defaultValue'])) {
            $inputValue['defaultValue'] = AST::valueFromAST(
                Parser::parseValue($inputValueIntrospection['defaultValue']),
                $type
            );
        }

        return $inputValue;
    }

    /**
     * @param array<string, mixed> $directive
     */
    public function buildDirective(array $directive) : Directive
    {
        if (! array_key_exists('args', $directive)) {
            throw new InvariantViolation('Introspection result missing directive args: ' . json_encode($directive) . '.');
        }
        if (! array_key_exists('locations', $directive)) {
            throw new InvariantViolation('Introspection result missing directive locations: ' . json_encode($directive) . '.');
        }

        return new Directive([
            'name' => $directive['name'],
            'description' => $directive['description'],
            'args' => $this->buildInputValueDefMap($directive['args']),
            'isRepeatable' => $directive['isRepeatable'] ?? false,
            'locations' => $directive['locations'],
        ]);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Utils\BuildSchema.php
<?php

declare(strict_types=1);

namespace GraphQL\Utils;

use GraphQL\Error\Error;
use GraphQL\Language\AST\DirectiveDefinitionNode;
use GraphQL\Language\AST\DocumentNode;
use GraphQL\Language\AST\EnumTypeDefinitionNode;
use GraphQL\Language\AST\InputObjectTypeDefinitionNode;
use GraphQL\Language\AST\InterfaceTypeDefinitionNode;
use GraphQL\Language\AST\ObjectTypeDefinitionNode;
use GraphQL\Language\AST\ScalarTypeDefinitionNode;
use GraphQL\Language\AST\SchemaDefinitionNode;
use GraphQL\Language\AST\TypeDefinitionNode;
use GraphQL\Language\AST\UnionTypeDefinitionNode;
use GraphQL\Language\Parser;
use GraphQL\Language\Source;
use GraphQL\Type\Definition\Directive;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Schema;
use GraphQL\Validator\DocumentValidator;
use function array_map;
use function sprintf;

/**
 * Build instance of `GraphQL\Type\Schema` out of type language definition (string or parsed AST)
 * See [section in docs](type-system/type-language.md) for details.
 */
class BuildSchema
{
    /** @var DocumentNode */
    private $ast;

    /** @var array<string, TypeDefinitionNode> */
    private $nodeMap;

    /** @var callable|null */
    private $typeConfigDecorator;

    /** @var array<string, bool> */
    private $options;

    /**
     * @param array<string, bool> $options
     */
    public function __construct(DocumentNode $ast, ?callable $typeConfigDecorator = null, array $options = [])
    {
        $this->ast                 = $ast;
        $this->typeConfigDecorator = $typeConfigDecorator;
        $this->options             = $options;
    }

    /**
     * A helper function to build a GraphQLSchema directly from a source
     * document.
     *
     * @param DocumentNode|Source|string $source
     * @param array<string, bool>        $options
     *
     * @return Schema
     *
     * @api
     */
    public static function build($source, ?callable $typeConfigDecorator = null, array $options = [])
    {
        $doc = $source instanceof DocumentNode
            ? $source
            : Parser::parse($source);

        return self::buildAST($doc, $typeConfigDecorator, $options);
    }

    /**
     * This takes the ast of a schema document produced by the parse function in
     * GraphQL\Language\Parser.
     *
     * If no schema definition is provided, then it will look for types named Query
     * and Mutation.
     *
     * Given that AST it constructs a GraphQL\Type\Schema. The resulting schema
     * has no resolve methods, so execution will use default resolvers.
     *
     * Accepts options as a third argument:
     *
     *    - commentDescriptions:
     *        Provide true to use preceding comments as the description.
     *        This option is provided to ease adoption and will be removed in v16.
     *
     * @param array<string, bool> $options
     *
     * @return Schema
     *
     * @throws Error
     *
     * @api
     */
    public static function buildAST(DocumentNode $ast, ?callable $typeConfigDecorator = null, array $options = [])
    {
        $builder = new self($ast, $typeConfigDecorator, $options);

        return $builder->buildSchema();
    }

    public function buildSchema()
    {
        $options = $this->options;
        if (! ($options['assumeValid'] ?? false) && ! ($options['assumeValidSDL'] ?? false)) {
            DocumentValidator::assertValidSDL($this->ast);
        }

        $schemaDef     = null;
        $typeDefs      = [];
        $this->nodeMap = [];
        /** @var array<int, DirectiveDefinitionNode> $directiveDefs */
        $directiveDefs = [];
        foreach ($this->ast->definitions as $definition) {
            switch (true) {
                case $definition instanceof SchemaDefinitionNode:
                    $schemaDef = $definition;
                    break;
                case $definition instanceof TypeDefinitionNode:
                    $typeName = $definition->name->value;
                    if (isset($this->nodeMap[$typeName])) {
                        throw new Error(sprintf('Type "%s" was defined more than once.', $typeName));
                    }
                    $typeDefs[]               = $definition;
                    $this->nodeMap[$typeName] = $definition;
                    break;
                case $definition instanceof DirectiveDefinitionNode:
                    $directiveDefs[] = $definition;
                    break;
            }
        }

        $operationTypes = $schemaDef !== null
            ? $this->getOperationTypes($schemaDef)
            : [
                'query'        => isset($this->nodeMap['Query']) ? 'Query' : null,
                'mutation'     => isset($this->nodeMap['Mutation']) ? 'Mutation' : null,
                'subscription' => isset($this->nodeMap['Subscription']) ? 'Subscription' : null,
            ];

        $DefinitionBuilder = new ASTDefinitionBuilder(
            $this->nodeMap,
            $this->options,
            static function ($typeName) : void {
                throw new Error('Type "' . $typeName . '" not found in document.');
            },
            $this->typeConfigDecorator
        );

        $directives = array_map(
            static function (DirectiveDefinitionNode $def) use ($DefinitionBuilder) : Directive {
                return $DefinitionBuilder->buildDirective($def);
            },
            $directiveDefs
        );

        // If specified directives were not explicitly declared, add them.
        $directivesByName = Utils::groupBy(
            $directives,
            static function (Directive $directive) : string {
                return $directive->name;
            }
        );
        if (! isset($directivesByName['skip'])) {
            $directives[] = Directive::skipDirective();
        }
        if (! isset($directivesByName['include'])) {
            $directives[] = Directive::includeDirective();
        }
        if (! isset($directivesByName['deprecated'])) {
            $directives[] = Directive::deprecatedDirective();
        }

        // Note: While this could make early assertions to get the correctly
        // typed values below, that would throw immediately while type system
        // validation with validateSchema() will produce more actionable results.

        return new Schema([
            'query'        => isset($operationTypes['query'])
                ? $DefinitionBuilder->buildType($operationTypes['query'])
                : null,
            'mutation'     => isset($operationTypes['mutation'])
                ? $DefinitionBuilder->buildType($operationTypes['mutation'])
                : null,
            'subscription' => isset($operationTypes['subscription'])
                ? $DefinitionBuilder->buildType($operationTypes['subscription'])
                : null,
            'typeLoader'   => static function ($name) use ($DefinitionBuilder) : Type {
                return $DefinitionBuilder->buildType($name);
            },
            'directives'   => $directives,
            'astNode'      => $schemaDef,
            'types'        => function () use ($DefinitionBuilder) : array {
                $types = [];
                /** @var ScalarTypeDefinitionNode|ObjectTypeDefinitionNode|InterfaceTypeDefinitionNode|UnionTypeDefinitionNode|EnumTypeDefinitionNode|InputObjectTypeDefinitionNode $def */
                foreach ($this->nodeMap as $name => $def) {
                    $types[] = $DefinitionBuilder->buildType($def->name->value);
                }

                return $types;
            },
        ]);
    }

    /**
     * @param SchemaDefinitionNode $schemaDef
     *
     * @return string[]
     *
     * @throws Error
     */
    private function getOperationTypes($schemaDef)
    {
        $opTypes = [];

        foreach ($schemaDef->operationTypes as $operationType) {
            $typeName  = $operationType->type->name->value;
            $operation = $operationType->operation;

            if (isset($opTypes[$operation])) {
                throw new Error(sprintf('Must provide only one %s type in schema.', $operation));
            }

            if (! isset($this->nodeMap[$typeName])) {
                throw new Error(sprintf('Specified %s type "%s" not found in document.', $operation, $typeName));
            }

            $opTypes[$operation] = $typeName;
        }

        return $opTypes;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Utils\InterfaceImplementations.php
<?php

declare(strict_types=1);

namespace GraphQL\Utils;

use GraphQL\Type\Definition\InterfaceType;
use GraphQL\Type\Definition\ObjectType;

/**
 * A way to track interface implementations.
 *
 * Distinguishes between implementations by ObjectTypes and InterfaceTypes.
 */
class InterfaceImplementations
{
    /** @var array<int, ObjectType> */
    private $objects;

    /** @var array<int, InterfaceType> */
    private $interfaces;

    /**
     * @param array<int, ObjectType>    $objects
     * @param array<int, InterfaceType> $interfaces
     */
    public function __construct(array $objects, array $interfaces)
    {
        $this->objects    = $objects;
        $this->interfaces = $interfaces;
    }

    /**
     * @return array<int, ObjectType>
     */
    public function objects() : array
    {
        return $this->objects;
    }

    /**
     * @return array<int, InterfaceType>
     */
    public function interfaces() : array
    {
        return $this->interfaces;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Utils\MixedStore.php
<?php

declare(strict_types=1);

namespace GraphQL\Utils;

use ArrayAccess;
use GraphQL\Type\Definition\EnumValueDefinition;
use InvalidArgumentException;
use ReturnTypeWillChange;
use SplObjectStorage;
use function array_key_exists;
use function array_search;
use function array_splice;
use function is_array;
use function is_float;
use function is_int;
use function is_object;
use function is_string;

/**
 * Similar to PHP array, but allows any type of data to act as key (including arrays, objects, scalars)
 *
 * Note: unfortunately when storing array as key - access and modification is O(N)
 * (yet this should rarely be the case and should be avoided when possible)
 */
class MixedStore implements ArrayAccess
{
    /** @var EnumValueDefinition[] */
    private $standardStore;

    /** @var mixed[] */
    private $floatStore;

    /** @var SplObjectStorage */
    private $objectStore;

    /** @var callable[] */
    private $arrayKeys;

    /** @var EnumValueDefinition[] */
    private $arrayValues;

    /** @var callable[] */
    private $lastArrayKey;

    /** @var mixed */
    private $lastArrayValue;

    /** @var mixed */
    private $nullValue;

    /** @var bool */
    private $nullValueIsSet;

    /** @var mixed */
    private $trueValue;

    /** @var bool */
    private $trueValueIsSet;

    /** @var mixed */
    private $falseValue;

    /** @var bool */
    private $falseValueIsSet;

    public function __construct()
    {
        $this->standardStore   = [];
        $this->floatStore      = [];
        $this->objectStore     = new SplObjectStorage();
        $this->arrayKeys       = [];
        $this->arrayValues     = [];
        $this->nullValueIsSet  = false;
        $this->trueValueIsSet  = false;
        $this->falseValueIsSet = false;
    }

    /**
     * Whether a offset exists
     *
     * @link http://php.net/manual/en/arrayaccess.offsetexists.php
     *
     * @param mixed $offset <p>
     * An offset to check for.
     * </p>
     *
     * @return bool true on success or false on failure.
     * </p>
     * <p>
     * The return value will be casted to boolean if non-boolean was returned.
     */
    public function offsetExists($offset) : bool
    {
        if ($offset === false) {
            return $this->falseValueIsSet;
        }
        if ($offset === true) {
            return $this->trueValueIsSet;
        }
        if (is_int($offset) || is_string($offset)) {
            return array_key_exists($offset, $this->standardStore);
        }
        if (is_float($offset)) {
            return array_key_exists((string) $offset, $this->floatStore);
        }
        if (is_object($offset)) {
            return $this->objectStore->offsetExists($offset);
        }
        if (is_array($offset)) {
            foreach ($this->arrayKeys as $index => $entry) {
                if ($entry === $offset) {
                    $this->lastArrayKey   = $offset;
                    $this->lastArrayValue = $this->arrayValues[$index];

                    return true;
                }
            }
        }
        if ($offset === null) {
            return $this->nullValueIsSet;
        }

        return false;
    }

    /**
     * Offset to retrieve
     *
     * @link http://php.net/manual/en/arrayaccess.offsetget.php
     *
     * @param mixed $offset <p>
     * The offset to retrieve.
     * </p>
     *
     * @return mixed Can return all value types.
     */
    #[ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        if ($offset === true) {
            return $this->trueValue;
        }
        if ($offset === false) {
            return $this->falseValue;
        }
        if (is_int($offset) || is_string($offset)) {
            return $this->standardStore[$offset];
        }
        if (is_float($offset)) {
            return $this->floatStore[(string) $offset];
        }
        if (is_object($offset)) {
            return $this->objectStore->offsetGet($offset);
        }
        if (is_array($offset)) {
            // offsetGet is often called directly after offsetExists, so optimize to avoid second loop:
            if ($this->lastArrayKey === $offset) {
                return $this->lastArrayValue;
            }
            foreach ($this->arrayKeys as $index => $entry) {
                if ($entry === $offset) {
                    return $this->arrayValues[$index];
                }
            }
        }
        if ($offset === null) {
            return $this->nullValue;
        }

        return null;
    }

    /**
     * Offset to set
     *
     * @link http://php.net/manual/en/arrayaccess.offsetset.php
     *
     * @param mixed $offset <p>
     * The offset to assign the value to.
     * </p>
     * @param mixed $value  <p>
     *  The value to set.
     *  </p>
     */
    public function offsetSet($offset, $value) : void
    {
        if ($offset === false) {
            $this->falseValue      = $value;
            $this->falseValueIsSet = true;
        } elseif ($offset === true) {
            $this->trueValue      = $value;
            $this->trueValueIsSet = true;
        } elseif (is_int($offset) || is_string($offset)) {
            $this->standardStore[$offset] = $value;
        } elseif (is_float($offset)) {
            $this->floatStore[(string) $offset] = $value;
        } elseif (is_object($offset)) {
            $this->objectStore[$offset] = $value;
        } elseif (is_array($offset)) {
            $this->arrayKeys[]   = $offset;
            $this->arrayValues[] = $value;
        } elseif ($offset === null) {
            $this->nullValue      = $value;
            $this->nullValueIsSet = true;
        } else {
            throw new InvalidArgumentException('Unexpected offset type: ' . Utils::printSafe($offset));
        }
    }

    /**
     * Offset to unset
     *
     * @link http://php.net/manual/en/arrayaccess.offsetunset.php
     *
     * @param mixed $offset <p>
     * The offset to unset.
     * </p>
     */
    public function offsetUnset($offset) : void
    {
        if ($offset === true) {
            $this->trueValue      = null;
            $this->trueValueIsSet = false;
        } elseif ($offset === false) {
            $this->falseValue      = null;
            $this->falseValueIsSet = false;
        } elseif (is_int($offset) || is_string($offset)) {
            unset($this->standardStore[$offset]);
        } elseif (is_float($offset)) {
            unset($this->floatStore[(string) $offset]);
        } elseif (is_object($offset)) {
            $this->objectStore->offsetUnset($offset);
        } elseif (is_array($offset)) {
            $index = array_search($offset, $this->arrayKeys, true);

            if ($index !== false) {
                array_splice($this->arrayKeys, $index, 1);
                array_splice($this->arrayValues, $index, 1);
            }
        } elseif ($offset === null) {
            $this->nullValue      = null;
            $this->nullValueIsSet = false;
        }
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Utils\PairSet.php
<?php

declare(strict_types=1);

namespace GraphQL\Utils;

/**
 * A way to keep track of pairs of things when the ordering of the pair does
 * not matter. We do this by maintaining a sort of double adjacency sets.
 */
class PairSet
{
    /** @var bool[][] */
    private $data;

    public function __construct()
    {
        $this->data = [];
    }

    /**
     * @param string $a
     * @param string $b
     * @param bool   $areMutuallyExclusive
     *
     * @return bool
     */
    public function has($a, $b, $areMutuallyExclusive)
    {
        $first  = $this->data[$a] ?? null;
        $result = $first && isset($first[$b]) ? $first[$b] : null;
        if ($result === null) {
            return false;
        }
        // areMutuallyExclusive being false is a superset of being true,
        // hence if we want to know if this PairSet "has" these two with no
        // exclusivity, we have to ensure it was added as such.
        if ($areMutuallyExclusive === false) {
            return $result === false;
        }

        return true;
    }

    /**
     * @param string $a
     * @param string $b
     * @param bool   $areMutuallyExclusive
     */
    public function add($a, $b, $areMutuallyExclusive)
    {
        $this->pairSetAdd($a, $b, $areMutuallyExclusive);
        $this->pairSetAdd($b, $a, $areMutuallyExclusive);
    }

    /**
     * @param string $a
     * @param string $b
     * @param bool   $areMutuallyExclusive
     */
    private function pairSetAdd($a, $b, $areMutuallyExclusive)
    {
        $this->data[$a]     = $this->data[$a] ?? [];
        $this->data[$a][$b] = $areMutuallyExclusive;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Utils\SchemaExtender.php
<?php

declare(strict_types=1);

namespace GraphQL\Utils;

use GraphQL\Error\Error;
use GraphQL\Language\AST\DirectiveDefinitionNode;
use GraphQL\Language\AST\DocumentNode;
use GraphQL\Language\AST\EnumTypeExtensionNode;
use GraphQL\Language\AST\InputObjectTypeExtensionNode;
use GraphQL\Language\AST\InterfaceTypeExtensionNode;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\ObjectTypeExtensionNode;
use GraphQL\Language\AST\SchemaDefinitionNode;
use GraphQL\Language\AST\SchemaTypeExtensionNode;
use GraphQL\Language\AST\TypeDefinitionNode;
use GraphQL\Language\AST\TypeExtensionNode;
use GraphQL\Language\AST\UnionTypeExtensionNode;
use GraphQL\Type\Definition\CustomScalarType;
use GraphQL\Type\Definition\Directive;
use GraphQL\Type\Definition\EnumType;
use GraphQL\Type\Definition\EnumValueDefinition;
use GraphQL\Type\Definition\FieldArgument;
use GraphQL\Type\Definition\ImplementingType;
use GraphQL\Type\Definition\InputObjectType;
use GraphQL\Type\Definition\InterfaceType;
use GraphQL\Type\Definition\ListOfType;
use GraphQL\Type\Definition\NamedType;
use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\ScalarType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Definition\UnionType;
use GraphQL\Type\Introspection;
use GraphQL\Type\Schema;
use GraphQL\Validator\DocumentValidator;
use function array_keys;
use function array_map;
use function array_merge;
use function array_values;
use function count;

class SchemaExtender
{
    const SCHEMA_EXTENSION = 'SchemaExtension';

    /** @var Type[] */
    protected static $extendTypeCache;

    /** @var mixed[] */
    protected static $typeExtensionsMap;

    /** @var ASTDefinitionBuilder */
    protected static $astBuilder;

    /**
     * @return TypeExtensionNode[]|null
     */
    protected static function getExtensionASTNodes(NamedType $type) : ?array
    {
        if (! $type instanceof Type) {
            return null;
        }

        $name = $type->name;
        if ($type->extensionASTNodes !== null) {
            if (isset(static::$typeExtensionsMap[$name])) {
                return array_merge($type->extensionASTNodes, static::$typeExtensionsMap[$name]);
            }

            return $type->extensionASTNodes;
        }

        return static::$typeExtensionsMap[$name] ?? null;
    }

    /**
     * @throws Error
     */
    protected static function checkExtensionNode(Type $type, Node $node) : void
    {
        switch (true) {
            case $node instanceof ObjectTypeExtensionNode:
                if (! ($type instanceof ObjectType)) {
                    throw new Error(
                        'Cannot extend non-object type "' . $type->name . '".',
                        [$node]
                    );
                }
                break;
            case $node instanceof InterfaceTypeExtensionNode:
                if (! ($type instanceof InterfaceType)) {
                    throw new Error(
                        'Cannot extend non-interface type "' . $type->name . '".',
                        [$node]
                    );
                }
                break;
            case $node instanceof EnumTypeExtensionNode:
                if (! ($type instanceof EnumType)) {
                    throw new Error(
                        'Cannot extend non-enum type "' . $type->name . '".',
                        [$node]
                    );
                }
                break;
            case $node instanceof UnionTypeExtensionNode:
                if (! ($type instanceof UnionType)) {
                    throw new Error(
                        'Cannot extend non-union type "' . $type->name . '".',
                        [$node]
                    );
                }
                break;
            case $node instanceof InputObjectTypeExtensionNode:
                if (! ($type instanceof InputObjectType)) {
                    throw new Error(
                        'Cannot extend non-input object type "' . $type->name . '".',
                        [$node]
                    );
                }
                break;
        }
    }

    protected static function extendScalarType(ScalarType $type) : CustomScalarType
    {
        return new CustomScalarType([
            'name' => $type->name,
            'description' => $type->description,
            'astNode' => $type->astNode,
            'serialize' => $type->config['serialize'] ?? null,
            'parseValue' => $type->config['parseValue'] ?? null,
            'parseLiteral' => $type->config['parseLiteral'] ?? null,
            'extensionASTNodes' => static::getExtensionASTNodes($type),
        ]);
    }

    protected static function extendUnionType(UnionType $type) : UnionType
    {
        return new UnionType([
            'name' => $type->name,
            'description' => $type->description,
            'types' => static function () use ($type) : array {
                return static::extendPossibleTypes($type);
            },
            'astNode' => $type->astNode,
            'resolveType' => $type->config['resolveType'] ?? null,
            'extensionASTNodes' => static::getExtensionASTNodes($type),
        ]);
    }

    protected static function extendEnumType(EnumType $type) : EnumType
    {
        return new EnumType([
            'name' => $type->name,
            'description' => $type->description,
            'values' => static::extendValueMap($type),
            'astNode' => $type->astNode,
            'extensionASTNodes' => static::getExtensionASTNodes($type),
        ]);
    }

    protected static function extendInputObjectType(InputObjectType $type) : InputObjectType
    {
        return new InputObjectType([
            'name' => $type->name,
            'description' => $type->description,
            'fields' => static function () use ($type) : array {
                return static::extendInputFieldMap($type);
            },
            'astNode' => $type->astNode,
            'extensionASTNodes' => static::getExtensionASTNodes($type),
        ]);
    }

    /**
     * @return mixed[]
     */
    protected static function extendInputFieldMap(InputObjectType $type) : array
    {
        $newFieldMap = [];
        $oldFieldMap = $type->getFields();
        foreach ($oldFieldMap as $fieldName => $field) {
            $newFieldMap[$fieldName] = [
                'description' => $field->description,
                'type' => static::extendType($field->getType()),
                'astNode' => $field->astNode,
            ];

            if (! $field->defaultValueExists()) {
                continue;
            }

            $newFieldMap[$fieldName]['defaultValue'] = $field->defaultValue;
        }

        $extensions = static::$typeExtensionsMap[$type->name] ?? null;
        if ($extensions !== null) {
            foreach ($extensions as $extension) {
                foreach ($extension->fields as $field) {
                    $fieldName = $field->name->value;
                    if (isset($oldFieldMap[$fieldName])) {
                        throw new Error('Field "' . $type->name . '.' . $fieldName . '" already exists in the schema. It cannot also be defined in this type extension.', [$field]);
                    }

                    $newFieldMap[$fieldName] = static::$astBuilder->buildInputField($field);
                }
            }
        }

        return $newFieldMap;
    }

    /**
     * @return mixed[]
     */
    protected static function extendValueMap(EnumType $type) : array
    {
        $newValueMap = [];
        /** @var EnumValueDefinition[] $oldValueMap */
        $oldValueMap = [];
        foreach ($type->getValues() as $value) {
            $oldValueMap[$value->name] = $value;
        }

        foreach ($oldValueMap as $key => $value) {
            $newValueMap[$key] = [
                'name' => $value->name,
                'description' => $value->description,
                'value' => $value->value,
                'deprecationReason' => $value->deprecationReason,
                'astNode' => $value->astNode,
            ];
        }

        $extensions = static::$typeExtensionsMap[$type->name] ?? null;
        if ($extensions !== null) {
            foreach ($extensions as $extension) {
                foreach ($extension->values as $value) {
                    $valueName = $value->name->value;
                    if (isset($oldValueMap[$valueName])) {
                        throw new Error('Enum value "' . $type->name . '.' . $valueName . '" already exists in the schema. It cannot also be defined in this type extension.', [$value]);
                    }
                    $newValueMap[$valueName] = static::$astBuilder->buildEnumValue($value);
                }
            }
        }

        return $newValueMap;
    }

    /**
     * @return ObjectType[]
     */
    protected static function extendPossibleTypes(UnionType $type) : array
    {
        $possibleTypes = array_map(static function ($type) {
            return static::extendNamedType($type);
        }, $type->getTypes());

        $extensions = static::$typeExtensionsMap[$type->name] ?? null;
        if ($extensions !== null) {
            foreach ($extensions as $extension) {
                foreach ($extension->types as $namedType) {
                    $possibleTypes[] = static::$astBuilder->buildType($namedType);
                }
            }
        }

        return $possibleTypes;
    }

    /**
     * @param ObjectType|InterfaceType $type
     *
     * @return array<int, InterfaceType>
     */
    protected static function extendImplementedInterfaces(ImplementingType $type) : array
    {
        $interfaces = array_map(static function (InterfaceType $interfaceType) {
            return static::extendNamedType($interfaceType);
        }, $type->getInterfaces());

        $extensions = static::$typeExtensionsMap[$type->name] ?? null;
        if ($extensions !== null) {
            /** @var ObjectTypeExtensionNode|InterfaceTypeExtensionNode $extension */
            foreach ($extensions as $extension) {
                foreach ($extension->interfaces as $namedType) {
                    $interfaces[] = static::$astBuilder->buildType($namedType);
                }
            }
        }

        return $interfaces;
    }

    protected static function extendType($typeDef)
    {
        if ($typeDef instanceof ListOfType) {
            return Type::listOf(static::extendType($typeDef->getOfType()));
        }

        if ($typeDef instanceof NonNull) {
            return Type::nonNull(static::extendType($typeDef->getWrappedType()));
        }

        return static::extendNamedType($typeDef);
    }

    /**
     * @param FieldArgument[] $args
     *
     * @return mixed[]
     */
    protected static function extendArgs(array $args) : array
    {
        return Utils::keyValMap(
            $args,
            static function (FieldArgument $arg) : string {
                return $arg->name;
            },
            static function (FieldArgument $arg) : array {
                $def = [
                    'type'        => static::extendType($arg->getType()),
                    'description' => $arg->description,
                    'astNode'     => $arg->astNode,
                ];

                if ($arg->defaultValueExists()) {
                    $def['defaultValue'] = $arg->defaultValue;
                }

                return $def;
            }
        );
    }

    /**
     * @param InterfaceType|ObjectType $type
     *
     * @return mixed[]
     *
     * @throws Error
     */
    protected static function extendFieldMap($type) : array
    {
        $newFieldMap = [];
        $oldFieldMap = $type->getFields();

        foreach (array_keys($oldFieldMap) as $fieldName) {
            $field = $oldFieldMap[$fieldName];

            $newFieldMap[$fieldName] = [
                'name' => $fieldName,
                'description' => $field->description,
                'deprecationReason' => $field->deprecationReason,
                'type' => static::extendType($field->getType()),
                'args' => static::extendArgs($field->args),
                'astNode' => $field->astNode,
                'resolve' => $field->resolveFn,
            ];
        }

        $extensions = static::$typeExtensionsMap[$type->name] ?? null;
        if ($extensions !== null) {
            foreach ($extensions as $extension) {
                foreach ($extension->fields as $field) {
                    $fieldName = $field->name->value;
                    if (isset($oldFieldMap[$fieldName])) {
                        throw new Error('Field "' . $type->name . '.' . $fieldName . '" already exists in the schema. It cannot also be defined in this type extension.', [$field]);
                    }

                    $newFieldMap[$fieldName] = static::$astBuilder->buildField($field);
                }
            }
        }

        return $newFieldMap;
    }

    protected static function extendObjectType(ObjectType $type) : ObjectType
    {
        return new ObjectType([
            'name' => $type->name,
            'description' => $type->description,
            'interfaces' => static function () use ($type) : array {
                return static::extendImplementedInterfaces($type);
            },
            'fields' => static function () use ($type) : array {
                return static::extendFieldMap($type);
            },
            'astNode' => $type->astNode,
            'extensionASTNodes' => static::getExtensionASTNodes($type),
            'isTypeOf' => $type->config['isTypeOf'] ?? null,
            'resolveField' => $type->resolveFieldFn ?? null,
        ]);
    }

    protected static function extendInterfaceType(InterfaceType $type) : InterfaceType
    {
        return new InterfaceType([
            'name' => $type->name,
            'description' => $type->description,
            'interfaces' => static function () use ($type) : array {
                return static::extendImplementedInterfaces($type);
            },
            'fields' => static function () use ($type) : array {
                return static::extendFieldMap($type);
            },
            'astNode' => $type->astNode,
            'extensionASTNodes' => static::getExtensionASTNodes($type),
            'resolveType' => $type->config['resolveType'] ?? null,
        ]);
    }

    protected static function isSpecifiedScalarType(Type $type) : bool
    {
        return $type instanceof NamedType &&
            (
                $type->name === Type::STRING ||
                $type->name === Type::INT ||
                $type->name === Type::FLOAT ||
                $type->name === Type::BOOLEAN ||
                $type->name === Type::ID
            );
    }

    protected static function extendNamedType(Type $type)
    {
        if (Introspection::isIntrospectionType($type) || static::isSpecifiedScalarType($type)) {
            return $type;
        }

        $name = $type->name;
        if (! isset(static::$extendTypeCache[$name])) {
            if ($type instanceof ScalarType) {
                static::$extendTypeCache[$name] = static::extendScalarType($type);
            } elseif ($type instanceof ObjectType) {
                static::$extendTypeCache[$name] = static::extendObjectType($type);
            } elseif ($type instanceof InterfaceType) {
                static::$extendTypeCache[$name] = static::extendInterfaceType($type);
            } elseif ($type instanceof UnionType) {
                static::$extendTypeCache[$name] = static::extendUnionType($type);
            } elseif ($type instanceof EnumType) {
                static::$extendTypeCache[$name] = static::extendEnumType($type);
            } elseif ($type instanceof InputObjectType) {
                static::$extendTypeCache[$name] = static::extendInputObjectType($type);
            }
        }

        return static::$extendTypeCache[$name];
    }

    /**
     * @return mixed|null
     */
    protected static function extendMaybeNamedType(?NamedType $type = null)
    {
        if ($type !== null) {
            return static::extendNamedType($type);
        }

        return null;
    }

    /**
     * @param DirectiveDefinitionNode[] $directiveDefinitions
     *
     * @return Directive[]
     */
    protected static function getMergedDirectives(Schema $schema, array $directiveDefinitions) : array
    {
        $existingDirectives = array_map(static function (Directive $directive) : Directive {
            return static::extendDirective($directive);
        }, $schema->getDirectives());

        Utils::invariant(count($existingDirectives) > 0, 'schema must have default directives');

        return array_merge(
            $existingDirectives,
            array_map(static function (DirectiveDefinitionNode $directive) : Directive {
                return static::$astBuilder->buildDirective($directive);
            }, $directiveDefinitions)
        );
    }

    protected static function extendDirective(Directive $directive) : Directive
    {
        return new Directive([
            'name' => $directive->name,
            'description' => $directive->description,
            'locations' => $directive->locations,
            'args' => static::extendArgs($directive->args),
            'astNode' => $directive->astNode,
            'isRepeatable' => $directive->isRepeatable,
        ]);
    }

    /**
     * @param array<string, bool> $options
     */
    public static function extend(
        Schema $schema,
        DocumentNode $documentAST,
        array $options = [],
        ?callable $typeConfigDecorator = null
    ) : Schema {
        if (! (isset($options['assumeValid']) || isset($options['assumeValidSDL']))) {
            DocumentValidator::assertValidSDLExtension($documentAST, $schema);
        }

        /** @var array<string, Node&TypeDefinitionNode> $typeDefinitionMap */
        $typeDefinitionMap         = [];
        static::$typeExtensionsMap = [];
        $directiveDefinitions      = [];
        /** @var SchemaDefinitionNode|null $schemaDef */
        $schemaDef = null;
        /** @var array<int, SchemaTypeExtensionNode> $schemaExtensions */
        $schemaExtensions = [];

        $definitionsCount = count($documentAST->definitions);
        for ($i = 0; $i < $definitionsCount; $i++) {

            /** @var Node $def */
            $def = $documentAST->definitions[$i];

            if ($def instanceof SchemaDefinitionNode) {
                $schemaDef = $def;
            } elseif ($def instanceof SchemaTypeExtensionNode) {
                $schemaExtensions[] = $def;
            } elseif ($def instanceof TypeDefinitionNode) {
                $typeName = isset($def->name) ? $def->name->value : null;

                try {
                    $type = $schema->getType($typeName);
                } catch (Error $error) {
                    $type = null;
                }

                if ($type) {
                    throw new Error('Type "' . $typeName . '" already exists in the schema. It cannot also be defined in this type definition.', [$def]);
                }
                $typeDefinitionMap[$typeName] = $def;
            } elseif ($def instanceof TypeExtensionNode) {
                $extendedTypeName = isset($def->name) ? $def->name->value : null;
                $existingType     = $schema->getType($extendedTypeName);
                if ($existingType === null) {
                    throw new Error('Cannot extend type "' . $extendedTypeName . '" because it does not exist in the existing schema.', [$def]);
                }

                static::checkExtensionNode($existingType, $def);

                $existingTypeExtensions                       = static::$typeExtensionsMap[$extendedTypeName] ?? null;
                static::$typeExtensionsMap[$extendedTypeName] = $existingTypeExtensions !== null ? array_merge($existingTypeExtensions, [$def]) : [$def];
            } elseif ($def instanceof DirectiveDefinitionNode) {
                $directiveName     = $def->name->value;
                $existingDirective = $schema->getDirective($directiveName);
                if ($existingDirective !== null) {
                    throw new Error('Directive "' . $directiveName . '" already exists in the schema. It cannot be redefined.', [$def]);
                }
                $directiveDefinitions[] = $def;
            }
        }

        if (count(static::$typeExtensionsMap) === 0
            && count($typeDefinitionMap) === 0
            && count($directiveDefinitions) === 0
            && count($schemaExtensions) === 0
            && $schemaDef === null
        ) {
            return $schema;
        }

        static::$astBuilder = new ASTDefinitionBuilder(
            $typeDefinitionMap,
            $options,
            static function (string $typeName) use ($schema) {
                /** @var ScalarType|ObjectType|InterfaceType|UnionType|EnumType|InputObjectType $existingType */
                $existingType = $schema->getType($typeName);
                if ($existingType !== null) {
                    return static::extendNamedType($existingType);
                }

                throw new Error('Unknown type: "' . $typeName . '". Ensure that this type exists either in the original schema, or is added in a type definition.', [$typeName]);
            },
            $typeConfigDecorator
        );

        static::$extendTypeCache = [];

        $operationTypes = [
            'query' => static::extendMaybeNamedType($schema->getQueryType()),
            'mutation' => static::extendMaybeNamedType($schema->getMutationType()),
            'subscription' => static::extendMaybeNamedType($schema->getSubscriptionType()),
        ];

        if ($schemaDef) {
            foreach ($schemaDef->operationTypes as $operationType) {
                $operation = $operationType->operation;
                $type      = $operationType->type;

                if (isset($operationTypes[$operation])) {
                    throw new Error('Must provide only one ' . $operation . ' type in schema.');
                }

                $operationTypes[$operation] = static::$astBuilder->buildType($type);
            }
        }

        foreach ($schemaExtensions as $schemaExtension) {
            if ($schemaExtension->operationTypes === null) {
                continue;
            }

            foreach ($schemaExtension->operationTypes as $operationType) {
                $operation = $operationType->operation;
                if (isset($operationTypes[$operation])) {
                    throw new Error('Must provide only one ' . $operation . ' type in schema.');
                }
                $operationTypes[$operation] = static::$astBuilder->buildType($operationType->type);
            }
        }

        $schemaExtensionASTNodes = array_merge($schema->extensionASTNodes, $schemaExtensions);

        $types = array_merge(
            // Iterate through all types, getting the type definition for each, ensuring
            // that any type not directly referenced by a field will get created.
            array_map(static function (Type $type) : Type {
                return static::extendNamedType($type);
            }, $schema->getTypeMap()),
            // Do the same with new types.
            array_map(static function (TypeDefinitionNode $type) : Type {
                return static::$astBuilder->buildType($type);
            }, $typeDefinitionMap)
        );

        return new Schema([
            'query' => $operationTypes['query'],
            'mutation' => $operationTypes['mutation'],
            'subscription' => $operationTypes['subscription'],
            'types' => $types,
            'directives' => static::getMergedDirectives($schema, $directiveDefinitions),
            'astNode' => $schema->getAstNode(),
            'extensionASTNodes' => $schemaExtensionASTNodes,
        ]);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Utils\SchemaPrinter.php
<?php

declare(strict_types=1);

namespace GraphQL\Utils;

use GraphQL\Error\Error;
use GraphQL\Language\Printer;
use GraphQL\Type\Definition\Directive;
use GraphQL\Type\Definition\EnumType;
use GraphQL\Type\Definition\InputObjectType;
use GraphQL\Type\Definition\InterfaceType;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\ScalarType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Definition\UnionType;
use GraphQL\Type\Introspection;
use GraphQL\Type\Schema;
use function array_filter;
use function array_keys;
use function array_map;
use function array_merge;
use function array_values;
use function count;
use function explode;
use function implode;
use function ksort;
use function mb_strlen;
use function preg_match_all;
use function sprintf;
use function str_replace;
use function strlen;
use function substr;

/**
 * Given an instance of Schema, prints it in GraphQL type language.
 */
class SchemaPrinter
{
    /**
     * @param array<string, bool> $options
     *    Available options:
     *    - commentDescriptions:
     *        Provide true to use preceding comments as the description.
     *        This option is provided to ease adoption and will be removed in v16.
     *
     * @api
     */
    public static function doPrint(Schema $schema, array $options = []) : string
    {
        return static::printFilteredSchema(
            $schema,
            static function ($type) : bool {
                return ! Directive::isSpecifiedDirective($type);
            },
            static function ($type) : bool {
                return ! Type::isBuiltInType($type);
            },
            $options
        );
    }

    /**
     * @param array<string, bool> $options
     */
    protected static function printFilteredSchema(Schema $schema, callable $directiveFilter, callable $typeFilter, array $options) : string
    {
        $directives = array_filter($schema->getDirectives(), $directiveFilter);

        $types = $schema->getTypeMap();
        ksort($types);
        $types = array_filter($types, $typeFilter);

        return sprintf(
            "%s\n",
            implode(
                "\n\n",
                array_filter(
                    array_merge(
                        [static::printSchemaDefinition($schema)],
                        array_map(
                            static function (Directive $directive) use ($options) : string {
                                return static::printDirective($directive, $options);
                            },
                            $directives
                        ),
                        array_map(
                            static function ($type) use ($options) : string {
                                return static::printType($type, $options);
                            },
                            $types
                        )
                    )
                )
            )
        );
    }

    protected static function printSchemaDefinition(Schema $schema) : string
    {
        if (static::isSchemaOfCommonNames($schema)) {
            return '';
        }

        $operationTypes = [];

        $queryType = $schema->getQueryType();
        if ($queryType !== null) {
            $operationTypes[] = sprintf('  query: %s', $queryType->name);
        }

        $mutationType = $schema->getMutationType();
        if ($mutationType !== null) {
            $operationTypes[] = sprintf('  mutation: %s', $mutationType->name);
        }

        $subscriptionType = $schema->getSubscriptionType();
        if ($subscriptionType !== null) {
            $operationTypes[] = sprintf('  subscription: %s', $subscriptionType->name);
        }

        return sprintf("schema {\n%s\n}", implode("\n", $operationTypes));
    }

    /**
     * GraphQL schema define root types for each type of operation. These types are
     * the same as any other type and can be named in any manner, however there is
     * a common naming convention:
     *
     *   schema {
     *     query: Query
     *     mutation: Mutation
     *   }
     *
     * When using this naming convention, the schema description can be omitted.
     */
    protected static function isSchemaOfCommonNames(Schema $schema) : bool
    {
        $queryType = $schema->getQueryType();
        if ($queryType !== null && $queryType->name !== 'Query') {
            return false;
        }

        $mutationType = $schema->getMutationType();
        if ($mutationType !== null && $mutationType->name !== 'Mutation') {
            return false;
        }

        $subscriptionType = $schema->getSubscriptionType();

        return $subscriptionType === null || $subscriptionType->name === 'Subscription';
    }

    /**
     * @param array<string, bool> $options
     */
    protected static function printDirective(Directive $directive, array $options) : string
    {
        return static::printDescription($options, $directive)
            . 'directive @' . $directive->name
            . static::printArgs($options, $directive->args)
            . ($directive->isRepeatable ? ' repeatable' : '')
            . ' on ' . implode(' | ', $directive->locations);
    }

    /**
     * @param array<string, bool> $options
     */
    protected static function printDescription(array $options, $def, $indentation = '', $firstInBlock = true) : string
    {
        if (! $def->description) {
            return '';
        }
        $lines = static::descriptionLines($def->description, 120 - strlen($indentation));
        if (isset($options['commentDescriptions'])) {
            return static::printDescriptionWithComments($lines, $indentation, $firstInBlock);
        }

        $description = $indentation && ! $firstInBlock
            ? "\n" . $indentation . '"""'
            : $indentation . '"""';

        // In some circumstances, a single line can be used for the description.
        if (count($lines) === 1 &&
            mb_strlen($lines[0]) < 70 &&
            substr($lines[0], -1) !== '"'
        ) {
            return $description . static::escapeQuote($lines[0]) . "\"\"\"\n";
        }

        // Format a multi-line block quote to account for leading space.
        $hasLeadingSpace = isset($lines[0]) &&
            (
                substr($lines[0], 0, 1) === ' ' ||
                substr($lines[0], 0, 1) === '\t'
            );
        if (! $hasLeadingSpace) {
            $description .= "\n";
        }

        $lineLength = count($lines);
        for ($i = 0; $i < $lineLength; $i++) {
            if ($i !== 0 || ! $hasLeadingSpace) {
                $description .= $indentation;
            }
            $description .= static::escapeQuote($lines[$i]) . "\n";
        }
        $description .= $indentation . "\"\"\"\n";

        return $description;
    }

    /**
     * @return string[]
     */
    protected static function descriptionLines(string $description, int $maxLen) : array
    {
        $lines    = [];
        $rawLines = explode("\n", $description);
        foreach ($rawLines as $line) {
            if ($line === '') {
                $lines[] = $line;
            } else {
                // For > 120 character long lines, cut at space boundaries into sublines
                // of ~80 chars.
                $sublines = static::breakLine($line, $maxLen);
                foreach ($sublines as $subline) {
                    $lines[] = $subline;
                }
            }
        }

        return $lines;
    }

    /**
     * @return string[]
     */
    protected static function breakLine(string $line, int $maxLen) : array
    {
        if (strlen($line) < $maxLen + 5) {
            return [$line];
        }
        preg_match_all('/((?: |^).{15,' . ($maxLen - 40) . '}(?= |$))/', $line, $parts);
        $parts = $parts[0];

        return array_map('trim', $parts);
    }

    protected static function printDescriptionWithComments($lines, $indentation, $firstInBlock) : string
    {
        $description = $indentation && ! $firstInBlock ? "\n" : '';
        foreach ($lines as $line) {
            if ($line === '') {
                $description .= $indentation . "#\n";
            } else {
                $description .= $indentation . '# ' . $line . "\n";
            }
        }

        return $description;
    }

    protected static function escapeQuote($line) : string
    {
        return str_replace('"""', '\\"""', $line);
    }

    /**
     * @param array<string, bool> $options
     */
    protected static function printArgs(array $options, $args, $indentation = '') : string
    {
        if (! $args) {
            return '';
        }

        // If every arg does not have a description, print them on one line.
        if (Utils::every(
            $args,
            static function ($arg) : bool {
                return strlen($arg->description ?? '') === 0;
            }
        )) {
            return '(' . implode(', ', array_map([static::class, 'printInputValue'], $args)) . ')';
        }

        return sprintf(
            "(\n%s\n%s)",
            implode(
                "\n",
                array_map(
                    static function ($arg, $i) use ($indentation, $options) : string {
                        return static::printDescription($options, $arg, '  ' . $indentation, ! $i) . '  ' . $indentation .
                            static::printInputValue($arg);
                    },
                    $args,
                    array_keys($args)
                )
            ),
            $indentation
        );
    }

    protected static function printInputValue($arg) : string
    {
        $argDecl = $arg->name . ': ' . (string) $arg->getType();
        if ($arg->defaultValueExists()) {
            $argDecl .= ' = ' . Printer::doPrint(AST::astFromValue($arg->defaultValue, $arg->getType()));
        }

        return $argDecl;
    }

    /**
     * @param array<string, bool> $options
     */
    public static function printType(Type $type, array $options = []) : string
    {
        if ($type instanceof ScalarType) {
            return static::printScalar($type, $options);
        }

        if ($type instanceof ObjectType) {
            return static::printObject($type, $options);
        }

        if ($type instanceof InterfaceType) {
            return static::printInterface($type, $options);
        }

        if ($type instanceof UnionType) {
            return static::printUnion($type, $options);
        }

        if ($type instanceof EnumType) {
            return static::printEnum($type, $options);
        }

        if ($type instanceof InputObjectType) {
            return static::printInputObject($type, $options);
        }

        throw new Error(sprintf('Unknown type: %s.', Utils::printSafe($type)));
    }

    /**
     * @param array<string, bool> $options
     */
    protected static function printScalar(ScalarType $type, array $options) : string
    {
        return sprintf('%sscalar %s', static::printDescription($options, $type), $type->name);
    }

    /**
     * @param array<string, bool> $options
     */
    protected static function printObject(ObjectType $type, array $options) : string
    {
        $interfaces            = $type->getInterfaces();
        $implementedInterfaces = count($interfaces) > 0
            ? ' implements ' . implode(
                ' & ',
                array_map(
                    static function (InterfaceType $interface) : string {
                        return $interface->name;
                    },
                    $interfaces
                )
            )
            : '';

        return static::printDescription($options, $type) .
            sprintf("type %s%s {\n%s\n}", $type->name, $implementedInterfaces, static::printFields($options, $type));
    }

    /**
     * @param array<string, bool> $options
     */
    protected static function printFields(array $options, $type) : string
    {
        $fields = array_values($type->getFields());

        return implode(
            "\n",
            array_map(
                static function ($f, $i) use ($options) : string {
                    return static::printDescription($options, $f, '  ', ! $i) . '  ' .
                        $f->name . static::printArgs($options, $f->args, '  ') . ': ' .
                        (string) $f->getType() . static::printDeprecated($f);
                },
                $fields,
                array_keys($fields)
            )
        );
    }

    protected static function printDeprecated($fieldOrEnumVal) : string
    {
        $reason = $fieldOrEnumVal->deprecationReason;
        if ($reason === null) {
            return '';
        }
        if ($reason === '' || $reason === Directive::DEFAULT_DEPRECATION_REASON) {
            return ' @deprecated';
        }

        return ' @deprecated(reason: ' .
            Printer::doPrint(AST::astFromValue($reason, Type::string())) . ')';
    }

    /**
     * @param array<string, bool> $options
     */
    protected static function printInterface(InterfaceType $type, array $options) : string
    {
        $interfaces            = $type->getInterfaces();
        $implementedInterfaces = count($interfaces) > 0
            ? ' implements ' . implode(
                ' & ',
                array_map(
                    static function (InterfaceType $interface) : string {
                        return $interface->name;
                    },
                    $interfaces
                )
            )
            : '';

        return static::printDescription($options, $type) .
            sprintf("interface %s%s {\n%s\n}", $type->name, $implementedInterfaces, static::printFields($options, $type));
    }

    /**
     * @param array<string, bool> $options
     */
    protected static function printUnion(UnionType $type, array $options) : string
    {
        return static::printDescription($options, $type) .
            sprintf('union %s = %s', $type->name, implode(' | ', $type->getTypes()));
    }

    /**
     * @param array<string, bool> $options
     */
    protected static function printEnum(EnumType $type, array $options) : string
    {
        return static::printDescription($options, $type) .
            sprintf("enum %s {\n%s\n}", $type->name, static::printEnumValues($type->getValues(), $options));
    }

    /**
     * @param array<string, bool> $options
     */
    protected static function printEnumValues($values, array $options) : string
    {
        return implode(
            "\n",
            array_map(
                static function ($value, $i) use ($options) : string {
                    return static::printDescription($options, $value, '  ', ! $i) . '  ' .
                        $value->name . static::printDeprecated($value);
                },
                $values,
                array_keys($values)
            )
        );
    }

    /**
     * @param array<string, bool> $options
     */
    protected static function printInputObject(InputObjectType $type, array $options) : string
    {
        $fields = array_values($type->getFields());

        return static::printDescription($options, $type) .
            sprintf(
                "input %s {\n%s\n}",
                $type->name,
                implode(
                    "\n",
                    array_map(
                        static function ($f, $i) use ($options) : string {
                            return static::printDescription($options, $f, '  ', ! $i) . '  ' . static::printInputValue($f);
                        },
                        $fields,
                        array_keys($fields)
                    )
                )
            );
    }

    /**
     * @param array<string, bool> $options
     *
     * @api
     */
    public static function printIntrospectionSchema(Schema $schema, array $options = []) : string
    {
        return static::printFilteredSchema(
            $schema,
            [Directive::class, 'isSpecifiedDirective'],
            [Introspection::class, 'isIntrospectionType'],
            $options
        );
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Utils\TypeComparators.php
<?php

declare(strict_types=1);

namespace GraphQL\Utils;

use GraphQL\Type\Definition\AbstractType;
use GraphQL\Type\Definition\CompositeType;
use GraphQL\Type\Definition\ImplementingType;
use GraphQL\Type\Definition\ListOfType;
use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Schema;

class TypeComparators
{
    /**
     * Provided two types, return true if the types are equal (invariant).
     *
     * @return bool
     */
    public static function isEqualType(Type $typeA, Type $typeB)
    {
        // Equivalent types are equal.
        if ($typeA === $typeB) {
            return true;
        }

        // If either type is non-null, the other must also be non-null.
        if ($typeA instanceof NonNull && $typeB instanceof NonNull) {
            return self::isEqualType($typeA->getWrappedType(), $typeB->getWrappedType());
        }

        // If either type is a list, the other must also be a list.
        if ($typeA instanceof ListOfType && $typeB instanceof ListOfType) {
            return self::isEqualType($typeA->getWrappedType(), $typeB->getWrappedType());
        }

        // Otherwise the types are not equal.
        return false;
    }

    /**
     * Provided a type and a super type, return true if the first type is either
     * equal or a subset of the second super type (covariant).
     *
     * @return bool
     */
    public static function isTypeSubTypeOf(Schema $schema, Type $maybeSubType, Type $superType)
    {
        // Equivalent type is a valid subtype
        if ($maybeSubType === $superType) {
            return true;
        }

        // If superType is non-null, maybeSubType must also be nullable.
        if ($superType instanceof NonNull) {
            if ($maybeSubType instanceof NonNull) {
                return self::isTypeSubTypeOf($schema, $maybeSubType->getWrappedType(), $superType->getWrappedType());
            }

            return false;
        }

        if ($maybeSubType instanceof NonNull) {
            // If superType is nullable, maybeSubType may be non-null.
            return self::isTypeSubTypeOf($schema, $maybeSubType->getWrappedType(), $superType);
        }

        // If superType type is a list, maybeSubType type must also be a list.
        if ($superType instanceof ListOfType) {
            if ($maybeSubType instanceof ListOfType) {
                return self::isTypeSubTypeOf($schema, $maybeSubType->getWrappedType(), $superType->getWrappedType());
            }

            return false;
        }

        if ($maybeSubType instanceof ListOfType) {
            // If superType is not a list, maybeSubType must also be not a list.
            return false;
        }

        // If superType type is an abstract type, maybeSubType type may be a currently
        // possible object or interface type.
        return Type::isAbstractType($superType) &&
            $maybeSubType instanceof ImplementingType &&
            $schema->isSubType(
                $superType,
                $maybeSubType
            );
    }

    /**
     * Provided two composite types, determine if they "overlap". Two composite
     * types overlap when the Sets of possible concrete types for each intersect.
     *
     * This is often used to determine if a fragment of a given type could possibly
     * be visited in a context of another type.
     *
     * This function is commutative.
     *
     * @return bool
     */
    public static function doTypesOverlap(Schema $schema, CompositeType $typeA, CompositeType $typeB)
    {
        // Equivalent types overlap
        if ($typeA === $typeB) {
            return true;
        }

        if ($typeA instanceof AbstractType) {
            if ($typeB instanceof AbstractType) {
                // If both types are abstract, then determine if there is any intersection
                // between possible concrete types of each.
                foreach ($schema->getPossibleTypes($typeA) as $type) {
                    if ($schema->isSubType($typeB, $type)) {
                        return true;
                    }
                }

                return false;
            }

            // Determine if the latter type is a possible concrete type of the former.
            return $schema->isSubType($typeA, $typeB);
        }

        if ($typeB instanceof AbstractType) {
            // Determine if the former type is a possible concrete type of the latter.
            return $schema->isSubType($typeB, $typeA);
        }

        // Otherwise the types do not overlap.
        return false;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Utils\TypeInfo.php
<?php

declare(strict_types=1);

namespace GraphQL\Utils;

use GraphQL\Error\InvariantViolation;
use GraphQL\Language\AST\ArgumentNode;
use GraphQL\Language\AST\DirectiveNode;
use GraphQL\Language\AST\EnumValueNode;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\FragmentDefinitionNode;
use GraphQL\Language\AST\InlineFragmentNode;
use GraphQL\Language\AST\ListTypeNode;
use GraphQL\Language\AST\ListValueNode;
use GraphQL\Language\AST\NamedTypeNode;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\NonNullTypeNode;
use GraphQL\Language\AST\ObjectFieldNode;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Language\AST\SelectionSetNode;
use GraphQL\Language\AST\VariableDefinitionNode;
use GraphQL\Type\Definition\CompositeType;
use GraphQL\Type\Definition\Directive;
use GraphQL\Type\Definition\EnumType;
use GraphQL\Type\Definition\FieldArgument;
use GraphQL\Type\Definition\FieldDefinition;
use GraphQL\Type\Definition\HasFieldsType;
use GraphQL\Type\Definition\ImplementingType;
use GraphQL\Type\Definition\InputObjectType;
use GraphQL\Type\Definition\InputType;
use GraphQL\Type\Definition\InterfaceType;
use GraphQL\Type\Definition\ListOfType;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\OutputType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Definition\UnionType;
use GraphQL\Type\Definition\WrappingType;
use GraphQL\Type\Introspection;
use GraphQL\Type\Schema;
use function array_map;
use function array_merge;
use function array_pop;
use function count;
use function is_array;
use function sprintf;

class TypeInfo
{
    /** @var Schema */
    private $schema;

    /** @var array<(OutputType&Type)|null> */
    private $typeStack;

    /** @var array<(CompositeType&Type)|null> */
    private $parentTypeStack;

    /** @var array<(InputType&Type)|null> */
    private $inputTypeStack;

    /** @var array<FieldDefinition> */
    private $fieldDefStack;

    /** @var array<mixed> */
    private $defaultValueStack;

    /** @var Directive|null */
    private $directive;

    /** @var FieldArgument|null */
    private $argument;

    /** @var mixed */
    private $enumValue;

    /**
     * @param Type|null $initialType
     */
    public function __construct(Schema $schema, $initialType = null)
    {
        $this->schema            = $schema;
        $this->typeStack         = [];
        $this->parentTypeStack   = [];
        $this->inputTypeStack    = [];
        $this->fieldDefStack     = [];
        $this->defaultValueStack = [];

        if ($initialType === null) {
            return;
        }

        if (Type::isInputType($initialType)) {
            $this->inputTypeStack[] = $initialType;
        }
        if (Type::isCompositeType($initialType)) {
            $this->parentTypeStack[] = $initialType;
        }
        if (! Type::isOutputType($initialType)) {
            return;
        }

        $this->typeStack[] = $initialType;
    }

    /**
     * @deprecated moved to GraphQL\Utils\TypeComparators
     *
     * @codeCoverageIgnore
     */
    public static function isEqualType(Type $typeA, Type $typeB) : bool
    {
        return TypeComparators::isEqualType($typeA, $typeB);
    }

    /**
     * @deprecated moved to GraphQL\Utils\TypeComparators
     *
     * @codeCoverageIgnore
     */
    public static function isTypeSubTypeOf(Schema $schema, Type $maybeSubType, Type $superType)
    {
        return TypeComparators::isTypeSubTypeOf($schema, $maybeSubType, $superType);
    }

    /**
     * @deprecated moved to GraphQL\Utils\TypeComparators
     *
     * @codeCoverageIgnore
     */
    public static function doTypesOverlap(Schema $schema, CompositeType $typeA, CompositeType $typeB)
    {
        return TypeComparators::doTypesOverlap($schema, $typeA, $typeB);
    }

    /**
     * Given root type scans through all fields to find nested types. Returns array where keys are for type name
     * and value contains corresponding type instance.
     *
     * Example output:
     * [
     *     'String' => $instanceOfStringType,
     *     'MyType' => $instanceOfMyType,
     *     ...
     * ]
     *
     * @param Type|null   $type
     * @param Type[]|null $typeMap
     *
     * @return Type[]|null
     */
    public static function extractTypes($type, ?array $typeMap = null)
    {
        if (! $typeMap) {
            $typeMap = [];
        }
        if (! $type) {
            return $typeMap;
        }

        if ($type instanceof WrappingType) {
            return self::extractTypes($type->getWrappedType(true), $typeMap);
        }

        if (! $type instanceof Type) {
            // Preserve these invalid types in map (at numeric index) to make them
            // detectable during $schema->validate()
            $i            = 0;
            $alreadyInMap = false;
            while (isset($typeMap[$i])) {
                $alreadyInMap = $alreadyInMap || $typeMap[$i] === $type;
                $i++;
            }
            if (! $alreadyInMap) {
                $typeMap[$i] = $type;
            }

            return $typeMap;
        }

        if (isset($typeMap[$type->name])) {
            Utils::invariant(
                $typeMap[$type->name] === $type,
                sprintf('Schema must contain unique named types but contains multiple types named "%s" ', $type) .
                '(see http://webonyx.github.io/graphql-php/type-system/#type-registry).'
            );

            return $typeMap;
        }
        $typeMap[$type->name] = $type;

        $nestedTypes = [];

        if ($type instanceof UnionType) {
            $nestedTypes = $type->getTypes();
        }
        if ($type instanceof ImplementingType) {
            $nestedTypes = array_merge($nestedTypes, $type->getInterfaces());
        }

        if ($type instanceof HasFieldsType) {
            foreach ($type->getFields() as $field) {
                if (count($field->args) > 0) {
                    $fieldArgTypes = array_map(
                        static function (FieldArgument $arg) : Type {
                            return $arg->getType();
                        },
                        $field->args
                    );

                    $nestedTypes = array_merge($nestedTypes, $fieldArgTypes);
                }
                $nestedTypes[] = $field->getType();
            }
        }
        if ($type instanceof InputObjectType) {
            foreach ($type->getFields() as $field) {
                $nestedTypes[] = $field->getType();
            }
        }
        foreach ($nestedTypes as $nestedType) {
            $typeMap = self::extractTypes($nestedType, $typeMap);
        }

        return $typeMap;
    }

    /**
     * @param Type[] $typeMap
     *
     * @return Type[]
     */
    public static function extractTypesFromDirectives(Directive $directive, array $typeMap = [])
    {
        if (is_array($directive->args)) {
            foreach ($directive->args as $arg) {
                $typeMap = self::extractTypes($arg->getType(), $typeMap);
            }
        }

        return $typeMap;
    }

    /**
     * @return (Type&InputType)|null
     */
    public function getParentInputType() : ?InputType
    {
        return $this->inputTypeStack[count($this->inputTypeStack) - 2] ?? null;
    }

    public function getArgument() : ?FieldArgument
    {
        return $this->argument;
    }

    /**
     * @return mixed
     */
    public function getEnumValue()
    {
        return $this->enumValue;
    }

    public function enter(Node $node)
    {
        $schema = $this->schema;

        // Note: many of the types below are explicitly typed as "mixed" to drop
        // any assumptions of a valid schema to ensure runtime types are properly
        // checked before continuing since TypeInfo is used as part of validation
        // which occurs before guarantees of schema and document validity.
        switch (true) {
            case $node instanceof SelectionSetNode:
                $namedType               = Type::getNamedType($this->getType());
                $this->parentTypeStack[] = Type::isCompositeType($namedType) ? $namedType : null;
                break;

            case $node instanceof FieldNode:
                $parentType = $this->getParentType();
                $fieldDef   = null;
                if ($parentType) {
                    $fieldDef = self::getFieldDefinition($schema, $parentType, $node);
                }
                $fieldType = null;
                if ($fieldDef) {
                    $fieldType = $fieldDef->getType();
                }
                $this->fieldDefStack[] = $fieldDef;
                $this->typeStack[]     = Type::isOutputType($fieldType) ? $fieldType : null;
                break;

            case $node instanceof DirectiveNode:
                $this->directive = $schema->getDirective($node->name->value);
                break;

            case $node instanceof OperationDefinitionNode:
                $type = null;
                if ($node->operation === 'query') {
                    $type = $schema->getQueryType();
                } elseif ($node->operation === 'mutation') {
                    $type = $schema->getMutationType();
                } elseif ($node->operation === 'subscription') {
                    $type = $schema->getSubscriptionType();
                }
                $this->typeStack[] = Type::isOutputType($type) ? $type : null;
                break;

            case $node instanceof InlineFragmentNode:
            case $node instanceof FragmentDefinitionNode:
                $typeConditionNode = $node->typeCondition;
                $outputType        = $typeConditionNode
                    ? self::typeFromAST(
                        $schema,
                        $typeConditionNode
                    )
                    : Type::getNamedType($this->getType());
                $this->typeStack[] = Type::isOutputType($outputType) ? $outputType : null;
                break;

            case $node instanceof VariableDefinitionNode:
                $inputType              = self::typeFromAST($schema, $node->type);
                $this->inputTypeStack[] = Type::isInputType($inputType) ? $inputType : null; // push
                break;

            case $node instanceof ArgumentNode:
                $fieldOrDirective = $this->getDirective() ?? $this->getFieldDef();
                $argDef           = $argType = null;
                if ($fieldOrDirective) {
                    /** @var FieldArgument $argDef */
                    $argDef = Utils::find(
                        $fieldOrDirective->args,
                        static function ($arg) use ($node) : bool {
                            return $arg->name === $node->name->value;
                        }
                    );
                    if ($argDef !== null) {
                        $argType = $argDef->getType();
                    }
                }
                $this->argument            = $argDef;
                $this->defaultValueStack[] = $argDef && $argDef->defaultValueExists() ? $argDef->defaultValue : Utils::undefined();
                $this->inputTypeStack[]    = Type::isInputType($argType) ? $argType : null;
                break;

            case $node instanceof ListValueNode:
                $type     = $this->getInputType();
                $listType = $type === null ? null : Type::getNullableType($type);
                $itemType = $listType instanceof ListOfType
                    ? $listType->getWrappedType()
                    : $listType;
                // List positions never have a default value.
                $this->defaultValueStack[] = Utils::undefined();
                $this->inputTypeStack[]    = Type::isInputType($itemType) ? $itemType : null;
                break;

            case $node instanceof ObjectFieldNode:
                $objectType     = Type::getNamedType($this->getInputType());
                $fieldType      = null;
                $inputField     = null;
                $inputFieldType = null;
                if ($objectType instanceof InputObjectType) {
                    $tmp            = $objectType->getFields();
                    $inputField     = $tmp[$node->name->value] ?? null;
                    $inputFieldType = $inputField ? $inputField->getType() : null;
                }
                $this->defaultValueStack[] = $inputField && $inputField->defaultValueExists() ? $inputField->defaultValue : Utils::undefined();
                $this->inputTypeStack[]    = Type::isInputType($inputFieldType) ? $inputFieldType : null;
                break;

            case $node instanceof EnumValueNode:
                $enumType  = Type::getNamedType($this->getInputType());
                $enumValue = null;
                if ($enumType instanceof EnumType) {
                    $this->enumValue = $enumType->getValue($node->value);
                }
                $this->enumValue = $enumValue;
                break;
        }
    }

    /**
     * @return (Type & OutputType) | null
     */
    public function getType() : ?OutputType
    {
        return $this->typeStack[count($this->typeStack) - 1] ?? null;
    }

    /**
     * @return (CompositeType & Type) | null
     */
    public function getParentType() : ?CompositeType
    {
        return $this->parentTypeStack[count($this->parentTypeStack) - 1] ?? null;
    }

    /**
     * Not exactly the same as the executor's definition of getFieldDef, in this
     * statically evaluated environment we do not always have an Object type,
     * and need to handle Interface and Union types.
     */
    private static function getFieldDefinition(Schema $schema, Type $parentType, FieldNode $fieldNode) : ?FieldDefinition
    {
        $name       = $fieldNode->name->value;
        $schemaMeta = Introspection::schemaMetaFieldDef();
        if ($name === $schemaMeta->name && $schema->getQueryType() === $parentType) {
            return $schemaMeta;
        }

        $typeMeta = Introspection::typeMetaFieldDef();
        if ($name === $typeMeta->name && $schema->getQueryType() === $parentType) {
            return $typeMeta;
        }
        $typeNameMeta = Introspection::typeNameMetaFieldDef();
        if ($name === $typeNameMeta->name && $parentType instanceof CompositeType) {
            return $typeNameMeta;
        }

        if ($parentType instanceof ObjectType ||
            $parentType instanceof InterfaceType
        ) {
            return $parentType->findField($name);
        }

        return null;
    }

    /**
     * @param NamedTypeNode|ListTypeNode|NonNullTypeNode $inputTypeNode
     *
     * @throws InvariantViolation
     */
    public static function typeFromAST(Schema $schema, $inputTypeNode) : ?Type
    {
        return AST::typeFromAST($schema, $inputTypeNode);
    }

    public function getDirective() : ?Directive
    {
        return $this->directive;
    }

    public function getFieldDef() : ?FieldDefinition
    {
        return $this->fieldDefStack[count($this->fieldDefStack) - 1] ?? null;
    }

    /**
     * @return mixed|null
     */
    public function getDefaultValue()
    {
        return $this->defaultValueStack[count($this->defaultValueStack) - 1] ?? null;
    }

    /**
     * @return (Type & InputType) | null
     */
    public function getInputType() : ?InputType
    {
        return $this->inputTypeStack[count($this->inputTypeStack) - 1] ?? null;
    }

    public function leave(Node $node)
    {
        switch (true) {
            case $node instanceof SelectionSetNode:
                array_pop($this->parentTypeStack);
                break;

            case $node instanceof FieldNode:
                array_pop($this->fieldDefStack);
                array_pop($this->typeStack);
                break;

            case $node instanceof DirectiveNode:
                $this->directive = null;
                break;

            case $node instanceof OperationDefinitionNode:
            case $node instanceof InlineFragmentNode:
            case $node instanceof FragmentDefinitionNode:
                array_pop($this->typeStack);
                break;
            case $node instanceof VariableDefinitionNode:
                array_pop($this->inputTypeStack);
                break;
            case $node instanceof ArgumentNode:
                $this->argument = null;
                array_pop($this->defaultValueStack);
                array_pop($this->inputTypeStack);
                break;
            case $node instanceof ListValueNode:
            case $node instanceof ObjectFieldNode:
                array_pop($this->defaultValueStack);
                array_pop($this->inputTypeStack);
                break;
            case $node instanceof EnumValueNode:
                $this->enumValue = null;
                break;
        }
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Utils\Utils.php
<?php

declare(strict_types=1);

namespace GraphQL\Utils;

use ErrorException;
use Exception;
use GraphQL\Error\Error;
use GraphQL\Error\InvariantViolation;
use GraphQL\Error\Warning;
use GraphQL\Language\AST\Node;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Definition\WrappingType;
use InvalidArgumentException;
use LogicException;
use stdClass;
use Traversable;
use function array_keys;
use function array_map;
use function array_reduce;
use function array_shift;
use function array_slice;
use function array_values;
use function asort;
use function count;
use function dechex;
use function func_get_args;
use function func_num_args;
use function get_class;
use function gettype;
use function is_array;
use function is_int;
use function is_object;
use function is_scalar;
use function is_string;
use function json_encode;
use function levenshtein;
use function max;
use function mb_convert_encoding;
use function mb_strlen;
use function mb_substr;
use function method_exists;
use function ord;
use function pack;
use function preg_match;
use function property_exists;
use function range;
use function restore_error_handler;
use function set_error_handler;
use function sprintf;
use function strtolower;
use function unpack;

class Utils
{
    public static function undefined()
    {
        static $undefined;

        return $undefined ?? $undefined = new stdClass();
    }

    /**
     * Check if the value is invalid
     *
     * @param mixed $value
     *
     * @return bool
     */
    public static function isInvalid($value)
    {
        return self::undefined() === $value;
    }

    /**
     * @param object   $obj
     * @param mixed[]  $vars
     * @param string[] $requiredKeys
     *
     * @return object
     */
    public static function assign($obj, array $vars, array $requiredKeys = [])
    {
        foreach ($requiredKeys as $key) {
            if (! isset($vars[$key])) {
                throw new InvalidArgumentException(sprintf('Key %s is expected to be set and not to be null', $key));
            }
        }

        foreach ($vars as $key => $value) {
            if (! property_exists($obj, $key)) {
                $cls = get_class($obj);
                Warning::warn(
                    sprintf("Trying to set non-existing property '%s' on class '%s'", $key, $cls),
                    Warning::WARNING_ASSIGN
                );
            }
            $obj->{$key} = $value;
        }

        return $obj;
    }

    /**
     * @param iterable<mixed> $iterable
     *
     * @return mixed|null
     */
    public static function find($iterable, callable $predicate)
    {
        self::invariant(
            is_array($iterable) || $iterable instanceof Traversable,
            __METHOD__ . ' expects array or Traversable'
        );

        foreach ($iterable as $key => $value) {
            if ($predicate($value, $key)) {
                return $value;
            }
        }

        return null;
    }

    /**
     * @param iterable<mixed> $iterable
     *
     * @return array<mixed>
     *
     * @throws Exception
     */
    public static function filter($iterable, callable $predicate) : array
    {
        self::invariant(
            is_array($iterable) || $iterable instanceof Traversable,
            __METHOD__ . ' expects array or Traversable'
        );

        $result = [];
        $assoc  = false;
        foreach ($iterable as $key => $value) {
            if (! $assoc && ! is_int($key)) {
                $assoc = true;
            }
            if (! $predicate($value, $key)) {
                continue;
            }

            $result[$key] = $value;
        }

        return $assoc ? $result : array_values($result);
    }

    /**
     * @param iterable<mixed> $iterable
     *
     * @return array<mixed>
     *
     * @throws Exception
     */
    public static function map($iterable, callable $fn) : array
    {
        self::invariant(
            is_array($iterable) || $iterable instanceof Traversable,
            __METHOD__ . ' expects array or Traversable'
        );

        $map = [];
        foreach ($iterable as $key => $value) {
            $map[$key] = $fn($value, $key);
        }

        return $map;
    }

    /**
     * @param iterable<mixed> $iterable
     *
     * @return array<mixed>
     *
     * @throws Exception
     */
    public static function mapKeyValue($iterable, callable $fn) : array
    {
        self::invariant(
            is_array($iterable) || $iterable instanceof Traversable,
            __METHOD__ . ' expects array or Traversable'
        );

        $map = [];
        foreach ($iterable as $key => $value) {
            [$newKey, $newValue] = $fn($value, $key);
            $map[$newKey]        = $newValue;
        }

        return $map;
    }

    /**
     * @param iterable<mixed> $iterable
     *
     * @return array<mixed>
     *
     * @throws Exception
     */
    public static function keyMap($iterable, callable $keyFn) : array
    {
        self::invariant(
            is_array($iterable) || $iterable instanceof Traversable,
            __METHOD__ . ' expects array or Traversable'
        );

        $map = [];
        foreach ($iterable as $key => $value) {
            $newKey = $keyFn($value, $key);
            if (! is_scalar($newKey)) {
                continue;
            }

            $map[$newKey] = $value;
        }

        return $map;
    }

    /**
     * @param iterable<mixed> $iterable
     */
    public static function each($iterable, callable $fn) : void
    {
        self::invariant(
            is_array($iterable) || $iterable instanceof Traversable,
            __METHOD__ . ' expects array or Traversable'
        );

        foreach ($iterable as $key => $item) {
            $fn($item, $key);
        }
    }

    /**
     * Splits original iterable to several arrays with keys equal to $keyFn return
     *
     * E.g. Utils::groupBy([1, 2, 3, 4, 5], function($value) {return $value % 3}) will output:
     * [
     *    1 => [1, 4],
     *    2 => [2, 5],
     *    0 => [3],
     * ]
     *
     * $keyFn is also allowed to return array of keys. Then value will be added to all arrays with given keys
     *
     * @param iterable<mixed> $iterable
     *
     * @return array<array<mixed>>
     */
    public static function groupBy($iterable, callable $keyFn) : array
    {
        self::invariant(
            is_array($iterable) || $iterable instanceof Traversable,
            __METHOD__ . ' expects array or Traversable'
        );

        $grouped = [];
        foreach ($iterable as $key => $value) {
            $newKeys = (array) $keyFn($value, $key);
            foreach ($newKeys as $newKey) {
                $grouped[$newKey][] = $value;
            }
        }

        return $grouped;
    }

    /**
     * @param iterable<mixed> $iterable
     *
     * @return array<mixed>
     */
    public static function keyValMap($iterable, callable $keyFn, callable $valFn) : array
    {
        $map = [];
        foreach ($iterable as $item) {
            $map[$keyFn($item)] = $valFn($item);
        }

        return $map;
    }

    /**
     * @param iterable<mixed> $iterable
     */
    public static function every($iterable, callable $predicate) : bool
    {
        foreach ($iterable as $key => $value) {
            if (! $predicate($value, $key)) {
                return false;
            }
        }

        return true;
    }

    /**
     * @param iterable<mixed> $iterable
     */
    public static function some($iterable, callable $predicate) : bool
    {
        foreach ($iterable as $key => $value) {
            if ($predicate($value, $key)) {
                return true;
            }
        }

        return false;
    }

    /**
     * @param bool   $test
     * @param string $message
     */
    public static function invariant($test, $message = '')
    {
        if (! $test) {
            if (func_num_args() > 2) {
                $args = func_get_args();
                array_shift($args);
                $message = sprintf(...$args);
            }
            // TODO switch to Error here
            throw new InvariantViolation($message);
        }
    }

    /**
     * @param Type|mixed $var
     *
     * @return string
     */
    public static function getVariableType($var)
    {
        if ($var instanceof Type) {
            // FIXME: Replace with schema printer call
            if ($var instanceof WrappingType) {
                $var = $var->getWrappedType(true);
            }

            return $var->name;
        }

        return is_object($var) ? get_class($var) : gettype($var);
    }

    /**
     * @param mixed $var
     *
     * @return string
     */
    public static function printSafeJson($var)
    {
        if ($var instanceof stdClass) {
            $var = (array) $var;
        }
        if (is_array($var)) {
            return json_encode($var);
        }
        if ($var === '') {
            return '(empty string)';
        }
        if ($var === null) {
            return 'null';
        }
        if ($var === false) {
            return 'false';
        }
        if ($var === true) {
            return 'true';
        }
        if (is_string($var)) {
            return sprintf('"%s"', $var);
        }
        if (is_scalar($var)) {
            return (string) $var;
        }

        return gettype($var);
    }

    /**
     * @param Type|mixed $var
     *
     * @return string
     */
    public static function printSafe($var)
    {
        if ($var instanceof Type) {
            return $var->toString();
        }
        if (is_object($var)) {
            if (method_exists($var, '__toString')) {
                return (string) $var;
            }

            return 'instance of ' . get_class($var);
        }
        if (is_array($var)) {
            return json_encode($var);
        }
        if ($var === '') {
            return '(empty string)';
        }
        if ($var === null) {
            return 'null';
        }
        if ($var === false) {
            return 'false';
        }
        if ($var === true) {
            return 'true';
        }
        if (is_string($var)) {
            return $var;
        }
        if (is_scalar($var)) {
            return (string) $var;
        }

        return gettype($var);
    }

    /**
     * UTF-8 compatible chr()
     *
     * @param string $ord
     * @param string $encoding
     *
     * @return string
     */
    public static function chr($ord, $encoding = 'UTF-8')
    {
        if ($encoding === 'UCS-4BE') {
            return pack('N', $ord);
        }

        return mb_convert_encoding(self::chr($ord, 'UCS-4BE'), $encoding, 'UCS-4BE');
    }

    /**
     * UTF-8 compatible ord()
     *
     * @param string $char
     * @param string $encoding
     *
     * @return mixed
     */
    public static function ord($char, $encoding = 'UTF-8')
    {
        if (! $char && $char !== '0') {
            return 0;
        }
        if (! isset($char[1])) {
            return ord($char);
        }
        if ($encoding !== 'UCS-4BE') {
            $char = mb_convert_encoding($char, 'UCS-4BE', $encoding);
        }

        return unpack('N', $char)[1];
    }

    /**
     * Returns UTF-8 char code at given $positing of the $string
     *
     * @param string $string
     * @param int    $position
     *
     * @return mixed
     */
    public static function charCodeAt($string, $position)
    {
        $char = mb_substr($string, $position, 1, 'UTF-8');

        return self::ord($char);
    }

    /**
     * @param int|null $code
     *
     * @return string
     */
    public static function printCharCode($code)
    {
        if ($code === null) {
            return '<EOF>';
        }

        return $code < 0x007F
            // Trust JSON for ASCII.
            ? json_encode(self::chr($code))
            // Otherwise print the escaped form.
            : '"\\u' . dechex($code) . '"';
    }

    /**
     * Upholds the spec rules about naming.
     *
     * @param string $name
     *
     * @throws Error
     */
    public static function assertValidName($name)
    {
        $error = self::isValidNameError($name);
        if ($error) {
            throw $error;
        }
    }

    /**
     * Returns an Error if a name is invalid.
     *
     * @param string    $name
     * @param Node|null $node
     *
     * @return Error|null
     */
    public static function isValidNameError($name, $node = null)
    {
        self::invariant(is_string($name), 'Expected string');

        if (isset($name[1]) && $name[0] === '_' && $name[1] === '_') {
            return new Error(
                sprintf('Name "%s" must not begin with "__", which is reserved by ', $name) .
                'GraphQL introspection.',
                $node
            );
        }

        if (! preg_match('/^[_a-zA-Z][_a-zA-Z0-9]*$/', $name)) {
            return new Error(
                sprintf('Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but "%s" does not.', $name),
                $node
            );
        }

        return null;
    }

    /**
     * Wraps original callable with PHP error handling (using set_error_handler).
     * Resulting callable will collect all PHP errors that occur during the call in $errors array.
     *
     * @param ErrorException[] $errors
     *
     * @return callable
     */
    public static function withErrorHandling(callable $fn, array &$errors)
    {
        return static function () use ($fn, &$errors) {
            // Catch custom errors (to report them in query results)
            set_error_handler(static function ($severity, $message, $file, $line) use (&$errors) : void {
                $errors[] = new ErrorException($message, 0, $severity, $file, $line);
            });

            try {
                return $fn();
            } finally {
                restore_error_handler();
            }
        };
    }

    /**
     * @param string[] $items
     *
     * @return string
     */
    public static function quotedOrList(array $items)
    {
        $items = array_map(
            static function ($item) : string {
                return sprintf('"%s"', $item);
            },
            $items
        );

        return self::orList($items);
    }

    /**
     * @param string[] $items
     *
     * @return string
     */
    public static function orList(array $items)
    {
        if (count($items) === 0) {
            throw new LogicException('items must not need to be empty.');
        }
        $selected       = array_slice($items, 0, 5);
        $selectedLength = count($selected);
        $firstSelected  = $selected[0];

        if ($selectedLength === 1) {
            return $firstSelected;
        }

        return array_reduce(
            range(1, $selectedLength - 1),
            static function ($list, $index) use ($selected, $selectedLength) : string {
                return $list .
                    ($selectedLength > 2 ? ', ' : ' ') .
                    ($index === $selectedLength - 1 ? 'or ' : '') .
                    $selected[$index];
            },
            $firstSelected
        );
    }

    /**
     * Given an invalid input string and a list of valid options, returns a filtered
     * list of valid options sorted based on their similarity with the input.
     *
     * Includes a custom alteration from Damerau-Levenshtein to treat case changes
     * as a single edit which helps identify mis-cased values with an edit distance
     * of 1
     *
     * @param string   $input
     * @param string[] $options
     *
     * @return string[]
     */
    public static function suggestionList($input, array $options)
    {
        $optionsByDistance = [];
        $threshold         = mb_strlen($input) * 0.4 + 1;
        foreach ($options as $option) {
            if ($input === $option) {
                $distance = 0;
            } else {
                $distance = (strtolower($input) === strtolower($option)
                    ? 1
                    : levenshtein($input, $option));
            }
            if ($distance > $threshold) {
                continue;
            }

            $optionsByDistance[$option] = $distance;
        }

        asort($optionsByDistance);

        return array_keys($optionsByDistance);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Utils\Value.php
<?php

declare(strict_types=1);

namespace GraphQL\Utils;

use Exception;
use GraphQL\Error\Error;
use GraphQL\Language\AST\Node;
use GraphQL\Type\Definition\EnumType;
use GraphQL\Type\Definition\InputObjectType;
use GraphQL\Type\Definition\InputType;
use GraphQL\Type\Definition\ListOfType;
use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\Definition\ScalarType;
use stdClass;
use Throwable;
use Traversable;
use function array_key_exists;
use function array_keys;
use function array_map;
use function array_merge;
use function is_array;
use function is_object;
use function is_string;
use function sprintf;

/**
 * Coerces a PHP value given a GraphQL Type.
 *
 * Returns either a value which is valid for the provided type or a list of
 * encountered coercion errors.
 */
class Value
{
    /**
     * Given a type and any value, return a runtime value coerced to match the type.
     *
     * @param ScalarType|EnumType|InputObjectType|ListOfType|NonNull $type
     * @param mixed[]                                                $path
     */
    public static function coerceValue($value, InputType $type, $blameNode = null, ?array $path = null)
    {
        if ($type instanceof NonNull) {
            if ($value === null) {
                return self::ofErrors([
                    self::coercionError(
                        sprintf('Expected non-nullable type %s not to be null', $type),
                        $blameNode,
                        $path
                    ),
                ]);
            }

            return self::coerceValue($value, $type->getWrappedType(), $blameNode, $path);
        }

        if ($value === null) {
            // Explicitly return the value null.
            return self::ofValue(null);
        }

        if ($type instanceof ScalarType) {
            // Scalars determine if a value is valid via parseValue(), which can
            // throw to indicate failure. If it throws, maintain a reference to
            // the original error.
            try {
                return self::ofValue($type->parseValue($value));
            } catch (Throwable $error) {
                return self::ofErrors([
                    self::coercionError(
                        sprintf('Expected type %s', $type->name),
                        $blameNode,
                        $path,
                        $error->getMessage(),
                        $error
                    ),
                ]);
            }
        }

        if ($type instanceof EnumType) {
            if (is_string($value)) {
                $enumValue = $type->getValue($value);
                if ($enumValue) {
                    return self::ofValue($enumValue->value);
                }
            }

            $suggestions = Utils::suggestionList(
                Utils::printSafe($value),
                array_map(
                    static function ($enumValue) : string {
                        return $enumValue->name;
                    },
                    $type->getValues()
                )
            );

            $didYouMean = $suggestions
                ? 'did you mean ' . Utils::orList($suggestions) . '?'
                : null;

            return self::ofErrors([
                self::coercionError(
                    sprintf('Expected type %s', $type->name),
                    $blameNode,
                    $path,
                    $didYouMean
                ),
            ]);
        }

        if ($type instanceof ListOfType) {
            $itemType = $type->getWrappedType();
            if (is_array($value) || $value instanceof Traversable) {
                $errors       = [];
                $coercedValue = [];
                foreach ($value as $index => $itemValue) {
                    $coercedItem = self::coerceValue(
                        $itemValue,
                        $itemType,
                        $blameNode,
                        self::atPath($path, $index)
                    );
                    if ($coercedItem['errors']) {
                        $errors = self::add($errors, $coercedItem['errors']);
                    } else {
                        $coercedValue[] = $coercedItem['value'];
                    }
                }

                return $errors ? self::ofErrors($errors) : self::ofValue($coercedValue);
            }
            // Lists accept a non-list value as a list of one.
            $coercedItem = self::coerceValue($value, $itemType, $blameNode);

            return $coercedItem['errors'] ? $coercedItem : self::ofValue([$coercedItem['value']]);
        }

        if ($type instanceof InputObjectType) {
            if (! is_object($value) && ! is_array($value) && ! $value instanceof Traversable) {
                return self::ofErrors([
                    self::coercionError(
                        sprintf('Expected type %s to be an object', $type->name),
                        $blameNode,
                        $path
                    ),
                ]);
            }

            // Cast \stdClass to associative array before checking the fields. Note that the coerced value will be an array.
            if ($value instanceof stdClass) {
                $value = (array) $value;
            }

            $errors       = [];
            $coercedValue = [];
            $fields       = $type->getFields();
            foreach ($fields as $fieldName => $field) {
                if (array_key_exists($fieldName, $value)) {
                    $fieldValue   = $value[$fieldName];
                    $coercedField = self::coerceValue(
                        $fieldValue,
                        $field->getType(),
                        $blameNode,
                        self::atPath($path, $fieldName)
                    );
                    if ($coercedField['errors']) {
                        $errors = self::add($errors, $coercedField['errors']);
                    } else {
                        $coercedValue[$fieldName] = $coercedField['value'];
                    }
                } elseif ($field->defaultValueExists()) {
                    $coercedValue[$fieldName] = $field->defaultValue;
                } elseif ($field->getType() instanceof NonNull) {
                    $fieldPath = self::printPath(self::atPath($path, $fieldName));
                    $errors    = self::add(
                        $errors,
                        self::coercionError(
                            sprintf(
                                'Field %s of required type %s was not provided',
                                $fieldPath,
                                $field->getType()->toString()
                            ),
                            $blameNode
                        )
                    );
                }
            }

            // Ensure every provided field is defined.
            foreach ($value as $fieldName => $field) {
                if (array_key_exists($fieldName, $fields)) {
                    continue;
                }

                $suggestions = Utils::suggestionList(
                    (string) $fieldName,
                    array_keys($fields)
                );
                $didYouMean  = $suggestions
                    ? 'did you mean ' . Utils::orList($suggestions) . '?'
                    : null;
                $errors      = self::add(
                    $errors,
                    self::coercionError(
                        sprintf('Field "%s" is not defined by type %s', $fieldName, $type->name),
                        $blameNode,
                        $path,
                        $didYouMean
                    )
                );
            }

            return $errors ? self::ofErrors($errors) : self::ofValue($coercedValue);
        }

        throw new Error(sprintf('Unexpected type %s', $type->name));
    }

    private static function ofErrors($errors)
    {
        return ['errors' => $errors, 'value' => Utils::undefined()];
    }

    /**
     * @param string                   $message
     * @param Node                     $blameNode
     * @param mixed[]|null             $path
     * @param string                   $subMessage
     * @param Exception|Throwable|null $originalError
     *
     * @return Error
     */
    private static function coercionError(
        $message,
        $blameNode,
        ?array $path = null,
        $subMessage = null,
        $originalError = null
    ) {
        $pathStr = self::printPath($path);

        // Return a GraphQLError instance
        return new Error(
            $message .
            ($pathStr ? ' at ' . $pathStr : '') .
            ($subMessage ? '; ' . $subMessage : '.'),
            $blameNode,
            null,
            [],
            null,
            $originalError
        );
    }

    /**
     * Build a string describing the path into the value where the error was found
     *
     * @param mixed[]|null $path
     *
     * @return string
     */
    private static function printPath(?array $path = null)
    {
        $pathStr     = '';
        $currentPath = $path;
        while ($currentPath) {
            $pathStr     =
                (is_string($currentPath['key'])
                    ? '.' . $currentPath['key']
                    : '[' . $currentPath['key'] . ']') . $pathStr;
            $currentPath = $currentPath['prev'];
        }

        return $pathStr ? 'value' . $pathStr : '';
    }

    /**
     * @param mixed $value
     *
     * @return (mixed|null)[]
     */
    private static function ofValue($value)
    {
        return ['errors' => null, 'value' => $value];
    }

    /**
     * @param mixed|null $prev
     * @param mixed|null $key
     *
     * @return (mixed|null)[]
     */
    private static function atPath($prev, $key)
    {
        return ['prev' => $prev, 'key' => $key];
    }

    /**
     * @param Error[]       $errors
     * @param Error|Error[] $moreErrors
     *
     * @return Error[]
     */
    private static function add($errors, $moreErrors)
    {
        return array_merge($errors, is_array($moreErrors) ? $moreErrors : [$moreErrors]);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\ASTValidationContext.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator;

use GraphQL\Error\Error;
use GraphQL\Language\AST\DocumentNode;
use GraphQL\Type\Schema;

abstract class ASTValidationContext
{
    /** @var DocumentNode */
    protected $ast;

    /** @var Error[] */
    protected $errors;

    /** @var Schema */
    protected $schema;

    public function __construct(DocumentNode $ast, ?Schema $schema = null)
    {
        $this->ast    = $ast;
        $this->schema = $schema;
        $this->errors = [];
    }

    public function reportError(Error $error)
    {
        $this->errors[] = $error;
    }

    /**
     * @return Error[]
     */
    public function getErrors()
    {
        return $this->errors;
    }

    /**
     * @return DocumentNode
     */
    public function getDocument()
    {
        return $this->ast;
    }

    public function getSchema() : ?Schema
    {
        return $this->schema;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\DocumentValidator.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator;

use Exception;
use GraphQL\Error\Error;
use GraphQL\Language\AST\DocumentNode;
use GraphQL\Language\Visitor;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Schema;
use GraphQL\Utils\TypeInfo;
use GraphQL\Validator\Rules\DisableIntrospection;
use GraphQL\Validator\Rules\ExecutableDefinitions;
use GraphQL\Validator\Rules\FieldsOnCorrectType;
use GraphQL\Validator\Rules\FragmentsOnCompositeTypes;
use GraphQL\Validator\Rules\KnownArgumentNames;
use GraphQL\Validator\Rules\KnownArgumentNamesOnDirectives;
use GraphQL\Validator\Rules\KnownDirectives;
use GraphQL\Validator\Rules\KnownFragmentNames;
use GraphQL\Validator\Rules\KnownTypeNames;
use GraphQL\Validator\Rules\LoneAnonymousOperation;
use GraphQL\Validator\Rules\LoneSchemaDefinition;
use GraphQL\Validator\Rules\NoFragmentCycles;
use GraphQL\Validator\Rules\NoUndefinedVariables;
use GraphQL\Validator\Rules\NoUnusedFragments;
use GraphQL\Validator\Rules\NoUnusedVariables;
use GraphQL\Validator\Rules\OverlappingFieldsCanBeMerged;
use GraphQL\Validator\Rules\PossibleFragmentSpreads;
use GraphQL\Validator\Rules\ProvidedRequiredArguments;
use GraphQL\Validator\Rules\ProvidedRequiredArgumentsOnDirectives;
use GraphQL\Validator\Rules\QueryComplexity;
use GraphQL\Validator\Rules\QueryDepth;
use GraphQL\Validator\Rules\QuerySecurityRule;
use GraphQL\Validator\Rules\ScalarLeafs;
use GraphQL\Validator\Rules\SingleFieldSubscription;
use GraphQL\Validator\Rules\UniqueArgumentNames;
use GraphQL\Validator\Rules\UniqueDirectivesPerLocation;
use GraphQL\Validator\Rules\UniqueFragmentNames;
use GraphQL\Validator\Rules\UniqueInputFieldNames;
use GraphQL\Validator\Rules\UniqueOperationNames;
use GraphQL\Validator\Rules\UniqueVariableNames;
use GraphQL\Validator\Rules\ValidationRule;
use GraphQL\Validator\Rules\ValuesOfCorrectType;
use GraphQL\Validator\Rules\VariablesAreInputTypes;
use GraphQL\Validator\Rules\VariablesInAllowedPosition;
use Throwable;
use function array_filter;
use function array_merge;
use function count;
use function is_array;
use function sprintf;

/**
 * Implements the "Validation" section of the spec.
 *
 * Validation runs synchronously, returning an array of encountered errors, or
 * an empty array if no errors were encountered and the document is valid.
 *
 * A list of specific validation rules may be provided. If not provided, the
 * default list of rules defined by the GraphQL specification will be used.
 *
 * Each validation rule is an instance of GraphQL\Validator\Rules\ValidationRule
 * which returns a visitor (see the [GraphQL\Language\Visitor API](reference.md#graphqllanguagevisitor)).
 *
 * Visitor methods are expected to return an instance of [GraphQL\Error\Error](reference.md#graphqlerrorerror),
 * or array of such instances when invalid.
 *
 * Optionally a custom TypeInfo instance may be provided. If not provided, one
 * will be created from the provided schema.
 */
class DocumentValidator
{
    /** @var ValidationRule[] */
    private static $rules = [];

    /** @var ValidationRule[]|null */
    private static $defaultRules;

    /** @var QuerySecurityRule[]|null */
    private static $securityRules;

    /** @var ValidationRule[]|null */
    private static $sdlRules;

    /** @var bool */
    private static $initRules = false;

    /**
     * Primary method for query validation. See class description for details.
     *
     * @param ValidationRule[]|null $rules
     *
     * @return Error[]
     *
     * @api
     */
    public static function validate(
        Schema $schema,
        DocumentNode $ast,
        ?array $rules = null,
        ?TypeInfo $typeInfo = null
    ) {
        if ($rules === null) {
            $rules = static::allRules();
        }

        if (is_array($rules) === true && count($rules) === 0) {
            // Skip validation if there are no rules
            return [];
        }

        $typeInfo = $typeInfo ?? new TypeInfo($schema);

        return static::visitUsingRules($schema, $typeInfo, $ast, $rules);
    }

    /**
     * Returns all global validation rules.
     *
     * @return ValidationRule[]
     *
     * @api
     */
    public static function allRules()
    {
        if (! self::$initRules) {
            static::$rules     = array_merge(static::defaultRules(), self::securityRules(), self::$rules);
            static::$initRules = true;
        }

        return self::$rules;
    }

    public static function defaultRules()
    {
        if (self::$defaultRules === null) {
            self::$defaultRules = [
                ExecutableDefinitions::class        => new ExecutableDefinitions(),
                UniqueOperationNames::class         => new UniqueOperationNames(),
                LoneAnonymousOperation::class       => new LoneAnonymousOperation(),
                SingleFieldSubscription::class      => new SingleFieldSubscription(),
                KnownTypeNames::class               => new KnownTypeNames(),
                FragmentsOnCompositeTypes::class    => new FragmentsOnCompositeTypes(),
                VariablesAreInputTypes::class       => new VariablesAreInputTypes(),
                ScalarLeafs::class                  => new ScalarLeafs(),
                FieldsOnCorrectType::class          => new FieldsOnCorrectType(),
                UniqueFragmentNames::class          => new UniqueFragmentNames(),
                KnownFragmentNames::class           => new KnownFragmentNames(),
                NoUnusedFragments::class            => new NoUnusedFragments(),
                PossibleFragmentSpreads::class      => new PossibleFragmentSpreads(),
                NoFragmentCycles::class             => new NoFragmentCycles(),
                UniqueVariableNames::class          => new UniqueVariableNames(),
                NoUndefinedVariables::class         => new NoUndefinedVariables(),
                NoUnusedVariables::class            => new NoUnusedVariables(),
                KnownDirectives::class              => new KnownDirectives(),
                UniqueDirectivesPerLocation::class  => new UniqueDirectivesPerLocation(),
                KnownArgumentNames::class           => new KnownArgumentNames(),
                UniqueArgumentNames::class          => new UniqueArgumentNames(),
                ValuesOfCorrectType::class          => new ValuesOfCorrectType(),
                ProvidedRequiredArguments::class    => new ProvidedRequiredArguments(),
                VariablesInAllowedPosition::class   => new VariablesInAllowedPosition(),
                OverlappingFieldsCanBeMerged::class => new OverlappingFieldsCanBeMerged(),
                UniqueInputFieldNames::class        => new UniqueInputFieldNames(),
            ];
        }

        return self::$defaultRules;
    }

    /**
     * @return QuerySecurityRule[]
     */
    public static function securityRules()
    {
        // This way of defining rules is deprecated
        // When custom security rule is required - it should be just added via DocumentValidator::addRule();
        // TODO: deprecate this

        if (self::$securityRules === null) {
            self::$securityRules = [
                DisableIntrospection::class => new DisableIntrospection(DisableIntrospection::DISABLED), // DEFAULT DISABLED
                QueryDepth::class           => new QueryDepth(QueryDepth::DISABLED), // default disabled
                QueryComplexity::class      => new QueryComplexity(QueryComplexity::DISABLED), // default disabled
            ];
        }

        return self::$securityRules;
    }

    public static function sdlRules()
    {
        if (self::$sdlRules === null) {
            self::$sdlRules = [
                LoneSchemaDefinition::class                  => new LoneSchemaDefinition(),
                KnownDirectives::class                       => new KnownDirectives(),
                KnownArgumentNamesOnDirectives::class        => new KnownArgumentNamesOnDirectives(),
                UniqueDirectivesPerLocation::class           => new UniqueDirectivesPerLocation(),
                UniqueArgumentNames::class                   => new UniqueArgumentNames(),
                UniqueInputFieldNames::class                 => new UniqueInputFieldNames(),
                ProvidedRequiredArgumentsOnDirectives::class => new ProvidedRequiredArgumentsOnDirectives(),
            ];
        }

        return self::$sdlRules;
    }

    /**
     * This uses a specialized visitor which runs multiple visitors in parallel,
     * while maintaining the visitor skip and break API.
     *
     * @param ValidationRule[] $rules
     *
     * @return Error[]
     */
    public static function visitUsingRules(Schema $schema, TypeInfo $typeInfo, DocumentNode $documentNode, array $rules)
    {
        $context  = new ValidationContext($schema, $documentNode, $typeInfo);
        $visitors = [];
        foreach ($rules as $rule) {
            $visitors[] = $rule->getVisitor($context);
        }
        Visitor::visit($documentNode, Visitor::visitWithTypeInfo($typeInfo, Visitor::visitInParallel($visitors)));

        return $context->getErrors();
    }

    /**
     * Returns global validation rule by name. Standard rules are named by class name, so
     * example usage for such rules:
     *
     * $rule = DocumentValidator::getRule(GraphQL\Validator\Rules\QueryComplexity::class);
     *
     * @param string $name
     *
     * @return ValidationRule
     *
     * @api
     */
    public static function getRule($name)
    {
        $rules = static::allRules();

        if (isset($rules[$name])) {
            return $rules[$name];
        }

        $name = sprintf('GraphQL\\Validator\\Rules\\%s', $name);

        return $rules[$name] ?? null;
    }

    /**
     * Add rule to list of global validation rules
     *
     * @api
     */
    public static function addRule(ValidationRule $rule)
    {
        self::$rules[$rule->getName()] = $rule;
    }

    public static function isError($value)
    {
        return is_array($value)
            ? count(array_filter(
                $value,
                static function ($item) : bool {
                    return $item instanceof Throwable;
                }
            )) === count($value)
            : $value instanceof Throwable;
    }

    public static function append(&$arr, $items)
    {
        if (is_array($items)) {
            $arr = array_merge($arr, $items);
        } else {
            $arr[] = $items;
        }

        return $arr;
    }

    /**
     * Utility which determines if a value literal node is valid for an input type.
     *
     * Deprecated. Rely on validation for documents co
     * ntaining literal values.
     *
     * @deprecated
     *
     * @return Error[]
     */
    public static function isValidLiteralValue(Type $type, $valueNode)
    {
        $emptySchema = new Schema([]);
        $emptyDoc    = new DocumentNode(['definitions' => []]);
        $typeInfo    = new TypeInfo($emptySchema, $type);
        $context     = new ValidationContext($emptySchema, $emptyDoc, $typeInfo);
        $validator   = new ValuesOfCorrectType();
        $visitor     = $validator->getVisitor($context);
        Visitor::visit($valueNode, Visitor::visitWithTypeInfo($typeInfo, $visitor));

        return $context->getErrors();
    }

    /**
     * @param ValidationRule[]|null $rules
     *
     * @return Error[]
     *
     * @throws Exception
     */
    public static function validateSDL(
        DocumentNode $documentAST,
        ?Schema $schemaToExtend = null,
        ?array $rules = null
    ) {
        $usedRules = $rules ?? self::sdlRules();
        $context   = new SDLValidationContext($documentAST, $schemaToExtend);
        $visitors  = [];
        foreach ($usedRules as $rule) {
            $visitors[] = $rule->getSDLVisitor($context);
        }
        Visitor::visit($documentAST, Visitor::visitInParallel($visitors));

        return $context->getErrors();
    }

    public static function assertValidSDL(DocumentNode $documentAST)
    {
        $errors = self::validateSDL($documentAST);
        if (count($errors) > 0) {
            throw new Error(self::combineErrorMessages($errors));
        }
    }

    public static function assertValidSDLExtension(DocumentNode $documentAST, Schema $schema)
    {
        $errors = self::validateSDL($documentAST, $schema);
        if (count($errors) > 0) {
            throw new Error(self::combineErrorMessages($errors));
        }
    }

    /**
     * @param Error[] $errors
     */
    private static function combineErrorMessages(array $errors) : string
    {
        $str = '';
        foreach ($errors as $error) {
            $str .= ($error->getMessage() . "\n\n");
        }

        return $str;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\SDLValidationContext.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator;

class SDLValidationContext extends ASTValidationContext
{
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\ValidationContext.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator;

use GraphQL\Error\InvariantViolation;
use GraphQL\Language\AST\DocumentNode;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\FragmentDefinitionNode;
use GraphQL\Language\AST\FragmentSpreadNode;
use GraphQL\Language\AST\HasSelectionSet;
use GraphQL\Language\AST\InlineFragmentNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Language\AST\SelectionSetNode;
use GraphQL\Language\AST\VariableNode;
use GraphQL\Language\Visitor;
use GraphQL\Type\Definition\CompositeType;
use GraphQL\Type\Definition\EnumType;
use GraphQL\Type\Definition\FieldDefinition;
use GraphQL\Type\Definition\InputObjectType;
use GraphQL\Type\Definition\InputType;
use GraphQL\Type\Definition\ListOfType;
use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\Definition\OutputType;
use GraphQL\Type\Definition\ScalarType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Schema;
use GraphQL\Utils\TypeInfo;
use SplObjectStorage;
use function array_merge;
use function array_pop;
use function assert;
use function count;

/**
 * An instance of this class is passed as the "this" context to all validators,
 * allowing access to commonly useful contextual information from within a
 * validation rule.
 */
class ValidationContext extends ASTValidationContext
{
    /** @var TypeInfo */
    private $typeInfo;

    /** @var FragmentDefinitionNode[] */
    private $fragments;

    /** @var SplObjectStorage */
    private $fragmentSpreads;

    /** @var SplObjectStorage */
    private $recursivelyReferencedFragments;

    /** @var SplObjectStorage */
    private $variableUsages;

    /** @var SplObjectStorage */
    private $recursiveVariableUsages;

    public function __construct(Schema $schema, DocumentNode $ast, TypeInfo $typeInfo)
    {
        parent::__construct($ast, $schema);
        $this->typeInfo                       = $typeInfo;
        $this->fragmentSpreads                = new SplObjectStorage();
        $this->recursivelyReferencedFragments = new SplObjectStorage();
        $this->variableUsages                 = new SplObjectStorage();
        $this->recursiveVariableUsages        = new SplObjectStorage();
    }

    /**
     * @return mixed[][] List of ['node' => VariableNode, 'type' => ?InputObjectType]
     */
    public function getRecursiveVariableUsages(OperationDefinitionNode $operation)
    {
        $usages = $this->recursiveVariableUsages[$operation] ?? null;

        if ($usages === null) {
            $usages    = $this->getVariableUsages($operation);
            $fragments = $this->getRecursivelyReferencedFragments($operation);

            $allUsages = [$usages];
            foreach ($fragments as $fragment) {
                $allUsages[] = $this->getVariableUsages($fragment);
            }
            $usages                                    = array_merge(...$allUsages);
            $this->recursiveVariableUsages[$operation] = $usages;
        }

        return $usages;
    }

    /**
     * @return mixed[][] List of ['node' => VariableNode, 'type' => ?InputObjectType]
     */
    private function getVariableUsages(HasSelectionSet $node)
    {
        $usages = $this->variableUsages[$node] ?? null;

        if ($usages === null) {
            $newUsages = [];
            $typeInfo  = new TypeInfo($this->schema);
            Visitor::visit(
                $node,
                Visitor::visitWithTypeInfo(
                    $typeInfo,
                    [
                        NodeKind::VARIABLE_DEFINITION => static function () : bool {
                            return false;
                        },
                        NodeKind::VARIABLE            => static function (VariableNode $variable) use (
                            &$newUsages,
                            $typeInfo
                        ) : void {
                            $newUsages[] = [
                                'node' => $variable,
                                'type' => $typeInfo->getInputType(),
                                'defaultValue' => $typeInfo->getDefaultValue(),
                            ];
                        },
                    ]
                )
            );
            $usages                      = $newUsages;
            $this->variableUsages[$node] = $usages;
        }

        return $usages;
    }

    /**
     * @return FragmentDefinitionNode[]
     */
    public function getRecursivelyReferencedFragments(OperationDefinitionNode $operation)
    {
        $fragments = $this->recursivelyReferencedFragments[$operation] ?? null;

        if ($fragments === null) {
            $fragments      = [];
            $collectedNames = [];
            $nodesToVisit   = [$operation];
            while (count($nodesToVisit) > 0) {
                $node    = array_pop($nodesToVisit);
                $spreads = $this->getFragmentSpreads($node);
                foreach ($spreads as $spread) {
                    $fragName = $spread->name->value;

                    if ($collectedNames[$fragName] ?? false) {
                        continue;
                    }

                    $collectedNames[$fragName] = true;
                    $fragment                  = $this->getFragment($fragName);
                    if (! $fragment) {
                        continue;
                    }

                    $fragments[]    = $fragment;
                    $nodesToVisit[] = $fragment;
                }
            }
            $this->recursivelyReferencedFragments[$operation] = $fragments;
        }

        return $fragments;
    }

    /**
     * @param OperationDefinitionNode|FragmentDefinitionNode $node
     *
     * @return FragmentSpreadNode[]
     */
    public function getFragmentSpreads(HasSelectionSet $node) : array
    {
        $spreads = $this->fragmentSpreads[$node] ?? null;
        if ($spreads === null) {
            $spreads = [];
            /** @var SelectionSetNode[] $setsToVisit */
            $setsToVisit = [$node->selectionSet];
            while (count($setsToVisit) > 0) {
                $set = array_pop($setsToVisit);

                foreach ($set->selections as $selection) {
                    if ($selection instanceof FragmentSpreadNode) {
                        $spreads[] = $selection;
                    } else {
                        assert($selection instanceof FieldNode || $selection instanceof InlineFragmentNode);
                        $selectionSet = $selection->selectionSet;
                        if ($selectionSet !== null) {
                            $setsToVisit[] = $selectionSet;
                        }
                    }
                }
            }
            $this->fragmentSpreads[$node] = $spreads;
        }

        return $spreads;
    }

    /**
     * @param string $name
     *
     * @return FragmentDefinitionNode|null
     */
    public function getFragment($name)
    {
        $fragments = $this->fragments;
        if (! $fragments) {
            $fragments = [];
            foreach ($this->getDocument()->definitions as $statement) {
                if (! ($statement instanceof FragmentDefinitionNode)) {
                    continue;
                }

                $fragments[$statement->name->value] = $statement;
            }
            $this->fragments = $fragments;
        }

        return $fragments[$name] ?? null;
    }

    public function getType() : ?OutputType
    {
        return $this->typeInfo->getType();
    }

    /**
     * @return (CompositeType & Type) | null
     */
    public function getParentType() : ?CompositeType
    {
        return $this->typeInfo->getParentType();
    }

    /**
     * @return (Type & InputType) | null
     */
    public function getInputType() : ?InputType
    {
        return $this->typeInfo->getInputType();
    }

    /**
     * @return (Type&InputType)|null
     */
    public function getParentInputType() : ?InputType
    {
        return $this->typeInfo->getParentInputType();
    }

    /**
     * @return FieldDefinition
     */
    public function getFieldDef()
    {
        return $this->typeInfo->getFieldDef();
    }

    public function getDirective()
    {
        return $this->typeInfo->getDirective();
    }

    public function getArgument()
    {
        return $this->typeInfo->getArgument();
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\CustomValidationRule.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Validator\ValidationContext;

class CustomValidationRule extends ValidationRule
{
    /** @var callable */
    private $visitorFn;

    public function __construct($name, callable $visitorFn)
    {
        $this->name      = $name;
        $this->visitorFn = $visitorFn;
    }

    /**
     * @return Error[]
     */
    public function getVisitor(ValidationContext $context)
    {
        $fn = $this->visitorFn;

        return $fn($context);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\DisableIntrospection.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Validator\ValidationContext;

class DisableIntrospection extends QuerySecurityRule
{
    public const ENABLED = 1;

    /** @var bool */
    private $isEnabled;

    public function __construct($enabled = self::ENABLED)
    {
        $this->setEnabled($enabled);
    }

    public function setEnabled($enabled)
    {
        $this->isEnabled = $enabled;
    }

    public function getVisitor(ValidationContext $context)
    {
        return $this->invokeIfNeeded(
            $context,
            [
                NodeKind::FIELD => static function (FieldNode $node) use ($context) : void {
                    if ($node->name->value !== '__type' && $node->name->value !== '__schema') {
                        return;
                    }

                    $context->reportError(new Error(
                        static::introspectionDisabledMessage(),
                        [$node]
                    ));
                },
            ]
        );
    }

    public static function introspectionDisabledMessage()
    {
        return 'GraphQL introspection is not allowed, but the query contained __schema or __type';
    }

    protected function isEnabled()
    {
        return $this->isEnabled !== self::DISABLED;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\ExecutableDefinitions.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\DocumentNode;
use GraphQL\Language\AST\ExecutableDefinitionNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\TypeSystemDefinitionNode;
use GraphQL\Language\Visitor;
use GraphQL\Language\VisitorOperation;
use GraphQL\Validator\ValidationContext;
use function sprintf;

/**
 * Executable definitions
 *
 * A GraphQL document is only valid for execution if all definitions are either
 * operation or fragment definitions.
 */
class ExecutableDefinitions extends ValidationRule
{
    public function getVisitor(ValidationContext $context)
    {
        return [
            NodeKind::DOCUMENT => static function (DocumentNode $node) use ($context) : VisitorOperation {
                /** @var ExecutableDefinitionNode|TypeSystemDefinitionNode $definition */
                foreach ($node->definitions as $definition) {
                    if ($definition instanceof ExecutableDefinitionNode) {
                        continue;
                    }

                    $context->reportError(new Error(
                        self::nonExecutableDefinitionMessage($definition->name->value),
                        [$definition->name]
                    ));
                }

                return Visitor::skipNode();
            },
        ];
    }

    public static function nonExecutableDefinitionMessage($defName)
    {
        return sprintf('The "%s" definition is not executable.', $defName);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\FieldsOnCorrectType.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Type\Definition\InterfaceType;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Schema;
use GraphQL\Utils\Utils;
use GraphQL\Validator\ValidationContext;
use function array_keys;
use function array_merge;
use function arsort;
use function count;
use function sprintf;

class FieldsOnCorrectType extends ValidationRule
{
    public function getVisitor(ValidationContext $context)
    {
        return [
            NodeKind::FIELD => function (FieldNode $node) use ($context) : void {
                $type = $context->getParentType();
                if (! $type) {
                    return;
                }

                $fieldDef = $context->getFieldDef();
                if ($fieldDef) {
                    return;
                }

                // This isn't valid. Let's find suggestions, if any.
                $schema    = $context->getSchema();
                $fieldName = $node->name->value;
                // First determine if there are any suggested types to condition on.
                $suggestedTypeNames = $this->getSuggestedTypeNames(
                    $schema,
                    $type,
                    $fieldName
                );
                // If there are no suggested types, then perhaps this was a typo?
                $suggestedFieldNames = $suggestedTypeNames
                    ? []
                    : $this->getSuggestedFieldNames(
                        $schema,
                        $type,
                        $fieldName
                    );

                // Report an error, including helpful suggestions.
                $context->reportError(new Error(
                    static::undefinedFieldMessage(
                        $node->name->value,
                        $type->name,
                        $suggestedTypeNames,
                        $suggestedFieldNames
                    ),
                    [$node]
                ));
            },
        ];
    }

    /**
     * Go through all of the implementations of type, as well as the interfaces
     * that they implement. If any of those types include the provided field,
     * suggest them, sorted by how often the type is referenced, starting
     * with Interfaces.
     *
     * @param ObjectType|InterfaceType $type
     * @param string                   $fieldName
     *
     * @return string[]
     */
    private function getSuggestedTypeNames(Schema $schema, $type, $fieldName)
    {
        if (Type::isAbstractType($type)) {
            $suggestedObjectTypes = [];
            $interfaceUsageCount  = [];

            foreach ($schema->getPossibleTypes($type) as $possibleType) {
                if (! $possibleType->hasField($fieldName)) {
                    continue;
                }
                // This object type defines this field.
                $suggestedObjectTypes[] = $possibleType->name;
                foreach ($possibleType->getInterfaces() as $possibleInterface) {
                    if (! $possibleInterface->hasField($fieldName)) {
                        continue;
                    }
                    // This interface type defines this field.
                    $interfaceUsageCount[$possibleInterface->name] =
                        ! isset($interfaceUsageCount[$possibleInterface->name])
                            ? 0
                            : $interfaceUsageCount[$possibleInterface->name] + 1;
                }
            }

            // Suggest interface types based on how common they are.
            arsort($interfaceUsageCount);
            $suggestedInterfaceTypes = array_keys($interfaceUsageCount);

            // Suggest both interface and object types.
            return array_merge($suggestedInterfaceTypes, $suggestedObjectTypes);
        }

        // Otherwise, must be an Object type, which does not have possible fields.
        return [];
    }

    /**
     * For the field name provided, determine if there are any similar field names
     * that may be the result of a typo.
     *
     * @param ObjectType|InterfaceType $type
     * @param string                   $fieldName
     *
     * @return array|string[]
     */
    private function getSuggestedFieldNames(Schema $schema, $type, $fieldName)
    {
        if ($type instanceof ObjectType || $type instanceof InterfaceType) {
            $possibleFieldNames = $type->getFieldNames();

            return Utils::suggestionList($fieldName, $possibleFieldNames);
        }

        // Otherwise, must be a Union type, which does not define fields.
        return [];
    }

    /**
     * @param string   $fieldName
     * @param string   $type
     * @param string[] $suggestedTypeNames
     * @param string[] $suggestedFieldNames
     *
     * @return string
     */
    public static function undefinedFieldMessage(
        $fieldName,
        $type,
        array $suggestedTypeNames,
        array $suggestedFieldNames
    ) {
        $message = sprintf('Cannot query field "%s" on type "%s".', $fieldName, $type);

        if ($suggestedTypeNames) {
            $suggestions = Utils::quotedOrList($suggestedTypeNames);

            $message .= sprintf(' Did you mean to use an inline fragment on %s?', $suggestions);
        } elseif (count($suggestedFieldNames) > 0) {
            $suggestions = Utils::quotedOrList($suggestedFieldNames);

            $message .= sprintf(' Did you mean %s?', $suggestions);
        }

        return $message;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\FragmentsOnCompositeTypes.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\FragmentDefinitionNode;
use GraphQL\Language\AST\InlineFragmentNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\Printer;
use GraphQL\Type\Definition\Type;
use GraphQL\Utils\TypeInfo;
use GraphQL\Validator\ValidationContext;
use function sprintf;

class FragmentsOnCompositeTypes extends ValidationRule
{
    public function getVisitor(ValidationContext $context)
    {
        return [
            NodeKind::INLINE_FRAGMENT     => static function (InlineFragmentNode $node) use ($context) : void {
                if (! $node->typeCondition) {
                    return;
                }

                $type = TypeInfo::typeFromAST($context->getSchema(), $node->typeCondition);
                if (! $type || Type::isCompositeType($type)) {
                    return;
                }

                $context->reportError(new Error(
                    static::inlineFragmentOnNonCompositeErrorMessage($type),
                    [$node->typeCondition]
                ));
            },
            NodeKind::FRAGMENT_DEFINITION => static function (FragmentDefinitionNode $node) use ($context) : void {
                $type = TypeInfo::typeFromAST($context->getSchema(), $node->typeCondition);

                if (! $type || Type::isCompositeType($type)) {
                    return;
                }

                $context->reportError(new Error(
                    static::fragmentOnNonCompositeErrorMessage(
                        $node->name->value,
                        Printer::doPrint($node->typeCondition)
                    ),
                    [$node->typeCondition]
                ));
            },
        ];
    }

    public static function inlineFragmentOnNonCompositeErrorMessage($type)
    {
        return sprintf('Fragment cannot condition on non composite type "%s".', $type);
    }

    public static function fragmentOnNonCompositeErrorMessage($fragName, $type)
    {
        return sprintf('Fragment "%s" cannot condition on non composite type "%s".', $fragName, $type);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\KnownArgumentNames.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\ArgumentNode;
use GraphQL\Language\AST\DirectiveNode;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Type\Definition\Type;
use GraphQL\Utils\Utils;
use GraphQL\Validator\ValidationContext;
use function array_map;
use function count;
use function sprintf;

/**
 * Known argument names
 *
 * A GraphQL field is only valid if all supplied arguments are defined by
 * that field.
 */
class KnownArgumentNames extends ValidationRule
{
    public function getVisitor(ValidationContext $context)
    {
        $knownArgumentNamesOnDirectives = new KnownArgumentNamesOnDirectives();

        return $knownArgumentNamesOnDirectives->getVisitor($context) + [
            NodeKind::ARGUMENT => static function (ArgumentNode $node) use ($context) : void {
                $argDef = $context->getArgument();
                if ($argDef !== null) {
                    return;
                }

                $fieldDef   = $context->getFieldDef();
                $parentType = $context->getParentType();
                if ($fieldDef === null || ! ($parentType instanceof Type)) {
                    return;
                }

                $context->reportError(new Error(
                    self::unknownArgMessage(
                        $node->name->value,
                        $fieldDef->name,
                        $parentType->name,
                        Utils::suggestionList(
                            $node->name->value,
                            array_map(
                                static function ($arg) : string {
                                    return $arg->name;
                                },
                                $fieldDef->args
                            )
                        )
                    ),
                    [$node]
                ));

                return;
            },
        ];
    }

    /**
     * @param string[] $suggestedArgs
     */
    public static function unknownArgMessage($argName, $fieldName, $typeName, array $suggestedArgs)
    {
        $message = sprintf('Unknown argument "%s" on field "%s" of type "%s".', $argName, $fieldName, $typeName);
        if (isset($suggestedArgs[0])) {
            $message .= sprintf(' Did you mean %s?', Utils::quotedOrList($suggestedArgs));
        }

        return $message;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\KnownArgumentNamesOnDirectives.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\DirectiveDefinitionNode;
use GraphQL\Language\AST\DirectiveNode;
use GraphQL\Language\AST\InputValueDefinitionNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\Visitor;
use GraphQL\Language\VisitorOperation;
use GraphQL\Type\Definition\Directive;
use GraphQL\Type\Definition\FieldArgument;
use GraphQL\Utils\Utils;
use GraphQL\Validator\ASTValidationContext;
use GraphQL\Validator\SDLValidationContext;
use GraphQL\Validator\ValidationContext;
use function array_map;
use function in_array;
use function sprintf;

/**
 * Known argument names on directives
 *
 * A GraphQL directive is only valid if all supplied arguments are defined by
 * that field.
 */
class KnownArgumentNamesOnDirectives extends ValidationRule
{
    /**
     * @param string[] $suggestedArgs
     */
    public static function unknownDirectiveArgMessage($argName, $directiveName, array $suggestedArgs)
    {
        $message = sprintf('Unknown argument "%s" on directive "@%s".', $argName, $directiveName);
        if (isset($suggestedArgs[0])) {
            $message .= sprintf(' Did you mean %s?', Utils::quotedOrList($suggestedArgs));
        }

        return $message;
    }

    public function getSDLVisitor(SDLValidationContext $context)
    {
        return $this->getASTVisitor($context);
    }

    public function getVisitor(ValidationContext $context)
    {
        return $this->getASTVisitor($context);
    }

    public function getASTVisitor(ASTValidationContext $context)
    {
        $directiveArgs     = [];
        $schema            = $context->getSchema();
        $definedDirectives = $schema !== null ? $schema->getDirectives() : Directive::getInternalDirectives();

        foreach ($definedDirectives as $directive) {
            $directiveArgs[$directive->name] = array_map(
                static function (FieldArgument $arg) : string {
                    return $arg->name;
                },
                $directive->args
            );
        }

        $astDefinitions = $context->getDocument()->definitions;
        foreach ($astDefinitions as $def) {
            if (! ($def instanceof DirectiveDefinitionNode)) {
                continue;
            }

            $name = $def->name->value;
            if ($def->arguments !== null) {
                $directiveArgs[$name] = Utils::map(
                    $def->arguments ?? [],
                    static function (InputValueDefinitionNode $arg) : string {
                        return $arg->name->value;
                    }
                );
            } else {
                $directiveArgs[$name] = [];
            }
        }

        return [
            NodeKind::DIRECTIVE => static function (DirectiveNode $directiveNode) use ($directiveArgs, $context) : VisitorOperation {
                $directiveName = $directiveNode->name->value;
                $knownArgs     = $directiveArgs[$directiveName] ?? null;

                if ($directiveNode->arguments === null || $knownArgs === null) {
                    return Visitor::skipNode();
                }

                foreach ($directiveNode->arguments as $argNode) {
                    $argName = $argNode->name->value;
                    if (in_array($argName, $knownArgs, true)) {
                        continue;
                    }

                    $suggestions = Utils::suggestionList($argName, $knownArgs);
                    $context->reportError(new Error(
                        self::unknownDirectiveArgMessage($argName, $directiveName, $suggestions),
                        [$argNode]
                    ));
                }

                return Visitor::skipNode();
            },
        ];
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\KnownDirectives.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use Exception;
use GraphQL\Error\Error;
use GraphQL\Language\AST\DirectiveDefinitionNode;
use GraphQL\Language\AST\DirectiveNode;
use GraphQL\Language\AST\EnumTypeDefinitionNode;
use GraphQL\Language\AST\EnumTypeExtensionNode;
use GraphQL\Language\AST\EnumValueDefinitionNode;
use GraphQL\Language\AST\FieldDefinitionNode;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\FragmentDefinitionNode;
use GraphQL\Language\AST\FragmentSpreadNode;
use GraphQL\Language\AST\InlineFragmentNode;
use GraphQL\Language\AST\InputObjectTypeDefinitionNode;
use GraphQL\Language\AST\InputObjectTypeExtensionNode;
use GraphQL\Language\AST\InputValueDefinitionNode;
use GraphQL\Language\AST\InterfaceTypeDefinitionNode;
use GraphQL\Language\AST\InterfaceTypeExtensionNode;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\NodeList;
use GraphQL\Language\AST\ObjectTypeDefinitionNode;
use GraphQL\Language\AST\ObjectTypeExtensionNode;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Language\AST\ScalarTypeDefinitionNode;
use GraphQL\Language\AST\ScalarTypeExtensionNode;
use GraphQL\Language\AST\SchemaDefinitionNode;
use GraphQL\Language\AST\SchemaTypeExtensionNode;
use GraphQL\Language\AST\UnionTypeDefinitionNode;
use GraphQL\Language\AST\UnionTypeExtensionNode;
use GraphQL\Language\AST\VariableDefinitionNode;
use GraphQL\Language\DirectiveLocation;
use GraphQL\Type\Definition\Directive;
use GraphQL\Utils\Utils;
use GraphQL\Validator\ASTValidationContext;
use GraphQL\Validator\SDLValidationContext;
use GraphQL\Validator\ValidationContext;
use function array_map;
use function count;
use function get_class;
use function in_array;
use function sprintf;

class KnownDirectives extends ValidationRule
{
    public function getVisitor(ValidationContext $context)
    {
        return $this->getASTVisitor($context);
    }

    public function getSDLVisitor(SDLValidationContext $context)
    {
        return $this->getASTVisitor($context);
    }

    public function getASTVisitor(ASTValidationContext $context)
    {
        $locationsMap      = [];
        $schema            = $context->getSchema();
        $definedDirectives = $schema
            ? $schema->getDirectives()
            : Directive::getInternalDirectives();

        foreach ($definedDirectives as $directive) {
            $locationsMap[$directive->name] = $directive->locations;
        }

        $astDefinition = $context->getDocument()->definitions;

        foreach ($astDefinition as $def) {
            if (! ($def instanceof DirectiveDefinitionNode)) {
                continue;
            }

            $locationsMap[$def->name->value] = Utils::map(
                $def->locations,
                static function ($name) : string {
                    return $name->value;
                }
            );
        }

        return [
            NodeKind::DIRECTIVE => function (
                DirectiveNode $node,
                $key,
                $parent,
                $path,
                $ancestors
            ) use (
                $context,
                $locationsMap
            ) : void {
                $name      = $node->name->value;
                $locations = $locationsMap[$name] ?? null;

                if (! $locations) {
                    $context->reportError(new Error(
                        self::unknownDirectiveMessage($name),
                        [$node]
                    ));

                    return;
                }

                $candidateLocation = $this->getDirectiveLocationForASTPath($ancestors);

                if (! $candidateLocation || in_array($candidateLocation, $locations, true)) {
                    return;
                }
                $context->reportError(
                    new Error(
                        self::misplacedDirectiveMessage($name, $candidateLocation),
                        [$node]
                    )
                );
            },
        ];
    }

    public static function unknownDirectiveMessage($directiveName)
    {
        return sprintf('Unknown directive "%s".', $directiveName);
    }

    /**
     * @param Node[]|NodeList[] $ancestors The type is actually (Node|NodeList)[] but this PSR-5 syntax is so far not supported by most of the tools
     *
     * @return string
     */
    private function getDirectiveLocationForASTPath(array $ancestors)
    {
        $appliedTo = $ancestors[count($ancestors) - 1];
        switch (true) {
            case $appliedTo instanceof OperationDefinitionNode:
                switch ($appliedTo->operation) {
                    case 'query':
                        return DirectiveLocation::QUERY;
                    case 'mutation':
                        return DirectiveLocation::MUTATION;
                    case 'subscription':
                        return DirectiveLocation::SUBSCRIPTION;
                }
                break;
            case $appliedTo instanceof FieldNode:
                return DirectiveLocation::FIELD;
            case $appliedTo instanceof FragmentSpreadNode:
                return DirectiveLocation::FRAGMENT_SPREAD;
            case $appliedTo instanceof InlineFragmentNode:
                return DirectiveLocation::INLINE_FRAGMENT;
            case $appliedTo instanceof FragmentDefinitionNode:
                return DirectiveLocation::FRAGMENT_DEFINITION;
            case $appliedTo instanceof VariableDefinitionNode:
                return DirectiveLocation::VARIABLE_DEFINITION;
            case $appliedTo instanceof SchemaDefinitionNode:
            case $appliedTo instanceof SchemaTypeExtensionNode:
                return DirectiveLocation::SCHEMA;
            case $appliedTo instanceof ScalarTypeDefinitionNode:
            case $appliedTo instanceof ScalarTypeExtensionNode:
                return DirectiveLocation::SCALAR;
            case $appliedTo instanceof ObjectTypeDefinitionNode:
            case $appliedTo instanceof ObjectTypeExtensionNode:
                return DirectiveLocation::OBJECT;
            case $appliedTo instanceof FieldDefinitionNode:
                return DirectiveLocation::FIELD_DEFINITION;
            case $appliedTo instanceof InterfaceTypeDefinitionNode:
            case $appliedTo instanceof InterfaceTypeExtensionNode:
                return DirectiveLocation::IFACE;
            case $appliedTo instanceof UnionTypeDefinitionNode:
            case $appliedTo instanceof UnionTypeExtensionNode:
                return DirectiveLocation::UNION;
            case $appliedTo instanceof EnumTypeDefinitionNode:
            case $appliedTo instanceof EnumTypeExtensionNode:
                return DirectiveLocation::ENUM;
            case $appliedTo instanceof EnumValueDefinitionNode:
                return DirectiveLocation::ENUM_VALUE;
            case $appliedTo instanceof InputObjectTypeDefinitionNode:
            case $appliedTo instanceof InputObjectTypeExtensionNode:
                return DirectiveLocation::INPUT_OBJECT;
            case $appliedTo instanceof InputValueDefinitionNode:
                $parentNode = $ancestors[count($ancestors) - 3];

                return $parentNode instanceof InputObjectTypeDefinitionNode
                    ? DirectiveLocation::INPUT_FIELD_DEFINITION
                    : DirectiveLocation::ARGUMENT_DEFINITION;
        }

        throw new Exception('Unknown directive location: ' . get_class($appliedTo));
    }

    public static function misplacedDirectiveMessage($directiveName, $location)
    {
        return sprintf('Directive "%s" may not be used on "%s".', $directiveName, $location);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\KnownFragmentNames.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\FragmentSpreadNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Validator\ValidationContext;
use function sprintf;

class KnownFragmentNames extends ValidationRule
{
    public function getVisitor(ValidationContext $context)
    {
        return [
            NodeKind::FRAGMENT_SPREAD => static function (FragmentSpreadNode $node) use ($context) : void {
                $fragmentName = $node->name->value;
                $fragment     = $context->getFragment($fragmentName);
                if ($fragment) {
                    return;
                }

                $context->reportError(new Error(
                    self::unknownFragmentMessage($fragmentName),
                    [$node->name]
                ));
            },
        ];
    }

    /**
     * @param string $fragName
     */
    public static function unknownFragmentMessage($fragName)
    {
        return sprintf('Unknown fragment "%s".', $fragName);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\KnownTypeNames.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\NamedTypeNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\Visitor;
use GraphQL\Language\VisitorOperation;
use GraphQL\Utils\Utils;
use GraphQL\Validator\ValidationContext;
use function array_keys;
use function count;
use function sprintf;

/**
 * Known type names
 *
 * A GraphQL document is only valid if referenced types (specifically
 * variable definitions and fragment conditions) are defined by the type schema.
 */
class KnownTypeNames extends ValidationRule
{
    public function getVisitor(ValidationContext $context)
    {
        $skip = static function () : VisitorOperation {
            return Visitor::skipNode();
        };

        return [
            // TODO: when validating IDL, re-enable these. Experimental version does not
            // add unreferenced types, resulting in false-positive errors. Squelched
            // errors for now.
            NodeKind::OBJECT_TYPE_DEFINITION       => $skip,
            NodeKind::INTERFACE_TYPE_DEFINITION    => $skip,
            NodeKind::UNION_TYPE_DEFINITION        => $skip,
            NodeKind::INPUT_OBJECT_TYPE_DEFINITION => $skip,
            NodeKind::NAMED_TYPE                   => static function (NamedTypeNode $node) use ($context) : void {
                $schema   = $context->getSchema();
                $typeName = $node->name->value;
                $type     = $schema->getType($typeName);
                if ($type !== null) {
                    return;
                }

                $context->reportError(new Error(
                    self::unknownTypeMessage(
                        $typeName,
                        Utils::suggestionList($typeName, array_keys($schema->getTypeMap()))
                    ),
                    [$node]
                ));
            },
        ];
    }

    /**
     * @param string   $type
     * @param string[] $suggestedTypes
     */
    public static function unknownTypeMessage($type, array $suggestedTypes)
    {
        $message = sprintf('Unknown type "%s".', $type);
        if (count($suggestedTypes) > 0) {
            $suggestions = Utils::quotedOrList($suggestedTypes);

            $message .= sprintf(' Did you mean %s?', $suggestions);
        }

        return $message;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\LoneAnonymousOperation.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\DocumentNode;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Utils\Utils;
use GraphQL\Validator\ValidationContext;
use function count;

/**
 * Lone anonymous operation
 *
 * A GraphQL document is only valid if when it contains an anonymous operation
 * (the query short-hand) that it contains only that one operation definition.
 */
class LoneAnonymousOperation extends ValidationRule
{
    public function getVisitor(ValidationContext $context)
    {
        $operationCount = 0;

        return [
            NodeKind::DOCUMENT             => static function (DocumentNode $node) use (&$operationCount) : void {
                $tmp = Utils::filter(
                    $node->definitions,
                    static function (Node $definition) : bool {
                        return $definition instanceof OperationDefinitionNode;
                    }
                );

                $operationCount = count($tmp);
            },
            NodeKind::OPERATION_DEFINITION => static function (OperationDefinitionNode $node) use (
                &$operationCount,
                $context
            ) : void {
                if ($node->name !== null || $operationCount <= 1) {
                    return;
                }

                $context->reportError(
                    new Error(self::anonOperationNotAloneMessage(), [$node])
                );
            },
        ];
    }

    public static function anonOperationNotAloneMessage()
    {
        return 'This anonymous operation must be the only defined operation.';
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\LoneSchemaDefinition.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\SchemaDefinitionNode;
use GraphQL\Validator\SDLValidationContext;

/**
 * Lone Schema definition
 *
 * A GraphQL document is only valid if it contains only one schema definition.
 */
class LoneSchemaDefinition extends ValidationRule
{
    public static function schemaDefinitionNotAloneMessage()
    {
        return 'Must provide only one schema definition.';
    }

    public static function canNotDefineSchemaWithinExtensionMessage()
    {
        return 'Cannot define a new schema within a schema extension.';
    }

    public function getSDLVisitor(SDLValidationContext $context)
    {
        $oldSchema      = $context->getSchema();
        $alreadyDefined = $oldSchema !== null
            ? (
                $oldSchema->getAstNode() !== null ||
                $oldSchema->getQueryType() !== null ||
                $oldSchema->getMutationType() !== null ||
                $oldSchema->getSubscriptionType() !== null
            )
            : false;

        $schemaDefinitionsCount = 0;

        return [
            NodeKind::SCHEMA_DEFINITION => static function (SchemaDefinitionNode $node) use ($alreadyDefined, $context, &$schemaDefinitionsCount) : void {
                if ($alreadyDefined !== false) {
                    $context->reportError(new Error(self::canNotDefineSchemaWithinExtensionMessage(), $node));

                    return;
                }

                if ($schemaDefinitionsCount > 0) {
                    $context->reportError(new Error(self::schemaDefinitionNotAloneMessage(), $node));
                }

                ++$schemaDefinitionsCount;
            },
        ];
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\NoFragmentCycles.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\FragmentDefinitionNode;
use GraphQL\Language\AST\FragmentSpreadNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\Visitor;
use GraphQL\Language\VisitorOperation;
use GraphQL\Utils\Utils;
use GraphQL\Validator\ValidationContext;
use function array_pop;
use function array_slice;
use function count;
use function implode;
use function sprintf;

class NoFragmentCycles extends ValidationRule
{
    /** @var bool[] */
    public $visitedFrags;

    /** @var FragmentSpreadNode[] */
    public $spreadPath;

    /** @var (int|null)[] */
    public $spreadPathIndexByName;

    public function getVisitor(ValidationContext $context)
    {
        // Tracks already visited fragments to maintain O(N) and to ensure that cycles
        // are not redundantly reported.
        $this->visitedFrags = [];

        // Array of AST nodes used to produce meaningful errors
        $this->spreadPath = [];

        // Position in the spread path
        $this->spreadPathIndexByName = [];

        return [
            NodeKind::OPERATION_DEFINITION => static function () : VisitorOperation {
                return Visitor::skipNode();
            },
            NodeKind::FRAGMENT_DEFINITION  => function (FragmentDefinitionNode $node) use ($context) : VisitorOperation {
                $this->detectCycleRecursive($node, $context);

                return Visitor::skipNode();
            },
        ];
    }

    private function detectCycleRecursive(FragmentDefinitionNode $fragment, ValidationContext $context)
    {
        if (isset($this->visitedFrags[$fragment->name->value])) {
            return;
        }

        $fragmentName                      = $fragment->name->value;
        $this->visitedFrags[$fragmentName] = true;

        $spreadNodes = $context->getFragmentSpreads($fragment);

        if (count($spreadNodes) === 0) {
            return;
        }

        $this->spreadPathIndexByName[$fragmentName] = count($this->spreadPath);

        for ($i = 0; $i < count($spreadNodes); $i++) {
            $spreadNode = $spreadNodes[$i];
            $spreadName = $spreadNode->name->value;
            $cycleIndex = $this->spreadPathIndexByName[$spreadName] ?? null;

            $this->spreadPath[] = $spreadNode;
            if ($cycleIndex === null) {
                $spreadFragment = $context->getFragment($spreadName);
                if ($spreadFragment) {
                    $this->detectCycleRecursive($spreadFragment, $context);
                }
            } else {
                $cyclePath     = array_slice($this->spreadPath, $cycleIndex);
                $fragmentNames = Utils::map(array_slice($cyclePath, 0, -1), static function ($s) {
                    return $s->name->value;
                });

                $context->reportError(new Error(
                    self::cycleErrorMessage($spreadName, $fragmentNames),
                    $cyclePath
                ));
            }
            array_pop($this->spreadPath);
        }

        $this->spreadPathIndexByName[$fragmentName] = null;
    }

    /**
     * @param string[] $spreadNames
     */
    public static function cycleErrorMessage($fragName, array $spreadNames = [])
    {
        return sprintf(
            'Cannot spread fragment "%s" within itself%s.',
            $fragName,
            count($spreadNames) > 0 ? ' via ' . implode(', ', $spreadNames) : ''
        );
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\NoUndefinedVariables.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Language\AST\VariableDefinitionNode;
use GraphQL\Validator\ValidationContext;
use function sprintf;

/**
 * A GraphQL operation is only valid if all variables encountered, both directly
 * and via fragment spreads, are defined by that operation.
 */
class NoUndefinedVariables extends ValidationRule
{
    public function getVisitor(ValidationContext $context)
    {
        $variableNameDefined = [];

        return [
            NodeKind::OPERATION_DEFINITION => [
                'enter' => static function () use (&$variableNameDefined) : void {
                    $variableNameDefined = [];
                },
                'leave' => static function (OperationDefinitionNode $operation) use (&$variableNameDefined, $context) : void {
                    $usages = $context->getRecursiveVariableUsages($operation);

                    foreach ($usages as $usage) {
                        $node    = $usage['node'];
                        $varName = $node->name->value;

                        if ($variableNameDefined[$varName] ?? false) {
                            continue;
                        }

                        $context->reportError(new Error(
                            self::undefinedVarMessage(
                                $varName,
                                $operation->name !== null
                                    ? $operation->name->value
                                    : null
                            ),
                            [$node, $operation]
                        ));
                    }
                },
            ],
            NodeKind::VARIABLE_DEFINITION  => static function (VariableDefinitionNode $def) use (&$variableNameDefined) : void {
                $variableNameDefined[$def->variable->name->value] = true;
            },
        ];
    }

    public static function undefinedVarMessage($varName, $opName = null)
    {
        return $opName
            ? sprintf('Variable "$%s" is not defined by operation "%s".', $varName, $opName)
            : sprintf('Variable "$%s" is not defined.', $varName);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\NoUnusedFragments.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\FragmentDefinitionNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Language\Visitor;
use GraphQL\Language\VisitorOperation;
use GraphQL\Validator\ValidationContext;
use function sprintf;

class NoUnusedFragments extends ValidationRule
{
    /** @var OperationDefinitionNode[] */
    public $operationDefs;

    /** @var FragmentDefinitionNode[] */
    public $fragmentDefs;

    public function getVisitor(ValidationContext $context)
    {
        $this->operationDefs = [];
        $this->fragmentDefs  = [];

        return [
            NodeKind::OPERATION_DEFINITION => function ($node) : VisitorOperation {
                $this->operationDefs[] = $node;

                return Visitor::skipNode();
            },
            NodeKind::FRAGMENT_DEFINITION  => function (FragmentDefinitionNode $def) : VisitorOperation {
                $this->fragmentDefs[] = $def;

                return Visitor::skipNode();
            },
            NodeKind::DOCUMENT             => [
                'leave' => function () use ($context) : void {
                    $fragmentNameUsed = [];

                    foreach ($this->operationDefs as $operation) {
                        foreach ($context->getRecursivelyReferencedFragments($operation) as $fragment) {
                            $fragmentNameUsed[$fragment->name->value] = true;
                        }
                    }

                    foreach ($this->fragmentDefs as $fragmentDef) {
                        $fragName = $fragmentDef->name->value;
                        if ($fragmentNameUsed[$fragName] ?? false) {
                            continue;
                        }

                        $context->reportError(new Error(
                            self::unusedFragMessage($fragName),
                            [$fragmentDef]
                        ));
                    }
                },
            ],
        ];
    }

    public static function unusedFragMessage($fragName)
    {
        return sprintf('Fragment "%s" is never used.', $fragName);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\NoUnusedVariables.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Language\AST\VariableDefinitionNode;
use GraphQL\Validator\ValidationContext;
use function sprintf;

class NoUnusedVariables extends ValidationRule
{
    /** @var VariableDefinitionNode[] */
    public $variableDefs;

    public function getVisitor(ValidationContext $context)
    {
        $this->variableDefs = [];

        return [
            NodeKind::OPERATION_DEFINITION => [
                'enter' => function () : void {
                    $this->variableDefs = [];
                },
                'leave' => function (OperationDefinitionNode $operation) use ($context) : void {
                    $variableNameUsed = [];
                    $usages           = $context->getRecursiveVariableUsages($operation);
                    $opName           = $operation->name !== null
                        ? $operation->name->value
                        : null;

                    foreach ($usages as $usage) {
                        $node                                 = $usage['node'];
                        $variableNameUsed[$node->name->value] = true;
                    }

                    foreach ($this->variableDefs as $variableDef) {
                        $variableName = $variableDef->variable->name->value;

                        if ($variableNameUsed[$variableName] ?? false) {
                            continue;
                        }

                        $context->reportError(new Error(
                            self::unusedVariableMessage($variableName, $opName),
                            [$variableDef]
                        ));
                    }
                },
            ],
            NodeKind::VARIABLE_DEFINITION  => function ($def) : void {
                $this->variableDefs[] = $def;
            },
        ];
    }

    public static function unusedVariableMessage($varName, $opName = null)
    {
        return $opName
            ? sprintf('Variable "$%s" is never used in operation "%s".', $varName, $opName)
            : sprintf('Variable "$%s" is never used.', $varName);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\OverlappingFieldsCanBeMerged.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\ArgumentNode;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\FragmentDefinitionNode;
use GraphQL\Language\AST\FragmentSpreadNode;
use GraphQL\Language\AST\InlineFragmentNode;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\SelectionSetNode;
use GraphQL\Language\Printer;
use GraphQL\Type\Definition\CompositeType;
use GraphQL\Type\Definition\InterfaceType;
use GraphQL\Type\Definition\ListOfType;
use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\Type;
use GraphQL\Utils\PairSet;
use GraphQL\Utils\TypeInfo;
use GraphQL\Validator\ValidationContext;
use SplObjectStorage;
use function array_keys;
use function array_map;
use function array_merge;
use function array_reduce;
use function count;
use function implode;
use function is_array;
use function sprintf;

class OverlappingFieldsCanBeMerged extends ValidationRule
{
    /**
     * A memoization for when two fragments are compared "between" each other for
     * conflicts. Two fragments may be compared many times, so memoizing this can
     * dramatically improve the performance of this validator.
     *
     * @var PairSet
     */
    private $comparedFragmentPairs;

    /**
     * A cache for the "field map" and list of fragment names found in any given
     * selection set. Selection sets may be asked for this information multiple
     * times, so this improves the performance of this validator.
     *
     * @var SplObjectStorage
     */
    private $cachedFieldsAndFragmentNames;

    public function getVisitor(ValidationContext $context)
    {
        $this->comparedFragmentPairs        = new PairSet();
        $this->cachedFieldsAndFragmentNames = new SplObjectStorage();

        return [
            NodeKind::SELECTION_SET => function (SelectionSetNode $selectionSet) use ($context) : void {
                $conflicts = $this->findConflictsWithinSelectionSet(
                    $context,
                    $context->getParentType(),
                    $selectionSet
                );

                foreach ($conflicts as $conflict) {
                    [[$responseName, $reason], $fields1, $fields2] = $conflict;

                    $context->reportError(new Error(
                        self::fieldsConflictMessage($responseName, $reason),
                        array_merge($fields1, $fields2)
                    ));
                }
            },
        ];
    }

    /**
     * Find all conflicts found "within" a selection set, including those found
     * via spreading in fragments. Called when visiting each SelectionSet in the
     * GraphQL Document.
     *
     * @param CompositeType $parentType
     *
     * @return mixed[]
     */
    private function findConflictsWithinSelectionSet(
        ValidationContext $context,
        $parentType,
        SelectionSetNode $selectionSet
    ) {
        [$fieldMap, $fragmentNames] = $this->getFieldsAndFragmentNames(
            $context,
            $parentType,
            $selectionSet
        );

        $conflicts = [];

        // (A) Find find all conflicts "within" the fields of this selection set.
        // Note: this is the *only place* `collectConflictsWithin` is called.
        $this->collectConflictsWithin(
            $context,
            $conflicts,
            $fieldMap
        );

        $fragmentNamesLength = count($fragmentNames);
        if ($fragmentNamesLength !== 0) {
            // (B) Then collect conflicts between these fields and those represented by
            // each spread fragment name found.
            $comparedFragments = [];
            for ($i = 0; $i < $fragmentNamesLength; $i++) {
                $this->collectConflictsBetweenFieldsAndFragment(
                    $context,
                    $conflicts,
                    $comparedFragments,
                    false,
                    $fieldMap,
                    $fragmentNames[$i]
                );
                // (C) Then compare this fragment with all other fragments found in this
                // selection set to collect conflicts between fragments spread together.
                // This compares each item in the list of fragment names to every other item
                // in that same list (except for itself).
                for ($j = $i + 1; $j < $fragmentNamesLength; $j++) {
                    $this->collectConflictsBetweenFragments(
                        $context,
                        $conflicts,
                        false,
                        $fragmentNames[$i],
                        $fragmentNames[$j]
                    );
                }
            }
        }

        return $conflicts;
    }

    /**
     * Given a selection set, return the collection of fields (a mapping of response
     * name to field ASTs and definitions) as well as a list of fragment names
     * referenced via fragment spreads.
     *
     * @param CompositeType $parentType
     *
     * @return mixed[]|SplObjectStorage
     */
    private function getFieldsAndFragmentNames(
        ValidationContext $context,
        $parentType,
        SelectionSetNode $selectionSet
    ) {
        if (isset($this->cachedFieldsAndFragmentNames[$selectionSet])) {
            $cached = $this->cachedFieldsAndFragmentNames[$selectionSet];
        } else {
            $astAndDefs    = [];
            $fragmentNames = [];

            $this->internalCollectFieldsAndFragmentNames(
                $context,
                $parentType,
                $selectionSet,
                $astAndDefs,
                $fragmentNames
            );
            $cached                                            = [$astAndDefs, array_keys($fragmentNames)];
            $this->cachedFieldsAndFragmentNames[$selectionSet] = $cached;
        }

        return $cached;
    }

    /**
     * Algorithm:
     *
     * Conflicts occur when two fields exist in a query which will produce the same
     * response name, but represent differing values, thus creating a conflict.
     * The algorithm below finds all conflicts via making a series of comparisons
     * between fields. In order to compare as few fields as possible, this makes
     * a series of comparisons "within" sets of fields and "between" sets of fields.
     *
     * Given any selection set, a collection produces both a set of fields by
     * also including all inline fragments, as well as a list of fragments
     * referenced by fragment spreads.
     *
     * A) Each selection set represented in the document first compares "within" its
     * collected set of fields, finding any conflicts between every pair of
     * overlapping fields.
     * Note: This is the *only time* that a the fields "within" a set are compared
     * to each other. After this only fields "between" sets are compared.
     *
     * B) Also, if any fragment is referenced in a selection set, then a
     * comparison is made "between" the original set of fields and the
     * referenced fragment.
     *
     * C) Also, if multiple fragments are referenced, then comparisons
     * are made "between" each referenced fragment.
     *
     * D) When comparing "between" a set of fields and a referenced fragment, first
     * a comparison is made between each field in the original set of fields and
     * each field in the the referenced set of fields.
     *
     * E) Also, if any fragment is referenced in the referenced selection set,
     * then a comparison is made "between" the original set of fields and the
     * referenced fragment (recursively referring to step D).
     *
     * F) When comparing "between" two fragments, first a comparison is made between
     * each field in the first referenced set of fields and each field in the the
     * second referenced set of fields.
     *
     * G) Also, any fragments referenced by the first must be compared to the
     * second, and any fragments referenced by the second must be compared to the
     * first (recursively referring to step F).
     *
     * H) When comparing two fields, if both have selection sets, then a comparison
     * is made "between" both selection sets, first comparing the set of fields in
     * the first selection set with the set of fields in the second.
     *
     * I) Also, if any fragment is referenced in either selection set, then a
     * comparison is made "between" the other set of fields and the
     * referenced fragment.
     *
     * J) Also, if two fragments are referenced in both selection sets, then a
     * comparison is made "between" the two fragments.
     */

    /**
     * Given a reference to a fragment, return the represented collection of fields
     * as well as a list of nested fragment names referenced via fragment spreads.
     *
     * @param CompositeType $parentType
     * @param mixed[][][]   $astAndDefs
     * @param bool[]        $fragmentNames
     */
    private function internalCollectFieldsAndFragmentNames(
        ValidationContext $context,
        $parentType,
        SelectionSetNode $selectionSet,
        array &$astAndDefs,
        array &$fragmentNames
    ) {
        foreach ($selectionSet->selections as $selection) {
            switch (true) {
                case $selection instanceof FieldNode:
                    $fieldName = $selection->name->value;
                    $fieldDef  = null;
                    if ($parentType instanceof ObjectType ||
                        $parentType instanceof InterfaceType
                    ) {
                        if ($parentType->hasField($fieldName)) {
                            $fieldDef = $parentType->getField($fieldName);
                        }
                    }
                    $responseName = $selection->alias ? $selection->alias->value : $fieldName;

                    if (! isset($astAndDefs[$responseName])) {
                        $astAndDefs[$responseName] = [];
                    }
                    $astAndDefs[$responseName][] = [$parentType, $selection, $fieldDef];
                    break;
                case $selection instanceof FragmentSpreadNode:
                    $fragmentNames[$selection->name->value] = true;
                    break;
                case $selection instanceof InlineFragmentNode:
                    $typeCondition      = $selection->typeCondition;
                    $inlineFragmentType = $typeCondition
                        ? TypeInfo::typeFromAST($context->getSchema(), $typeCondition)
                        : $parentType;

                    $this->internalCollectFieldsAndFragmentNames(
                        $context,
                        $inlineFragmentType,
                        $selection->selectionSet,
                        $astAndDefs,
                        $fragmentNames
                    );
                    break;
            }
        }
    }

    /**
     * Collect all Conflicts "within" one collection of fields.
     *
     * @param mixed[][] $conflicts
     * @param mixed[][] $fieldMap
     */
    private function collectConflictsWithin(
        ValidationContext $context,
        array &$conflicts,
        array $fieldMap
    ) {
        // A field map is a keyed collection, where each key represents a response
        // name and the value at that key is a list of all fields which provide that
        // response name. For every response name, if there are multiple fields, they
        // must be compared to find a potential conflict.
        foreach ($fieldMap as $responseName => $fields) {
            // This compares every field in the list to every other field in this list
            // (except to itself). If the list only has one item, nothing needs to
            // be compared.
            $fieldsLength = count($fields);
            if ($fieldsLength <= 1) {
                continue;
            }

            for ($i = 0; $i < $fieldsLength; $i++) {
                for ($j = $i + 1; $j < $fieldsLength; $j++) {
                    $conflict = $this->findConflict(
                        $context,
                        false, // within one collection is never mutually exclusive
                        $responseName,
                        $fields[$i],
                        $fields[$j]
                    );
                    if (! $conflict) {
                        continue;
                    }

                    $conflicts[] = $conflict;
                }
            }
        }
    }

    /**
     * Determines if there is a conflict between two particular fields, including
     * comparing their sub-fields.
     *
     * @param bool    $parentFieldsAreMutuallyExclusive
     * @param string  $responseName
     * @param mixed[] $field1
     * @param mixed[] $field2
     *
     * @return mixed[]|null
     */
    private function findConflict(
        ValidationContext $context,
        $parentFieldsAreMutuallyExclusive,
        $responseName,
        array $field1,
        array $field2
    ) {
        [$parentType1, $ast1, $def1] = $field1;
        [$parentType2, $ast2, $def2] = $field2;

        // If it is known that two fields could not possibly apply at the same
        // time, due to the parent types, then it is safe to permit them to diverge
        // in aliased field or arguments used as they will not present any ambiguity
        // by differing.
        // It is known that two parent types could never overlap if they are
        // different Object types. Interface or Union types might overlap - if not
        // in the current state of the schema, then perhaps in some future version,
        // thus may not safely diverge.
        $areMutuallyExclusive =
            $parentFieldsAreMutuallyExclusive ||
            (
                $parentType1 !== $parentType2 &&
                $parentType1 instanceof ObjectType &&
                $parentType2 instanceof ObjectType
            );

        // The return type for each field.
        $type1 = $def1 === null ? null : $def1->getType();
        $type2 = $def2 === null ? null : $def2->getType();

        if (! $areMutuallyExclusive) {
            // Two aliases must refer to the same field.
            $name1 = $ast1->name->value;
            $name2 = $ast2->name->value;
            if ($name1 !== $name2) {
                return [
                    [$responseName, sprintf('%s and %s are different fields', $name1, $name2)],
                    [$ast1],
                    [$ast2],
                ];
            }

            if (! $this->sameArguments($ast1->arguments ?? [], $ast2->arguments ?? [])) {
                return [
                    [$responseName, 'they have differing arguments'],
                    [$ast1],
                    [$ast2],
                ];
            }
        }

        if ($type1 && $type2 && $this->doTypesConflict($type1, $type2)) {
            return [
                [$responseName, sprintf('they return conflicting types %s and %s', $type1, $type2)],
                [$ast1],
                [$ast2],
            ];
        }

        // Collect and compare sub-fields. Use the same "visited fragment names" list
        // for both collections so fields in a fragment reference are never
        // compared to themselves.
        $selectionSet1 = $ast1->selectionSet;
        $selectionSet2 = $ast2->selectionSet;
        if ($selectionSet1 && $selectionSet2) {
            $conflicts = $this->findConflictsBetweenSubSelectionSets(
                $context,
                $areMutuallyExclusive,
                Type::getNamedType($type1),
                $selectionSet1,
                Type::getNamedType($type2),
                $selectionSet2
            );

            return $this->subfieldConflicts(
                $conflicts,
                $responseName,
                $ast1,
                $ast2
            );
        }

        return null;
    }

    /**
     * @param ArgumentNode[] $arguments1
     * @param ArgumentNode[] $arguments2
     *
     * @return bool
     */
    private function sameArguments($arguments1, $arguments2)
    {
        if (count($arguments1) !== count($arguments2)) {
            return false;
        }
        foreach ($arguments1 as $argument1) {
            $argument2 = null;
            foreach ($arguments2 as $argument) {
                if ($argument->name->value === $argument1->name->value) {
                    $argument2 = $argument;
                    break;
                }
            }
            if (! $argument2) {
                return false;
            }

            if (! $this->sameValue($argument1->value, $argument2->value)) {
                return false;
            }
        }

        return true;
    }

    /**
     * @return bool
     */
    private function sameValue(Node $value1, Node $value2)
    {
        return (! $value1 && ! $value2) || (Printer::doPrint($value1) === Printer::doPrint($value2));
    }

    /**
     * Two types conflict if both types could not apply to a value simultaneously.
     * Composite types are ignored as their individual field types will be compared
     * later recursively. However List and Non-Null types must match.
     */
    private function doTypesConflict(Type $type1, Type $type2) : bool
    {
        if ($type1 instanceof ListOfType) {
            return $type2 instanceof ListOfType
                ? $this->doTypesConflict($type1->getWrappedType(), $type2->getWrappedType())
                : true;
        }
        if ($type2 instanceof ListOfType) {
            return $type1 instanceof ListOfType
                ? $this->doTypesConflict($type1->getWrappedType(), $type2->getWrappedType())
                : true;
        }
        if ($type1 instanceof NonNull) {
            return $type2 instanceof NonNull
                ? $this->doTypesConflict($type1->getWrappedType(), $type2->getWrappedType())
                : true;
        }
        if ($type2 instanceof NonNull) {
            return $type1 instanceof NonNull
                ? $this->doTypesConflict($type1->getWrappedType(), $type2->getWrappedType())
                : true;
        }
        if (Type::isLeafType($type1) || Type::isLeafType($type2)) {
            return $type1 !== $type2;
        }

        return false;
    }

    /**
     * Find all conflicts found between two selection sets, including those found
     * via spreading in fragments. Called when determining if conflicts exist
     * between the sub-fields of two overlapping fields.
     *
     * @param bool          $areMutuallyExclusive
     * @param CompositeType $parentType1
     * @param CompositeType $parentType2
     *
     * @return mixed[][]
     */
    private function findConflictsBetweenSubSelectionSets(
        ValidationContext $context,
        $areMutuallyExclusive,
        $parentType1,
        SelectionSetNode $selectionSet1,
        $parentType2,
        SelectionSetNode $selectionSet2
    ) {
        $conflicts = [];

        [$fieldMap1, $fragmentNames1] = $this->getFieldsAndFragmentNames(
            $context,
            $parentType1,
            $selectionSet1
        );
        [$fieldMap2, $fragmentNames2] = $this->getFieldsAndFragmentNames(
            $context,
            $parentType2,
            $selectionSet2
        );

        // (H) First, collect all conflicts between these two collections of field.
        $this->collectConflictsBetween(
            $context,
            $conflicts,
            $areMutuallyExclusive,
            $fieldMap1,
            $fieldMap2
        );

        // (I) Then collect conflicts between the first collection of fields and
        // those referenced by each fragment name associated with the second.
        $fragmentNames2Length = count($fragmentNames2);
        if ($fragmentNames2Length !== 0) {
            $comparedFragments = [];
            for ($j = 0; $j < $fragmentNames2Length; $j++) {
                $this->collectConflictsBetweenFieldsAndFragment(
                    $context,
                    $conflicts,
                    $comparedFragments,
                    $areMutuallyExclusive,
                    $fieldMap1,
                    $fragmentNames2[$j]
                );
            }
        }

        // (I) Then collect conflicts between the second collection of fields and
        // those referenced by each fragment name associated with the first.
        $fragmentNames1Length = count($fragmentNames1);
        if ($fragmentNames1Length !== 0) {
            $comparedFragments = [];
            for ($i = 0; $i < $fragmentNames1Length; $i++) {
                $this->collectConflictsBetweenFieldsAndFragment(
                    $context,
                    $conflicts,
                    $comparedFragments,
                    $areMutuallyExclusive,
                    $fieldMap2,
                    $fragmentNames1[$i]
                );
            }
        }

        // (J) Also collect conflicts between any fragment names by the first and
        // fragment names by the second. This compares each item in the first set of
        // names to each item in the second set of names.
        for ($i = 0; $i < $fragmentNames1Length; $i++) {
            for ($j = 0; $j < $fragmentNames2Length; $j++) {
                $this->collectConflictsBetweenFragments(
                    $context,
                    $conflicts,
                    $areMutuallyExclusive,
                    $fragmentNames1[$i],
                    $fragmentNames2[$j]
                );
            }
        }

        return $conflicts;
    }

    /**
     * Collect all Conflicts between two collections of fields. This is similar to,
     * but different from the `collectConflictsWithin` function above. This check
     * assumes that `collectConflictsWithin` has already been called on each
     * provided collection of fields. This is true because this validator traverses
     * each individual selection set.
     *
     * @param mixed[][] $conflicts
     * @param bool      $parentFieldsAreMutuallyExclusive
     * @param mixed[]   $fieldMap1
     * @param mixed[]   $fieldMap2
     */
    private function collectConflictsBetween(
        ValidationContext $context,
        array &$conflicts,
        $parentFieldsAreMutuallyExclusive,
        array $fieldMap1,
        array $fieldMap2
    ) {
        // A field map is a keyed collection, where each key represents a response
        // name and the value at that key is a list of all fields which provide that
        // response name. For any response name which appears in both provided field
        // maps, each field from the first field map must be compared to every field
        // in the second field map to find potential conflicts.
        foreach ($fieldMap1 as $responseName => $fields1) {
            if (! isset($fieldMap2[$responseName])) {
                continue;
            }

            $fields2       = $fieldMap2[$responseName];
            $fields1Length = count($fields1);
            $fields2Length = count($fields2);
            for ($i = 0; $i < $fields1Length; $i++) {
                for ($j = 0; $j < $fields2Length; $j++) {
                    $conflict = $this->findConflict(
                        $context,
                        $parentFieldsAreMutuallyExclusive,
                        $responseName,
                        $fields1[$i],
                        $fields2[$j]
                    );
                    if (! $conflict) {
                        continue;
                    }

                    $conflicts[] = $conflict;
                }
            }
        }
    }

    /**
     * Collect all conflicts found between a set of fields and a fragment reference
     * including via spreading in any nested fragments.
     *
     * @param mixed[][] $conflicts
     * @param bool[]    $comparedFragments
     * @param bool      $areMutuallyExclusive
     * @param mixed[][] $fieldMap
     * @param string    $fragmentName
     */
    private function collectConflictsBetweenFieldsAndFragment(
        ValidationContext $context,
        array &$conflicts,
        array &$comparedFragments,
        $areMutuallyExclusive,
        array $fieldMap,
        $fragmentName
    ) {
        if (isset($comparedFragments[$fragmentName])) {
            return;
        }
        $comparedFragments[$fragmentName] = true;

        $fragment = $context->getFragment($fragmentName);
        if (! $fragment) {
            return;
        }

        [$fieldMap2, $fragmentNames2] = $this->getReferencedFieldsAndFragmentNames(
            $context,
            $fragment
        );

        if ($fieldMap === $fieldMap2) {
            return;
        }

        // (D) First collect any conflicts between the provided collection of fields
        // and the collection of fields represented by the given fragment.
        $this->collectConflictsBetween(
            $context,
            $conflicts,
            $areMutuallyExclusive,
            $fieldMap,
            $fieldMap2
        );

        // (E) Then collect any conflicts between the provided collection of fields
        // and any fragment names found in the given fragment.
        $fragmentNames2Length = count($fragmentNames2);
        for ($i = 0; $i < $fragmentNames2Length; $i++) {
            $this->collectConflictsBetweenFieldsAndFragment(
                $context,
                $conflicts,
                $comparedFragments,
                $areMutuallyExclusive,
                $fieldMap,
                $fragmentNames2[$i]
            );
        }
    }

    /**
     * Given a reference to a fragment, return the represented collection of fields
     * as well as a list of nested fragment names referenced via fragment spreads.
     *
     * @return mixed[]|SplObjectStorage
     */
    private function getReferencedFieldsAndFragmentNames(
        ValidationContext $context,
        FragmentDefinitionNode $fragment
    ) {
        // Short-circuit building a type from the AST if possible.
        if (isset($this->cachedFieldsAndFragmentNames[$fragment->selectionSet])) {
            return $this->cachedFieldsAndFragmentNames[$fragment->selectionSet];
        }

        $fragmentType = TypeInfo::typeFromAST($context->getSchema(), $fragment->typeCondition);

        return $this->getFieldsAndFragmentNames(
            $context,
            $fragmentType,
            $fragment->selectionSet
        );
    }

    /**
     * Collect all conflicts found between two fragments, including via spreading in
     * any nested fragments.
     *
     * @param mixed[][] $conflicts
     * @param bool      $areMutuallyExclusive
     * @param string    $fragmentName1
     * @param string    $fragmentName2
     */
    private function collectConflictsBetweenFragments(
        ValidationContext $context,
        array &$conflicts,
        $areMutuallyExclusive,
        $fragmentName1,
        $fragmentName2
    ) {
        // No need to compare a fragment to itself.
        if ($fragmentName1 === $fragmentName2) {
            return;
        }

        // Memoize so two fragments are not compared for conflicts more than once.
        if ($this->comparedFragmentPairs->has(
            $fragmentName1,
            $fragmentName2,
            $areMutuallyExclusive
        )
        ) {
            return;
        }
        $this->comparedFragmentPairs->add(
            $fragmentName1,
            $fragmentName2,
            $areMutuallyExclusive
        );

        $fragment1 = $context->getFragment($fragmentName1);
        $fragment2 = $context->getFragment($fragmentName2);
        if (! $fragment1 || ! $fragment2) {
            return;
        }

        [$fieldMap1, $fragmentNames1] = $this->getReferencedFieldsAndFragmentNames(
            $context,
            $fragment1
        );
        [$fieldMap2, $fragmentNames2] = $this->getReferencedFieldsAndFragmentNames(
            $context,
            $fragment2
        );

        // (F) First, collect all conflicts between these two collections of fields
        // (not including any nested fragments).
        $this->collectConflictsBetween(
            $context,
            $conflicts,
            $areMutuallyExclusive,
            $fieldMap1,
            $fieldMap2
        );

        // (G) Then collect conflicts between the first fragment and any nested
        // fragments spread in the second fragment.
        $fragmentNames2Length = count($fragmentNames2);
        for ($j = 0; $j < $fragmentNames2Length; $j++) {
            $this->collectConflictsBetweenFragments(
                $context,
                $conflicts,
                $areMutuallyExclusive,
                $fragmentName1,
                $fragmentNames2[$j]
            );
        }

        // (G) Then collect conflicts between the second fragment and any nested
        // fragments spread in the first fragment.
        $fragmentNames1Length = count($fragmentNames1);
        for ($i = 0; $i < $fragmentNames1Length; $i++) {
            $this->collectConflictsBetweenFragments(
                $context,
                $conflicts,
                $areMutuallyExclusive,
                $fragmentNames1[$i],
                $fragmentName2
            );
        }
    }

    /**
     * Given a series of Conflicts which occurred between two sub-fields, generate
     * a single Conflict.
     *
     * @param mixed[][] $conflicts
     * @param string    $responseName
     *
     * @return mixed[]|null
     */
    private function subfieldConflicts(
        array $conflicts,
        $responseName,
        FieldNode $ast1,
        FieldNode $ast2
    ) {
        if (count($conflicts) === 0) {
            return null;
        }

        return [
            [
                $responseName,
                array_map(
                    static function ($conflict) {
                        return $conflict[0];
                    },
                    $conflicts
                ),
            ],
            array_reduce(
                $conflicts,
                static function ($allFields, $conflict) : array {
                    return array_merge($allFields, $conflict[1]);
                },
                [$ast1]
            ),
            array_reduce(
                $conflicts,
                static function ($allFields, $conflict) : array {
                    return array_merge($allFields, $conflict[2]);
                },
                [$ast2]
            ),
        ];
    }

    /**
     * @param string $responseName
     * @param string $reason
     */
    public static function fieldsConflictMessage($responseName, $reason)
    {
        $reasonMessage = self::reasonMessage($reason);

        return sprintf(
            'Fields "%s" conflict because %s. Use different aliases on the fields to fetch both if this was intentional.',
            $responseName,
            $reasonMessage
        );
    }

    public static function reasonMessage($reason)
    {
        if (is_array($reason)) {
            $tmp = array_map(
                static function ($tmp) : string {
                    [$responseName, $subReason] = $tmp;

                    $reasonMessage = self::reasonMessage($subReason);

                    return sprintf('subfields "%s" conflict because %s', $responseName, $reasonMessage);
                },
                $reason
            );

            return implode(' and ', $tmp);
        }

        return $reason;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\PossibleFragmentSpreads.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\FragmentSpreadNode;
use GraphQL\Language\AST\InlineFragmentNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Type\Definition\AbstractType;
use GraphQL\Type\Definition\CompositeType;
use GraphQL\Type\Definition\InterfaceType;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\UnionType;
use GraphQL\Type\Schema;
use GraphQL\Utils\TypeInfo;
use GraphQL\Validator\ValidationContext;
use function sprintf;

class PossibleFragmentSpreads extends ValidationRule
{
    public function getVisitor(ValidationContext $context)
    {
        return [
            NodeKind::INLINE_FRAGMENT => function (InlineFragmentNode $node) use ($context) : void {
                $fragType   = $context->getType();
                $parentType = $context->getParentType();

                if (! ($fragType instanceof CompositeType) ||
                    ! ($parentType instanceof CompositeType) ||
                    $this->doTypesOverlap($context->getSchema(), $fragType, $parentType)) {
                    return;
                }

                $context->reportError(new Error(
                    self::typeIncompatibleAnonSpreadMessage($parentType, $fragType),
                    [$node]
                ));
            },
            NodeKind::FRAGMENT_SPREAD => function (FragmentSpreadNode $node) use ($context) : void {
                $fragName   = $node->name->value;
                $fragType   = $this->getFragmentType($context, $fragName);
                $parentType = $context->getParentType();

                if (! $fragType ||
                    ! $parentType ||
                    $this->doTypesOverlap($context->getSchema(), $fragType, $parentType)
                ) {
                    return;
                }

                $context->reportError(new Error(
                    self::typeIncompatibleSpreadMessage($fragName, $parentType, $fragType),
                    [$node]
                ));
            },
        ];
    }

    private function doTypesOverlap(Schema $schema, CompositeType $fragType, CompositeType $parentType)
    {
        // Checking in the order of the most frequently used scenarios:
        // Parent type === fragment type
        if ($parentType === $fragType) {
            return true;
        }

        // Parent type is interface or union, fragment type is object type
        if ($parentType instanceof AbstractType && $fragType instanceof ObjectType) {
            return $schema->isSubType($parentType, $fragType);
        }

        // Parent type is object type, fragment type is interface (or rather rare - union)
        if ($parentType instanceof ObjectType && $fragType instanceof AbstractType) {
            return $schema->isSubType($fragType, $parentType);
        }

        // Both are object types:
        if ($parentType instanceof ObjectType && $fragType instanceof ObjectType) {
            return $parentType === $fragType;
        }

        // Both are interfaces
        // This case may be assumed valid only when implementations of two interfaces intersect
        // But we don't have information about all implementations at runtime
        // (getting this information via $schema->getPossibleTypes() requires scanning through whole schema
        // which is very costly to do at each request due to PHP "shared nothing" architecture)
        //
        // So in this case we just make it pass - invalid fragment spreads will be simply ignored during execution
        // See also https://github.com/webonyx/graphql-php/issues/69#issuecomment-283954602
        if ($parentType instanceof InterfaceType && $fragType instanceof InterfaceType) {
            return true;

            // Note that there is one case when we do have information about all implementations:
            // When schema descriptor is defined ($schema->hasDescriptor())
            // BUT we must avoid situation when some query that worked in development had suddenly stopped
            // working in production. So staying consistent and always validate.
        }

        // Interface within union
        if ($parentType instanceof UnionType && $fragType instanceof InterfaceType) {
            foreach ($parentType->getTypes() as $type) {
                if ($type->implementsInterface($fragType)) {
                    return true;
                }
            }
        }

        if ($parentType instanceof InterfaceType && $fragType instanceof UnionType) {
            foreach ($fragType->getTypes() as $type) {
                if ($type->implementsInterface($parentType)) {
                    return true;
                }
            }
        }

        if ($parentType instanceof UnionType && $fragType instanceof UnionType) {
            foreach ($fragType->getTypes() as $type) {
                if ($parentType->isPossibleType($type)) {
                    return true;
                }
            }
        }

        return false;
    }

    public static function typeIncompatibleAnonSpreadMessage($parentType, $fragType)
    {
        return sprintf(
            'Fragment cannot be spread here as objects of type "%s" can never be of type "%s".',
            $parentType,
            $fragType
        );
    }

    private function getFragmentType(ValidationContext $context, $name)
    {
        $frag = $context->getFragment($name);
        if ($frag) {
            $type = TypeInfo::typeFromAST($context->getSchema(), $frag->typeCondition);
            if ($type instanceof CompositeType) {
                return $type;
            }
        }

        return null;
    }

    public static function typeIncompatibleSpreadMessage($fragName, $parentType, $fragType)
    {
        return sprintf(
            'Fragment "%s" cannot be spread here as objects of type "%s" can never be of type "%s".',
            $fragName,
            $parentType,
            $fragType
        );
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\ProvidedRequiredArguments.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\Visitor;
use GraphQL\Language\VisitorOperation;
use GraphQL\Validator\ValidationContext;
use function sprintf;

class ProvidedRequiredArguments extends ValidationRule
{
    public function getVisitor(ValidationContext $context)
    {
        $providedRequiredArgumentsOnDirectives = new ProvidedRequiredArgumentsOnDirectives();

        return $providedRequiredArgumentsOnDirectives->getVisitor($context) + [
            NodeKind::FIELD => [
                'leave' => static function (FieldNode $fieldNode) use ($context) : ?VisitorOperation {
                    $fieldDef = $context->getFieldDef();

                    if (! $fieldDef) {
                        return Visitor::skipNode();
                    }
                    $argNodes = $fieldNode->arguments ?? [];

                    $argNodeMap = [];
                    foreach ($argNodes as $argNode) {
                        $argNodeMap[$argNode->name->value] = $argNode;
                    }
                    foreach ($fieldDef->args as $argDef) {
                        $argNode = $argNodeMap[$argDef->name] ?? null;
                        if ($argNode || ! $argDef->isRequired()) {
                            continue;
                        }

                        $context->reportError(new Error(
                            self::missingFieldArgMessage($fieldNode->name->value, $argDef->name, $argDef->getType()),
                            [$fieldNode]
                        ));
                    }

                    return null;
                },
            ],
        ];
    }

    public static function missingFieldArgMessage($fieldName, $argName, $type)
    {
        return sprintf(
            'Field "%s" argument "%s" of type "%s" is required but not provided.',
            $fieldName,
            $argName,
            $type
        );
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\ProvidedRequiredArgumentsOnDirectives.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\ArgumentNode;
use GraphQL\Language\AST\DirectiveDefinitionNode;
use GraphQL\Language\AST\DirectiveNode;
use GraphQL\Language\AST\InputValueDefinitionNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\NonNullTypeNode;
use GraphQL\Language\Printer;
use GraphQL\Type\Definition\Directive;
use GraphQL\Type\Definition\FieldArgument;
use GraphQL\Utils\Utils;
use GraphQL\Validator\ASTValidationContext;
use GraphQL\Validator\SDLValidationContext;
use GraphQL\Validator\ValidationContext;
use function array_filter;

/**
 * Provided required arguments on directives
 *
 * A directive is only valid if all required (non-null without a
 * default value) field arguments have been provided.
 */
class ProvidedRequiredArgumentsOnDirectives extends ValidationRule
{
    public static function missingDirectiveArgMessage(string $directiveName, string $argName, string $type)
    {
        return 'Directive "@' . $directiveName . '" argument "' . $argName
            . '" of type "' . $type . '" is required but not provided.';
    }

    public function getSDLVisitor(SDLValidationContext $context)
    {
        return $this->getASTVisitor($context);
    }

    public function getVisitor(ValidationContext $context)
    {
        return $this->getASTVisitor($context);
    }

    public function getASTVisitor(ASTValidationContext $context)
    {
        $requiredArgsMap   = [];
        $schema            = $context->getSchema();
        $definedDirectives = $schema
            ? $schema->getDirectives()
            : Directive::getInternalDirectives();

        foreach ($definedDirectives as $directive) {
            $requiredArgsMap[$directive->name] = Utils::keyMap(
                array_filter($directive->args, static function (FieldArgument $arg) : bool {
                    return $arg->isRequired();
                }),
                static function (FieldArgument $arg) : string {
                    return $arg->name;
                }
            );
        }

        $astDefinition = $context->getDocument()->definitions;
        foreach ($astDefinition as $def) {
            if (! ($def instanceof DirectiveDefinitionNode)) {
                continue;
            }
            $arguments = $def->arguments ?? [];

            $requiredArgsMap[$def->name->value] = Utils::keyMap(
                Utils::filter($arguments, static function (InputValueDefinitionNode $argument) : bool {
                    return $argument->type instanceof NonNullTypeNode &&
                        (
                            ! isset($argument->defaultValue) ||
                            $argument->defaultValue === null
                        );
                }),
                static function (InputValueDefinitionNode $argument) : string {
                    return $argument->name->value;
                }
            );
        }

        return [
            NodeKind::DIRECTIVE => [
                // Validate on leave to allow for deeper errors to appear first.
                'leave' => static function (DirectiveNode $directiveNode) use ($requiredArgsMap, $context) : ?string {
                    $directiveName = $directiveNode->name->value;
                    $requiredArgs  = $requiredArgsMap[$directiveName] ?? null;
                    if (! $requiredArgs) {
                        return null;
                    }

                    $argNodes   = $directiveNode->arguments ?? [];
                    $argNodeMap = Utils::keyMap(
                        $argNodes,
                        static function (ArgumentNode $arg) : string {
                            return $arg->name->value;
                        }
                    );

                    foreach ($requiredArgs as $argName => $arg) {
                        if (isset($argNodeMap[$argName])) {
                            continue;
                        }

                        if ($arg instanceof FieldArgument) {
                            $argType = (string) $arg->getType();
                        } elseif ($arg instanceof InputValueDefinitionNode) {
                            $argType = Printer::doPrint($arg->type);
                        } else {
                            $argType = '';
                        }

                        $context->reportError(
                            new Error(static::missingDirectiveArgMessage($directiveName, $argName, $argType), [$directiveNode])
                        );
                    }

                    return null;
                },
            ],
        ];
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\QueryComplexity.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use ArrayObject;
use GraphQL\Error\Error;
use GraphQL\Executor\Values;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\FragmentSpreadNode;
use GraphQL\Language\AST\InlineFragmentNode;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Language\AST\SelectionSetNode;
use GraphQL\Language\Visitor;
use GraphQL\Language\VisitorOperation;
use GraphQL\Type\Definition\Directive;
use GraphQL\Type\Definition\FieldDefinition;
use GraphQL\Validator\ValidationContext;
use function array_map;
use function count;
use function implode;
use function method_exists;
use function sprintf;

class QueryComplexity extends QuerySecurityRule
{
    /** @var int */
    private $maxQueryComplexity;

    /** @var mixed[]|null */
    private $rawVariableValues = [];

    /** @var ArrayObject */
    private $variableDefs;

    /** @var ArrayObject */
    private $fieldNodeAndDefs;

    /** @var ValidationContext */
    private $context;

    /** @var int */
    private $complexity;

    public function __construct($maxQueryComplexity)
    {
        $this->setMaxQueryComplexity($maxQueryComplexity);
    }

    public function getVisitor(ValidationContext $context)
    {
        $this->context = $context;

        $this->variableDefs     = new ArrayObject();
        $this->fieldNodeAndDefs = new ArrayObject();
        $this->complexity       = 0;

        return $this->invokeIfNeeded(
            $context,
            [
                NodeKind::SELECTION_SET        => function (SelectionSetNode $selectionSet) use ($context) : void {
                    $this->fieldNodeAndDefs = $this->collectFieldASTsAndDefs(
                        $context,
                        $context->getParentType(),
                        $selectionSet,
                        null,
                        $this->fieldNodeAndDefs
                    );
                },
                NodeKind::VARIABLE_DEFINITION  => function ($def) : VisitorOperation {
                    $this->variableDefs[] = $def;

                    return Visitor::skipNode();
                },
                NodeKind::OPERATION_DEFINITION => [
                    'leave' => function (OperationDefinitionNode $operationDefinition) use ($context, &$complexity) : void {
                        $errors = $context->getErrors();

                        if (count($errors) > 0) {
                            return;
                        }

                        $this->complexity = $this->fieldComplexity($operationDefinition, $complexity);

                        if ($this->getQueryComplexity() <= $this->getMaxQueryComplexity()) {
                            return;
                        }

                        $context->reportError(
                            new Error(self::maxQueryComplexityErrorMessage(
                                $this->getMaxQueryComplexity(),
                                $this->getQueryComplexity()
                            ))
                        );
                    },
                ],
            ]
        );
    }

    private function fieldComplexity($node, $complexity = 0)
    {
        if (isset($node->selectionSet) && $node->selectionSet instanceof SelectionSetNode) {
            foreach ($node->selectionSet->selections as $childNode) {
                $complexity = $this->nodeComplexity($childNode, $complexity);
            }
        }

        return $complexity;
    }

    private function nodeComplexity(Node $node, $complexity = 0)
    {
        switch (true) {
            case $node instanceof FieldNode:
                // default values
                $args         = [];
                $complexityFn = FieldDefinition::DEFAULT_COMPLEXITY_FN;

                // calculate children complexity if needed
                $childrenComplexity = 0;

                // node has children?
                if (isset($node->selectionSet)) {
                    $childrenComplexity = $this->fieldComplexity($node);
                }

                $astFieldInfo = $this->astFieldInfo($node);
                $fieldDef     = $astFieldInfo[1];

                if ($fieldDef instanceof FieldDefinition) {
                    if ($this->directiveExcludesField($node)) {
                        break;
                    }

                    $args = $this->buildFieldArguments($node);
                    //get complexity fn using fieldDef complexity
                    if (method_exists($fieldDef, 'getComplexityFn')) {
                        $complexityFn = $fieldDef->getComplexityFn();
                    }
                }

                $complexity += $complexityFn($childrenComplexity, $args);
                break;

            case $node instanceof InlineFragmentNode:
                // node has children?
                if (isset($node->selectionSet)) {
                    $complexity = $this->fieldComplexity($node, $complexity);
                }
                break;

            case $node instanceof FragmentSpreadNode:
                $fragment = $this->getFragment($node);

                if ($fragment !== null) {
                    $complexity = $this->fieldComplexity($fragment, $complexity);
                }
                break;
        }

        return $complexity;
    }

    private function astFieldInfo(FieldNode $field)
    {
        $fieldName    = $this->getFieldName($field);
        $astFieldInfo = [null, null];
        if (isset($this->fieldNodeAndDefs[$fieldName])) {
            foreach ($this->fieldNodeAndDefs[$fieldName] as $astAndDef) {
                if ($astAndDef[0] === $field) {
                    $astFieldInfo = $astAndDef;
                    break;
                }
            }
        }

        return $astFieldInfo;
    }

    private function directiveExcludesField(FieldNode $node)
    {
        foreach ($node->directives as $directiveNode) {
            if ($directiveNode->name->value === 'deprecated') {
                return false;
            }
            [$errors, $variableValues] = Values::getVariableValues(
                $this->context->getSchema(),
                $this->variableDefs,
                $this->getRawVariableValues()
            );
            if (count($errors ?? []) > 0) {
                throw new Error(implode(
                    "\n\n",
                    array_map(
                        static function ($error) {
                            return $error->getMessage();
                        },
                        $errors
                    )
                ));
            }
            if ($directiveNode->name->value === 'include') {
                $directive = Directive::includeDirective();
                /** @var bool $directiveArgsIf */
                $directiveArgsIf = Values::getArgumentValues($directive, $directiveNode, $variableValues)['if'];

                return ! $directiveArgsIf;
            }
            if ($directiveNode->name->value === Directive::SKIP_NAME) {
                $directive = Directive::skipDirective();
                /** @var bool $directiveArgsIf */
                $directiveArgsIf = Values::getArgumentValues($directive, $directiveNode, $variableValues)['if'];

                return $directiveArgsIf;
            }
        }

        return false;
    }

    public function getRawVariableValues()
    {
        return $this->rawVariableValues;
    }

    /**
     * @param mixed[]|null $rawVariableValues
     */
    public function setRawVariableValues(?array $rawVariableValues = null)
    {
        $this->rawVariableValues = $rawVariableValues ?? [];
    }

    private function buildFieldArguments(FieldNode $node)
    {
        $rawVariableValues = $this->getRawVariableValues();
        $astFieldInfo      = $this->astFieldInfo($node);
        $fieldDef          = $astFieldInfo[1];

        $args = [];

        if ($fieldDef instanceof FieldDefinition) {
            [$errors, $variableValues] = Values::getVariableValues(
                $this->context->getSchema(),
                $this->variableDefs,
                $rawVariableValues
            );

            if (count($errors ?? []) > 0) {
                throw new Error(implode(
                    "\n\n",
                    array_map(
                        static function ($error) {
                            return $error->getMessage();
                        },
                        $errors
                    )
                ));
            }

            $args = Values::getArgumentValues($fieldDef, $node, $variableValues);
        }

        return $args;
    }

    public function getQueryComplexity()
    {
        return $this->complexity;
    }

    public function getMaxQueryComplexity()
    {
        return $this->maxQueryComplexity;
    }

    /**
     * Set max query complexity. If equal to 0 no check is done. Must be greater or equal to 0.
     */
    public function setMaxQueryComplexity($maxQueryComplexity)
    {
        $this->checkIfGreaterOrEqualToZero('maxQueryComplexity', $maxQueryComplexity);

        $this->maxQueryComplexity = (int) $maxQueryComplexity;
    }

    public static function maxQueryComplexityErrorMessage($max, $count)
    {
        return sprintf('Max query complexity should be %d but got %d.', $max, $count);
    }

    protected function isEnabled()
    {
        return $this->getMaxQueryComplexity() !== self::DISABLED;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\QueryDepth.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\FragmentSpreadNode;
use GraphQL\Language\AST\InlineFragmentNode;
use GraphQL\Language\AST\Node;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Language\AST\SelectionSetNode;
use GraphQL\Validator\ValidationContext;
use function sprintf;

class QueryDepth extends QuerySecurityRule
{
    /** @var int */
    private $maxQueryDepth;

    public function __construct($maxQueryDepth)
    {
        $this->setMaxQueryDepth($maxQueryDepth);
    }

    public function getVisitor(ValidationContext $context)
    {
        return $this->invokeIfNeeded(
            $context,
            [
                NodeKind::OPERATION_DEFINITION => [
                    'leave' => function (OperationDefinitionNode $operationDefinition) use ($context) : void {
                        $maxDepth = $this->fieldDepth($operationDefinition);

                        if ($maxDepth <= $this->getMaxQueryDepth()) {
                            return;
                        }

                        $context->reportError(
                            new Error(self::maxQueryDepthErrorMessage($this->getMaxQueryDepth(), $maxDepth))
                        );
                    },
                ],
            ]
        );
    }

    private function fieldDepth($node, $depth = 0, $maxDepth = 0)
    {
        if (isset($node->selectionSet) && $node->selectionSet instanceof SelectionSetNode) {
            foreach ($node->selectionSet->selections as $childNode) {
                $maxDepth = $this->nodeDepth($childNode, $depth, $maxDepth);
            }
        }

        return $maxDepth;
    }

    private function nodeDepth(Node $node, $depth = 0, $maxDepth = 0)
    {
        switch (true) {
            case $node instanceof FieldNode:
                // node has children?
                if ($node->selectionSet !== null) {
                    // update maxDepth if needed
                    if ($depth > $maxDepth) {
                        $maxDepth = $depth;
                    }
                    $maxDepth = $this->fieldDepth($node, $depth + 1, $maxDepth);
                }
                break;

            case $node instanceof InlineFragmentNode:
                // node has children?
                if ($node->selectionSet !== null) {
                    $maxDepth = $this->fieldDepth($node, $depth, $maxDepth);
                }
                break;

            case $node instanceof FragmentSpreadNode:
                $fragment = $this->getFragment($node);

                if ($fragment !== null) {
                    $maxDepth = $this->fieldDepth($fragment, $depth, $maxDepth);
                }
                break;
        }

        return $maxDepth;
    }

    public function getMaxQueryDepth()
    {
        return $this->maxQueryDepth;
    }

    /**
     * Set max query depth. If equal to 0 no check is done. Must be greater or equal to 0.
     */
    public function setMaxQueryDepth($maxQueryDepth)
    {
        $this->checkIfGreaterOrEqualToZero('maxQueryDepth', $maxQueryDepth);

        $this->maxQueryDepth = (int) $maxQueryDepth;
    }

    public static function maxQueryDepthErrorMessage($max, $count)
    {
        return sprintf('Max query depth should be %d but got %d.', $max, $count);
    }

    protected function isEnabled()
    {
        return $this->getMaxQueryDepth() !== self::DISABLED;
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\QuerySecurityRule.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use ArrayObject;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\FragmentDefinitionNode;
use GraphQL\Language\AST\FragmentSpreadNode;
use GraphQL\Language\AST\InlineFragmentNode;
use GraphQL\Language\AST\SelectionSetNode;
use GraphQL\Type\Definition\HasFieldsType;
use GraphQL\Type\Definition\InputObjectType;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Introspection;
use GraphQL\Utils\TypeInfo;
use GraphQL\Validator\ValidationContext;
use InvalidArgumentException;
use function class_alias;
use function sprintf;

abstract class QuerySecurityRule extends ValidationRule
{
    public const DISABLED = 0;

    /** @var FragmentDefinitionNode[] */
    private $fragments = [];

    /**
     * check if equal to 0 no check is done. Must be greater or equal to 0.
     *
     * @param string $name
     * @param int    $value
     */
    protected function checkIfGreaterOrEqualToZero($name, $value)
    {
        if ($value < 0) {
            throw new InvalidArgumentException(sprintf('$%s argument must be greater or equal to 0.', $name));
        }
    }

    protected function getFragment(FragmentSpreadNode $fragmentSpread)
    {
        $spreadName = $fragmentSpread->name->value;
        $fragments  = $this->getFragments();

        return $fragments[$spreadName] ?? null;
    }

    /**
     * @return FragmentDefinitionNode[]
     */
    protected function getFragments()
    {
        return $this->fragments;
    }

    /**
     * @param callable[] $validators
     *
     * @return callable[]
     */
    protected function invokeIfNeeded(ValidationContext $context, array $validators)
    {
        // is disabled?
        if (! $this->isEnabled()) {
            return [];
        }

        $this->gatherFragmentDefinition($context);

        return $validators;
    }

    abstract protected function isEnabled();

    protected function gatherFragmentDefinition(ValidationContext $context)
    {
        // Gather all the fragment definition.
        // Importantly this does not include inline fragments.
        $definitions = $context->getDocument()->definitions;
        foreach ($definitions as $node) {
            if (! ($node instanceof FragmentDefinitionNode)) {
                continue;
            }

            $this->fragments[$node->name->value] = $node;
        }
    }

    /**
     * Given a selectionSet, adds all of the fields in that selection to
     * the passed in map of fields, and returns it at the end.
     *
     * Note: This is not the same as execution's collectFields because at static
     * time we do not know what object type will be used, so we unconditionally
     * spread in all fragments.
     *
     * @see \GraphQL\Validator\Rules\OverlappingFieldsCanBeMerged
     *
     * @param Type|null $parentType
     *
     * @return ArrayObject
     */
    protected function collectFieldASTsAndDefs(
        ValidationContext $context,
        $parentType,
        SelectionSetNode $selectionSet,
        ?ArrayObject $visitedFragmentNames = null,
        ?ArrayObject $astAndDefs = null
    ) {
        $_visitedFragmentNames = $visitedFragmentNames ?? new ArrayObject();
        $_astAndDefs           = $astAndDefs ?? new ArrayObject();

        foreach ($selectionSet->selections as $selection) {
            switch (true) {
                case $selection instanceof FieldNode:
                    $fieldName = $selection->name->value;
                    $fieldDef  = null;
                    if ($parentType instanceof HasFieldsType || $parentType instanceof InputObjectType) {
                        $schemaMetaFieldDef   = Introspection::schemaMetaFieldDef();
                        $typeMetaFieldDef     = Introspection::typeMetaFieldDef();
                        $typeNameMetaFieldDef = Introspection::typeNameMetaFieldDef();

                        if ($fieldName === $schemaMetaFieldDef->name && $context->getSchema()->getQueryType() === $parentType) {
                            $fieldDef = $schemaMetaFieldDef;
                        } elseif ($fieldName === $typeMetaFieldDef->name && $context->getSchema()->getQueryType() === $parentType) {
                            $fieldDef = $typeMetaFieldDef;
                        } elseif ($fieldName === $typeNameMetaFieldDef->name) {
                            $fieldDef = $typeNameMetaFieldDef;
                        } elseif ($parentType->hasField($fieldName)) {
                            $fieldDef = $parentType->getField($fieldName);
                        }
                    }
                    $responseName = $this->getFieldName($selection);
                    if (! isset($_astAndDefs[$responseName])) {
                        $_astAndDefs[$responseName] = new ArrayObject();
                    }
                    // create field context
                    $_astAndDefs[$responseName][] = [$selection, $fieldDef];
                    break;
                case $selection instanceof InlineFragmentNode:
                    $_astAndDefs = $this->collectFieldASTsAndDefs(
                        $context,
                        TypeInfo::typeFromAST($context->getSchema(), $selection->typeCondition),
                        $selection->selectionSet,
                        $_visitedFragmentNames,
                        $_astAndDefs
                    );
                    break;
                case $selection instanceof FragmentSpreadNode:
                    $fragName = $selection->name->value;

                    if (! ($_visitedFragmentNames[$fragName] ?? false)) {
                        $_visitedFragmentNames[$fragName] = true;
                        $fragment                         = $context->getFragment($fragName);

                        if ($fragment) {
                            $_astAndDefs = $this->collectFieldASTsAndDefs(
                                $context,
                                TypeInfo::typeFromAST($context->getSchema(), $fragment->typeCondition),
                                $fragment->selectionSet,
                                $_visitedFragmentNames,
                                $_astAndDefs
                            );
                        }
                    }
                    break;
            }
        }

        return $_astAndDefs;
    }

    protected function getFieldName(FieldNode $node)
    {
        $fieldName = $node->name->value;

        return $node->alias ? $node->alias->value : $fieldName;
    }
}

class_alias(QuerySecurityRule::class, 'GraphQL\Validator\Rules\AbstractQuerySecurity');


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\ScalarLeafs.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Type\Definition\Type;
use GraphQL\Validator\ValidationContext;
use function sprintf;

class ScalarLeafs extends ValidationRule
{
    public function getVisitor(ValidationContext $context)
    {
        return [
            NodeKind::FIELD => static function (FieldNode $node) use ($context) : void {
                $type = $context->getType();
                if (! $type) {
                    return;
                }

                if (Type::isLeafType(Type::getNamedType($type))) {
                    if ($node->selectionSet) {
                        $context->reportError(new Error(
                            self::noSubselectionAllowedMessage($node->name->value, $type),
                            [$node->selectionSet]
                        ));
                    }
                } elseif (! $node->selectionSet) {
                    $context->reportError(new Error(
                        self::requiredSubselectionMessage($node->name->value, $type),
                        [$node]
                    ));
                }
            },
        ];
    }

    public static function noSubselectionAllowedMessage($field, $type)
    {
        return sprintf('Field "%s" of type "%s" must not have a sub selection.', $field, $type);
    }

    public static function requiredSubselectionMessage($field, $type)
    {
        return sprintf('Field "%s" of type "%s" must have a sub selection.', $field, $type);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\SingleFieldSubscription.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\NodeList;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Language\Visitor;
use GraphQL\Language\VisitorOperation;
use GraphQL\Validator\ValidationContext;
use function array_splice;
use function count;
use function sprintf;

class SingleFieldSubscription extends ValidationRule
{
    /**
     * @return array<string, callable>
     */
    public function getVisitor(ValidationContext $context) : array
    {
        return [
            NodeKind::OPERATION_DEFINITION => static function (OperationDefinitionNode $node) use ($context) : VisitorOperation {
                if ($node->operation === 'subscription') {
                    $selections = $node->selectionSet->selections;

                    if (count($selections) !== 1) {
                        if ($selections instanceof NodeList) {
                            $offendingSelections = $selections->splice(1, count($selections));
                        } else {
                            $offendingSelections = array_splice($selections, 1);
                        }

                        $context->reportError(new Error(
                            self::multipleFieldsInOperation($node->name->value ?? null),
                            $offendingSelections
                        ));
                    }
                }

                return Visitor::skipNode();
            },
        ];
    }

    public static function multipleFieldsInOperation(?string $operationName) : string
    {
        if ($operationName === null) {
            return sprintf('Anonymous Subscription must select only one top level field.');
        }

        return sprintf('Subscription "%s" must select only one top level field.', $operationName);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\UniqueArgumentNames.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\ArgumentNode;
use GraphQL\Language\AST\NameNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\Visitor;
use GraphQL\Language\VisitorOperation;
use GraphQL\Validator\ASTValidationContext;
use GraphQL\Validator\SDLValidationContext;
use GraphQL\Validator\ValidationContext;
use function sprintf;

class UniqueArgumentNames extends ValidationRule
{
    /** @var NameNode[] */
    public $knownArgNames;

    public function getSDLVisitor(SDLValidationContext $context)
    {
        return $this->getASTVisitor($context);
    }

    public function getVisitor(ValidationContext $context)
    {
        return $this->getASTVisitor($context);
    }

    public function getASTVisitor(ASTValidationContext $context)
    {
        $this->knownArgNames = [];

        return [
            NodeKind::FIELD     => function () : void {
                $this->knownArgNames = [];
            },
            NodeKind::DIRECTIVE => function () : void {
                $this->knownArgNames = [];
            },
            NodeKind::ARGUMENT  => function (ArgumentNode $node) use ($context) : VisitorOperation {
                $argName = $node->name->value;
                if ($this->knownArgNames[$argName] ?? false) {
                    $context->reportError(new Error(
                        self::duplicateArgMessage($argName),
                        [$this->knownArgNames[$argName], $node->name]
                    ));
                } else {
                    $this->knownArgNames[$argName] = $node->name;
                }

                return Visitor::skipNode();
            },
        ];
    }

    public static function duplicateArgMessage($argName)
    {
        return sprintf('There can be only one argument named "%s".', $argName);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\UniqueDirectivesPerLocation.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\DirectiveDefinitionNode;
use GraphQL\Language\AST\DirectiveNode;
use GraphQL\Language\AST\Node;
use GraphQL\Type\Definition\Directive;
use GraphQL\Validator\ASTValidationContext;
use GraphQL\Validator\SDLValidationContext;
use GraphQL\Validator\ValidationContext;
use function sprintf;

/**
 * Unique directive names per location
 *
 * A GraphQL document is only valid if all non-repeatable directives at
 * a given location are uniquely named.
 */
class UniqueDirectivesPerLocation extends ValidationRule
{
    public function getVisitor(ValidationContext $context)
    {
        return $this->getASTVisitor($context);
    }

    public function getSDLVisitor(SDLValidationContext $context)
    {
        return $this->getASTVisitor($context);
    }

    public function getASTVisitor(ASTValidationContext $context)
    {
        /** @var array<string, true> $uniqueDirectiveMap */
        $uniqueDirectiveMap = [];

        $schema            = $context->getSchema();
        $definedDirectives = $schema !== null
            ? $schema->getDirectives()
            : Directive::getInternalDirectives();
        foreach ($definedDirectives as $directive) {
            if ($directive->isRepeatable) {
                continue;
            }

            $uniqueDirectiveMap[$directive->name] = true;
        }

        $astDefinitions = $context->getDocument()->definitions;
        foreach ($astDefinitions as $definition) {
            if (! ($definition instanceof DirectiveDefinitionNode)
                || $definition->repeatable
            ) {
                continue;
            }

            $uniqueDirectiveMap[$definition->name->value] = true;
        }

        return [
            'enter' => static function (Node $node) use ($uniqueDirectiveMap, $context) : void {
                if (! isset($node->directives)) {
                    return;
                }

                $knownDirectives = [];

                /** @var DirectiveNode $directive */
                foreach ($node->directives as $directive) {
                    $directiveName = $directive->name->value;

                    if (! isset($uniqueDirectiveMap[$directiveName])) {
                        continue;
                    }

                    if (isset($knownDirectives[$directiveName])) {
                        $context->reportError(new Error(
                            self::duplicateDirectiveMessage($directiveName),
                            [$knownDirectives[$directiveName], $directive]
                        ));
                    } else {
                        $knownDirectives[$directiveName] = $directive;
                    }
                }
            },
        ];
    }

    public static function duplicateDirectiveMessage($directiveName)
    {
        return sprintf('The directive "%s" can only be used once at this location.', $directiveName);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\UniqueFragmentNames.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\FragmentDefinitionNode;
use GraphQL\Language\AST\NameNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\Visitor;
use GraphQL\Language\VisitorOperation;
use GraphQL\Validator\ValidationContext;
use function sprintf;

class UniqueFragmentNames extends ValidationRule
{
    /** @var NameNode[] */
    public $knownFragmentNames;

    public function getVisitor(ValidationContext $context)
    {
        $this->knownFragmentNames = [];

        return [
            NodeKind::OPERATION_DEFINITION => static function () : VisitorOperation {
                return Visitor::skipNode();
            },
            NodeKind::FRAGMENT_DEFINITION  => function (FragmentDefinitionNode $node) use ($context) : VisitorOperation {
                $fragmentName = $node->name->value;
                if (! isset($this->knownFragmentNames[$fragmentName])) {
                    $this->knownFragmentNames[$fragmentName] = $node->name;
                } else {
                    $context->reportError(new Error(
                        self::duplicateFragmentNameMessage($fragmentName),
                        [$this->knownFragmentNames[$fragmentName], $node->name]
                    ));
                }

                return Visitor::skipNode();
            },
        ];
    }

    public static function duplicateFragmentNameMessage($fragName)
    {
        return sprintf('There can be only one fragment named "%s".', $fragName);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\UniqueInputFieldNames.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\NameNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\ObjectFieldNode;
use GraphQL\Language\Visitor;
use GraphQL\Language\VisitorOperation;
use GraphQL\Validator\ASTValidationContext;
use GraphQL\Validator\SDLValidationContext;
use GraphQL\Validator\ValidationContext;
use function array_pop;
use function sprintf;

class UniqueInputFieldNames extends ValidationRule
{
    /** @var array<string, NameNode> */
    public $knownNames;

    /** @var array<array<string, NameNode>> */
    public $knownNameStack;

    public function getVisitor(ValidationContext $context)
    {
        return $this->getASTVisitor($context);
    }

    public function getSDLVisitor(SDLValidationContext $context)
    {
        return $this->getASTVisitor($context);
    }

    public function getASTVisitor(ASTValidationContext $context)
    {
        $this->knownNames     = [];
        $this->knownNameStack = [];

        return [
            NodeKind::OBJECT       => [
                'enter' => function () : void {
                    $this->knownNameStack[] = $this->knownNames;
                    $this->knownNames       = [];
                },
                'leave' => function () : void {
                    $this->knownNames = array_pop($this->knownNameStack);
                },
            ],
            NodeKind::OBJECT_FIELD => function (ObjectFieldNode $node) use ($context) : VisitorOperation {
                $fieldName = $node->name->value;

                if (isset($this->knownNames[$fieldName])) {
                    $context->reportError(new Error(
                        self::duplicateInputFieldMessage($fieldName),
                        [$this->knownNames[$fieldName], $node->name]
                    ));
                } else {
                    $this->knownNames[$fieldName] = $node->name;
                }

                return Visitor::skipNode();
            },
        ];
    }

    public static function duplicateInputFieldMessage($fieldName)
    {
        return sprintf('There can be only one input field named "%s".', $fieldName);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\UniqueOperationNames.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\NameNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Language\Visitor;
use GraphQL\Language\VisitorOperation;
use GraphQL\Validator\ValidationContext;
use function sprintf;

class UniqueOperationNames extends ValidationRule
{
    /** @var NameNode[] */
    public $knownOperationNames;

    public function getVisitor(ValidationContext $context)
    {
        $this->knownOperationNames = [];

        return [
            NodeKind::OPERATION_DEFINITION => function (OperationDefinitionNode $node) use ($context) : VisitorOperation {
                $operationName = $node->name;

                if ($operationName !== null) {
                    if (! isset($this->knownOperationNames[$operationName->value])) {
                        $this->knownOperationNames[$operationName->value] = $operationName;
                    } else {
                        $context->reportError(new Error(
                            self::duplicateOperationNameMessage($operationName->value),
                            [$this->knownOperationNames[$operationName->value], $operationName]
                        ));
                    }
                }

                return Visitor::skipNode();
            },
            NodeKind::FRAGMENT_DEFINITION  => static function () : VisitorOperation {
                return Visitor::skipNode();
            },
        ];
    }

    public static function duplicateOperationNameMessage($operationName)
    {
        return sprintf('There can be only one operation named "%s".', $operationName);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\UniqueVariableNames.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\NameNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\VariableDefinitionNode;
use GraphQL\Validator\ValidationContext;
use function sprintf;

class UniqueVariableNames extends ValidationRule
{
    /** @var NameNode[] */
    public $knownVariableNames;

    public function getVisitor(ValidationContext $context)
    {
        $this->knownVariableNames = [];

        return [
            NodeKind::OPERATION_DEFINITION => function () : void {
                $this->knownVariableNames = [];
            },
            NodeKind::VARIABLE_DEFINITION  => function (VariableDefinitionNode $node) use ($context) : void {
                $variableName = $node->variable->name->value;
                if (! isset($this->knownVariableNames[$variableName])) {
                    $this->knownVariableNames[$variableName] = $node->variable->name;
                } else {
                    $context->reportError(new Error(
                        self::duplicateVariableMessage($variableName),
                        [$this->knownVariableNames[$variableName], $node->variable->name]
                    ));
                }
            },
        ];
    }

    public static function duplicateVariableMessage($variableName)
    {
        return sprintf('There can be only one variable named "%s".', $variableName);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\ValidationRule.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Validator\SDLValidationContext;
use GraphQL\Validator\ValidationContext;
use function class_alias;

abstract class ValidationRule
{
    /** @var string */
    protected $name;

    public function getName()
    {
        return $this->name === '' || $this->name === null  ? static::class : $this->name;
    }

    public function __invoke(ValidationContext $context)
    {
        return $this->getVisitor($context);
    }

    /**
     * Returns structure suitable for GraphQL\Language\Visitor
     *
     * @see \GraphQL\Language\Visitor
     *
     * @return mixed[]
     */
    public function getVisitor(ValidationContext $context)
    {
        return [];
    }

    /**
     * Returns structure suitable for GraphQL\Language\Visitor
     *
     * @see \GraphQL\Language\Visitor
     *
     * @return mixed[]
     */
    public function getSDLVisitor(SDLValidationContext $context)
    {
        return [];
    }
}

class_alias(ValidationRule::class, 'GraphQL\Validator\Rules\AbstractValidationRule');


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\ValuesOfCorrectType.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\BooleanValueNode;
use GraphQL\Language\AST\EnumValueNode;
use GraphQL\Language\AST\FieldNode;
use GraphQL\Language\AST\FloatValueNode;
use GraphQL\Language\AST\IntValueNode;
use GraphQL\Language\AST\ListValueNode;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\NullValueNode;
use GraphQL\Language\AST\ObjectFieldNode;
use GraphQL\Language\AST\ObjectValueNode;
use GraphQL\Language\AST\StringValueNode;
use GraphQL\Language\AST\ValueNode;
use GraphQL\Language\AST\VariableNode;
use GraphQL\Language\Printer;
use GraphQL\Language\Visitor;
use GraphQL\Language\VisitorOperation;
use GraphQL\Type\Definition\EnumType;
use GraphQL\Type\Definition\EnumValueDefinition;
use GraphQL\Type\Definition\InputObjectType;
use GraphQL\Type\Definition\ListOfType;
use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\Definition\ScalarType;
use GraphQL\Type\Definition\Type;
use GraphQL\Utils\Utils;
use GraphQL\Validator\ValidationContext;
use Throwable;
use function array_combine;
use function array_keys;
use function array_map;
use function array_values;
use function iterator_to_array;
use function sprintf;

/**
 * Value literals of correct type
 *
 * A GraphQL document is only valid if all value literals are of the type
 * expected at their position.
 */
class ValuesOfCorrectType extends ValidationRule
{
    public function getVisitor(ValidationContext $context)
    {
        $fieldName = '';

        return [
            NodeKind::FIELD        => [
                'enter' => static function (FieldNode $node) use (&$fieldName) : void {
                    $fieldName = $node->name->value;
                },
            ],
            NodeKind::NULL         => static function (NullValueNode $node) use ($context, &$fieldName) : void {
                $type = $context->getInputType();
                if (! ($type instanceof NonNull)) {
                    return;
                }

                $context->reportError(
                    new Error(
                        self::getBadValueMessage((string) $type, Printer::doPrint($node), null, $context, $fieldName),
                        $node
                    )
                );
            },
            NodeKind::LST          => function (ListValueNode $node) use ($context, &$fieldName) : ?VisitorOperation {
                // Note: TypeInfo will traverse into a list's item type, so look to the
                // parent input type to check if it is a list.
                $type = Type::getNullableType($context->getParentInputType());
                if (! $type instanceof ListOfType) {
                    $this->isValidScalar($context, $node, $fieldName);

                    return Visitor::skipNode();
                }

                return null;
            },
            NodeKind::OBJECT       => function (ObjectValueNode $node) use ($context, &$fieldName) : ?VisitorOperation {
                // Note: TypeInfo will traverse into a list's item type, so look to the
                // parent input type to check if it is a list.
                $type = Type::getNamedType($context->getInputType());
                if (! $type instanceof InputObjectType) {
                    $this->isValidScalar($context, $node, $fieldName);

                    return Visitor::skipNode();
                }
                unset($fieldName);
                // Ensure every required field exists.
                $inputFields  = $type->getFields();
                $nodeFields   = iterator_to_array($node->fields);
                $fieldNodeMap = array_combine(
                    array_map(
                        static function ($field) : string {
                            return $field->name->value;
                        },
                        $nodeFields
                    ),
                    array_values($nodeFields)
                );
                foreach ($inputFields as $fieldName => $fieldDef) {
                    $fieldType = $fieldDef->getType();
                    if (isset($fieldNodeMap[$fieldName]) || ! $fieldDef->isRequired()) {
                        continue;
                    }

                    $context->reportError(
                        new Error(
                            self::requiredFieldMessage($type->name, $fieldName, (string) $fieldType),
                            $node
                        )
                    );
                }

                return null;
            },
            NodeKind::OBJECT_FIELD => static function (ObjectFieldNode $node) use ($context) : void {
                $parentType = Type::getNamedType($context->getParentInputType());
                /** @var ScalarType|EnumType|InputObjectType|ListOfType|NonNull $fieldType */
                $fieldType = $context->getInputType();
                if ($fieldType || ! ($parentType instanceof InputObjectType)) {
                    return;
                }

                $suggestions = Utils::suggestionList(
                    $node->name->value,
                    array_keys($parentType->getFields())
                );
                $didYouMean  = $suggestions
                    ? 'Did you mean ' . Utils::orList($suggestions) . '?'
                    : null;

                $context->reportError(
                    new Error(
                        self::unknownFieldMessage($parentType->name, $node->name->value, $didYouMean),
                        $node
                    )
                );
            },
            NodeKind::ENUM         => function (EnumValueNode $node) use ($context, &$fieldName) : void {
                $type = Type::getNamedType($context->getInputType());
                if (! $type instanceof EnumType) {
                    $this->isValidScalar($context, $node, $fieldName);
                } elseif (! $type->getValue($node->value)) {
                    $context->reportError(
                        new Error(
                            self::getBadValueMessage(
                                $type->name,
                                Printer::doPrint($node),
                                $this->enumTypeSuggestion($type, $node),
                                $context,
                                $fieldName
                            ),
                            $node
                        )
                    );
                }
            },
            NodeKind::INT          => function (IntValueNode $node) use ($context, &$fieldName) : void {
                $this->isValidScalar($context, $node, $fieldName);
            },
            NodeKind::FLOAT        => function (FloatValueNode $node) use ($context, &$fieldName) : void {
                $this->isValidScalar($context, $node, $fieldName);
            },
            NodeKind::STRING       => function (StringValueNode $node) use ($context, &$fieldName) : void {
                $this->isValidScalar($context, $node, $fieldName);
            },
            NodeKind::BOOLEAN      => function (BooleanValueNode $node) use ($context, &$fieldName) : void {
                $this->isValidScalar($context, $node, $fieldName);
            },
        ];
    }

    public static function badValueMessage($typeName, $valueName, $message = null)
    {
        return sprintf('Expected type %s, found %s', $typeName, $valueName) .
            ($message ? "; {$message}" : '.');
    }

    /**
     * @param VariableNode|NullValueNode|IntValueNode|FloatValueNode|StringValueNode|BooleanValueNode|EnumValueNode|ListValueNode|ObjectValueNode $node
     */
    private function isValidScalar(ValidationContext $context, ValueNode $node, $fieldName)
    {
        // Report any error at the full type expected by the location.
        /** @var ScalarType|EnumType|InputObjectType|ListOfType|NonNull $locationType */
        $locationType = $context->getInputType();

        if (! $locationType) {
            return;
        }

        $type = Type::getNamedType($locationType);

        if (! $type instanceof ScalarType) {
            $context->reportError(
                new Error(
                    self::getBadValueMessage(
                        (string) $locationType,
                        Printer::doPrint($node),
                        $this->enumTypeSuggestion($type, $node),
                        $context,
                        $fieldName
                    ),
                    $node
                )
            );

            return;
        }

        // Scalars determine if a literal value is valid via parseLiteral() which
        // may throw to indicate failure.
        try {
            $type->parseLiteral($node);
        } catch (Throwable $error) {
            // Ensure a reference to the original error is maintained.
            $context->reportError(
                new Error(
                    self::getBadValueMessage(
                        (string) $locationType,
                        Printer::doPrint($node),
                        $error->getMessage(),
                        $context,
                        $fieldName
                    ),
                    $node,
                    null,
                    [],
                    null,
                    $error
                )
            );
        }
    }

    /**
     * @param VariableNode|NullValueNode|IntValueNode|FloatValueNode|StringValueNode|BooleanValueNode|EnumValueNode|ListValueNode|ObjectValueNode $node
     */
    private function enumTypeSuggestion($type, ValueNode $node)
    {
        if ($type instanceof EnumType) {
            $suggestions = Utils::suggestionList(
                Printer::doPrint($node),
                array_map(
                    static function (EnumValueDefinition $value) : string {
                        return $value->name;
                    },
                    $type->getValues()
                )
            );

            return $suggestions ? 'Did you mean the enum value ' . Utils::orList($suggestions) . '?' : null;
        }
    }

    public static function badArgumentValueMessage($typeName, $valueName, $fieldName, $argName, $message = null)
    {
        return sprintf('Field "%s" argument "%s" requires type %s, found %s', $fieldName, $argName, $typeName, $valueName) .
            ($message ? sprintf('; %s', $message) : '.');
    }

    public static function requiredFieldMessage($typeName, $fieldName, $fieldTypeName)
    {
        return sprintf('Field %s.%s of required type %s was not provided.', $typeName, $fieldName, $fieldTypeName);
    }

    public static function unknownFieldMessage($typeName, $fieldName, $message = null)
    {
        return sprintf('Field "%s" is not defined by type %s', $fieldName, $typeName) .
            ($message ? sprintf('; %s', $message) : '.');
    }

    private static function getBadValueMessage($typeName, $valueName, $message = null, $context = null, $fieldName = null)
    {
        if ($context) {
            $arg = $context->getArgument();
            if ($arg) {
                return self::badArgumentValueMessage($typeName, $valueName, $fieldName, $arg->name, $message);
            }
        }

        return self::badValueMessage($typeName, $valueName, $message);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\VariablesAreInputTypes.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\VariableDefinitionNode;
use GraphQL\Language\Printer;
use GraphQL\Type\Definition\Type;
use GraphQL\Utils\TypeInfo;
use GraphQL\Validator\ValidationContext;
use function sprintf;

class VariablesAreInputTypes extends ValidationRule
{
    public function getVisitor(ValidationContext $context)
    {
        return [
            NodeKind::VARIABLE_DEFINITION => static function (VariableDefinitionNode $node) use ($context) : void {
                $type = TypeInfo::typeFromAST($context->getSchema(), $node->type);

                // If the variable type is not an input type, return an error.
                if (! $type || Type::isInputType($type)) {
                    return;
                }

                $variableName = $node->variable->name->value;
                $context->reportError(new Error(
                    self::nonInputTypeOnVarMessage($variableName, Printer::doPrint($node->type)),
                    [$node->type]
                ));
            },
        ];
    }

    public static function nonInputTypeOnVarMessage($variableName, $typeName)
    {
        return sprintf('Variable "$%s" cannot be non-input type "%s".', $variableName, $typeName);
    }
}


// File: wp-graphql\vendor\webonyx\graphql-php\src\Validator\Rules\VariablesInAllowedPosition.php
<?php

declare(strict_types=1);

namespace GraphQL\Validator\Rules;

use GraphQL\Error\Error;
use GraphQL\Language\AST\NodeKind;
use GraphQL\Language\AST\NullValueNode;
use GraphQL\Language\AST\OperationDefinitionNode;
use GraphQL\Language\AST\ValueNode;
use GraphQL\Language\AST\VariableDefinitionNode;
use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\Definition\Type;
use GraphQL\Type\Schema;
use GraphQL\Utils\TypeComparators;
use GraphQL\Utils\TypeInfo;
use GraphQL\Utils\Utils;
use GraphQL\Validator\ValidationContext;
use function sprintf;

class VariablesInAllowedPosition extends ValidationRule
{
    /**
     * A map from variable names to their definition nodes.
     *
     * @var VariableDefinitionNode[]
     */
    public $varDefMap;

    public function getVisitor(ValidationContext $context)
    {
        return [
            NodeKind::OPERATION_DEFINITION => [
                'enter' => function () : void {
                    $this->varDefMap = [];
                },
                'leave' => function (OperationDefinitionNode $operation) use ($context) : void {
                    $usages = $context->getRecursiveVariableUsages($operation);

                    foreach ($usages as $usage) {
                        $node         = $usage['node'];
                        $type         = $usage['type'];
                        $defaultValue = $usage['defaultValue'];
                        $varName      = $node->name->value;
                        $varDef       = $this->varDefMap[$varName] ?? null;

                        if ($varDef === null || $type === null) {
                            continue;
                        }

                        // A var type is allowed if it is the same or more strict (e.g. is
                        // a subtype of) than the expected type. It can be more strict if
                        // the variable type is non-null when the expected type is nullable.
                        // If both are list types, the variable item type can be more strict
                        // than the expected item type (contravariant).
                        $schema  = $context->getSchema();
                        $varType = TypeInfo::typeFromAST($schema, $varDef->type);

                        if (! $varType || $this->allowedVariableUsage($schema, $varType, $varDef->defaultValue, $type, $defaultValue)) {
                            continue;
                        }

                        $context->reportError(new Error(
                            self::badVarPosMessage($varName, $varType, $type),
                            [$varDef, $node]
                        ));
                    }
                },
            ],
            NodeKind::VARIABLE_DEFINITION  => function (VariableDefinitionNode $varDefNode) : void {
                $this->varDefMap[$varDefNode->variable->name->value] = $varDefNode;
            },
        ];
    }

    /**
     * A var type is allowed if it is the same or more strict than the expected
     * type. It can be more strict if the variable type is non-null when the
     * expected type is nullable. If both are list types, the variable item type can
     * be more strict than the expected item type.
     */
    public static function badVarPosMessage($varName, $varType, $expectedType)
    {
        return sprintf(
            'Variable "$%s" of type "%s" used in position expecting type "%s".',
            $varName,
            $varType,
            $expectedType
        );
    }

    /**
     * Returns true if the variable is allowed in the location it was found,
     * which includes considering if default values exist for either the variable
     * or the location at which it is located.
     *
     * @param ValueNode|null $varDefaultValue
     * @param mixed          $locationDefaultValue
     */
    private function allowedVariableUsage(Schema $schema, Type $varType, $varDefaultValue, Type $locationType, $locationDefaultValue) : bool
    {
        if ($locationType instanceof NonNull && ! $varType instanceof NonNull) {
            $hasNonNullVariableDefaultValue = $varDefaultValue && ! $varDefaultValue instanceof NullValueNode;
            $hasLocationDefaultValue        = ! Utils::isInvalid($locationDefaultValue);
            if (! $hasNonNullVariableDefaultValue && ! $hasLocationDefaultValue) {
                return false;
            }
            $nullableLocationType = $locationType->getWrappedType();

            return TypeComparators::isTypeSubTypeOf($schema, $varType, $nullableLocationType);
        }

        return TypeComparators::isTypeSubTypeOf($schema, $varType, $locationType);
    }
}


